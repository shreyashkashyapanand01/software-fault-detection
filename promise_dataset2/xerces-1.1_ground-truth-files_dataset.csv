File,Bug,SRC
org/xml/sax/SAXParseException.java,true,"// SAX exception class.
// No warranty; no copyright -- use this as you will.
// $Id: SAXParseException.java,v 1.4 2000/05/05 17:48:16 david Exp $

package org.xml.sax;

/**
 * Encapsulate an XML parse error or warning.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This exception will include information for locating the error
 * in the original XML document.  Note that although the application
 * will receive a SAXParseException as the argument to the handlers
 * in the {@link org.xml.sax.ErrorHandler ErrorHandler} interface, 
 * the application is not actually required to throw the exception; 
 * instead, it can simply read the information in it and take a 
 * different action.</p>
 *
 * <p>Since this exception is a subclass of {@link org.xml.sax.SAXException 
 * SAXException}, it inherits the ability to wrap another exception.</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.SAXException
 * @see org.xml.sax.Locator
 * @see org.xml.sax.ErrorHandler
 */
public class SAXParseException extends SAXException {
    
    
    //////////////////////////////////////////////////////////////////////
    // Constructors.
    //////////////////////////////////////////////////////////////////////


    /**
     * Create a new SAXParseException from a message and a Locator.
     *
     * <p>This constructor is especially useful when an application is
     * creating its own exception from within a {@link org.xml.sax.ContentHandler
     * ContentHandler} callback.</p>
     *
     * @param message The error or warning message.
     * @param locator The locator object for the error or warning (may be
     *        null).
     * @see org.xml.sax.Locator
     * @see org.xml.sax.Parser#setLocale 
     */
    public SAXParseException (String message, Locator locator) {
	super(message);
	if (locator != null) {
	    init(locator.getPublicId(), locator.getSystemId(),
		 locator.getLineNumber(), locator.getColumnNumber());
	} else {
	    init(null, null, -1, -1);
	}
    }
    
    
    /**
     * Wrap an existing exception in a SAXParseException.
     *
     * <p>This constructor is especially useful when an application is
     * creating its own exception from within a {@link org.xml.sax.ContentHandler
     * ContentHandler} callback, and needs to wrap an existing exception that is not a
     * subclass of {@link org.xml.sax.SAXException SAXException}.</p>
     *
     * @param message The error or warning message, or null to
     *                use the message from the embedded exception.
     * @param locator The locator object for the error or warning (may be
     *        null).
     * @param e Any exception.
     * @see org.xml.sax.Locator
     * @see org.xml.sax.Parser#setLocale
     */
    public SAXParseException (String message, Locator locator,
			      Exception e) {
	super(message, e);
	if (locator != null) {
	    init(locator.getPublicId(), locator.getSystemId(),
		 locator.getLineNumber(), locator.getColumnNumber());
	} else {
	    init(null, null, -1, -1);
	}
    }
    
    
    /**
     * Create a new SAXParseException.
     *
     * <p>This constructor is most useful for parser writers.</p>
     *
     * <p>If the system identifier is a URL, the parser must resolve it
     * fully before creating the exception.</p>
     *
     * @param message The error or warning message.
     * @param publicId The public identifer of the entity that generated
     *                 the error or warning.
     * @param systemId The system identifer of the entity that generated
     *                 the error or warning.
     * @param lineNumber The line number of the end of the text that
     *                   caused the error or warning.
     * @param columnNumber The column number of the end of the text that
     *                     cause the error or warning.
     * @see org.xml.sax.Parser#setLocale
     */
    public SAXParseException (String message, String publicId, String systemId,
			      int lineNumber, int columnNumber)
    {
	super(message);
	init(publicId, systemId, lineNumber, columnNumber);
    }
    
    
    /**
     * Create a new SAXParseException with an embedded exception.
     *
     * <p>This constructor is most useful for parser writers who
     * need to wrap an exception that is not a subclass of
     * {@link org.xml.sax.SAXException SAXException}.</p>
     *
     * <p>If the system identifier is a URL, the parser must resolve it
     * fully before creating the exception.</p>
     *
     * @param message The error or warning message, or null to use
     *                the message from the embedded exception.
     * @param publicId The public identifer of the entity that generated
     *                 the error or warning.
     * @param systemId The system identifer of the entity that generated
     *                 the error or warning.
     * @param lineNumber The line number of the end of the text that
     *                   caused the error or warning.
     * @param columnNumber The column number of the end of the text that
     *                     cause the error or warning.
     * @param e Another exception to embed in this one.
     * @see org.xml.sax.Parser#setLocale
     */
    public SAXParseException (String message, String publicId, String systemId,
			      int lineNumber, int columnNumber, Exception e)
    {
	super(message, e);
	init(publicId, systemId, lineNumber, columnNumber);
    }


    /**
     * Internal initialization method.
     *
     * @param publicId The public identifier of the entity which generated the exception,
     *        or null.
     * @param systemId The system identifier of the entity which generated the exception,
     *        or null.
     * @param lineNumber The line number of the error, or -1.
     * @param columnNumber The column number of the error, or -1.
     */
    private void init (String publicId, String systemId,
		       int lineNumber, int columnNumber)
    {
	this.publicId = publicId;
	this.systemId = systemId;
	this.lineNumber = lineNumber;
	this.columnNumber = columnNumber;
    }
    
    
    /**
     * Get the public identifier of the entity where the exception occurred.
     *
     * @return A string containing the public identifier, or null
     *         if none is available.
     * @see org.xml.sax.Locator#getPublicId
     */
    public String getPublicId ()
    {
	return this.publicId;
    }
    
    
    /**
     * Get the system identifier of the entity where the exception occurred.
     *
     * <p>If the system identifier is a URL, it will be resolved
     * fully.</p>
     *
     * @return A string containing the system identifier, or null
     *         if none is available.
     * @see org.xml.sax.Locator#getSystemId
     */
    public String getSystemId ()
    {
	return this.systemId;
    }
    
    
    /**
     * The line number of the end of the text where the exception occurred.
     *
     * @return An integer representing the line number, or -1
     *         if none is available.
     * @see org.xml.sax.Locator#getLineNumber
     */
    public int getLineNumber ()
    {
	return this.lineNumber;
    }
    
    
    /**
     * The column number of the end of the text where the exception occurred.
     *
     * <p>The first column in a line is position 1.</p>
     *
     * @return An integer representing the column number, or -1
     *         if none is available.
     * @see org.xml.sax.Locator#getColumnNumber
     */
    public int getColumnNumber ()
    {
	return this.columnNumber;
    }
    
    
    
    //////////////////////////////////////////////////////////////////////
    // Internal state.
    //////////////////////////////////////////////////////////////////////


    /**
     * @serial The public identifier, or null.
     * @see #getPublicId
     */    
    private String publicId;


    /**
     * @serial The system identifier, or null.
     * @see #getSystemId
     */
    private String systemId;


    /**
     * @serial The line number, or -1.
     * @see #getLineNumber
     */
    private int lineNumber;


    /**
     * @serial The column number, or -1.
     * @see #getColumnNumber
     */
    private int columnNumber;
    
}

// end of SAXParseException.java
"
org/apache/xerces/utils/UTF8DataChunk.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import org.apache.xerces.readers.XMLEntityHandler;
import java.util.Vector;

//
//
//
public class UTF8DataChunk implements StringPool.StringProducer {
    //
    // Chunk size constants
    //
    public static final int CHUNK_SHIFT = 14;           // 2^14 = 16k
    public static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);
    public static final int CHUNK_MASK = CHUNK_SIZE - 1;
    //
    // Public constructor (factory)
    //
    public static UTF8DataChunk createChunk(StringPool stringPool, UTF8DataChunk prev) {

        synchronized (UTF8DataChunk.class) {
            if (fgFreeChunks != null) {
                UTF8DataChunk newChunk = fgFreeChunks;
                fgFreeChunks = newChunk.fNextChunk;
                newChunk.fNextChunk = null;
                newChunk.init(stringPool, prev);
                return newChunk;
            }
        }
        UTF8DataChunk chunk = new UTF8DataChunk(stringPool, prev);
        return chunk;
    }
    //
    //
    //
    public final byte[] toByteArray() {
        return fData;
    }
    //
    //
    //
    public void setByteArray(byte[] data) {
        fData = data;
    }
    //
    //
    //
    public UTF8DataChunk nextChunk() {
        return fNextChunk;
    }
    //
    //
    //
    public boolean clearPreviousChunk() {
        if (fPreviousChunk != null) {
            fPreviousChunk.setNextChunk(null);
            fPreviousChunk.removeRef();
//System.err.println(""["" + fPreviousChunk.fChunk + ""] "" + fPreviousChunk.fRefCount + "" refs after clearPreviousChunk"");
//System.err.println(""["" + fChunk + ""] "" + fRefCount + "" refs after clearPreviousChunk"");
            fPreviousChunk = null;
            return true;
        }
        return fChunk == 0;
    }
    //
    //
    //
    public void releaseChunk() {
        removeRef();
//System.err.println(""["" + fChunk + ""] "" + fRefCount + "" refs after releaseChunk"");
    }
    //
    //
    //
    public void releaseString(int offset, int length) {
        removeRef();
    }
    //
    //
    //
    public String toString(int offset, int length) {

        synchronized (fgTempBufferLock) {
            int outOffset = 0;
            UTF8DataChunk dataChunk = this;
            int endOffset = offset + length;
            int index = offset & CHUNK_MASK;
            byte[] data = fData;
            boolean skiplf = false;
            while (offset < endOffset) {
                int b0 = data[index++] & 0xff;
                offset++;
                if (index == CHUNK_SIZE && offset < endOffset) {
                    dataChunk = dataChunk.fNextChunk;
                    data = dataChunk.fData;
                    index = 0;
                }
                if (b0 < 0x80) {
                    if (skiplf) {
                        skiplf = false;
                        if (b0 == 0x0A)
                            continue;
                    }
                    if (b0 == 0x0D) {
                        b0 = 0x0A;
                        skiplf = true;
                    }
                    try {
                        fgTempBuffer[outOffset] = (char)b0;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)b0;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)b0;
                    }
                    continue;
                }
                int b1 = data[index++] & 0xff;
                offset++;
                if (index == CHUNK_SIZE && offset < endOffset) {
                    dataChunk = dataChunk.fNextChunk;
                    data = dataChunk.fData;
                    index = 0;
                }
                if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                    int ch = ((0x1f & b0)<<6) + (0x3f & b1); // yyy yyxx xxxx (0x80 to 0x7ff)
                    try {
                        fgTempBuffer[outOffset] = (char)ch;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)ch;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)ch;
                    }
                    continue;
                }
                int b2 = data[index++] & 0xff;
                offset++;
                if (index == CHUNK_SIZE && offset < endOffset) {
                    dataChunk = dataChunk.fNextChunk;
                    data = dataChunk.fData;
                    index = 0;
                }
                if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                    int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                    try {
                        fgTempBuffer[outOffset] = (char)ch;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)ch;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)ch;
                    }
                    continue;
                }
                int b3 = data[index++] & 0xff;  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
                offset++;
                if (index == CHUNK_SIZE && offset < endOffset) {
                    dataChunk = dataChunk.fNextChunk;
                    data = dataChunk.fData;
                    index = 0;
                }
                int ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3);
                if (ch < 0x10000) {
                    try {
                        fgTempBuffer[outOffset] = (char)ch;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)ch;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)ch;
                    }
                } else {
                    char ch1 = (char)(((ch-0x00010000)>>10)+0xd800);
                    char ch2 = (char)(((ch-0x00010000)&0x3ff)+0xdc00);
                    try {
                        fgTempBuffer[outOffset] = (char)ch1;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)ch1;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)ch1;
                    }
                    try {
                        fgTempBuffer[outOffset] = (char)ch2;
                        outOffset++;
                    } catch (NullPointerException ex) {
                        fgTempBuffer = new char[CHUNK_SIZE];
                        fgTempBuffer[outOffset++] = (char)ch2;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        char[] newBuffer = new char[outOffset * 2];
                        System.arraycopy(fgTempBuffer, 0, newBuffer, 0, outOffset);
                        fgTempBuffer = newBuffer;
                        fgTempBuffer[outOffset++] = (char)ch2;
                    }
                }
            }
            return new String(fgTempBuffer, 0, outOffset);
        }
    }
    //
    //
    //
    public boolean equalsString(int offset, int length, char[] strChars, int strOffset, int strLength) {
        UTF8DataChunk dataChunk = this;
        int endOffset = offset + length;
        int index = offset & CHUNK_MASK;
        byte[] data = fData;
        boolean skiplf = false;
        while (offset < endOffset) {
            if (strLength-- == 0)
                return false;
            int b0 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if (b0 < 0x80) {
                if (skiplf) {
                    skiplf = false;
                    if (b0 == 0x0A)
                        continue;
                }
                if (b0 == 0x0D) {
                    b0 = 0x0A;
                    skiplf = true;
                }
                if (b0 != strChars[strOffset++])
                    return false;
                continue;
            }
            int b1 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                int ch = ((0x1f & b0)<<6) + (0x3f & b1);
                if (ch != strChars[strOffset++])
                    return false;
                continue;
            }
            int b2 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                if (ch != strChars[strOffset++])
                    return false;
                continue;
            }
            int b3 = data[index++] & 0xff;  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            int ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12)
                   + ((0x3f & b2)<<6) + (0x3f & b3);
            if (ch < 0x10000) {
                if (ch != strChars[strOffset++])
                    return false;
            } else {
                if ((((ch-0x00010000)>>10)+0xd800) != strChars[strOffset++])
                    return false;
                if (strLength-- == 0)
                    return false;
                if ((((ch-0x00010000)&0x3ff)+0xdc00) != strChars[strOffset++])
                    return false;
            }
        }
        return (strLength == 0);
    }
    //
    //
    //
    public int addString(int offset, int length) {
        if (length == 0)
            return StringPool.EMPTY_STRING;
        int chunk = offset >> CHUNK_SHIFT;
        if (chunk != fChunk) {
            if (fPreviousChunk == null)
                throw new RuntimeException(new ImplementationMessages().createMessage(null, ImplementationMessages.INT_PCN, 0, null));
            return fPreviousChunk.addString(offset, length);
        }
        int lastChunk = (offset + length - 1) >> CHUNK_SHIFT;
        if (chunk == lastChunk) {
            addRef();
            return fStringPool.addString(this, offset & CHUNK_MASK, length);
        }
        String str = toString(offset & CHUNK_MASK, length);
        return fStringPool.addString(str);
    }
    //
    //
    //
    public int addSymbol(int offset, int length, int hashcode) {
        if (length == 0)
            return StringPool.EMPTY_STRING;
        int chunk = offset >> CHUNK_SHIFT;
        if (chunk != fChunk) {
            if (fPreviousChunk == null)
                throw new RuntimeException(new ImplementationMessages().createMessage(null, ImplementationMessages.INT_PCN, 0, null));
            return fPreviousChunk.addSymbol(offset, length, hashcode);
        }
        int lastChunk = (offset + length - 1) >> CHUNK_SHIFT;
        int index = offset & CHUNK_MASK;
        if (chunk == lastChunk) {
            if (hashcode == 0) {
                hashcode = getHashcode(index, length);
            }
            int symbol = fStringPool.lookupSymbol(this, index, length, hashcode);
            if (symbol == -1) {
                String str = toString(index, length);
                symbol = fStringPool.addNewSymbol(str, hashcode);
            }
            return symbol;
        }
        String str = toString(index, length);
        return fStringPool.addSymbol(str);
    }
    //
    //
    //
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        //
        // Setup for the operation.
        //
        UTF8DataChunk dataChunk = chunkFor(offset);
        int endOffset = offset + length;
        int index = offset & CHUNK_MASK;
        byte[] data = dataChunk.fData;
        boolean skiplf = false;
        while (offset < endOffset) {
            int b0 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if (b0 < 0x80) {
                if (skiplf) {
                    skiplf = false;
                    if (b0 == 0x0A)
                        continue;
                }
                if (b0 == 0x0D) {
                    b0 = 0x0A;
                    skiplf = true;
                }
                charBuffer.append((char)b0);
                continue;
            }
            int b1 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                int ch = ((0x1f & b0)<<6) + (0x3f & b1);
                charBuffer.append((char)ch); // yyy yyxx xxxx (0x80 to 0x7ff)
                continue;
            }
            int b2 = data[index++] & 0xff;
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                charBuffer.append((char)ch); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                continue;
            }
            int b3 = data[index++] & 0xff;  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
            offset++;
            if (index == CHUNK_SIZE && offset < endOffset) {
                dataChunk = dataChunk.fNextChunk;
                data = dataChunk.fData;
                index = 0;
            }
            int ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12)
                   + ((0x3f & b2)<<6) + (0x3f & b3);
            if (ch < 0x10000)
                charBuffer.append((char)ch);
            else {
                charBuffer.append((char)(((ch-0x00010000)>>10)+0xd800));
                charBuffer.append((char)(((ch-0x00010000)&0x3ff)+0xdc00));
            }
        }
    }
    //
    //
    //
    private int getHashcode(int index, int length) {
        int endIndex = index + length;
        int hashcode = 0;
        byte[] data = fData;
        while (index < endIndex) {
            int b0 = data[index++] & 0xff;
            if ((b0 & 0x80) == 0) {
                hashcode = StringHasher.hashChar(hashcode, b0);
                continue;
            }
            int b1 = data[index++] & 0xff;
            if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                int ch = ((0x1f & b0)<<6) + (0x3f & b1); // yyy yyxx xxxx (0x80 to 0x7ff)
                hashcode = StringHasher.hashChar(hashcode, ch);
                continue;
            }
            int b2 = data[index++] & 0xff;
            if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                hashcode = StringHasher.hashChar(hashcode, ch);
                continue;
            }
            int b3 = data[index++] & 0xff;  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
            int ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12)
                    + ((0x3f & b2)<<6) + (0x3f & b3);
            if (ch < 0x10000)
                hashcode = StringHasher.hashChar(hashcode, ch);
            else {
                hashcode = StringHasher.hashChar(hashcode, (int)(((ch-0x00010000)>>10)+0xd800));
                hashcode = StringHasher.hashChar(hashcode, (int)(((ch-0x00010000)&0x3ff)+0xdc00));
            }
        }
        return StringHasher.finishHash(hashcode);
    }
    //
    //
    //
    private void init(StringPool stringPool, UTF8DataChunk prev) {
        fStringPool = stringPool;
        fRefCount = 1;
        fChunk = prev == null ? 0 : prev.fChunk + 1;
        fNextChunk = null;
        fPreviousChunk = prev;
        if (prev != null) {
            prev.addRef();
            prev.setNextChunk(this);
            prev.removeRef();
        }
    }
    //
    // Constructor for factory method.
    //
    private UTF8DataChunk(StringPool stringPool, UTF8DataChunk prev) {
        init(stringPool, prev);
    }
    //
    //
    //
    private final UTF8DataChunk chunkFor(int offset) {
        if ((offset >> CHUNK_SHIFT) == fChunk)
            return this;
        return slowChunkFor(offset);
    }
    private UTF8DataChunk slowChunkFor(int offset) {
        int firstChunk = offset >> CHUNK_SHIFT;
        UTF8DataChunk dataChunk = this;
        while (firstChunk != dataChunk.fChunk)
            dataChunk = dataChunk.fPreviousChunk;
        return dataChunk;
    }
    //
    //
    //
    private final void addRef() {
        fRefCount++;
//System.err.println("">>["" + fChunk + ""] "" + (fRefCount - 1) + "" -> "" + fRefCount);
    }
    //
    //
    //
    private final void removeRef() {
        fRefCount--;
//System.err.println(""<<["" + fChunk + ""] "" + (fRefCount + 1) + "" -> "" + fRefCount);
        if (fRefCount == 0) {
//System.err.println(""["" + fChunk + ""] recycled a "" + fData.length + "" character array"");
            fStringPool = null;
            fChunk = -1;
//            fData = null;
            fPreviousChunk = null;
            synchronized (UTF8DataChunk.class) {
                /*** Only keep one free chunk at a time! ***
                fNextChunk = fgFreeChunks;
                /***/
                fNextChunk = null;
                fgFreeChunks = this;
            }
        }
    }
    //
    //
    //
    private void setNextChunk(UTF8DataChunk nextChunk) {
        if (nextChunk == null) {
            if (fNextChunk != null)
                fNextChunk.removeRef();
        } else if (fNextChunk == null) {
            nextChunk.addRef();
        } else
            throw new RuntimeException(""UTF8DataChunk::setNextChunk"");
        fNextChunk = nextChunk;
    }
    //
    //
    //
    private StringPool fStringPool;
    private int fRefCount;
    private int fChunk;
    private byte[] fData = null;
    private UTF8DataChunk fNextChunk;
    private UTF8DataChunk fPreviousChunk;
    private static UTF8DataChunk fgFreeChunks = null;
    private static char[] fgTempBuffer = null;
    private static Object fgTempBufferLock = new Object();
}
"
org/apache/xerces/parsers/DOMParser.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.parsers;

import java.io.IOException;
import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xerces.dom.TextImpl;
import org.apache.xerces.framework.XMLAttrList;
import org.apache.xerces.framework.XMLContentSpec;
import org.apache.xerces.framework.XMLDocumentHandler;
import org.apache.xerces.framework.XMLParser;
import org.apache.xerces.readers.XMLEntityHandler;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.validators.schema.XUtil;

import org.apache.xerces.dom.DeferredDocumentImpl;
import org.apache.xerces.dom.DocumentImpl;
import org.apache.xerces.dom.DocumentTypeImpl;
import org.apache.xerces.dom.NodeImpl;
import org.apache.xerces.dom.EntityImpl;
import org.apache.xerces.dom.NotationImpl;
import org.apache.xerces.dom.ElementDefinitionImpl;
import org.apache.xerces.dom.AttrImpl;
import org.apache.xerces.dom.TextImpl;
import org.apache.xerces.dom.ElementImpl;
import org.apache.xerces.dom.EntityImpl;
import org.apache.xerces.dom.EntityReferenceImpl;

import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.Entity;
import org.w3c.dom.EntityReference;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

/**
 * DOMParser provides a parser which produces a W3C DOM tree as its output
 *
 * 
 * @version $Id$
 */
public class DOMParser
    extends XMLParser
    implements XMLDocumentHandler, XMLDocumentHandler.DTDHandler
    {

    //
    // Constants
    //

    // public

    /** Default programmatic document class name (org.apache.xerces.dom.DocumentImpl). */
    public static final String DEFAULT_DOCUMENT_CLASS_NAME = ""org.apache.xerces.dom.DocumentImpl"";

    // debugging

    /** Set to true to debug attribute list declaration calls. */
    private static final boolean DEBUG_ATTLIST_DECL = false;

    // features and properties

    /** Features recognized by this parser. */
    private static final String RECOGNIZED_FEATURES[] = {
        // SAX2 core features
        // Xerces features
        ""http://apache.org/xml/features/dom/defer-node-expansion"",
        ""http://apache.org/xml/features/dom/create-entity-ref-nodes"",
        ""http://apache.org/xml/features/dom/include-ignorable-whitespace"",
        // Experimental features
        ""http://apache.org/xml/features/domx/grammar-access"",
    };

    /** Properties recognized by this parser. */
    private static final String RECOGNIZED_PROPERTIES[] = {
        // SAX2 core properties
        // Xerces properties
        ""http://apache.org/xml/properties/dom/document-class-name"",
        ""http://apache.org/xml/properties/dom/current-element-node"",
    };

    /** For experimental grammar access. */
    private static final Hashtable TYPES = new Hashtable();

    //
    // Data
    //

    // common data

    protected Document fDocument;

    // deferred expansion data

    protected DeferredDocumentImpl fDeferredDocumentImpl;
    protected int                  fDocumentIndex;
    protected int                  fDocumentTypeIndex;
    protected int                  fCurrentNodeIndex;

    // full expansion data

    protected DocumentImpl fDocumentImpl;
    protected DocumentType fDocumentType;
    protected Node         fCurrentElementNode;

    // state

    protected boolean fWithinElement;
    protected boolean fInCDATA;

    // features
    private boolean fGrammarAccess;

    // properties

    // REVISIT: Even though these have setters and getters, should they
    //          be protected visibility? -Ac
    private String  fDocumentClassName;
    private boolean fDeferNodeExpansion;
    private boolean fCreateEntityReferenceNodes;
    private boolean fIncludeIgnorableWhitespace;

    // built-in entities

    protected int fAmpIndex;
    protected int fLtIndex;
    protected int fGtIndex;
    protected int fAposIndex;
    protected int fQuotIndex;

    private boolean fSeenRootElement;

    private XMLAttrList fAttrList;

    //
    // Static initializer
    //

    static {
        String types[][] = {
            { ""CDATA"",       ""minOccurs"", ""maxOccurs"" },
            { ""ENUMERATION"", ""collection"", ""order"", ""export"" },
            { ""NMTOKEN"",     ""name"", ""ref"" },
        };
        for (int i = 0; i < types.length; i++) {
            String typeName = types[i][0];
            for (int j = 1; j < types[i].length; j++) {
                TYPES.put(types[i][j], typeName);
            }
        }
    }

    //
    // Constructors
    //

    /** Default constructor. */
    public DOMParser() {

        initHandlers(false, this, this);

        // setup parser state
        init();

        // set default values
        try {
            setDocumentClassName(DEFAULT_DOCUMENT_CLASS_NAME);
            setCreateEntityReferenceNodes(true);
            setDeferNodeExpansion(true);
            setIncludeIgnorableWhitespace(true);
        } catch (SAXException e) {
            throw new RuntimeException(""PAR001 Fatal error constructing DOMParser."");
        }

    } // <init>()

    //
    // Public methods
    //

    // document

    /** Returns the document. */
    public Document getDocument() {
        if (fDocumentImpl != null) {
            fDocumentImpl.setErrorChecking(true);
        }
        return fDocument;
    }

    // features and properties

    /**
     * Returns a list of features that this parser recognizes.
     * This method will never return null; if no features are
     * recognized, this method will return a zero length array.
     *
     * @see #isFeatureRecognized
     * @see #setFeature
     * @see #getFeature
     */
    public String[] getFeaturesRecognized() {

        // get features that super/this recognizes
        String superRecognized[] = super.getFeaturesRecognized();
        String thisRecognized[] = RECOGNIZED_FEATURES;

        // is one or the other the empty set?
        int thisLength = thisRecognized.length;
        if (thisLength == 0) {
            return superRecognized;
        }
        int superLength = superRecognized.length;
        if (superLength == 0) {
            return thisRecognized;
        }

        // combine the two lists and return
        String recognized[] = new String[superLength + thisLength];
        System.arraycopy(superRecognized, 0, recognized, 0, superLength);
        System.arraycopy(thisRecognized, 0, recognized, superLength, thisLength);
        return recognized;

    } // getFeaturesRecognized():String[]

    /**
     * Returns a list of properties that this parser recognizes.
     * This method will never return null; if no properties are
     * recognized, this method will return a zero length array.
     *
     * @see #isPropertyRecognized
     * @see #setProperty
     * @see #getProperty
     */
    public String[] getPropertiesRecognized() {

        // get properties that super/this recognizes
        String superRecognized[] = super.getPropertiesRecognized();
        String thisRecognized[] = RECOGNIZED_PROPERTIES;

        // is one or the other the empty set?
        int thisLength = thisRecognized.length;
        if (thisLength == 0) {
            return superRecognized;
        }
        int superLength = superRecognized.length;
        if (superLength == 0) {
            return thisRecognized;
        }

        // combine the two lists and return
        String recognized[] = new String[superLength + thisLength];
        System.arraycopy(superRecognized, 0, recognized, 0, superLength);
        System.arraycopy(thisRecognized, 0, recognized, superLength, thisLength);
        return recognized;

    }

    // resetting

    /** Resets the parser. */
    public void reset() throws Exception {
        super.reset();
        init();
    }

    /** Resets or copies the parser. */
    public void resetOrCopy() throws Exception {
        super.resetOrCopy();
        init();
    }

    //
    // Protected methods
    //

    // initialization

    /**
     * Initializes the parser to a pre-parse state. This method is
     * called between calls to <code>parse()</code>.
     */
    protected void init() {

        // init common
        fDocument = null;

        // init deferred expansion
        fDeferredDocumentImpl = null;
        fDocumentIndex = -1;
        fDocumentTypeIndex = -1;
        fCurrentNodeIndex = -1;

        // init full expansion
        fDocumentImpl = null;
        fDocumentType = null;
        fCurrentElementNode = null;

        // state
        fWithinElement = false;
        fInCDATA = false;

        // built-in entities
        fAmpIndex = fStringPool.addSymbol(""amp"");
        fLtIndex = fStringPool.addSymbol(""lt"");
        fGtIndex = fStringPool.addSymbol(""gt"");
        fAposIndex = fStringPool.addSymbol(""apos"");
        fQuotIndex = fStringPool.addSymbol(""quot"");

        fSeenRootElement = false;

        fAttrList = new XMLAttrList(fStringPool);

    } // init()

    // features

    /**
     * This method sets whether the expansion of the nodes in the default
     * DOM implementation are deferred.
     *
     * @see #getDeferNodeExpansion
     * @see #setDocumentClassName
     */
    protected void setDeferNodeExpansion(boolean deferNodeExpansion) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fDeferNodeExpansion = deferNodeExpansion;
    }

    /**
     * Returns true if the expansion of the nodes in the default DOM
     * implementation are deferred.
     *
     * @see #setDeferNodeExpansion
     */
    protected boolean getDeferNodeExpansion() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fDeferNodeExpansion;
    }

    /**
     * This feature determines whether entity references within
     * the document are included in the document tree as
     * EntityReference nodes.
     * <p>
     * Note: The children of the entity reference are always
     * added to the document. This feature only affects
     * whether an EntityReference node is also included
     * as the parent of the entity reference children.
     *
     * @param create True to create entity reference nodes; false
     *               to only insert the entity reference children.
     *
     * @see #getCreateEntityReferenceNodes
     */
    protected void setCreateEntityReferenceNodes(boolean create) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fCreateEntityReferenceNodes = create;
    }

    /**
     * Returns true if entity references within the document are
     * included in the document tree as EntityReference nodes.
     *
     * @see #setCreateEntityReferenceNodes
     */
    public boolean getCreateEntityReferenceNodes() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fCreateEntityReferenceNodes;
    }

    /**
     * This feature determines whether text nodes that can be
     * considered ""ignorable whitespace"" are included in the DOM
     * tree.
     * <p>
     * Note: The only way that the parser can determine if text
     * is ignorable is by reading the associated grammar
     * and having a content model for the document. When
     * ignorable whitespace text nodes *are* included in
     * the DOM tree, they will be flagged as ignorable.
     * The ignorable flag can be queried by calling the
     * TextImpl#isIgnorableWhitespace():boolean method.
     *
     * @param include True to include ignorable whitespace text nodes;
     *                false to not include ignorable whitespace text
     *                nodes.
     *
     * @see #getIncludeIgnorableWhitespace
     */
    public void setIncludeIgnorableWhitespace(boolean include) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fIncludeIgnorableWhitespace = include;
    }

    /**
     * Returns true if ignorable whitespace text nodes are included
     * in the DOM tree.
     *
     * @see #setIncludeIgnorableWhitespace
     */
    public boolean getIncludeIgnorableWhitespace() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fIncludeIgnorableWhitespace;
    }
    
    // properties

    /**
     * This method allows the programmer to decide which document
     * factory to use when constructing the DOM tree. However, doing
     * so will lose the functionality of the default factory. Also,
     * a document class other than the default will lose the ability
     * to defer node expansion on the DOM tree produced.
     *
     * @param documentClassName The fully qualified class name of the
     *                      document factory to use when constructing
     *                      the DOM tree.
     *
     * @see #getDocumentClassName
     * @see #setDeferNodeExpansion
     * @see #DEFAULT_DOCUMENT_CLASS_NAME
     */
    protected void setDocumentClassName(String documentClassName) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        // normalize class name
        if (documentClassName == null) {
            documentClassName = DEFAULT_DOCUMENT_CLASS_NAME;
        }

        // verify that this class exists and is of the right type
        try {
            Class _class = Class.forName(documentClassName);
            //if (!_class.isAssignableFrom(Document.class)) {
            if (!Document.class.isAssignableFrom(_class)) {
                throw new IllegalArgumentException(""PAR002 Class, \""""+documentClassName+""\"", is not of type org.w3c.dom.Document.""+""\n""+documentClassName);
            }
        }
        catch (ClassNotFoundException e) {
            throw new IllegalArgumentException(""PAR003 Class, \""""+documentClassName+""\"", not found.""+""\n""+documentClassName);
        }

        // set document class name
        fDocumentClassName = documentClassName;
        if (!documentClassName.equals(DEFAULT_DOCUMENT_CLASS_NAME)) {
            setDeferNodeExpansion(false);
        }

    } // setDocumentClassName(String)

    /**
     * Returns the fully qualified class name of the document factory
     * used when constructing the DOM tree.
     *
     * @see #setDocumentClassName
     */
    protected String getDocumentClassName() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fDocumentClassName;
    }

    /**
     * Returns the current element node.
     * <p>
     * Note: This method is not supported when the ""deferNodeExpansion""
     *       property is set to true and the document factory is set to
     *       the default factory.
     */
    protected Element getCurrentElementNode() 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        if (fCurrentElementNode != null &&
            fCurrentElementNode.getNodeType() == Node.ELEMENT_NODE) {
            return (Element)fCurrentElementNode;
        }
        return null;

    } // getCurrentElementNode():Element

    //
    // Configurable methods
    //

    /**
     * Set the state of any feature in a SAX2 parser.  The parser
     * might not recognize the feature, and if it does recognize
     * it, it might not be able to fulfill the request.
     *
     * @param featureId The unique identifier (URI) of the feature.
     * @param state The requested state of the feature (true or false).
     *
     * @exception SAXNotRecognizedException If the requested feature is
     *                                      not known.
     * @exception SAXNotSupportedException If the requested feature is
     *                                     known, but the requested state
     *                                     is not supported.
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 core features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            //
            // No additional SAX properties defined for DOMParser.
            // Pass request off to XMLParser for the common cases.
            //
        }

        //
        // Xerces features
        //

        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            String feature = featureId.substring(XERCES_FEATURES_PREFIX.length());
            //
            // http://apache.org/xml/features/dom/defer-node-expansion
            //   Allows the document tree returned by getDocument()
            //   to be constructed lazily. In other words, the DOM
            //   nodes are constructed as the tree is traversed.
            //   This allows the document to be returned sooner with
            //   the expense of holding all of the blocks of character
            //   data held in memory. Then again, lots of DOM nodes
            //   use a lot of memory as well.
            //
            if (feature.equals(""dom/defer-node-expansion"")) {
                if (fParseInProgress) {
                    throw new SAXNotSupportedException(""PAR004 Cannot setFeature(""+featureId + ""): parse is in progress.""+""\n""+featureId);
                }
                setDeferNodeExpansion(state);
                return;
            }
            //
            // http://apache.org/xml/features/dom/create-entity-ref-nodes
            //   This feature determines whether entity references within
            //   the document are included in the document tree as
            //   EntityReference nodes.
            //   Note: The children of the entity reference are always
            //         added to the document. This feature only affects
            //         whether an EntityReference node is also included
            //         as the parent of the entity reference children.
            //
            if (feature.equals(""dom/create-entity-ref-nodes"")) {
                setCreateEntityReferenceNodes(state);
                return;
            }

            //
            // http://apache.org/xml/features/dom/include-ignorable-whitespace
            //   This feature determines whether text nodes that can be
            //   considered ""ignorable whitespace"" are included in the DOM
            //   tree.
            //   Note: The only way that the parser can determine if text
            //         is ignorable is by reading the associated grammar
            //         and having a content model for the document. When
            //         ignorable whitespace text nodes *are* included in
            //         the DOM tree, they will be flagged as ignorable.
            //         The ignorable flag can be queried by calling the
            //         TextImpl#isIgnorableWhitespace():boolean method.
            //
            if (feature.equals(""dom/include-ignorable-whitespace"")) {
                setIncludeIgnorableWhitespace(state);
                return;
            }
            
            //
            // Experimental features
            //

            //
            // http://apache.org/xml/features/domx/grammar-access
            //   Allows grammar access in the DOM tree. Currently, this
            //   means that there is an XML Schema document tree as a
            //   child of the Doctype node.
            //
            if (feature.equals(""domx/grammar-access"")) {
                fGrammarAccess = state;
                return;
            }

            //
            // Pass request off to XMLParser for the common cases.
            //
        }

        //
        // Pass request off to XMLParser for the common cases.
        //
        super.setFeature(featureId, state);

    } // setFeature(String,boolean)

    /**
     * Query the current state of any feature in a SAX2 parser.  The
     * parser might not recognize the feature.
     *
     * @param featureId The unique identifier (URI) of the feature
     *                  being set.
     *
     * @return The current state of the feature.
     *
     * @exception SAXNotRecognizedException If the requested feature is
     *                                      not known.
     */
    public boolean getFeature(String featureId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 core features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            //
            // No additional SAX properties defined for DOMParser.
            // Pass request off to XMLParser for the common cases.
            //
        }

        //
        // Xerces features
        //

        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            String feature = featureId.substring(XERCES_FEATURES_PREFIX.length());
            //
            // http://apache.org/xml/features/dom/defer-node-expansion
            //   Allows the document tree returned by getDocument()
            //   to be constructed lazily. In other words, the DOM
            //   nodes are constructed as the tree is traversed.
            //   This allows the document to be returned sooner with
            //   the expense of holding all of the blocks of character
            //   data held in memory. Then again, lots of DOM nodes
            //   use a lot of memory as well.
            //
            if (feature.equals(""dom/defer-node-expansion"")) {
                return getDeferNodeExpansion();
            }
            //
            // http://apache.org/xml/features/dom/create-entity-ref-nodes
            //   This feature determines whether entity references within
            //   the document are included in the document tree as
            //   EntityReference nodes.
            //   Note: The children of the entity reference are always
            //         added to the document. This feature only affects
            //         whether an EntityReference node is also included
            //         as the parent of the entity reference children.
            //
            else if (feature.equals(""dom/create-entity-ref-nodes"")) {
                return getCreateEntityReferenceNodes();
            }

            //
            // http://apache.org/xml/features/dom/include-ignorable-whitespace
            //   This feature determines whether text nodes that can be
            //   considered ""ignorable whitespace"" are included in the DOM
            //   tree.
            //   Note: The only way that the parser can determine if text
            //         is ignorable is by reading the associated grammar
            //         and having a content model for the document. When
            //         ignorable whitespace text nodes *are* included in
            //         the DOM tree, they will be flagged as ignorable.
            //         The ignorable flag can be queried by calling the
            //         TextImpl#isIgnorableWhitespace():boolean method.
            //
            if (feature.equals(""dom/include-ignorable-whitespace"")) {
                return getIncludeIgnorableWhitespace();
            }

            //
            // Experimental features
            //

            //
            // http://apache.org/xml/features/domx/grammar-access
            //   Allows grammar access in the DOM tree. Currently, this
            //   means that there is an XML Schema document tree as a
            //   child of the Doctype node.
            //
            if (feature.equals(""domx/grammar-access"")) {
                return fGrammarAccess;
            }

            //
            // Pass request off to XMLParser for the common cases.
            //
        }

        //
        // Pass request off to XMLParser for the common cases.
        //
        return super.getFeature(featureId);

    } // getFeature(String):boolean

    /**
     * Set the value of any property in a SAX2 parser.  The parser
     * might not recognize the property, and if it does recognize
     * it, it might not support the requested value.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     * @param Object The value to which the property is being set.
     *
     * @exception SAXNotRecognizedException If the requested property is
     *                                      not known.
     * @exception SAXNotSupportedException If the requested property is
     *                                     known, but the requested
     *                                     value is not supported.
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // Xerces properties
        //

        if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(XERCES_PROPERTIES_PREFIX.length());
            //
            // http://apache.org/xml/properties/dom/current-element-node
            //   Returns the current element node as the DOM Parser is
            //   parsing. This property is useful for determining the
            //   relative location of the document when an error is
            //   encountered. Note that this feature does *not* work
            //   when the http://apache.org/xml/features/dom/defer-node-expansion
            //   is set to true.
            //
            if (property.equals(""dom/current-element-node"")) {
                throw new SAXNotSupportedException(""PAR005 Property, \""""+propertyId+""\"" is read-only.\n""+propertyId);
            }
            //
            // http://apache.org/xml/properties/dom/document-class-name
            //   This property can be used to set/query the name of the
            //   document factory.
            //
            else if (property.equals(""dom/document-class-name"")) {
                if (value != null && !(value instanceof String)) {
                    throw new SAXNotSupportedException(""PAR006 Property value must be of type java.lang.String."");
                }
                setDocumentClassName((String)value);
                return;
            }
        }

        //
        // Pass request off to XMLParser for the common cases.
        //
        super.setProperty(propertyId, value);

    } // setProperty(String,Object)

    /**
     * Return the current value of a property in a SAX2 parser.
     * The parser might not recognize the property.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     *
     * @return The current value of the property.
     *
     * @exception SAXNotRecognizedException If the requested property is
     *                                      not known.
     *
     * @see Configurable#getProperty
     */
    public Object getProperty(String propertyId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // Xerces properties
        //

        if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(XERCES_PROPERTIES_PREFIX.length());
            //
            // http://apache.org/xml/properties/dom/current-element-node
            //   Returns the current element node as the DOM Parser is
            //   parsing. This property is useful for determining the
            //   relative location of the document when an error is
            //   encountered. Note that this feature does *not* work
            //   when the http://apache.org/xml/features/dom/defer-node-expansion
            //   is set to true.
            //
            if (property.equals(""dom/current-element-node"")) {
                boolean throwException = false;
                try {
                    throwException = getFeature(XERCES_FEATURES_PREFIX+""dom/defer-node-expansion"");
                }
                catch (SAXNotSupportedException e) {
                    // ignore
                }
                catch (SAXNotRecognizedException e) {
                    // ignore
                }
                if (throwException) {
                    throw new SAXNotSupportedException(""PAR007 Current element node cannot be queried when node expansion is deferred."");
                }
                return getCurrentElementNode();
            }
            //
            // http://apache.org/xml/properties/dom/document-class-name
            //   This property can be used to set/query the name of the
            //   document factory.
            //
            else if (property.equals(""dom/document-class-name"")) {
                return getDocumentClassName();
            }
        }

        //
        // Pass request off to XMLParser for the common cases.
        //
        return super.getProperty(propertyId);

    } // getProperty(String):Object

    //
    // XMLParser methods
    //

    /** Start document. */
    public void startDocument() {

        // deferred expansion
        String documentClassName = null;
        try {
            documentClassName = getDocumentClassName();
        } catch (SAXException e) {
            throw new RuntimeException(""PAR008 Fatal error getting document factory."");
        }
        boolean deferNodeExpansion = true;
        try {
            deferNodeExpansion = getDeferNodeExpansion();
        } catch (SAXException e) {
            throw new RuntimeException(""PAR009 Fatal error reading expansion mode."");
        }
        if (documentClassName.equals(DEFAULT_DOCUMENT_CLASS_NAME) && deferNodeExpansion) {
            boolean nsEnabled = false;
            try { nsEnabled = getNamespaces(); }
            catch (SAXException s) {}
            fDocument = fDeferredDocumentImpl =
                new DeferredDocumentImpl(fStringPool, nsEnabled, fGrammarAccess);
            fDocumentIndex = fDeferredDocumentImpl.createDocument();
            fCurrentNodeIndex = fDocumentIndex;
        }

        // full expansion
        else {

            if (documentClassName.equals(DEFAULT_DOCUMENT_CLASS_NAME)) {
                fDocument = fDocumentImpl = new DocumentImpl(fGrammarAccess);
                fDocumentImpl.setErrorChecking(false);
            }
            else {
                try {
                    Class documentClass = Class.forName(documentClassName);
                    fDocument = (Document)documentClass.newInstance();
                }
                catch (Exception e) {
                    // REVISIT: We've already checked the type of the factory
                    //          in the setDocumentClassName() method. The only
                    //          exception that can occur here is if the class
                    //          doesn't have a zero-arg constructor. -Ac
                }
            }

            fCurrentElementNode = fDocument;
        }

    } // startDocument()

    /** End document. */
    public void endDocument() throws Exception {}

    /** XML declaration. */
    public void xmlDecl(int versionIndex, int encodingIndex, int standaloneIndex) throws Exception {

        // release strings
        fStringPool.releaseString(versionIndex);
        fStringPool.releaseString(encodingIndex);
        fStringPool.releaseString(standaloneIndex);
    }

    /** Text declaration. */
    public void textDecl(int versionIndex, int encodingIndex) throws Exception {

        // release strings
        fStringPool.releaseString(versionIndex);
        fStringPool.releaseString(encodingIndex);
    }

    /** Report the start of the scope of a namespace declaration. */
    public void startNamespaceDeclScope(int prefix, int uri) throws Exception {}

    /** Report the end of the scope of a namespace declaration. */
    public void endNamespaceDeclScope(int prefix) throws Exception {}
    
    

    /** Start element. */
    public void startElement(QName elementQName,
                             XMLAttrList xmlAttrList, int attrListIndex)
        throws Exception {

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            int element =
                fDeferredDocumentImpl.createElement(elementQName.rawname,
                                                    elementQName.uri,
                                                    xmlAttrList,
                                                    attrListIndex);
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, element);
            fCurrentNodeIndex = element;
            fWithinElement = true;

            // identifier registration
            int index = xmlAttrList.getFirstAttr(attrListIndex);
            while (index != -1) {
                if (xmlAttrList.getAttType(index) == fStringPool.addSymbol(""ID"")) {
                    int nameIndex = xmlAttrList.getAttValue(index);
                    fDeferredDocumentImpl.putIdentifier(nameIndex, element);
                }
                index = xmlAttrList.getNextAttr(index);
            }

            // copy schema grammar, if needed
            if (!fSeenRootElement) {
                fSeenRootElement = true;
                /*REVISIT - Grammar Access revisit
                if (fGrammarAccess) {
                    Document schemaDocument = fValidator.getSchemaDocument();
                    if (schemaDocument != null) {
                        if (fDocumentTypeIndex == -1) {
                            fDocumentTypeIndex = fDeferredDocumentImpl.createDocumentType(elementQName.rawname, -1, -1);
                            fDeferredDocumentImpl.appendChild(0, fDocumentTypeIndex);
                        }

                        Element schema = schemaDocument.getDocumentElement();
                        copyInto(schema, fDocumentTypeIndex);
                    }
                }
              */
            }
        }

        // full expansion
        else {

            boolean nsEnabled = false;
            try { nsEnabled = getNamespaces(); }
            catch (SAXException s) {}

            String elementName = fStringPool.toString(elementQName.rawname);
            Element e;
            if (nsEnabled) {
                e = fDocument.createElementNS(
                        // REVISIT: Make sure uri is filled in by caller.
                        fStringPool.toString(elementQName.uri),
                        fStringPool.toString(elementQName.localpart)
                    );
            } else {
                e = fDocument.createElement(elementName);
            }
            int attrHandle = xmlAttrList.getFirstAttr(attrListIndex);
            while (attrHandle != -1) {
                if (nsEnabled) {
                    int attName = xmlAttrList.getAttrName(attrHandle);
                    String attNameStr = fStringPool.toString(attName);
		    int nsURIIndex = xmlAttrList.getAttrURI(attrHandle);
		    String namespaceURI = fStringPool.toString(nsURIIndex);
		    // DOM Level 2 wants all namespace declaration attributes
		    // to be bound to ""http://www.w3.org/2000/xmlns/""
		    // So as long as the XML parser doesn't do it, it needs to
		    // done here.
		    int prefixIndex = xmlAttrList.getAttrPrefix(attrHandle);
		    String prefix = fStringPool.toString(prefixIndex);
		    if (namespaceURI == null) {
			if (prefix != null) {
			    if (prefix.equals(""xmlns"")) {
				namespaceURI = ""http://www.w3.org/2000/xmlns/"";
			    }
			} else if (attNameStr.equals(""xmlns"")) {
			    namespaceURI = ""http://www.w3.org/2000/xmlns/"";
			}
		    }
                    e.setAttributeNS(namespaceURI,
				     attNameStr,
                                     xmlAttrList.getValue(attrHandle));
                } else {
                    String attrName = fStringPool.toString(xmlAttrList.getAttrName(attrHandle));
                    String attrValue = fStringPool.toString(xmlAttrList.getAttValue(attrHandle));
                    e.setAttribute(attrName, attrValue);
                    if (fDocumentImpl != null
                        && !xmlAttrList.isSpecified(attrHandle)) {
                        ((AttrImpl)e.getAttributeNode(attrName))
                            .setSpecified(false);
                    }
                }
                attrHandle = xmlAttrList.getNextAttr(attrHandle);
            }
            fCurrentElementNode.appendChild(e);
            fCurrentElementNode = e;
            fWithinElement = true;

            // identifier registration
            if (fDocumentImpl != null) {
                int index = xmlAttrList.getFirstAttr(attrListIndex);
                while (index != -1) {
                    if (xmlAttrList.getAttType(index) == fStringPool.addSymbol(""ID"")) {
                        String name = fStringPool.toString(xmlAttrList.getAttValue(index));
                        fDocumentImpl.putIdentifier(name, e);
                    }
                    index = xmlAttrList.getNextAttr(index);
                }
            }

            xmlAttrList.releaseAttrList(attrListIndex);

            // copy schema grammar, if needed
            if (!fSeenRootElement) {
                fSeenRootElement = true;
                /* REVISIT Grammar Access
                if (fDocumentImpl != null && fGrammarAccess)  {
                    Document schemaDocument = fValidator.getSchemaDocument();
                    if (schemaDocument != null) {
                        if (fDocumentType == null) {
                            String rootName = elementName;
                            String systemId = """"; // REVISIT: How do we get this value? -Ac
                            String publicId = """"; // REVISIT: How do we get this value? -Ac
                            fDocumentType = fDocumentImpl.createDocumentType(rootName, publicId, systemId);
                            fDocument.appendChild(fDocumentType);
                        }

                        Element schema = schemaDocument.getDocumentElement();
                        XUtil.copyInto(schema, fDocumentType);
                    }
                }
               */
            }
        }

    } // startElement(QName,XMLAttrList,int)

    /** End element. */
    public void endElement(QName elementQName)
        throws Exception {

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {
            fCurrentNodeIndex = fDeferredDocumentImpl.getParentNode(fCurrentNodeIndex, false);
            fWithinElement = false;
        }

        // full node expansion
        else {
            fCurrentElementNode = fCurrentElementNode.getParentNode();
            fWithinElement = false;
        }

    } // endElement(QName)

    /** Characters. */
    public void characters(int dataIndex)
        throws Exception {

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {

            int text;

            if (fInCDATA) {
                text = fDeferredDocumentImpl.createCDATASection(dataIndex, false);
            } else {
                // The Text normalization is taken care of within the Text Node
                // in the DEFERRED case.
                text = fDeferredDocumentImpl.createTextNode(dataIndex, false);
            }
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, text);
        }

        // full node expansion
        else {

            Text text;

            if (fInCDATA) {
                text = fDocument.createCDATASection(fStringPool.orphanString(dataIndex));
            }
            else {

                if (fWithinElement && fCurrentElementNode.getNodeType() == Node.ELEMENT_NODE) {
                    Node lastChild = fCurrentElementNode.getLastChild();
                    if (lastChild != null
                        && lastChild.getNodeType() == Node.TEXT_NODE) {
                        // Normalization of Text Nodes - append rather than create.
                        ((Text)lastChild).appendData(fStringPool.orphanString(dataIndex));
                        return;
                    }
                }
                text = fDocument.createTextNode(fStringPool.orphanString(dataIndex));
            }

            fCurrentElementNode.appendChild(text);

        }

    } // characters(int)

    /** Ignorable whitespace. */
    public void ignorableWhitespace(int dataIndex) throws Exception {

        // ignore the whitespace
        if (!fIncludeIgnorableWhitespace) {
            fStringPool.orphanString(dataIndex);
            return;
        }

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {

            int text;

            if (fInCDATA) {
                text = fDeferredDocumentImpl.createCDATASection(dataIndex, true);
            } else {
                // The Text normalization is taken care of within the Text Node
                // in the DEFERRED case.
                text = fDeferredDocumentImpl.createTextNode(dataIndex, true);
            }
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, text);
        }

        // full node expansion
        else {

            Text text;

            if (fInCDATA) {
                text = fDocument.createCDATASection(fStringPool.orphanString(dataIndex));
            }
            else {

                if (fWithinElement && fCurrentElementNode.getNodeType() == Node.ELEMENT_NODE) {
                    Node lastChild = fCurrentElementNode.getLastChild();
                    if (lastChild != null
                        && lastChild.getNodeType() == Node.TEXT_NODE) {
                        // Normalization of Text Nodes - append rather than create.
                        ((Text)lastChild).appendData(fStringPool.orphanString(dataIndex));
                        return;
                    }
                }
                text = fDocument.createTextNode(fStringPool.orphanString(dataIndex));
            }

            if (fDocumentImpl != null) {
                ((TextImpl)text).setIgnorableWhitespace(true);
            }

            fCurrentElementNode.appendChild(text);

        }

    } // ignorableWhitespace(int)

    /** Processing instruction. */
    public void processingInstruction(int targetIndex, int dataIndex)
        throws Exception {

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {
            int pi = fDeferredDocumentImpl.createProcessingInstruction(targetIndex, dataIndex);
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, pi);
        }

        // full node expansion
        else {
            String target = fStringPool.orphanString(targetIndex);
            String data = fStringPool.orphanString(dataIndex);
            ProcessingInstruction pi = fDocument.createProcessingInstruction(target, data);
            fCurrentElementNode.appendChild(pi);
        }

    } // processingInstruction(int,int)

    /** Comment. */
    public void comment(int dataIndex) throws Exception {

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {
            int comment = fDeferredDocumentImpl.createComment(dataIndex);
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, comment);
        }

        // full node expansion
        else {
            Comment comment = fDocument.createComment(fStringPool.orphanString(dataIndex));
            fCurrentElementNode.appendChild(comment);
        }

    } // comment(int)

    /** Not called. */
    public void characters(char ch[], int start, int length) throws Exception {}

    /** Not called. */
    public void ignorableWhitespace(char ch[], int start, int length) throws Exception {}

    //
    // XMLDocumentScanner methods
    //

    /** Start CDATA section. */
    public void startCDATA() throws Exception {
        fInCDATA = true;
    }

    /** End CDATA section. */
    public void endCDATA() throws Exception {
        fInCDATA = false;
    }

    //
    // XMLEntityHandler methods
    //

    /** Start entity reference. */
    public void startEntityReference(int entityName, int entityType,
                                     int entityContext) throws Exception {

        // are we ignoring entity reference nodes?
        if (!fCreateEntityReferenceNodes) {
            return;
        }

        // ignore built-in entities
        if (entityName == fAmpIndex ||
            entityName == fGtIndex ||
            entityName == fLtIndex ||
            entityName == fAposIndex ||
            entityName == fQuotIndex) {
            return;
        }

        // we only support one context for entity references right now...
        if (entityContext != XMLEntityHandler.ENTITYREF_IN_CONTENT) {
            return;
        }

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {

            int entityRefIndex = fDeferredDocumentImpl.createEntityReference(entityName);
            fDeferredDocumentImpl.appendChild(fCurrentNodeIndex, entityRefIndex);

            fCurrentNodeIndex = entityRefIndex;
        }

        // full node expansion
        else {

            EntityReference er =
             fDocument.createEntityReference(fStringPool.toString(entityName));

            fCurrentElementNode.appendChild(er);
            fCurrentElementNode = er;
            try {
                EntityReferenceImpl xer = (EntityReferenceImpl) er;
                xer.setReadOnly(false, false);
            } catch (Exception e) {
                // we aren't building against Xerces - do nothing
            }
        }

    } // startEntityReference(int,int,int)

    /** End entity reference. */
    public void endEntityReference(int entityName, int entityType,
                                   int entityContext) throws Exception {

        // are we ignoring entity reference nodes?
        if (!fCreateEntityReferenceNodes) {
            return;
        }

        // ignore built-in entities
        if (entityName == fAmpIndex ||
            entityName == fGtIndex ||
            entityName == fLtIndex ||
            entityName == fAposIndex ||
            entityName == fQuotIndex) {
            return;
        }

        // we only support one context for entity references right now...
        if (entityContext != XMLEntityHandler.ENTITYREF_IN_CONTENT) {
            return;
        }

        // deferred node expansion
        if (fDeferredDocumentImpl != null) {

            String name = fStringPool.toString(entityName);

            int erChild = fCurrentNodeIndex;
            fCurrentNodeIndex = fDeferredDocumentImpl.getParentNode(erChild, false);

            // should never be true - we should not return here.
            if (fDeferredDocumentImpl.getNodeType(erChild, false) != Node.ENTITY_REFERENCE_NODE)  return;

            erChild = fDeferredDocumentImpl.getLastChild(erChild, false); // first Child of EntityReference

            if (fDocumentTypeIndex != -1) {
                // find Entity decl for this EntityReference.
                int entityDecl = fDeferredDocumentImpl.getLastChild(fDocumentTypeIndex, false);
                while (entityDecl != -1) {
                    if (fDeferredDocumentImpl.getNodeType(entityDecl, false) == Node.ENTITY_NODE
                    && fDeferredDocumentImpl.getNodeNameString(entityDecl, false).equals(name)) // string compare...
                    {
                        break;
                    }
                    entityDecl = fDeferredDocumentImpl.getPrevSibling(entityDecl, false);
                }

                if (entityDecl != -1
                    && fDeferredDocumentImpl.getLastChild(entityDecl, false) == -1) {
                    // found entityDecl with same name as this reference
                    // AND it doesn't have any children.

                    // we don't need to iterate, because the whole structure
                    // should already be connected to the 1st child.
                    fDeferredDocumentImpl.setAsLastChild(entityDecl, erChild);
                }
            }

        }

        // full node expansion
        else {

            Node erNode = fCurrentElementNode;//fCurrentElementNode.getParentNode();
            fCurrentElementNode = erNode.getParentNode();

            try {
                EntityReferenceImpl xer = (EntityReferenceImpl) erNode;
                xer.setReadOnly(false, false);

                // if necessary populate the related entity now
                if (fDocumentImpl != null) {

                    NamedNodeMap entities = fDocumentType.getEntities();
                    String name = fStringPool.toString(entityName);
                    Node entityNode = entities.getNamedItem(name);

                    // We could simply return here if there is no entity for
                    // the reference or if the entity is already populated.
                    if (entityNode == null || entityNode.hasChildNodes()) {
                        return;
                    }

                    EntityImpl entity = (EntityImpl) entityNode;
                    entity.setReadOnly(false, false);
                    for (Node child = erNode.getFirstChild();
                         child != null;
                         child = child.getNextSibling()) {
                        Node childClone = child.cloneNode(true);
                        entity.appendChild(childClone);
                    }
                    entity.setReadOnly(true, true);
                }
            } catch (Exception e) {
                // we aren't building against Xerces - do nothing
            }
        }

    } // endEntityReference(int,int,int)

    //
    // DTDValidator.EventHandler methods
    //

    /**
     *  This function will be called when a &lt;!DOCTYPE...&gt; declaration is
     *  encountered.
     */
    public void startDTD(QName rootElement, int publicId, int systemId)
        throws Exception {

        // full expansion
        if (fDocumentImpl != null) {
            String rootElementName = fStringPool.toString(rootElement.rawname);
            String publicString = fStringPool.toString(publicId);
            String systemString = fStringPool.toString(systemId);
            fDocumentType = fDocumentImpl.
                createDocumentType(rootElementName, publicString, systemString);
            fDocumentImpl.appendChild(fDocumentType);

            /*  TODO - Grammar Access revisit

            if (fGrammarAccess) {
                Element schema = fDocument.createElement(""schema"");
                // REVISIT: What should the namespace be? -Ac
                schema.setAttribute(""xmlns"", ""http://www.w3.org/1999/XMLSchema"");
                ((AttrImpl)schema.getAttributeNode(""xmlns"")).setSpecified(false);
                schema.setAttribute(""finalDefault"", """");
                ((AttrImpl)schema.getAttributeNode(""finalDefault"")).setSpecified(false);
                schema.setAttribute(""exactDefault"", """");
                ((AttrImpl)schema.getAttributeNode(""exactDefault"")).setSpecified(false);
                fDocumentType.appendChild(schema);
            } */

        }

        // deferred expansion
        else if (fDeferredDocumentImpl != null) {
            fDocumentTypeIndex =
                fDeferredDocumentImpl.
                    createDocumentType(rootElement.rawname, publicId, systemId);
            fDeferredDocumentImpl.appendChild(fDocumentIndex, fDocumentTypeIndex);

            /*REVISIT - Grammar Access
            if (fGrammarAccess) {
                int handle = fAttrList.startAttrList();
                fAttrList.addAttr(
                    fStringPool.addSymbol(""xmlns""),
                    fStringPool.addString(""http://www.w3.org/1999/XMLSchema""),
                    fStringPool.addSymbol(""CDATA""),
                    false,
                    false); // search
                fAttrList.addAttr(
                    fStringPool.addSymbol(""finalDefault""),
                    fStringPool.addString(""""),
                    fStringPool.addSymbol(""CDATA""),
                    false,
                    false); // search
                fAttrList.addAttr(
                    fStringPool.addSymbol(""exactDefault""),
                    fStringPool.addString(""""),
                    fStringPool.addSymbol(""CDATA""),
                    false,
                    false); // search
                fAttrList.endAttrList();
                int schemaIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""schema""), fAttrList, handle);
                // REVISIT: What should the namespace be? -Ac
                fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, schemaIndex);
            }
            */
        }

    } // startDTD(int,int,int)
    
    /**
     * Supports DOM Level 2 internalSubset additions.
     * Called when the internal subset is completely scanned.
     */
    public  void internalSubset(int internalSubset) {
        
        //System.out.println(""internalSubset callback:""+fStringPool.toString(internalSubset));
        
        // full expansion
        if (fDocumentImpl != null && fDocumentType != null) {
            ((DocumentTypeImpl)fDocumentType).setInternalSubset(fStringPool.toString(internalSubset));
        }

        // deferred expansion
        else if (fDeferredDocumentImpl != null) {
            fDeferredDocumentImpl.setInternalSubset(fDocumentTypeIndex, internalSubset);
        }
        
    }
    

    /**
     *  This function will be called at the end of the DTD.
     */
    public void endDTD() throws Exception {}

    /**
     * &lt;!ELEMENT Name contentspec&gt;
     */
    public void elementDecl(QName elementDecl, XMLContentSpec contentSpec)
        throws Exception {

        if (DEBUG_ATTLIST_DECL) {
            String contentModel = contentSpec.toString();
            System.out.println(""elementDecl("" + fStringPool.toString(elementDecl.rawname) + "", "" +
                                                contentModel + "")"");
        }

        //
        // Create element declaration
        //
        /*REVISIT  Grammar Access
        if (fGrammarAccess) {

            if (fDeferredDocumentImpl != null) {

                //
                // Build element
                //

                // get element declaration; create if necessary
                int schemaIndex = getLastChildElement(fDocumentTypeIndex, ""schema"");
                String elementName = fStringPool.toString(elementDecl.rawname);
                int elementIndex = getLastChildElement(schemaIndex, ""element"", ""name"", elementName);
                if (elementIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(elementName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""minOccurs""), // name
                        fStringPool.addString(""1""), // value
                        fStringPool.addSymbol(""NMTOKEN""), // type
                        false, // specified
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""nullable""), // name
                        fStringPool.addString(""false""), // value
                        fStringPool.addSymbol(""ENUMERATION""), // type
                        false, // specified
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""abstract""), // name
                        fStringPool.addString(""false""), // value
                        fStringPool.addSymbol(""ENUMERATION""), // type
                        false, // specified
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""final""), // name
                        fStringPool.addString(""false""), // value
                        fStringPool.addSymbol(""ENUMERATION""), // type
                        false, // specified
                        false); // search
                    fAttrList.endAttrList();
                    elementIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""element""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, elementIndex);
                }

                //
                // Build content model
                //

                // <!ELEMENT name (#PCDATA)>
                int contentType = contentSpec.getType();
                String contentTypeName = fStringPool.toString(contentType);
                XMLContentSpec.Node node = new XMLContentSpec.Node();
                int contentSpecHandle = contentSpec.getHandle();
                if (contentSpecHandle != -1) {
                    contentSpec.getNode(contentSpecHandle, node);
                }

                // (#PCDATA)
                if (contentTypeName.equals(""MIXED"") && node.type == 0) {
                    int attrNameIndex = fStringPool.addSymbol(""type"");
                    int attrValueIndex = fStringPool.addString(""string"");
                    boolean attrSpecified = true;
                    int attrIndex = fDeferredDocumentImpl.createAttribute(attrNameIndex, attrValueIndex, attrSpecified);
                    fDeferredDocumentImpl.setAttributeNode(elementIndex, attrIndex);
                }

                // other content models
                else {
                    // get type element; create if necessary
                    int typeIndex = getLastChildElement(elementIndex, ""type"");
                    if (typeIndex == -1) {
                        typeIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""type""), null, -1);
                        // REVISIT: Check for type redeclaration? -Ac
                        fDeferredDocumentImpl.insertBefore(elementIndex, typeIndex, getLastChildElement(elementIndex));
                    }

                    // <!ELEMENT name EMPTY>
                    if (contentTypeName.equals(""EMPTY"")) {
                        int attributeIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""content""), fStringPool.addString(""empty""), true);
                        fDeferredDocumentImpl.setAttributeNode(typeIndex, attributeIndex);
                    }

                    // <!ELEMENT name ANY>
                    else if (contentTypeName.equals(""ANY"")) {
                        int anyIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""any""), null, -1);
                        fDeferredDocumentImpl.insertBefore(typeIndex, anyIndex, getLastChildElement(typeIndex));
                    }

                    // <!ELEMENT name (a,b,...)> or <!ELEMENT name (a|b|...)>
                    else if (contentTypeName.equals(""CHILDREN"")) {
                        int attributeIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""content""), fStringPool.addString(""elementOnly""), true);
                        fDeferredDocumentImpl.setAttributeNode(typeIndex, attributeIndex);
                        //attributeIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""order""), fStringPool.addString(""seq""), false);
                        //fDeferredDocumentImpl.setAttributeNode(typeIndex, attributeIndex);

                        int contentSpecIndex = contentSpec.getHandle();
                        contentSpec.getNode(contentSpecIndex, node);
                        Element model = createContentModel(contentSpec, node);

                        int modelIndex = createDeferredContentModel(model);
                        int firstChildIndex = getLastChildElement(typeIndex);
                        fDeferredDocumentImpl.insertBefore(typeIndex, modelIndex, firstChildIndex);
                    }

                    // <!ELEMENT name (#PCDATA|a|...)*>
                    else {
                        // REVISIT: Any chance of getting other than MIXED? -Ac
                        // set content type
                        int attrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""content""), fStringPool.addString(""mixed""), true);
                        fDeferredDocumentImpl.setAttributeNode(typeIndex, attrIndex);

                        // skip '*' node
                        contentSpec.getNode(node.value, node);

                        // add leaves (on descent)
                        do {
                            int index = node.value;
                            int handle = fAttrList.startAttrList();
                            contentSpec.getNode(node.otherValue, node);
                            String elementRefName = fStringPool.toString(node.value);
                            fAttrList.addAttr(
                                fStringPool.addSymbol(""ref""),
                                fStringPool.addString(elementRefName),
                                fStringPool.addSymbol(""NMTOKEN""),
                                true,
                                false); // search
                            fAttrList.endAttrList();
                            int elementRefIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""element""), fAttrList, handle);
                            fDeferredDocumentImpl.insertBefore(typeIndex, elementRefIndex, getLastChildElement(typeIndex, ""element""));
                            contentSpec.getNode(index, node);
                        } while (node.type != XMLContentSpec.CONTENTSPECNODE_LEAF);
                    }
                }

            } // if defer-node-expansion

            else if (fDocumentImpl != null) {

                //
                // Build element
                //

                // get element declaration; create if necessary
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                String elementName = fStringPool.toString(elementDecl.rawname);
                Element element = XUtil.getFirstChildElement(schema, ""element"", ""name"", elementName);
                if (element == null) {
                    element = fDocument.createElement(""element"");
                    element.setAttribute(""name"", elementName);
                    element.setAttribute(""minOccurs"", ""1"");
                    ((AttrImpl)element.getAttributeNode(""minOccurs"")).setSpecified(false);
                    element.setAttribute(""nullable"", ""false"");
                    ((AttrImpl)element.getAttributeNode(""nullable"")).setSpecified(false);
                    element.setAttribute(""abstract"", ""false"");
                    ((AttrImpl)element.getAttributeNode(""abstract"")).setSpecified(false);
                    element.setAttribute(""final"", ""false"");
                    ((AttrImpl)element.getAttributeNode(""final"")).setSpecified(false);
                    schema.appendChild(element);
                }

                //
                // Build content model
                //

                // <!ELEMENT name (#PCDATA)>
                int contentType = contentSpec.getType();
                String contentTypeName = fStringPool.toString(contentType);
                XMLContentSpec.Node node = new XMLContentSpec.Node();
                int contentSpecHandle = contentSpec.getHandle();
                if (contentSpecHandle != -1) {
                    contentSpec.getNode(contentSpecHandle, node);
                }

                // (#PCDATA)
                if (contentTypeName.equals(""MIXED"") && node.type == 0) {
                    element.setAttribute(""type"", ""string"");
                }

                // other content models
                else {
                    // get type element; create if necessary
                    Element type = XUtil.getFirstChildElement(element, ""type"");
                    if (type == null) {
                        type = fDocumentImpl.createElement(""type"");
                        // REVISIT: Check for type redeclaration? -Ac
                        element.insertBefore(type, XUtil.getFirstChildElement(element));
                    }

                    // <!ELEMENT name EMPTY>
                    if (contentTypeName.equals(""EMPTY"")) {
                        type.setAttribute(""content"", ""empty"");
                    }

                    // <!ELEMENT name ANY>
                    else if (contentTypeName.equals(""ANY"")) {
                        Element any = fDocumentImpl.createElement(""any"");
                        type.insertBefore(any, XUtil.getFirstChildElement(type));
                    }

                    // <!ELEMENT name (a,b,...)> or <!ELEMENT name (a|b|...)>
                    else if (contentTypeName.equals(""CHILDREN"")) {
                        type.setAttribute(""content"", ""elementOnly"");
                        //((AttrImpl)type.getAttributeNode(""content"")).setSpecified(false);
                        //type.setAttribute(""order"", ""seq"");
                        //((AttrImpl)type.getAttributeNode(""order"")).setSpecified(false);

                        int contentSpecIndex = contentSpec.getHandle();
                        contentSpec.getNode(contentSpecIndex, node);
                        Element model = createContentModel(contentSpec, node);
                        Node fragment = fDocument.createDocumentFragment();
                        XUtil.copyInto(model, fragment);
                        Element firstChild = XUtil.getFirstChildElement(type);
                        type.insertBefore(fragment, firstChild);
                    }

                    // <!ELEMENT name (#PCDATA|a|...)*>
                    else {
                        // REVISIT: Any chance of getting other than MIXED? -Ac
                        // set content type
                        type.setAttribute(""content"", ""mixed"");

                        // skip '*' node
                        contentSpec.getNode(node.value, node);

                        // add leaves (on descent)
                        do {
                            int index = node.value;
                            int handle = fAttrList.startAttrList();
                            contentSpec.getNode(node.otherValue, node);
                            String elementRefName = fStringPool.toString(node.value);
                            Element elementRef = fDocumentImpl.createElement(""element"");
                            elementRef.setAttribute(""ref"", elementRefName);
                            type.insertBefore(elementRef, XUtil.getFirstChildElement(type, ""element""));
                            contentSpec.getNode(index, node);
                        } while (node.type != XMLContentSpec.CONTENTSPECNODE_LEAF);
                    }
                }

            } // if NOT defer-node-expansion

        } // if grammar-access
       */

    } // elementDecl(int,String)

    /**
     * &lt;!ATTLIST Name AttDef&gt;
     */
    public void attlistDecl(QName elementDecl, QName attributeDecl, 
                            int attType, String enumString,
                            int attDefaultType, int attDefaultValue)
        throws Exception {

        if (DEBUG_ATTLIST_DECL) {
            System.out.println(""attlistDecl("" + fStringPool.toString(elementDecl.rawname) + "", "" +
                                                fStringPool.toString(attributeDecl.rawname) + "", "" +
                                                fStringPool.toString(attType) + "", "" +
                                                enumString + "", "" +
                                                fStringPool.toString(attDefaultType) + "", "" +
                                                fStringPool.toString(attDefaultValue) + "")"");
        }

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            // get the default value
            if (attDefaultValue != -1) {
                if (DEBUG_ATTLIST_DECL) {
                    System.out.println(""  adding default attribute value: ""+
                                       fStringPool.toString(attDefaultValue));
                }

                // get element definition
                int elementDefIndex  = fDeferredDocumentImpl.lookupElementDefinition(elementDecl.rawname);

                // create element definition if not already there
                if (elementDefIndex == -1) {
                    elementDefIndex = fDeferredDocumentImpl.createElementDefinition(elementDecl.rawname);
                    fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, elementDefIndex);
                }

                // add default attribute
                int attrIndex =
                   fDeferredDocumentImpl.createAttribute(attributeDecl.rawname,
                                                         attributeDecl.uri,
                                                         attDefaultValue,
                                                         false);
                fDeferredDocumentImpl.appendChild(elementDefIndex, attrIndex);

            }

            //
            // Create attribute declaration
            //
            /*REVISIT- Grammar Access
            if (fGrammarAccess) {

                // get element declaration; create it if necessary
                int schemaIndex = getLastChildElement(fDocumentTypeIndex, ""schema"");
                String elementName = fStringPool.toString(elementDecl.rawname);
                int elementIndex = getLastChildElement(schemaIndex, ""element"", ""name"", elementName);
                if (elementIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(elementName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); //search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""export""),
                        fStringPool.addString(""true""),
                        fStringPool.addSymbol(""ENUMERATION""),
                        false,
                        false); // search
                    fAttrList.endAttrList();
                    elementIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""element""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, elementIndex);
                }

                // get type element; create it if necessary
                int typeIndex = getLastChildElement(elementIndex, ""type"");
                if (typeIndex == -1) {
                    typeIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""type""), null, -1);
                    fDeferredDocumentImpl.insertBefore(elementIndex, typeIndex, getLastChildElement(elementIndex));
                }

                // create attribute and set its attributes
                String attributeName = fStringPool.toString(attributeDecl.rawname);
                int attributeIndex = getLastChildElement(elementIndex, ""attribute"", ""name"", attributeName);
                if (attributeIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(attributeName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    /***
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""type""),
                        fStringPool.addString(""string""),
                        fStringPool.addSymbol(""CDATA""),
                        true,
                        false); // search
                    /***/
            /*
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""minOccurs""),
                        fStringPool.addString(""0""),
                        fStringPool.addSymbol(""CDATA""),
                        false,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""maxOccurs""),
                        fStringPool.addString(""1""),
                        fStringPool.addSymbol(""CDATA""),
                        false,
                        false); // search
                    fAttrList.endAttrList();
                    attributeIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""attribute""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(typeIndex, attributeIndex);

                    // attribute type: CDATA, ENTITY, ... , NMTOKENS; ENUMERATION
                    String attributeTypeName = fStringPool.toString(attType);
                    if (attributeTypeName.equals(""CDATA"")) {
                        int typeAttrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""type""), fStringPool.addString(""string""), false);
                        fDeferredDocumentImpl.setAttributeNode(attributeIndex, typeAttrIndex);
                    }
                    else if (attributeTypeName.equals(""ENUMERATION"")) {
                        handle = fAttrList.startAttrList();
                        fAttrList.addAttr(
                            fStringPool.addSymbol(""source""),
                            fStringPool.addString(""NMTOKEN""),
                            fStringPool.addSymbol(""CDATA""),
                            true,
                            false); // search
                        fAttrList.endAttrList();
                        int datatypeIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""datatype""), fAttrList, handle);
                        fDeferredDocumentImpl.appendChild(attributeIndex, datatypeIndex);

                        String tokenizerString = enumString.substring(1, enumString.length() - 1);
                        StringTokenizer tokenizer = new StringTokenizer(tokenizerString, ""|"");
                        while (tokenizer.hasMoreTokens()) {
                            handle = fAttrList.startAttrList();
                            fAttrList.addAttr(
                                fStringPool.addSymbol(""value""),
                                fStringPool.addString(tokenizer.nextToken()),
                                fStringPool.addSymbol(""CDATA""),
                                true,
                                false); // search
                            fAttrList.endAttrList();
                            int enumerationIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""enumeration""), fAttrList, handle);
                            fDeferredDocumentImpl.appendChild(datatypeIndex, enumerationIndex);
                        }
                    }
                    else {
                        // REVISIT: Could we ever get an unknown data type? -Ac
                        int typeAttrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""type""), fStringPool.addString(attributeTypeName), true);
                        fDeferredDocumentImpl.setAttributeNode(attributeIndex, typeAttrIndex);
                    }

                    // attribute default type: #IMPLIED, #REQUIRED, #FIXED
                    boolean fixed = false;
                    if (attDefaultType != -1) {
                        String attributeDefaultTypeName = fStringPool.toString(attDefaultType);
                        if (attributeDefaultTypeName.equals(""#REQUIRED"")) {
                            int minOccursAttrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""minOccurs""), fStringPool.addString(""1""), true);
                            int oldMinOccursAttrIndex = fDeferredDocumentImpl.setAttributeNode(attributeIndex, minOccursAttrIndex);
                            fStringPool.releaseString(fDeferredDocumentImpl.getNodeValue(oldMinOccursAttrIndex, false));
                        }
                        else if (attributeDefaultTypeName.equals(""#FIXED"")) {
                            fixed = true;
                            int fixedAttrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""fixed""), attDefaultValue, true);
                            fDeferredDocumentImpl.setAttributeNode(attributeIndex, fixedAttrIndex);
                        }
                    }

                    // attribute default value
                    if (!fixed && attDefaultValue != -1) {
                        int defaultAttrIndex = fDeferredDocumentImpl.createAttribute(fStringPool.addSymbol(""default""), attDefaultValue, true);
                        fDeferredDocumentImpl.setAttributeNode(attributeIndex, defaultAttrIndex);
                    }
                }
            }
            */

        }

        // full expansion
        else if (fDocumentImpl != null) {

            // get the default value
            if (attDefaultValue != -1) {
                if (DEBUG_ATTLIST_DECL) {
                    System.out.println(""  adding default attribute value: ""+
                                       fStringPool.toString(attDefaultValue));
                }

                // get element name
                String elementName = fStringPool.toString(elementDecl.rawname);

                // get element definition node
                NamedNodeMap elements = ((DocumentTypeImpl)fDocumentType).getElements();
                ElementDefinitionImpl elementDef = (ElementDefinitionImpl)elements.getNamedItem(elementName);
                if (elementDef == null) {
                    elementDef = fDocumentImpl.createElementDefinition(elementName);
                    ((DocumentTypeImpl)fDocumentType).getElements().setNamedItem(elementDef);
                }

                // REVISIT: Check for uniqueness of element name? -Ac
                // REVISIT: what about default attributes with URI? -ALH

                // get attribute name and value index
                String attrName      = fStringPool.toString(attributeDecl.rawname);
                String attrValue     = fStringPool.toString(attDefaultValue);

                // create attribute and set properties
                AttrImpl attr = (AttrImpl)fDocumentImpl.createAttribute(attrName);
                attr.setValue(attrValue);
                attr.setSpecified(false);

                // add default attribute to element definition
                elementDef.getAttributes().setNamedItem(attr);
            }

            //
            // Create attribute declaration
            //
            /*REVISIT  Grammar Access
            if (fGrammarAccess) {

                // get element declaration; create it if necessary
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                String elementName = fStringPool.toString(elementDecl.rawname);
                Element element = XUtil.getFirstChildElement(schema, ""element"", ""name"", elementName);
                if (element == null) {
                    element = fDocument.createElement(""element"");
                    element.setAttribute(""name"", elementName);
                    //element.setAttribute(""export"", ""true"");
                    //((AttrImpl)element.getAttributeNode(""export"")).setSpecified(false);
                    schema.appendChild(element);
                }

                // get type element; create it if necessary
                Element type = XUtil.getFirstChildElement(element, ""type"");
                if (type == null) {
                    type = fDocument.createElement(""type"");
                    // REVISIT: Check for archetype redeclaration? -Ac
                    element.insertBefore(type, XUtil.getFirstChildElement(element));
                }

                // create attribute and set its attributes
                String attributeName = fStringPool.toString(attributeDecl.rawname);
                Element attribute = XUtil.getFirstChildElement(element, ""attribute"", ""name"", attributeName);
                if (attribute == null) {
                    attribute = fDocument.createElement(""attribute"");
                    attribute.setAttribute(""name"", attributeName);
                    attribute.setAttribute(""minOccurs"", ""0"");
                    ((AttrImpl)attribute.getAttributeNode(""minOccurs"")).setSpecified(false);
                    attribute.setAttribute(""maxOccurs"", ""1"");
                    ((AttrImpl)attribute.getAttributeNode(""maxOccurs"")).setSpecified(false);
                    type.appendChild(attribute);

                    // attribute type: CDATA, ENTITY, ... , NMTOKENS; ENUMERATION
                    String attributeTypeName = fStringPool.toString(attType);
                    if (attributeTypeName.equals(""CDATA"")) {
                        attribute.setAttribute(""type"", ""string"");
                        ((AttrImpl)attribute.getAttributeNode(""type"")).setSpecified(false);
                    }
                    else if (attributeTypeName.equals(""ENUMERATION"")) {
                        Element datatype = fDocumentImpl.createElement(""datatype"");
                        datatype.setAttribute(""source"", ""NMTOKEN"");
                        attribute.appendChild(datatype);
                        String tokenizerString = enumString.substring(1, enumString.length() - 1);
                        StringTokenizer tokenizer = new StringTokenizer(tokenizerString, ""|"");
                        while (tokenizer.hasMoreTokens()) {
                            Element enumeration = fDocument.createElement(""enumeration"");
                            enumeration.setAttribute(""value"", tokenizer.nextToken());
                            datatype.appendChild(enumeration);
                        }
                    }
                    else {
                        // REVISIT: Could we ever get an unknown data type? -Ac
                        attribute.setAttribute(""type"", attributeTypeName);
                    }

                    // attribute default type: #IMPLIED, #REQUIRED, #FIXED
                    boolean fixed = false;
                    if (attDefaultType != -1) {
                        String attributeDefaultTypeName = fStringPool.toString(attDefaultType);
                        if (attributeDefaultTypeName.equals(""#REQUIRED"")) {
                            attribute.setAttribute(""minOccurs"", ""1"");
                            ((AttrImpl)attribute.getAttributeNode(""minOccurs"")).setSpecified(true);
                        }
                        else if (attributeDefaultTypeName.equals(""#FIXED"")) {
                            fixed = true;
                            String fixedValue = fStringPool.toString(attDefaultValue);
                            attribute.setAttribute(""fixed"", fixedValue);
                        }
                    }

                    // attribute default value
                    if (!fixed && attDefaultValue != -1) {
                        String defaultValue = fStringPool.toString(attDefaultValue);
                        attribute.setAttribute(""default"", defaultValue);
                    }
                }
            }
           */

        } // if NOT defer-node-expansion

    } // attlistDecl(int,int,int,String,int,int)

    /**
     * &lt;!ENTITY % Name EntityValue&gt; (internal)
     */
    public void internalPEDecl(int entityName, int entityValue) throws Exception {}

    /**
     * &lt;!ENTITY % Name ExternalID>                (external)
     */
    public void externalPEDecl(int entityName, int publicId, int systemId) throws Exception {}

    /**
     * &lt;!ENTITY Name EntityValue&gt; (internal)
     */
    public void internalEntityDecl(int entityNameIndex, int entityValueIndex)
        throws Exception {

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            if (fDocumentTypeIndex == -1) return; //revisit: should never happen. Exception?

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            int newEntityIndex = fDeferredDocumentImpl.createEntity(entityNameIndex, -1, -1, -1);
            fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, newEntityIndex);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // create internal entity declaration
            if (fGrammarAccess) {
                int schemaIndex = getFirstChildElement(fDocumentTypeIndex, ""schema"");
                String entityName = fStringPool.toString(entityNameIndex);
                int textEntityIndex = getFirstChildElement(schemaIndex, ""textEntity"", ""name"", entityName);
                if (textEntityIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(entityName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""export""),
                        fStringPool.addString(""true""),
                        fStringPool.addSymbol(""ENUMERATION""),
                        false,
                        false); // search
                    fAttrList.endAttrList();

                    textEntityIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""textEntity""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, textEntityIndex);

                    int textIndex = fDeferredDocumentImpl.createTextNode(entityValueIndex, false);
                    fDeferredDocumentImpl.appendChild(textEntityIndex, textIndex);
                }
            }
            /***/
        }

        // full expansion
        else if (fDocumentImpl != null) {
            if (fDocumentType == null) return; //revisit: should never happen. Exception?

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            String entityName = fStringPool.toString(entityNameIndex);

            Entity entity = fDocumentImpl.createEntity(entityName);
            fDocumentType.getEntities().setNamedItem(entity);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // create internal entity declaration
            if (fGrammarAccess) {
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                Element textEntity = XUtil.getFirstChildElement(schema, ""textEntity"", ""name"", entityName);
                if (textEntity == null) {
                    textEntity = fDocument.createElement(""textEntity"");
                    textEntity.setAttribute(""name"", entityName);
                    textEntity.setAttribute(""export"", ""true"");
                    ((AttrImpl)textEntity.getAttributeNode(""export"")).setSpecified(false);
                    String entityValue = fStringPool.toString(entityValueIndex);
                    Text value = fDocument.createTextNode(entityValue);
                    textEntity.appendChild(value);
                    schema.appendChild(textEntity);
                }
            }
            /***/
        }

    } // internalEntityDecl(int,int)

    /**
     * &lt;!ENTITY Name ExternalID>                (external)
     */
    public void externalEntityDecl(int entityNameIndex, int publicIdIndex, int systemIdIndex)
        throws Exception {

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            int newEntityIndex = fDeferredDocumentImpl.createEntity(entityNameIndex, publicIdIndex, systemIdIndex, -1);

            fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, newEntityIndex);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // create external entity declaration
            if (fGrammarAccess) {
                int schemaIndex = getFirstChildElement(fDocumentTypeIndex, ""schema"");
                String entityName = fStringPool.toString(entityNameIndex);
                int externalEntityIndex = getFirstChildElement(schemaIndex, ""externalEntity"", ""name"", entityName);
                if (externalEntityIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(entityName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""export""),
                        fStringPool.addString(""true""),
                        fStringPool.addSymbol(""ENUMERATION""),
                        false,
                        false); // search
                    if (publicIdIndex != -1) {
                        fAttrList.addAttr(
                            fStringPool.addSymbol(""public""),
                            publicIdIndex,
                            fStringPool.addSymbol(""CDATA""),
                            true,
                            false); // search
                    }
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""system""),
                        systemIdIndex,
                        fStringPool.addSymbol(""CDATA""),
                        true,
                        false); // search
                    fAttrList.endAttrList();
                    externalEntityIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""externalEntity""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, externalEntityIndex);
                }
            }
            /***/
        }

        // full expansion
        else if (fDocumentImpl != null) {

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            String entityName = fStringPool.toString(entityNameIndex);
            String publicId = fStringPool.toString(publicIdIndex);
            String systemId = fStringPool.toString(systemIdIndex);

            EntityImpl entity = (EntityImpl)fDocumentImpl.createEntity(entityName);
            if (publicIdIndex != -1) {
                entity.setPublicId(publicId);
            }
            entity.setSystemId(systemId);
            fDocumentType.getEntities().setNamedItem(entity);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // create external entity declaration
            if (fGrammarAccess) {
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                Element externalEntity = XUtil.getFirstChildElement(schema, ""externalEntity"", ""name"", entityName);
                if (externalEntity == null) {
                    externalEntity = fDocument.createElement(""externalEntity"");
                    externalEntity.setAttribute(""name"", entityName);
                    externalEntity.setAttribute(""export"", ""true"");
                    ((AttrImpl)externalEntity.getAttributeNode(""export"")).setSpecified(false);
                    if (publicIdIndex != -1) {
                        externalEntity.setAttribute(""public"", publicId);
                    }
                    externalEntity.setAttribute(""system"", systemId);
                    schema.appendChild(externalEntity);
                }
            }
            /***/
        }

    } // externalEntityDecl(int,int,int)

    /**
     * &lt;!ENTITY Name ExternalID NDataDecl>      (unparsed)
     */
    public void unparsedEntityDecl(int entityNameIndex,
                                   int publicIdIndex, int systemIdIndex,
                                   int notationNameIndex) throws Exception {

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            int newEntityIndex = fDeferredDocumentImpl.createEntity(entityNameIndex, publicIdIndex, systemIdIndex, notationNameIndex);

            fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, newEntityIndex);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // add unparsed entity declaration
            if (fGrammarAccess) {
                int schemaIndex = getFirstChildElement(fDocumentTypeIndex, ""schema"");
                String entityName = fStringPool.toString(entityNameIndex);
                int unparsedEntityIndex = getFirstChildElement(schemaIndex, ""unparsedEntity"", ""name"", entityName);
                if (unparsedEntityIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(entityName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""export""),
                        fStringPool.addString(""true""),
                        fStringPool.addSymbol(""ENUMERATION""),
                        false,
                        false); // search
                    if (publicIdIndex != -1) {
                        fAttrList.addAttr(
                            fStringPool.addSymbol(""public""),
                            publicIdIndex,
                            fStringPool.addSymbol(""CDATA""),
                            true,
                            false); // search
                    }
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""system""),
                        systemIdIndex,
                        fStringPool.addSymbol(""CDATA""),
                        true,
                        false); // search
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""notation""),
                        fStringPool.addString(fStringPool.toString(notationNameIndex)),
                        fStringPool.addSymbol(""CDATA""),
                        true,
                        false); // search
                    fAttrList.endAttrList();
                    unparsedEntityIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""unparsedEntity""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, unparsedEntityIndex);
                }
            }
            /***/
        }

        // full expansion
        else if (fDocumentImpl != null) {

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            String entityName = fStringPool.toString(entityNameIndex);
            String publicId = fStringPool.toString(publicIdIndex);
            String systemId = fStringPool.toString(systemIdIndex);
            String notationName = fStringPool.toString(notationNameIndex);

            EntityImpl entity = (EntityImpl)fDocumentImpl.createEntity(entityName);
            if (publicIdIndex != -1) {
                entity.setPublicId(publicId);
            }
            entity.setSystemId(systemId);
            entity.setNotationName(notationName);
            fDocumentType.getEntities().setNamedItem(entity);

            /***
            // REVISIT: Entities were removed from latest working draft. -Ac
            // add unparsed entity declaration
            if (fGrammarAccess) {
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                Element unparsedEntity = XUtil.getFirstChildElement(schema, ""unparsedEntity"", ""name"", entityName);
                if (unparsedEntity == null) {
                    unparsedEntity = fDocument.createElement(""unparsedEntity"");
                    unparsedEntity.setAttribute(""name"", entityName);
                    unparsedEntity.setAttribute(""export"", ""true"");
                    ((AttrImpl)unparsedEntity.getAttributeNode(""export"")).setSpecified(false);
                    if (publicIdIndex != -1) {
                        unparsedEntity.setAttribute(""public"", publicId);
                    }
                    unparsedEntity.setAttribute(""system"", systemId);
                    unparsedEntity.setAttribute(""notation"", notationName);
                    schema.appendChild(unparsedEntity);
                }
            }
            /***/
        }

    } // unparsedEntityDecl(int,int,int,int)

    /**
     * &lt;!NOTATION Name ExternalId>
     */
    public void notationDecl(int notationNameIndex, int publicIdIndex, int systemIdIndex)
        throws Exception {

        // deferred expansion
        if (fDeferredDocumentImpl != null) {

            //revisit: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            int newNotationIndex = fDeferredDocumentImpl.createNotation(notationNameIndex, publicIdIndex, systemIdIndex);

            fDeferredDocumentImpl.appendChild(fDocumentTypeIndex, newNotationIndex);

            // create notation declaration
            /*REVISIT  Grammar Access
            if (fGrammarAccess) {
                int schemaIndex = getLastChildElement(fDocumentTypeIndex, ""schema"");
                String notationName = fStringPool.toString(notationNameIndex);
                int notationIndex = getLastChildElement(schemaIndex, ""notation"", ""name"", notationName);
                if (notationIndex == -1) {
                    int handle = fAttrList.startAttrList();
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""name""),
                        fStringPool.addString(notationName),
                        fStringPool.addSymbol(""NMTOKEN""),
                        true,
                        false); // search
                    /***
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""export""),
                        fStringPool.addString(""true""),
                        fStringPool.addSymbol(""ENUMERATION""),
                        false,
                        false); // search
                    /***/
            /*
                    if (publicIdIndex == -1) {
                        publicIdIndex = 0; // empty string in string pool
                    }
                    fAttrList.addAttr(
                        fStringPool.addSymbol(""public""),
                        publicIdIndex,
                        fStringPool.addSymbol(""CDATA""),
                        true,
                        false); // search
                    if (systemIdIndex != -1) {
                        fAttrList.addAttr(
                            fStringPool.addSymbol(""system""),
                            systemIdIndex,
                            fStringPool.addSymbol(""CDATA""),
                            true,
                            false); // search
                    }
                    fAttrList.endAttrList();
                    notationIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(""notation""), fAttrList, handle);
                    fDeferredDocumentImpl.appendChild(schemaIndex, notationIndex);
                }
            }
            */
        }

        // full expansion
        else if (fDocumentImpl != null) {

            // REVISIT: how to check if entity was already declared.
            // XML spec says that 1st Entity decl is binding.

            String notationName = fStringPool.toString(notationNameIndex);
            String publicId = fStringPool.toString(publicIdIndex);
            String systemId = fStringPool.toString(systemIdIndex);

            NotationImpl notationImpl = (NotationImpl)fDocumentImpl.createNotation(notationName);
            notationImpl.setPublicId(publicId);
            if (systemIdIndex != -1) {
                notationImpl.setSystemId(systemId);
            }

            fDocumentType.getNotations().setNamedItem(notationImpl);

            // create notation declaration
            /*REVISIT Grammar access
            if (fGrammarAccess) {
                Element schema = XUtil.getFirstChildElement(fDocumentType, ""schema"");
                Element notation = XUtil.getFirstChildElement(schema, ""notation"", ""name"", notationName);
                if (notation == null) {
                    notation = fDocument.createElement(""notation"");
                    notation.setAttribute(""name"", notationName);
                    //notation.setAttribute(""export"", ""true"");
                    //((AttrImpl)notation.getAttributeNode(""export"")).setSpecified(false);
                    if (publicId == null) {
                        publicId = """";
                    }
                    notation.setAttribute(""public"", publicId);
                    if (systemIdIndex != -1) {
                        notation.setAttribute(""system"", systemId);
                    }
                    schema.appendChild(notation);
                }
            }
            */
        }

    } // notationDecl(int,int,int)

    //
    // Private methods
    //

    /**
     * Creates a content model from the specified content spec node.
     * This method will always return a <em>group</em> element as the
     * containing element, even when the content model contains a
     * single element reference.
     */
    /*REVISIT Grammar access
    private Element createContentModel(XMLContentSpec contentSpec, XMLContentSpec.Node node) {

        Element model = createContentModel(contentSpec, node, 
                                           new DocumentImpl(), null);
        return model;

    } // createContentModel(XMLContentSpec.Node):Element

    */

    /**
     * This is the real <em>createContentModel</em> method. This is a
     * recursive solution.
     */
    /*REVISIT Grammar Access
    private Element createContentModel(XMLContentSpec contentSpec,
                                       XMLContentSpec.Node node, 
                                       Document factory, 
                                       Element parent) {

        // figure out occurrence count
        int minOccur = 1;
        int maxOccur = 1;
        switch (node.type) {
            case XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE: {
                minOccur = 1;
                maxOccur = -1;
                contentSpec.getNode(node.value, node);
                break;
            }
            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE: {
                minOccur = 0;
                maxOccur = -1;
                contentSpec.getNode(node.value, node);
                break;
            }
            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE: {
                minOccur = 0;
                maxOccur = 1;
                contentSpec.getNode(node.value, node);
                break;
            }
        }

        // flatten model
        int nodeType = node.type;
        switch (nodeType) {

            // CHOICE or SEQUENCE
            case XMLContentSpec.CONTENTSPECNODE_CHOICE:
            case XMLContentSpec.CONTENTSPECNODE_SEQ: {

                // go down left side
                int leftIndex  = node.value;
                int rightIndex = node.otherValue;
                contentSpec.getNode(leftIndex, node);
                Element left = createContentModel(contentSpec, node, 
                                                  factory, parent);

                // go down right side
                contentSpec.getNode(rightIndex, node);
                Element right = createContentModel(contentSpec, node, 
                                                   factory, null);

                // append left children
                String  type  = nodeType == XMLContentSpec.CONTENTSPECNODE_CHOICE
                              ? ""choice""
                              : ""seq"";
                Element model = left;
                if (!left.getAttribute(""order"").equals(type)) {
                    String minOccurs = left.getAttribute(""minOccurs"");
                    String maxOccurs = left.getAttribute(""maxOccurs"");
                    if (parent == null ||
                        ((minOccurs.equals(""1"") || minOccurs.length() == 0) &&
                        (maxOccurs.equals(""1"") || maxOccurs.length() == 0))) {
                        model = factory.createElement(""group"");
                        model.setAttribute(""order"", type);
                        if (type.equals(""seq"")) {
                            ((AttrImpl)model.getAttributeNode(""order"")).setSpecified(false);
                        }
                        model.appendChild(left);
                    }
                    else {
                        model = parent;
                    }
                }

                // set occurrence count
                setOccurrenceCount(model, minOccur, maxOccur);

                // append right children
                model.appendChild(right);

                // return model
                return model;
            }

            // LEAF
            case XMLContentSpec.CONTENTSPECNODE_LEAF: {
                String  name = fStringPool.toString(node.value);
                Element leaf = factory.createElement(""element"");
                leaf.setAttribute(""ref"", name);

                // set occurrence count and return
                setOccurrenceCount(leaf, minOccur, maxOccur);
                return leaf;
            }

        } // switch node type

        // error
        return null;

    } // createContentModel(XMLContentSpec.Node,Element):Element

      */
    /**
     * Sets the appropriate occurrence count attributes on the specified
     * model element.
     */
    private void setOccurrenceCount(Element model, int minOccur, int maxOccur) {

        // min
        model.setAttribute(""minOccurs"", Integer.toString(minOccur));
        if (minOccur == 1) {
            ((AttrImpl)model.getAttributeNode(""minOccurs"")).setSpecified(false);
        }

        // max
        if (maxOccur == -1) {
            model.setAttribute(""maxOccurs"", ""*"");
        }
        else if (maxOccur != 1) {
            model.setAttribute(""maxOccurs"", Integer.toString(maxOccur));
        }

    } // setOccurrenceCount(Element,int,int)

    /** Returns the first child element of the specified node. */
    private int getLastChildElement(int nodeIndex) {
        int childIndex = fDeferredDocumentImpl.getLastChild(nodeIndex, false);
        while (childIndex != -1) {
            if (fDeferredDocumentImpl.getNodeType(childIndex, false) == Node.ELEMENT_NODE) {
                return childIndex;
            }
            childIndex = fDeferredDocumentImpl.getPrevSibling(childIndex, false);
        }
        return -1;
    }

    /** Returns the next sibling element of the specified node. */
    private int getPrevSiblingElement(int nodeIndex) {
        int siblingIndex = fDeferredDocumentImpl.getPrevSibling(nodeIndex, false);
        while (siblingIndex != -1) {
            if (fDeferredDocumentImpl.getNodeType(siblingIndex, false) == Node.ELEMENT_NODE) {
                return siblingIndex;
            }
            siblingIndex = fDeferredDocumentImpl.getPrevSibling(siblingIndex, false);
        }
        return -1;
    }

    /** Returns the first child element with the given name. */
    private int getLastChildElement(int nodeIndex, String elementName) {
        int childIndex = getLastChildElement(nodeIndex);
        if (childIndex != -1) {
            while (childIndex != -1) {
                String nodeName = fDeferredDocumentImpl.getNodeNameString(childIndex, false);
                if (nodeName.equals(elementName)) {
                    return childIndex;
                }
                childIndex = getPrevSiblingElement(childIndex);
            }
        }
        return -1;
    }

    /** Returns the next sibling element with the given name. */
    private int getPrevSiblingElement(int nodeIndex, String elementName) {
        int siblingIndex = getPrevSiblingElement(nodeIndex);
        if (siblingIndex != -1) {
            while (siblingIndex != -1) {
                String nodeName = fDeferredDocumentImpl.getNodeNameString(siblingIndex, false);
                if (nodeName.equals(elementName)) {
                    return siblingIndex;
                }
                siblingIndex = getPrevSiblingElement(siblingIndex);
            }
        }
        return -1;
    }

    /** Returns the first child element with the given name. */
    private int getLastChildElement(int nodeIndex, String elemName, String attrName, String attrValue) {
        int childIndex = getLastChildElement(nodeIndex, elemName);
        if (childIndex != -1) {
            while (childIndex != -1) {
                int attrIndex = fDeferredDocumentImpl.getNodeValue(childIndex, false);
                while (attrIndex != -1) {
                    String nodeName = fDeferredDocumentImpl.getNodeNameString(attrIndex, false);
                    if (nodeName.equals(attrName)) {
                        // REVISIT: Do we need to normalize the text? -Ac
                        int textIndex = fDeferredDocumentImpl.getLastChild(attrIndex, false);
                        String nodeValue = fDeferredDocumentImpl.getNodeValueString(textIndex, false);
                        if (nodeValue.equals(attrValue)) {
                            return childIndex;
                        }
                    }
                    attrIndex = fDeferredDocumentImpl.getPrevSibling(attrIndex, false);
                }
                childIndex = getPrevSiblingElement(childIndex, elemName);
            }
        }
        return -1;
    }

    /** Returns the next sibling element with the given name and attribute. */
    private int getPrevSiblingElement(int nodeIndex, String elemName, String attrName, String attrValue) {
        int siblingIndex = getPrevSiblingElement(nodeIndex, elemName);
        if (siblingIndex != -1) {
            int attributeNameIndex = fStringPool.addSymbol(attrName);
            while (siblingIndex != -1) {
                int attrIndex = fDeferredDocumentImpl.getNodeValue(siblingIndex, false);
                while (attrIndex != -1) {
                    int attrValueIndex = fDeferredDocumentImpl.getNodeValue(attrIndex, false);
                    if (attrValue.equals(fStringPool.toString(attrValueIndex))) {
                        return siblingIndex;
                    }
                    attrIndex = fDeferredDocumentImpl.getPrevSibling(attrIndex, false);
                }
                siblingIndex = getPrevSiblingElement(siblingIndex, elemName);
            }
        }
        return -1;
    }

    /**
     * Copies the source tree into the specified place in a destination
     * tree. The source node and its children are appended as children
     * of the destination node.
     * <p>
     * <em>Note:</em> This is an iterative implementation.
     */
    private void copyInto(Node src, int destIndex) throws Exception {

        // for ignorable whitespace features
        boolean domimpl = src != null && src instanceof DocumentImpl;

        // placement variables
        Node start  = src;
        Node parent = src;
        Node place  = src;

        // traverse source tree
        while (place != null) {

            // copy this node
            int nodeIndex = -1;
            short type = place.getNodeType();
            switch (type) {
                case Node.CDATA_SECTION_NODE: {
                    boolean ignorable = domimpl && ((TextImpl)place).isIgnorableWhitespace();
                    nodeIndex = fDeferredDocumentImpl.createCDATASection(fStringPool.addString(place.getNodeValue()), ignorable);
                    break;
                }
                case Node.COMMENT_NODE: {
                    nodeIndex = fDeferredDocumentImpl.createComment(fStringPool.addString(place.getNodeValue()));
                    break;
                }
                case Node.ELEMENT_NODE: {
                    XMLAttrList attrList = null;
                    int handle = -1;
                    NamedNodeMap attrs = place.getAttributes();
                    if (attrs != null) {
                        int length = attrs.getLength();
                        if (length > 0) {
                            handle = fAttrList.startAttrList();
                            for (int i = 0; i < length; i++) {
                                Attr attr = (Attr)attrs.item(i);
                                String attrName = attr.getNodeName();
                                String attrValue = attr.getNodeValue();
                                fAttrList.addAttr(
                                    fStringPool.addSymbol(attrName),
                                    fStringPool.addString(attrValue),
                                    fStringPool.addSymbol(""CDATA""), // REVISIT
                                    attr.getSpecified(),
                                    false); // search
                            }
                            fAttrList.endAttrList();
                            attrList = fAttrList;
                        }
                    }
                    nodeIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(place.getNodeName()), attrList, handle);
                    break;
                }
                case Node.ENTITY_REFERENCE_NODE: {
                    nodeIndex = fDeferredDocumentImpl.createEntityReference(fStringPool.addSymbol(place.getNodeName()));
                    break;
                }
                case Node.PROCESSING_INSTRUCTION_NODE: {
                    nodeIndex = fDeferredDocumentImpl.createProcessingInstruction(fStringPool.addSymbol(place.getNodeName()), fStringPool.addString(place.getNodeValue()));
                    break;
                }
                case Node.TEXT_NODE: {
                    boolean ignorable = domimpl && ((TextImpl)place).isIgnorableWhitespace();
                    nodeIndex = fDeferredDocumentImpl.createTextNode(fStringPool.addString(place.getNodeValue()), ignorable);
                    break;
                }
                default: {
                    throw new IllegalArgumentException(""PAR010 Can't copy node type, ""+
                                                       type+"" (""+
                                                       place.getNodeName()+')'
                                                       +""\n""+type+""\t""+place.getNodeName());
                }
            }
            fDeferredDocumentImpl.appendChild(destIndex, nodeIndex);

            // iterate over children
            if (place.hasChildNodes()) {
                parent = place;
                place = place.getFirstChild();
                destIndex = nodeIndex;
            }

            // advance
            else {
                place = place.getNextSibling();
                while (place == null && parent != start) {
                    place = parent.getNextSibling();
                    parent = parent.getParentNode();
                    destIndex = fDeferredDocumentImpl.getParentNode(destIndex, false);
                }
            }

        }

    } // copyInto(Node,int)

    /** Creates the content model elements for the deferred DOM tree. */
    private int createDeferredContentModel(Node model) throws Exception {

        int nodeType = model.getNodeType();
        switch (nodeType) {
            case Node.ELEMENT_NODE: {
                NamedNodeMap attrs = model.getAttributes();
                int handle = fAttrList.startAttrList();
                int length = attrs.getLength();
                for (int i = 0; i < length; i++) {
                    Attr attr = (Attr)attrs.item(i);
                    String attrName = attr.getNodeName();
                    String attrValue = attr.getNodeValue();

                    fAttrList.addAttr(
                        fStringPool.addSymbol(attrName),
                        fStringPool.addString(attrValue),
                        fStringPool.addSymbol((String)TYPES.get(attrName)),
                        attr.getSpecified(),
                        false); // search
                }
                fAttrList.endAttrList();

                int modelIndex = fDeferredDocumentImpl.createElement(fStringPool.addSymbol(model.getNodeName()), fAttrList, handle);

                Node child = model.getFirstChild();
                while (child != null) {
                    int childIndex = createDeferredContentModel(child);
                    fDeferredDocumentImpl.appendChild(modelIndex, childIndex);
                    child = child.getNextSibling();
                }

                return modelIndex;
            }
            case Node.TEXT_NODE: {
                return fDeferredDocumentImpl.createTextNode(fStringPool.addString(model.getNodeValue()), false);
            }
        }

        return -1;

    } // createDeferredContentModel(Node):int

} // class DOMParser
"
org/apache/xerces/dom/DocumentFragmentImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * DocumentFragment is a ""lightweight"" or ""minimal"" Document
 * object. It is very common to want to be able to extract a portion
 * of a document's tree or to create a new fragment of a
 * document. Imagine implementing a user command like cut or
 * rearranging a document by moving fragments around. It is desirable
 * to have an object which can hold such fragments and it is quite
 * natural to use a Node for this purpose. While it is true that a
 * Document object could fulfil this role, a Document object can
 * potentially be a heavyweight object, depending on the underlying
 * implementation... and in DOM Level 1, nodes aren't allowed to cross
 * Document boundaries anyway. What is really needed for this is a
 * very lightweight object.  DocumentFragment is such an object.
 * <P>
 * Furthermore, various operations -- such as inserting nodes as
 * children of another Node -- may take DocumentFragment objects as
 * arguments; this results in all the child nodes of the
 * DocumentFragment being moved to the child list of this node.
 * <P>
 * The children of a DocumentFragment node are zero or more nodes
 * representing the tops of any sub-trees defining the structure of
 * the document.  DocumentFragment do not need to be well-formed XML
 * documents (although they do need to follow the rules imposed upon
 * well-formed XML parsed entities, which can have multiple top
 * nodes). For example, a DocumentFragment might have only one child
 * and that child node could be a Text node. Such a structure model
 * represents neither an HTML document nor a well-formed XML document.
 * <P>
 * When a DocumentFragment is inserted into a Document (or indeed any
 * other Node that may take children) the children of the
 * DocumentFragment and not the DocumentFragment itself are inserted
 * into the Node. This makes the DocumentFragment very useful when the
 * user wishes to create nodes that are siblings; the DocumentFragment
 * acts as the parent of these nodes so that the user can use the
 * standard methods from the Node interface, such as insertBefore()
 * and appendChild().
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DocumentFragmentImpl 
    extends ParentNode
    implements DocumentFragment {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -7596449967279236746L;
    
    //
    // Constructors
    //

    /** Factory constructor. */
    public DocumentFragmentImpl(DocumentImpl ownerDoc) {
        super(ownerDoc);
    }  
  
    /** Constructor for serialization. */
    public DocumentFragmentImpl() {}

    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.DOCUMENT_FRAGMENT_NODE;
    }

    /** Returns the node name. */
    public String getNodeName() {
        return ""#document-fragment"";
    }
    
} // class DocumentFragmentImpl
"
org/apache/xerces/validators/datatype/DatatypeValidator.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.datatype;

import java.util.Hashtable;
import java.util.Locale;

/**
 * DataTypeValidator defines the interface that data type validators must obey.
 * These validators can be supplied by the application writer and may be useful as
 * standalone code as well as plugins to the validator architecture.
 * Note: there is no support for facets in this API, since we are trying to convince
 * W3C to remove facets from the data type spec.
 * 
 * @author Jeffrey Rodriguez-
 */
public interface DatatypeValidator {
    public static final int FACET_LENGTH       = 1;
    public static final int FACET_MINLENGTH    = 1<<1;
    public static final int FACET_MAXLENGTH    = 1<<2;
    public static final int FACET_PATTERN      = 1<<3; 
    public static final int FACET_ENUMERATION  = 1<<4;
    public static final int FACET_MAXINCLUSIVE = 1<<5;
    public static final int FACET_MAXEXCLUSIVE = 1<<6;
    public static final int FACET_MININCLUSIVE = 1<<7;
    public static final int FACET_MINEXCLUSIVE = 1<<8;
    public static final int FACET_PRECISSION   = 1<<9;
    public static final int FACET_SCALE        = 1<<10;
    public static final int FACET_ENCODING     = 1<<11;
    public static final int FACET_DURATION     = 1<<12;
    public static final int FACET_PERIOD       = 1<<13;
    public static final int DERIVED_BY_RESTRICTION   = 1;
    public static final int DERIVED_BY_LIST          = 1<<1;



    /**
     * Checks that ""content"" string is valid 
     * datatype.
     * If invalid a Datatype validation exception is thrown.
     * 
     * @param content A string containing the content to be validated
     * @param derivedBylist
     *                Flag which is true when type
     *                is derived by list otherwise it
     *                it is derived by extension.
     *                
     * @exception throws InvalidDatatypeException if the content is
     *                   invalid according to the rules for the validators
     * @exception InvalidDatatypeValueException
     * @see         org.apache.xerces.validators.datatype.InvalidDatatypeValueException
     */
    public void validate(String content ) throws InvalidDatatypeValueException;

    /**
     * set the facets for this datatype
     * 
     * setFacets is responsible for ensuring that the supplied facets do not contradict each
     * other.
     * 
     * @param facets A hashtable where facet name Symbols  are keys and facet values are stored
     *               in the hashtable.  Usually facet values are strings, except for the
     *               enumeration facet.  The value for this facet is a Vector of strings, one
     *               per enumeration value
     * @exception throws UnknownFacetException
     * @exception throws IllegalFacetException
     * @exception throws IllegalFacetValueException
     * @exception UnknownFacetException
     * @exception IllegalFacetException
     * @exception IllegalFacetValueException
     * @exception ConstrainException
     * @see org.apache.xerces.validators.schema.SchemaSymbols
     * @see org.apache.xerces.validators.datatype.IllegalFacetException
     * @see org.apache.xerces.validators.datatype.IllegalFacetValueException
     * @see org.apache.xerces.validators.datatype.ConstrainException
     */
    public void setFacets(Hashtable facets,String  derivationType ) throws UnknownFacetException, 
        IllegalFacetException, IllegalFacetValueException,  ConstrainException; 

    /**
     * Name of base type as a string.
     * A Native datatype has the string ""native""  as its
     * base type.
     * 
     * @param base   the validator for this type's base type
     */
    public void setBasetype(String base);


    /**
    * set the locate to be used for error messages
    */
    public void setLocale(Locale locale);

    /**
     * REVISIT
     * Compares two Datatype for order
     * 
     * @param o1
     * @param o2
     * @return 
     */
    public int compare( DatatypeValidator o1, DatatypeValidator o2);

}
"
org/w3c/dom/CDATASection.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  CDATA sections are used to escape blocks of text containing  characters 
 * that would otherwise be regarded as markup. The only  delimiter that is 
 * recognized in a CDATA section is the ""]]&gt;"" string  that ends the CDATA 
 * section. CDATA sections cannot be  nested. Their primary purpose is for 
 * including material such as XML fragments, without needing to escape all 
 * the delimiters.
 * <p> The <code>DOMString</code> attribute of the <code>Text</code> node 
 * holds the text that is contained by the CDATA section. Note that this  may 
 * contain characters that need to be escaped outside of CDATA sections and 
 * that, depending on the character encoding (""charset"") chosen for 
 * serialization, it may be impossible to write out some characters as part 
 * of a CDATA section. 
 * <p> The <code>CDATASection</code> interface inherits from the 
 * <code>CharacterData</code> interface through the <code>Text</code> 
 * interface. Adjacent <code>CDATASections</code> nodes are not merged by use 
 * of the <code>normalize</code> method of the <code>Element</code> interface.
 *  Because no markup is recognized within a <code>CDATASection</code> , 
 * character numeric references cannot be used as an escape mechanism when 
 * serializing. Therefore, action needs to be taken when serializing a 
 * <code>CDATASection</code> with a character encoding where some of the 
 * contained characters cannot be represented. Failure to do so would not 
 * produce well-formed XML. One potential solution in the serialization 
 * process is to end the CDATA section before the character, output the 
 * character using a  character reference or entity reference, and open a new 
 * CDATA section  for any further characters in the text node. Note, however, 
 * that some  code conversion libraries at the time of writing do not return 
 * an error or exception when a character is missing from the encoding,  
 * making the task of ensuring that data is not corrupted on serialization 
 * more difficult.
 */
public interface CDATASection extends Text {
}

"
org/w3c/dom/Notation.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  This interface represents a notation declared in the DTD. A notation 
 * either declares, by name, the format of an unparsed entity (see section 4.7
 *  of the XML 1.0 specification), or is used for formal declaration of 
 * processing instruction targets (see section 2.6 of the XML 1.0 
 * specification). The <code>nodeName</code> attribute inherited from 
 * <code>Node</code> is set to the declared name of the notation.
 * <p> The DOM Level 1 does not support editing <code>Notation</code> nodes; 
 * they are therefore readonly.
 * <p> A <code>Notation</code> node does not have any parent.
 */
public interface Notation extends Node {
    /**
     *  The public identifier of this notation. If the  public identifier was 
     * not specified, this is <code>null</code> .
     */
    public String getPublicId();

    /**
     *  The system identifier of this notation. If the  system identifier was 
     * not specified, this is <code>null</code> .
     */
    public String getSystemId();

}

"
org/apache/xerces/validators/datatype/StringValidator.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.datatype;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Locale;
import java.text.Collator;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.NoSuchElementException;
import org.apache.xerces.validators.schema.SchemaSymbols;
import org.apache.xerces.utils.regex.RegularExpression;

/**
 * StringValidator validates that XML content is a W3C string type.
 * @author Ted Leung
 * @author Kito D. Mann, Virtua Communications Corp.
 * @author Jeffrey Rodriguez
 */
public class StringValidator implements DatatypeValidator {
    private Locale    fLocale          = null;
    private String    fBaseValidator   = ""native"";

    private int       _length          = 0;
    private int       _maxLength       = 0;
    private int       _minLength       = 0;
    private String    _pattern         = null;
    private Vector    _enumeration     = null;
    private String    _maxInclusive    = null;
    private String    _maxExclusive    = null;
    private String    _minInclusive    = null;
    private String    _minExclusive    = null;
    private int       _facetsDefined   = 0;
    private int       _derivedBy       = DatatypeValidator.DERIVED_BY_RESTRICTION;//default

    private boolean isMaxExclusiveDefined = false;
    private boolean isMaxInclusiveDefined = false;
    private boolean isMinExclusiveDefined = false;
    private boolean isMinInclusiveDefined = false;

    /**
     * validate that a string is a W3C string type
     * 
     * @param content A string containing the content to be validated
     * @param list
     * @exception throws InvalidDatatypeException if the content is
     *                   not a W3C string type
     * @exception InvalidDatatypeValueException
     */
    public void validate(String content)  throws InvalidDatatypeValueException
    {
        if ( _facetsDefined == 0 )// No Facets to validate against
            return;

        if( _derivedBy == DatatypeValidator.DERIVED_BY_RESTRICTION  ){ 
            checkContent( content );

        } else {
            StringTokenizer parsedList = new StringTokenizer( content );
            try {
               while ( parsedList.hasMoreTokens() ) {
                   checkContentList( parsedList.nextToken() );
               }
            } catch ( NoSuchElementException e ) {
                e.printStackTrace();
            }
        }
    }


    public void setFacets(Hashtable facets, String derivationBy) throws UnknownFacetException,
    IllegalFacetException, IllegalFacetValueException, ConstrainException 
    {
        if( facets == null )
            return;

        if( derivationBy.equals( SchemaSymbols.ATTVAL_RESTRICTION )){
            for (Enumeration e = facets.keys(); e.hasMoreElements();) {
                String key = (String) e.nextElement();

                if ( key.equals(SchemaSymbols.ELT_LENGTH) ) {
                    _facetsDefined += DatatypeValidator.FACET_LENGTH;
                    String lengthValue = (String)facets.get(key);
                    try {
                        _length     = Integer.parseInt( lengthValue );
                    } catch (NumberFormatException nfe) {
                        throw new IllegalFacetValueException(""Length value '""+lengthValue+""' is invalid."");
                    }
                    if ( _length < 0 )
                        throw new IllegalFacetValueException(""Length value '""+lengthValue+""'  must be a nonNegativeInteger."");

                } else if (key.equals(SchemaSymbols.ELT_MINLENGTH) ) {
                    _facetsDefined += DatatypeValidator.FACET_MINLENGTH;
                    String minLengthValue = (String)facets.get(key);
                    try {
                        _minLength     = Integer.parseInt( minLengthValue );
                    } catch (NumberFormatException nfe) {
                        throw new IllegalFacetValueException(""maxLength value '""+minLengthValue+""' is invalid."");
                    }
                } else if (key.equals(SchemaSymbols.ELT_MAXLENGTH) ) {
                    _facetsDefined += DatatypeValidator.FACET_MAXLENGTH;
                    String maxLengthValue = (String)facets.get(key);
                    try {
                        _maxLength     = Integer.parseInt( maxLengthValue );
                    } catch (NumberFormatException nfe) {
                        throw new IllegalFacetValueException(""maxLength value '""+maxLengthValue+""' is invalid."");
                    }
                } else if (key.equals(SchemaSymbols.ELT_PATTERN)) {
                    _facetsDefined += DatatypeValidator.FACET_PATTERN;
                    _pattern = (String)facets.get(key);
                } else if (key.equals(SchemaSymbols.ELT_ENUMERATION)) {
                    _facetsDefined += DatatypeValidator.FACET_ENUMERATION;
                    _enumeration = (Vector)facets.get(key);
                } else if (key.equals(SchemaSymbols.ELT_MAXINCLUSIVE)) {
                    _facetsDefined += DatatypeValidator.FACET_MAXINCLUSIVE;
                    _maxInclusive = (String)facets.get(key);
                } else if (key.equals(SchemaSymbols.ELT_MAXEXCLUSIVE)) {
                    _facetsDefined += DatatypeValidator.FACET_MAXEXCLUSIVE;
                    _maxExclusive = (String)facets.get(key);
                } else if (key.equals(SchemaSymbols.ELT_MININCLUSIVE)) {
                    _facetsDefined += DatatypeValidator.FACET_MININCLUSIVE;
                    _minInclusive = (String)facets.get(key);
                } else if (key.equals(SchemaSymbols.ELT_MINEXCLUSIVE)) {
                    _facetsDefined += DatatypeValidator.FACET_MININCLUSIVE;
                    _minExclusive = (String)facets.get(key);
                } else {
                    throw new IllegalFacetException();
                }
            }

            if (((_facetsDefined & DatatypeValidator.FACET_LENGTH ) != 0 ) ) {
                if (((_facetsDefined & DatatypeValidator.FACET_MAXLENGTH ) != 0 ) ) {
                    throw new ConstrainException(
                                                ""It is an error for both length and maxLength to be members of facets."" );  
                } else if (((_facetsDefined & DatatypeValidator.FACET_MINLENGTH ) != 0 ) ) {
                    throw new ConstrainException(
                                                ""It is an error for both length and minLength to be members of facets."" );
                }
            }

            if ( ( (_facetsDefined & ( DatatypeValidator.FACET_MINLENGTH |
                                       DatatypeValidator.FACET_MAXLENGTH) ) != 0 ) ) {
                if ( _minLength < _maxLength ) {
                    throw new ConstrainException( ""Value of minLength = "" + _minLength +
                                                  ""must be greater that the value of maxLength"" + _maxLength );
                }
            }

            isMaxExclusiveDefined = ((_facetsDefined & 
                                      DatatypeValidator.FACET_MAXEXCLUSIVE ) != 0 )?true:false;
            isMaxInclusiveDefined = ((_facetsDefined & 
                                      DatatypeValidator.FACET_MAXINCLUSIVE ) != 0 )?true:false;
            isMinExclusiveDefined = ((_facetsDefined &
                                      DatatypeValidator.FACET_MINEXCLUSIVE ) != 0 )?true:false;
            isMinInclusiveDefined = ((_facetsDefined &
                                      DatatypeValidator.FACET_MININCLUSIVE ) != 0 )?true:false;

            if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) {
                throw new ConstrainException(
                                            ""It is an error for both maxInclusive and maxExclusive to be specified for the same datatype."" ); 
            }
            if ( isMinExclusiveDefined && isMinInclusiveDefined ) {
                throw new ConstrainException(
                                            ""It is an error for both minInclusive and minExclusive to be specified for the same datatype."" ); 
            }
         } else { //derived by list
             for (Enumeration e = facets.keys(); e.hasMoreElements();) {
               String key = (String) e.nextElement();
               if ( key.equals(SchemaSymbols.ELT_LENGTH) ) {
                   _facetsDefined += DatatypeValidator.FACET_LENGTH;
                   String lengthValue = (String)facets.get(key);
                   try {
                       _length     = Integer.parseInt( lengthValue );
                   } catch (NumberFormatException nfe) {
                       throw new IllegalFacetValueException(""Length value '""+lengthValue+""' is invalid."");
                   }
                   if ( _length < 0 )
                       throw new IllegalFacetValueException(""Length value '""+lengthValue+""'  must be a nonNegativeInteger."");

               } else if (key.equals(SchemaSymbols.ELT_MINLENGTH) ) {
                   _facetsDefined += DatatypeValidator.FACET_MINLENGTH;
                   String minLengthValue = (String)facets.get(key);
                   try {
                       _minLength     = Integer.parseInt( minLengthValue );
                   } catch (NumberFormatException nfe) {
                       throw new IllegalFacetValueException(""maxLength value '""+minLengthValue+""' is invalid."");
                   }
               } else if (key.equals(SchemaSymbols.ELT_MAXLENGTH) ) {
                   _facetsDefined += DatatypeValidator.FACET_MAXLENGTH;
                   String maxLengthValue = (String)facets.get(key);
                   try {
                       _maxLength     = Integer.parseInt( maxLengthValue );
                   } catch (NumberFormatException nfe) {
                       throw new IllegalFacetValueException(""maxLength value '""+maxLengthValue+""' is invalid."");
                   }
               } else if (key.equals(SchemaSymbols.ELT_ENUMERATION)) {
                   _facetsDefined += DatatypeValidator.FACET_ENUMERATION;
                   _enumeration    = (Vector)facets.get(key);
               } else {
                   throw new IllegalFacetException();
               }
             }
             if (((_facetsDefined & DatatypeValidator.FACET_LENGTH ) != 0 ) ) {
                 if (((_facetsDefined & DatatypeValidator.FACET_MAXLENGTH ) != 0 ) ) {
                     throw new ConstrainException(
                                              ""It is an error for both length and maxLength to be members of facets."" );  
                 } else if (((_facetsDefined & DatatypeValidator.FACET_MINLENGTH ) != 0 ) ) {
                     throw new ConstrainException(
                                              ""It is an error for both length and minLength to be members of facets."" );
                 }
             }

             if ( ( (_facetsDefined & ( DatatypeValidator.FACET_MINLENGTH |
                                     DatatypeValidator.FACET_MAXLENGTH) ) != 0 ) ) {
                 if ( _minLength < _maxLength ) {
                     throw new ConstrainException( ""Value of minLength = "" + _minLength +
                                                ""must be greater that the value of maxLength"" + _maxLength );
                 }
             }
         }
    }

    public void setBasetype( String base) {
        fBaseValidator = base;
    }

    /**
     * set the locate to be used for error messages
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }

    public int compare( DatatypeValidator o1, DatatypeValidator o2){
        return 0;
    }

    private void checkContent( String content )throws InvalidDatatypeValueException
    {
        if ( (_facetsDefined & DatatypeValidator.FACET_MAXLENGTH) != 0 ) {
            if ( content.length() > _maxLength ) {
                throw new InvalidDatatypeValueException(""Value '""+content+
                                                        ""' with length '""+content.length()+
                                                        ""' exceeds maximum length of ""+_maxLength+""."");
            }
        }
        if ( (_facetsDefined & DatatypeValidator.FACET_ENUMERATION) != 0 ) {
            if ( _enumeration.contains( content ) == false )
                throw new InvalidDatatypeValueException(""Value '""+content+""' must be one of ""+_enumeration);
        }

        if ( isMaxExclusiveDefined == true ) {
            int comparisonResult;
            comparisonResult  = compare( content, _maxExclusive );
            if ( comparisonResult > 0 ) {
                throw new InvalidDatatypeValueException( ""Value '""+content+ ""'  must be"" +
                                                         ""lexicographically less than"" + _maxExclusive );

            }

        }
        if ( isMaxInclusiveDefined == true ) {
            int comparisonResult;
            comparisonResult  = compare( content, _maxInclusive );
            if ( comparisonResult >= 0 )
                throw new InvalidDatatypeValueException( ""Value '""+content+ ""' must be"" +
                                                         ""lexicographically less or equal than"" + _maxInclusive );
        }

        if ( isMinExclusiveDefined == true ) {
            int comparisonResult;
            comparisonResult  = compare( content, _minExclusive );
            if ( comparisonResult < 0 )
                throw new InvalidDatatypeValueException( ""Value '""+content+ ""' must be"" +
                                                         ""lexicographically greater than"" + _minExclusive );
        }
        if ( isMinInclusiveDefined == true ) {
            int comparisonResult;
            comparisonResult = compare( content, _minInclusive );
            if ( comparisonResult <= 0 )
                throw new InvalidDatatypeValueException( ""Value '""+content+ ""' must be"" +
                                                         ""lexicographically greater or equal than"" + _minInclusive );
        }

        if ( (_facetsDefined & DatatypeValidator.FACET_PATTERN ) != 0 ) {
            RegularExpression regex = new RegularExpression(_pattern, ""X"" );
            if ( regex.matches( content) == false )
                throw new InvalidDatatypeValueException(""Value'""+content+
                                                        ""does not match regular expression facet"" + _pattern );
        }

    }
    private void checkContentList( String content )throws InvalidDatatypeValueException
    {
        //Revisit
    }
    private int compare( String content, String facetValue ){
        Locale    loc       = Locale.getDefault();
        Collator  collator  = Collator.getInstance( loc );
        return collator.compare( content, facetValue );
    }

}

"
org/apache/xerces/utils/ChunkyCharArray.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import org.apache.xerces.readers.XMLEntityHandler;

/**
 *
 * @version
 */
public final class ChunkyCharArray implements XMLEntityHandler.CharBuffer {

    /**
     * Constructor
     */
    public ChunkyCharArray(StringPool stringPool) {
        fStringPool = stringPool;
        fCurrentChunk = CharDataChunk.createChunk(stringPool, null);
    }

    /**
     *
     */
    public int length() {
        return fLength;
    }

    /**
     *
     */
    public void append(char ch) {
        try {
            fCurrentData[fCurrentIndex] = ch;
        } catch (ArrayIndexOutOfBoundsException ex) {
            if (fCurrentIndex == CharDataChunk.CHUNK_SIZE) {
                fCurrentChunk = CharDataChunk.createChunk(fStringPool, fCurrentChunk);
                fCurrentData = new char[INITIAL_CHUNK_SIZE];
                fCurrentIndex = 0;
            } else {
                char[] newData = new char[fCurrentIndex * 2];
                System.arraycopy(fCurrentData, 0, newData, 0, fCurrentIndex);
                fCurrentData = newData;
            }
            fCurrentChunk.setCharArray(fCurrentData);
            fCurrentData[fCurrentIndex] = ch;
        } catch (NullPointerException ex) {
            fCurrentData = new char[INITIAL_CHUNK_SIZE];
            fCurrentChunk.setCharArray(fCurrentData);
            fCurrentData[fCurrentIndex] = ch;
        }
        fCurrentIndex++;
        fLength++;
    }

    /**
     * Append a <code>String</code> to this buffer
     *
     * @param s the string to append.
     */
    public void append(String s) {
        int slen = s.length();
        for (int i = 0; i < slen; i++)
            append(s.charAt(i));
    }

    /**
     *
     */
    public void append(char[] ch, int offset, int length) {
        while (length-- > 0)
            append(ch[offset++]);
    }

    /**
     * Append a <code>ChunkyCharArray</code> to this buffer.
     *
     * @param charArray buffer to be appended.
     * @param offset The offset within charArray of the first character.
     * @param length The number of characters to append.
     */
    public void append(ChunkyCharArray charArray, int offset, int length) {
        fCurrentChunk.append(charArray, offset, length);
    }

    /**
     *
     */
    public int addString(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addString(offset, length);
    }

    /**
     * Add a region of this buffer to the <code>StringPool</code> as a symbol
     * 
     * @param offset The offset within this buffer of the first character of the string
     * @param length The number of characters in the symbol
     */
    public int addSymbol(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addSymbol(offset, length, 0);
    }

    //
    // Chunk size constants
    //
    private static final int INITIAL_CHUNK_SHIFT = 7;        // 2^7 = 128
    private static final int INITIAL_CHUNK_SIZE = (1 << INITIAL_CHUNK_SHIFT);

    //
    // Instance variables
    //
    private StringPool fStringPool = null;
    private CharDataChunk fCurrentChunk = null;
    private char[] fCurrentData = null;
    private int fCurrentIndex = 0;
    private int fLength = 0;
}
"
org/apache/xerces/dom/NamedNodeMapImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import java.io.*;
import java.util.Vector;
import java.util.Enumeration;

import org.w3c.dom.*;

//import org.apache.xerces.domx.events.*;
import org.apache.xerces.dom.events.MutationEventImpl;
import org.w3c.dom.events.*;

/**
 * NamedNodeMaps represent collections of Nodes that can be accessed
 * by name. They're currently used in two modes. Attributes are
 * placed in a NamedNodeMap rather than being children of the node
 * they describe. On the other hand Entity and Notation appear both
 * in the NamedNodeMap _and_ as kids of the DocumentType, requiring
 * some additional logic so these are maintained as ""live views"" of
 * each other.
 * <P>
 * Only one Node may be stored per name; attempting to
 * store another will replace the previous value.
 * <P>
 * NOTE: The ""primary"" storage key is taken from the NodeName attribute of the
 * node. The ""nodes"" Vector is kept sorted by this key to speed lookup,
 * ad make it easier to reconcile with the defaults. The ""secondary"" 
 * storage key is the namespaceURI and localName, when accessed by 
 * DOM level 2 nodes. all nodes, even DOM Level 2 nodes are stored in
 * a single Vector sorted by the primary ""nodename"" key.
 * <P>
 * NOTE: item()'s integer index does _not_ imply that the named nodes
 * must be stored in an array; that's only an access method. Note too
 * that these indices are ""live""; if someone changes the map's
 * contents, the indices associated with nodes may change.
 * <P>
 * As of REC-DOM-Level-1-19981001, Entities and Notations are no longer
 * shadowed as children of DocumentType.
 * <P>
 * This implementation includes support for DOM Level 2 Mutation Events.
 * If the static boolean NodeImpl.MUTATIONEVENTS is not set true, that support
 * is disabled and can be optimized out to reduce code size.
 * <P>
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class NamedNodeMapImpl
    implements NamedNodeMap, Serializable {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -7039242451046758020L;
    static final boolean DEBUG = false;

    //
    // Data
    //

    protected short flags;

    protected final static short READONLY     = 0x1<<0;
    protected final static short CHANGED      = 0x1<<1;

    /** Nodes. */
    protected Vector nodes;

    protected NodeImpl ownerNode; // the node this map belongs to

    /** Default nodes. */
    protected NamedNodeMapImpl defaults;

    //
    // Constructors
    //

    /** Constructs a named node map. */
    protected NamedNodeMapImpl(NodeImpl ownerNode, NamedNodeMapImpl defaults) {
        this.ownerNode = ownerNode;
        this.defaults = defaults;
        changed(true);          // to get reconcileDefaults called
    }

    //
    // NamedNodeMap methods
    //

    /**
     * Report how many nodes are currently stored in this NamedNodeMap.
     * Caveat: This is a count rather than an index, so the
     * highest-numbered node at any time can be accessed via
     * item(getLength()-1).
     * <P>
     * COMPLICATION: In the case of attributes,
     * the count has to include any defaults that may be inherited, yet
     * not double-count when there is both a default and a specified
     * value. Convolving the two lists is expensive, and for GC reasons
     * we don't want to register with the DTD (it wouldn't know when to
     * release us).
     * <P>
     * One solution is to go into the change-counter domain, as we did for
     * DeepNodeList. Another is to accept the convolution, and count
     * on the fact that our implementation is a sorted list to keep the cost
     * managable... which works pretty well for getLength(), but makes
     * item() expensive.
     * <P>
     * The ideal fix would be to rearchitect to eliminate integer indexing,
     * but of course that wouldn't meet the spec!
     */
    public int getLength() {
    	reconcileDefaults();
    	return (nodes != null) ? nodes.size() : 0;
    }

    /**
     * Retrieve an item from the map by 0-based index.
     *
     * @param index Which item to retrieve. Note that indices are just an
     * enumeration of the current contents; they aren't guaranteed to be
     * stable, nor do they imply any promises about the order of the
     * NamedNodeMap's contents. In other words, DO NOT assume either that
     * index(i) will always refer to the same entry, or that there is any
     * stable ordering of entries... and be prepared for double-reporting
     * or skips as insertion and deletion occur.
     *
     * @returns the node which currenly has the specified index, or null
     * if index is greater than or equal to getLength().
     */
    public Node item(int index) {
    	reconcileDefaults();
    	return (nodes != null && index < nodes.size()) ?
                    (Node)(nodes.elementAt(index)) : null;
    }

    /**
     * Retrieve a node by name. If not explicitly defined, checks the
     * defaults before giving up.
     *
     * @param name Name of a node to look up.
     * @returns the Node (of unspecified sub-class) stored with that name,
     * or null if no value has been assigned to that name.
     */
    public Node getNamedItem(String name) {

    	int i = findNamePoint(name,0);
        return (i < 0) ? null : (Node)(nodes.elementAt(i));

    } // getNamedItem(String):Node

    /**
     * Introduced in DOM Level 2. <p>
     * Retrieves a node specified by local name and namespace URI.
     *
     * @param namespaceURI  The namespace URI of the node to retrieve.
     *                      When it is null or an empty string, this
     *                      method behaves like getNamedItem.
     * @param localName     The local name of the node to retrieve.
     * @return Node         A Node (of any type) with the specified name, or null if the specified
     *                      name did not identify any node in the map.
     */
    public Node getNamedItemNS(String namespaceURI, String localName) {

    	int i = findNamePoint(namespaceURI, localName);
        return (i < 0) ? null : (Node)(nodes.elementAt(i));

    } // getNamedItemNS(String,String):Node

    /**
     * Adds a node using its nodeName attribute.
     * As the nodeName attribute is used to derive the name which the node must be
     * stored under, multiple nodes of certain types (those that have a ""special"" string
     * value) cannot be stored as the names would clash. This is seen as preferable to
     * allowing nodes to be aliased.
     * @see org.w3c.dom.NamedNodeMap#setNamedItem
     * @return If the new Node replaces an existing node the replaced Node is returned,
     *      otherwise null is returned. 
     * @param arg 
     *      A node to store in a named node map. The node will later be
     *      accessible using the value of the namespaceURI and localName
     *      attribute of the node. If a node with those namespace URI and
     *      local name is already present in the map, it is replaced by the new
     *      one.
     * @exception org.w3c.dom.DOMException The exception description.
     */
    public Node setNamedItem(Node arg)
        throws DOMException {

    	if (readOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR,
                                       ""DOM001 Modification not allowed"");
        }
    	if(arg.getOwnerDocument() != ownerNode.ownerDocument()) {
            throw new DOMExceptionImpl(DOMException.WRONG_DOCUMENT_ERR,
                                       ""DOM005 Wrong document"");
        }

        NodeImpl argn = (NodeImpl)arg;

    	if (argn.owned()) {
            throw new DOMExceptionImpl(DOMException.INUSE_ATTRIBUTE_ERR,
                                       ""DOM009 Attribute already in use"");
        }
        argn.ownerNode = ownerNode;
        argn.owned(true);
   	int i = findNamePoint(arg.getNodeName(),0);
    	NodeImpl previous = null;
    	if (i >= 0) {
            previous = (NodeImpl) nodes.elementAt(i);
            nodes.setElementAt(arg,i);
            previous.ownerNode = ownerNode.ownerDocument();
            previous.owned(false);
    	} else {
            i = -1 - i; // Insert point (may be end of list)
            if (null == nodes) {
                nodes = new Vector(5, 10);
            }
            nodes.insertElementAt(arg, i);
        }
        changed(true);

    	// Only NamedNodeMaps containing attributes (those which are
    	// bound to an element) need report MutationEvents
        if (NodeImpl.MUTATIONEVENTS &&
           ownerNode != null && ownerNode instanceof ElementImpl)
        {
            // MUTATION POST-EVENTS:
            ownerNode.dispatchAggregateEvents(
                (AttrImpl)arg,
                previous==null ? null : previous.getNodeValue()
                );
        }
    	return previous;

    } // setNamedItem(Node):Node

    /**
     * Adds a node using its namespaceURI and localName.
     * @see org.w3c.dom.NamedNodeMap#setNamedItem
     * @return If the new Node replaces an existing node the replaced Node is returned,
     *      otherwise null is returned. 
     * @param arg A node to store in a named node map. The node will later be
     *      accessible using the value of the namespaceURI and localName
     *      attribute of the node. If a node with those namespace URI and
     *      local name is already present in the map, it is replaced by the new
     *      one.
     */
    public Node setNamedItemNS(Node arg)
        throws DOMException {

    	if (readOnly()) {
            throw new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR,
                                       ""DOM001 Modification not allowed"");
        }
    
    	if(arg.getOwnerDocument() != ownerNode.ownerDocument()) {
            throw new DOMExceptionImpl(DOMException.WRONG_DOCUMENT_ERR,
                                       ""DOM005 Wrong document"");
        }

        NodeImpl argn = (NodeImpl)arg;
    	if (argn.owned()) {
            throw new DOMExceptionImpl(DOMException.INUSE_ATTRIBUTE_ERR,
                                       ""DOM009 Attribute already in use"");
        }

    	int i = findNamePoint(argn.getNamespaceURI(), argn.getLocalName());
    	NodeImpl previous = null;
    	if (i >= 0) {
            previous = (NodeImpl) nodes.elementAt(i);
            nodes.setElementAt(arg,i);
            previous.ownerNode = ownerNode.ownerDocument();
            previous.owned(false);
    	} else {
    	    // If we can't find by namespaceURI, localName, then we find by
    	    // nodeName so we know where to insert.
    	    i = findNamePoint(argn.getNodeName(),0);
            if (i >=0) {
                previous = (NodeImpl) nodes.elementAt(i);
                nodes.insertElementAt(arg,i);
            } else {
                i = -1 - i; // Insert point (may be end of list)
                if (null == nodes) {
                    nodes = new Vector(5, 10);
                }
                nodes.insertElementAt(arg, i);
            }
        }
    	changed(true);

    	// Only NamedNodeMaps containing attributes (those which are
    	// bound to an element) need report MutationEvents
        if (NodeImpl.MUTATIONEVENTS &&
           ownerNode != null && ownerNode instanceof ElementImpl)
        {
            // MUTATION POST-EVENTS:
            ownerNode.dispatchAggregateEvents(
                (AttrImpl)arg,
                previous==null ? null : previous.getNodeValue()
                );
        }
    	return previous;

    } // setNamedItem(Node):Node
   
    /**
     * Removes a node specified by name.
     * @param name
     *      The name of a node to remove. When this NamedNodeMap
     *      contains the attributes attached to an element, as returned
     *      by the attributes attribute of the Node interface, if the
     *      removed attribute is known to have a default value, an
     *      attribute immediately appears containing the default value
     *      as well as the corresponding namespace URI, local name,
     *      and prefix when applicable.
     * @return The node removed from the map if a node with such a name exists.
     */
    /***/
    public Node removeNamedItem(String name)
        throws DOMException {

    	if (readOnly()) {
            throw
                new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR,
                                     ""DOM001 Modification not allowed"");
        }
    	int i = findNamePoint(name,0);
    	if (i < 0) {
            throw new DOMExceptionImpl(DOMException.NOT_FOUND_ERR,
                                       ""DOM008 Not found"");
        }

        NodeImpl n = (NodeImpl)nodes.elementAt(i);
        // If there's a default, add it instead
        Node d;
        if (defaults != null && (d = defaults.getNamedItem(name)) != null
            && findNamePoint(name, i+1) < 0) {
            
            NodeImpl clone = (NodeImpl)d.cloneNode(true);
            clone.ownerNode = ownerNode;
            clone.owned(true);
            nodes.setElementAt(clone, i);
        }
        else {
            nodes.removeElementAt(i);
        }

        changed(true);
        // remove owning element
        n.ownerNode = ownerNode.ownerDocument();
        n.owned(false);
        return n;

    } // removeNamedItem(String):Node
    
    /**
     * Introduced in DOM Level 2. <p>
     * Removes a node specified by local name and namespace URI.
     * @param namespaceURI
     *                      The namespace URI of the node to remove.
     *                      When it is null or an empty string, this
     *                      method behaves like removeNamedItem.
     * @param               The local name of the node to remove. When
     *                      this NamedNodeMap contains the attributes
     *                      attached to an element, as returned by the
     *                      attributes attribute of the Node interface, if the
     *                      removed attribute is known to have a default
     *                      value, an attribute immediately appears
     *                      containing the default value.
     * @return Node         The node removed from the map if a node with such a local name and
     *                       namespace URI exists.
     * @throws              NOT_FOUND_ERR: Raised if there is no node named
     *                      name in the map.

     */
     public Node removeNamedItemNS(String namespaceURI, String name)
        throws DOMException {

    	if (readOnly()) {
            throw
                new DOMExceptionImpl(DOMException.NO_MODIFICATION_ALLOWED_ERR,
                                     ""DOM001 Modification not allowed"");
        }
    	int i = findNamePoint(namespaceURI, name);
    	if (i < 0) {
            throw new DOMExceptionImpl(DOMException.NOT_FOUND_ERR,
                                       ""DOM008 Not found"");
        }

        LCount lc=null;
        String oldvalue="""";
        AttrImpl enclosingAttribute=null;
        if (NodeImpl.MUTATIONEVENTS &&
           ownerNode != null && ownerNode instanceof ElementImpl)
        {
            // MUTATION PREPROCESSING AND PRE-EVENTS:
            lc=LCount.lookup(MutationEventImpl.DOM_ATTR_MODIFIED);
            if(lc.captures+lc.bubbles+lc.defaults>0)
            {
               enclosingAttribute=(AttrImpl)(nodes.elementAt(i));
               oldvalue=enclosingAttribute.getNodeValue();
            }
        } // End mutation preprocessing

        NodeImpl n = (NodeImpl)nodes.elementAt(i);
        // If there's a default, add it instead
        Node d;
        String nodeName = n.getNodeName();
        if (defaults != null && (d = defaults.getNamedItem(nodeName)) != null)
        {
            int j = findNamePoint(nodeName,0);
            if (j>=0 && findNamePoint(nodeName, j+1) < 0) {
                NodeImpl clone = (NodeImpl)d.cloneNode(true);
                clone.ownerNode = ownerNode;
                clone.owned(true);
                nodes.setElementAt(clone, i);
            } else {
                nodes.removeElementAt(i);
            }
        }
        else {
            nodes.removeElementAt(i);
        }

        changed(true);

        // Need to remove references to an Attr's owner before the
        // MutationEvents fire.
        n.ownerNode = ownerNode.ownerDocument();
        n.owned(false);

        // We can't use the standard dispatchAggregate, since it assumes
        // that the Attr is still attached to an owner. This code is
        // similar but dispatches to the previous owner, ""element"".
        if(NodeImpl.MUTATIONEVENTS &&
           ownerNode != null && ownerNode instanceof ElementImpl)
        {
    	    // If we have to send DOMAttrModified (determined earlier),
	        // do so.
	        if(lc.captures+lc.bubbles+lc.defaults>0)
	        {
                MutationEvent me= new MutationEventImpl();
                //?????ownerDocument.createEvent(""MutationEvents"");
                me.initMutationEvent(MutationEventImpl.DOM_ATTR_MODIFIED,
                                     true, false,
                                     null, n.getNodeValue(),
                             ((ElementImpl)ownerNode).getAttribute(name),name);
                ownerNode.dispatchEvent(me);
            }

            // We can hand off to process DOMSubtreeModified, though.
            // Note that only the Element needs to be informed; the
            // Attr's subtree has not been changed by this operation.
            ownerNode.dispatchAggregateEvents(null,null);
        }
        return n;

    } // removeNamedItem(String):Node

    //
    // Public methods
    //

    /**
     * Cloning a NamedNodeMap is a DEEP OPERATION; it always clones
     * all the nodes contained in the map.
     */
     
     // REVIST: Currently, this does _not_ clone the docType reference.
     // Should the new docType object (if any) be a parameter, rather
     // than being set manually later on?
     // We _do_ clone the defaults reference, if any.
    public NamedNodeMapImpl cloneMap(NodeImpl ownerNode) {
    	NamedNodeMapImpl newmap = new NamedNodeMapImpl(ownerNode, defaults);
    	if (nodes != null) {
            newmap.nodes = new Vector(nodes.size());
            for (int i = 0; i < nodes.size(); ++i) {
                NodeImpl clone = (NodeImpl)((Node)nodes.elementAt(i)).cloneNode(true);
                newmap.setNamedItem(clone);
            }
        }
    	newmap.defaults = defaults;
        newmap.changed(changed());
    	return newmap;

    } // cloneMap():NamedNodeMapImpl

    //
    // Package methods
    //

    /**
     * Internal subroutine to allow read-only Nodes to make their contained
     * NamedNodeMaps readonly too. I expect that in fact the shallow
     * version of this operation will never be
     *
     * @param readOnly boolean true to make read-only, false to permit editing.
     * @param deep boolean true to pass this request along to the contained
     * nodes, false to only toggle the NamedNodeMap itself. I expect that
     * the shallow version of this operation will never be used, but I want
     * to design it in now, while I'm thinking about it.
     */
    void setReadOnly(boolean readOnly, boolean deep) {

        readOnly(readOnly);
    	if(deep && nodes != null) {
    		Enumeration e=nodes.elements();
    		while(e.hasMoreElements()) {
    			((NodeImpl)e.nextElement()).setReadOnly(readOnly,deep);
            }
    	}

    } // setReadOnly(boolean,boolean)
    
    /**
     * Internal subroutine returns this NodeNameMap's (shallow) readOnly value.
     *
     */
    boolean getReadOnly() {
    	return readOnly();
    } // getReadOnly()
    

    //
    // Protected methods
    //

    /**
     * Subroutine: If this NamedNodeMap is backed by a ""defaults"" map (eg,
     * if it's being used for Attributes of an XML file validated against
     * a DTD), we need to deal with the risk that those defaults might
     * have changed. Entries may have been added, changed, or removed, and
     * if so we need to update our version of that information
     * <P>
     * Luckily, this currently applies _only_ to Attributes, which have a
     * ""specified"" flag that allows us to distinguish which we set manually
     * versus which were defaults... assuming that the defaults list is being
     * maintained properly, of course.
     * <P>
     * Also luckily, The NameNodeMaps are maintained as 
     * sorted lists. This should keep the cost of convolving the two lists
     * managable... not wonderful, but at least more like 2N than N**2..
     * <P>
     * Finally, to avoid doing the convolution except when there are actually
     * changes to be absorbed, I've made the Map aware of whether or not
     * its defaults Map has changed. This is not 110% reliable, but it should
     * work under normal circumstances, especially since the DTD is usually
     * relatively static information.
     * <P>
     * Note: This is NON-DOM implementation, though used to support behavior
     * that the DOM requires.
     */
    protected void reconcileDefaults() {
        
        if (DEBUG) System.out.println(""reconcileDefaults:"");
    	if (defaults != null && changed()) {

    		int n = 0;
            int d = 0;
            int nsize = (nodes != null) ? nodes.size() : 0;
            int dsize = defaults.nodes.size();

    		AttrImpl nnode = (nsize == 0) ? null : (AttrImpl) nodes.elementAt(0);
    		AttrImpl dnode = (dsize == 0) ? null : (AttrImpl) defaults.nodes.elementAt(0);

    		while (n < nsize && d < dsize) {
    			nnode = (AttrImpl) nodes.elementAt(n);
    			dnode = (AttrImpl) defaults.nodes.elementAt(d);
    			if (DEBUG) {
    			System.out.println(""\n\nnnode=""+nnode.getNodeName());
    			System.out.println(""dnode=""+dnode.getNodeName());
    			}
    			
    			
    			int test = nnode.getNodeName().compareTo(dnode.getNodeName());

                //REVIST: EACH CONDITION - HOW IT RESPONDS TO DUPLICATE KEYS!
    			// Same name and a default -- make sure same value
    			if (test == 0) {
    			    if (!nnode.getSpecified()) {
    			        if (DEBUG) System.out.println(""reconcile (test==0, specified = false): clone default"");
                        NodeImpl clone = (NodeImpl)dnode.cloneNode(true);
                        clone.ownerNode = ownerNode;
                        clone.owned(true);
    				    nodes.setElementAt(clone, n);
    				    // Advance over both, since names in sync
    				    ++n;
    				    ++d;
    			    }
    			    else { //REVIST: if same name, but specified, simply increment over it.
    			        if (DEBUG)
                                    System.out.println(""reconcile (test==0, specified=true): just increment"");
    				    ++n;
    				    ++d;
    			    }
    			}

    			// Different name, new default in table; add it
    			else if (test > 0) {
    			    if (DEBUG) System.out.println(""reconcile (test>0): insert new default"");
                    NodeImpl clone = (NodeImpl)dnode.cloneNode(true);
                    clone.ownerNode = ownerNode;
                    clone.owned(true);
    				nodes.insertElementAt(clone, n);
    				// Now in sync, so advance over both
    				++n;
    				++d;
    			}

    			// Different name, old default here; remove it.
    			else if (!nnode.getSpecified()) {
    			    if (DEBUG) System.out.println(""reconcile(!specified): remove old default:""
    			    +nnode.getNodeName());
                    // NOTE: We don't need to null out the parent
                    //       because this is a node that we're
                    //       throwing away (not returning). -Ac
                    // REVISIT: [Q] Should we null it out anyway? -Ac
    				nodes.removeElementAt(n);
    				// n didn't advance but represents a different element
    			}

    			// Different name, specified; accept it
                else {
    			    if (DEBUG) System.out.println(""reconcile: Different name else accept it."");
    				++n;
                }
        	}

    		// If we ran out of local before default, pick up defaults
            if (d < dsize) {
                if (nodes == null) nodes = new Vector();
                while (d < dsize) {
                    dnode = (AttrImpl)defaults.nodes.elementAt(d++);
                    NodeImpl clone = (NodeImpl)dnode.cloneNode(true);
                    clone.ownerNode = ownerNode;
                    clone.owned(true);
    			    if (DEBUG) System.out.println(""reconcile: adding""+clone);
                    nodes.addElement(clone);
                }
            }
            changed(false);
    	}
    } // reconcileDefaults()


    /**
     * NON-DOM
     * set the ownerDocument of this node, and the attributes it contains
     */
    void setOwnerDocument(DocumentImpl doc) {
        if (nodes != null) {
            for (int i = 0; i < nodes.size(); i++) {
                ((NodeImpl)item(i)).setOwnerDocument(doc);
            }
        }
    }

    final boolean readOnly() {
        return (flags & READONLY) != 0;
    }

    final void readOnly(boolean value) {
        flags = (short) (value ? flags | READONLY : flags & ~READONLY);
    }

    final boolean changed() {
        return (flags & CHANGED) != 0;
    }

    final void changed(boolean value) {
        flags = (short) (value ? flags | CHANGED : flags & ~CHANGED);
    }

    //
    // Private methods
    //

    /**
     * Subroutine: Locate the named item, or the point at which said item
     * should be added. 
     *
     * SIDE EFFECT: Resynchronizes w/ Defaults. 
     *
     * @param name Name of a node to look up.
     *
     * @return If positive or zero, the index of the found item.
     * If negative, index of the appropriate point at which to insert
     * the item, encoded as -1-index and hence reconvertable by subtracting
     * it from -1. (Encoding because I don't want to recompare the strings
     * but don't want to burn bytes on a datatype to hold a flagged value.)
     */
    private int findNamePoint(String name, int start) {

    	reconcileDefaults();

    	// Binary search
    	int i = 0;
    	if(nodes != null) {
    		int first = start;
            int last  = nodes.size() - 1;

    		while (first <= last) {
    			i = (first + last) / 2;
    			int test = name.compareTo(((Node)(nodes.elementAt(i))).getNodeName());
    			if(test == 0) {
    				return i; // Name found
                }
    			else if (test < 0) {
    				last = i - 1;
                }
    			else {
    				first = i + 1;
                }
    		}

    		if (first > i) {
                i = first;
            }
    	}

    	return -1 - i; // not-found has to be encoded.

    } // findNamePoint(String):int

    
    /** This findNamePoint is for DOM Level 2 Namespaces.
     */
    private int findNamePoint(String namespaceURI, String name) {
        
        reconcileDefaults();
        if (nodes == null) return -1;
        if (namespaceURI == null) return -1;
        if (name == null) return -1;
        
        // This is a linear search through the same nodes Vector.
        // The Vector is sorted on the DOM Level 1 nodename.
        // The DOM Level 2 NS keys are namespaceURI and Localname, 
        // so we must linear search thru it.
        
        for (int i = 0; i < nodes.size(); i++) {
            NodeImpl a = (NodeImpl)nodes.elementAt(i);
            if (namespaceURI.equals(a.getNamespaceURI())
                && name.equals(a.getLocalName())
                ) {
                return i;
            }
        }
        return -1;
    }
    

} // class NamedNodeMapImpl
"
org/apache/xerces/dom/CharacterDataImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;
import java.util.Enumeration;

import org.apache.xerces.dom.events.MutationEventImpl;
import org.w3c.dom.events.*;

/**
 * CharacterData is an abstract Node that can carry character data as its
 * Value.  It provides shared behavior for Text, CData, and
 * possibly other node types. All offsets are 0-based.
 * <p>
 * This implementation includes support for DOM Level 2 Mutation Events.
 * If the static boolean NodeImpl.MUTATIONEVENTS is not set true, that support
 * is disabled and can be optimized out to reduce code size.
 *
 * Since this ProcessingInstructionImpl inherits from this class to reuse the
 * setNodeValue method, this class isn't declared as implementing the interface
 * CharacterData. This is done by relevant subclasses (TexImpl, CommentImpl).
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public abstract class CharacterDataImpl
    extends ChildNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 7931170150428474230L;

    //
    // Data
    //

    protected String data;

    /** Empty child nodes. */
    private static transient NodeList singletonNodeList = new NodeList() {
        public Node item(int index) { return null; }
        public int getLength() { return 0; }
    };

    //
    // Constructors
    //

    /** Factory constructor. */
    protected CharacterDataImpl(DocumentImpl ownerDocument, String data) {
        super(ownerDocument);
        this.data = data;
    }

    //
    // Node methods
    //

    /** Returns an empty node list. */
    public NodeList getChildNodes() {
        return singletonNodeList;
    }

    /*
     * returns the content of this node
     */
    public String getNodeValue() {
        if (syncData()) {
            synchronizeData();
        }
        return data;
    }

    /** This function added so that we can distinguish whether
     *  setNodeValue has been called from some other DOM functions.
     *  or by the client.<p>
     *  This is important, because we do one type of Range fix-up, 
     *  from the high-level functions in CharacterData, and another
     *  type if the client simply calls setNodeValue(value).
     */
    void setNodeValueInternal(String value) {
        /** flag to indicate whether setNodeValue was called by the
         *  client or from the DOM.
         */
        setValue(true);
        setNodeValue(value);
        setValue(false);
    }
    
    /**
     * Sets the content, possibly firing related events, and updating ranges
     */
    public void setNodeValue(String value) {
    	if (readOnly())
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        // revisit: may want to set the value in ownerDocument.
    	// Default behavior, overridden in some subclasses
        if (syncData()) {
            synchronizeData();
        }
            
        // Cache old value for DOMCharacterDataModified.
        String oldvalue = value;
        EnclosingAttr enclosingAttr=null;
        if(MUTATIONEVENTS)
        {
            // MUTATION PREPROCESSING AND PRE-EVENTS:
            // If we're within the scope of an Attr and DOMAttrModified 
            // was requested, we need to preserve its previous value for
            // that event.
            LCount lc=LCount.lookup(MutationEventImpl.DOM_ATTR_MODIFIED);
            if(lc.captures+lc.bubbles+lc.defaults>0)
            {
                enclosingAttr=getEnclosingAttr();
            }
        } // End mutation preprocessing
            
    	this.data = value;
    	if (!setValue()) {
            // call out to any Ranges to set any boundary index to zero.
            Enumeration ranges = ownerDocument().getRanges();
            if (ranges != null) {
                while ( ranges.hasMoreElements()) {
                   ((RangeImpl)ranges.nextElement()).receiveReplacedText(this);
                }
            }
        }
    	
        if(MUTATIONEVENTS)
        {
            // MUTATION POST-EVENTS:
            LCount lc =
                LCount.lookup(MutationEventImpl.DOM_CHARACTER_DATA_MODIFIED);
            if(lc.captures+lc.bubbles+lc.defaults>0)
            {
                MutationEvent me= new MutationEventImpl();
                //?????ownerDocument.createEvent(""MutationEvents"");
                me.initMutationEvent(
                                 MutationEventImpl.DOM_CHARACTER_DATA_MODIFIED,
                                     true,false,null,oldvalue,value,null);
                dispatchEvent(me);
            }
            
            // Subroutine: Transmit DOMAttrModified and DOMSubtreeModified,
            // if required. (Common to most kinds of mutation)
            dispatchAggregateEvents(enclosingAttr);
        } // End mutation postprocessing

    } // setNodeValue(String)

    //
    // CharacterData methods
    //

    /**
     * Retrieve character data currently stored in this node.
     * 
     * @throws DOMExcpetion(DOMSTRING_SIZE_ERR) In some implementations,
     * the stored data may exceed the permitted length of strings. If so,
     * getData() will throw this DOMException advising the user to
     * instead retrieve the data in chunks via the substring() operation.  
     */
    public String getData() {
        if (syncData()) {
            synchronizeData();
        }
        return data;
    }

    /** 
     * Report number of characters currently stored in this node's
     * data. It may be 0, meaning that the value is an empty string. 
     */
    public int getLength() {   
        if (syncData()) {
            synchronizeData();
        }
        return data.length();
    }  

    /** 
     * Concatenate additional characters onto the end of the data
     * stored in this node. Note that this, and insert(), are the paths
     * by which a DOM could wind up accumulating more data than the
     * language's strings can easily handle. (See above discussion.)
     * 
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is readonly.
     */
    public void appendData(String data) {

        if (readOnly()) {
        	throw new DOMExceptionImpl(
        		DOMException.NO_MODIFICATION_ALLOWED_ERR,
        		""DOM001 Modification not allowed"");
        }

        if (syncData()) {
            synchronizeData();
        }
        
        // Handles mutation event generation, if any
        setNodeValue(this.data + data);

    } // appendData(String)

    /**
     * Remove a range of characters from the node's value. Throws a
     * DOMException if the offset is beyond the end of the
     * string. However, a deletion _count_ that exceeds the available
     * data is accepted as a delete-to-end request.
     * 
     * @throws DOMException(INDEX_SIZE_ERR) if offset is negative or
     * greater than length, or if count is negative.
     * 
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is
     * readonly.  
     */
    public void deleteData(int offset, int count) 
        throws DOMException {

        if (readOnly()) {
        	throw new DOMExceptionImpl(
        		DOMException.NO_MODIFICATION_ALLOWED_ERR, 
        		""DOM001 Modification not allowed"");
        }

        if (count < 0) {
        	throw new DOMExceptionImpl(DOMException.INDEX_SIZE_ERR, 
        	                           ""DOM004 Index out of bounds"");
        }

        if (syncData()) {
            synchronizeData();
        }
        int tailLength = Math.max(data.length() - count - offset, 0);
        try {
            // Handles mutation event generation, if any
            setNodeValueInternal(data.substring(0, offset) +
                                 (tailLength > 0 
		? data.substring(offset + count, offset + count + tailLength) 
                                  : """") );
            Enumeration ranges = ownerDocument().getRanges();
            if (ranges != null) {
                while ( ranges.hasMoreElements()) {
                    RangeImpl r = ((RangeImpl)ranges.nextElement());
                    r.receiveDeletedText( this,  offset,  count);
                }
            }
        }
        catch (StringIndexOutOfBoundsException e) {
        	throw new DOMExceptionImpl(DOMException.INDEX_SIZE_ERR, 
        	                           ""DOM004 Index out of bounds"");
        }

    } // deleteData(int,int)

    /**
     * Insert additional characters into the data stored in this node,
     * at the offset specified.
     *
     * @throws DOMException(INDEX_SIZE_ERR) if offset is negative or
     * greater than length.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is readonly.  
     */
    public void insertData(int offset, String data) 
        throws DOMException {

        if (readOnly()) {
        	throw new DOMExceptionImpl(
        		DOMException.NO_MODIFICATION_ALLOWED_ERR, 
        		""DOM001 Modification not allowed"");
        }

        if (syncData()) {
            synchronizeData();
        }
        try {
       		// Handles mutation event generation, if any
            setNodeValueInternal(
                new StringBuffer(this.data).insert(offset, data).toString()
                );
            Enumeration ranges = ownerDocument().getRanges();
            if (ranges != null) {
                while ( ranges.hasMoreElements()) {
                    RangeImpl r = ((RangeImpl)ranges.nextElement());
                    r.receiveInsertedText( this,  offset,  data.length());
                }
            }
        }
        catch (StringIndexOutOfBoundsException e) {
        	throw new DOMExceptionImpl(DOMException.INDEX_SIZE_ERR, 
        	                           ""DOM004 Index out of bounds"");
        }

    } // insertData(int,int)

    /**
     * Replace a series of characters at the specified (zero-based)
     * offset with a new string, NOT necessarily of the same
     * length. Convenience method, equivalent to a delete followed by an
     * insert. Throws a DOMException if the specified offset is beyond
     * the end of the existing data.
     * 
     * @param offset       The offset at which to begin replacing.
     * 
     * @param count        The number of characters to remove, 
     * interpreted as in the delete() method.
     * 
     * @param data         The new string to be inserted at offset in place of
     * the removed data. Note that the entire string will
     * be inserted -- the count parameter does not affect
     * insertion, and the new data may be longer or shorter
     * than the substring it replaces.
     * 
     * @throws DOMException(INDEX_SIZE_ERR) if offset is negative or
     * greater than length, or if count is negative.
     * 
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is
     * readonly.  
     */
    public void replaceData(int offset, int count, String data) 
        throws DOMException {

		// The read-only check is done by deleteData()
		// ***** This could be more efficient w/r/t Mutation Events,
		// specifically by aggregating DOMAttrModified and
		// DOMSubtreeModified. But mutation events are 
		// underspecified; I don't feel compelled
		// to deal with it right now.
		deleteData(offset, count);
		insertData(offset, data);

    } // replaceData(int,int,String)

    /**
     * Store character data into this node.
     * 
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is readonly.
     */
    public void setData(String value) 
        throws DOMException {
        setNodeValue(value);
    }

    /** 
     * Substring is more than a convenience function. In some
     * implementations of the DOM, where the stored data may exceed the
     * length that can be returned in a single string, the only way to
     * read it all is to extract it in chunks via this method.
     *
     * @param offset        Zero-based offset of first character to retrieve.
     * @param count Number of characters to retrieve. 
     *
     * If the sum of offset and count exceeds the length, all characters
     * to end of data are returned.
     *
     * @throws DOMException(INDEX_SIZE_ERR) if offset is negative or
     * greater than length, or if count is negative.
     *
     * @throws DOMException(WSTRING_SIZE_ERR) In some implementations,
     * count may exceed the permitted length of strings. If so,
     * substring() will throw this DOMException advising the user to
     * instead retrieve the data in smaller chunks.  
     */
    public String substringData(int offset, int count) 
        throws DOMException {

        if (syncData()) {
            synchronizeData();
        }
        
        int length = data.length();
        if (count < 0 || offset < 0 || offset > length - 1) {
            throw new DOMExceptionImpl(DOMException.INDEX_SIZE_ERR, 
                                       ""DOM004 Index out of bounds"");
        }

        int tailIndex = Math.min(offset + count, length);

        return data.substring(offset, tailIndex);

    } // substringData(int,int):String

} // class CharacterDataImpl
"
org/apache/xerces/readers/CharReader.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.CharDataChunk;
import org.apache.xerces.utils.StringPool;
import java.io.Reader;

/**
 * General purpose character stream reader.
 *
 * This class is used when the input source for the document entity is
 * specified using a character stream, when the input source is specified
 * using a byte stream with an explicit encoding, or when a recognizer
 * scans the encoding decl from the byte stream and chooses to use this
 * reader class for that encoding.  For the latter two cases, the byte
 * stream is wrapped in the appropriate InputStreamReader using the
 * desired encoding.
 *
 * @version
 */
final class CharReader extends AbstractCharReader {
    //
    //
    //
    CharReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, Reader reader, StringPool stringPool) throws Exception {
        super(entityHandler, errorReporter, sendCharDataAsCharArray, stringPool);
        fCharacterStream = reader;
        fillCurrentChunk();
    }
    //
    //
    //
    private Reader fCharacterStream = null;
    //
    // When we fill a chunk there may be data that was read from the
    // input stream that has not been ""processed"".  We need to save
    // that data, and any in-progress state, between the calls to
    // fillCurrentChunk() in these instance variables.  
    //
    private boolean fCheckOverflow = false;
    private char[] fOverflow = null;
    private int fOverflowOffset = 0;
    private int fOverflowEnd = 0;
    private int fOutputOffset = 0;
    private boolean fSkipLinefeed = false;
    //
    //
    //
    protected int fillCurrentChunk() throws Exception {
        //
        // See if we can find a way to reuse the buffer that may have been returned
        // with a recyled data chunk.
        //
        char[] recycledData = fCurrentChunk.toCharArray();
        //
        // If we have overflow from the last call, normalize from where
        // we left off, copying into the front of the output buffer.
        //
        fOutputOffset = 0;
        if (fCheckOverflow) {
            //
            // The fOverflowEnd should always be equal to CHUNK_SIZE, unless we hit
            // EOF during the previous call.  Copy the remaining data to the front
            // of the buffer and return it as the final chunk.
            //
            fMostRecentData = recycledData;
            if (fOverflowEnd < CharDataChunk.CHUNK_SIZE) {
                recycledData = null;
                if (fOverflowEnd > 0) {
                    if (fMostRecentData == null || fMostRecentData.length < 1 + fOverflowEnd - fOverflowOffset)
                        fMostRecentData = new char[1 + fOverflowEnd - fOverflowOffset];
                    copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                } else {
                    if (fMostRecentData == null)
                        fMostRecentData = new char[1];
                }
                fMostRecentData[fOutputOffset] = 0;
                //
                // Update our instance variables
                //
                fOverflow = null;
                fLength += fOutputOffset;
                fCurrentIndex = 0;
                fCurrentChunk.setCharArray(fMostRecentData);
                return (fMostRecentChar = fMostRecentData[0]);
            }
            if (fMostRecentData == null || fMostRecentData.length < CharDataChunk.CHUNK_SIZE)
                fMostRecentData = new char[CharDataChunk.CHUNK_SIZE];
            else
                recycledData = null;
            copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
            fCheckOverflow = false;
        } else {
            if (fOverflow == null) {
                fOverflow = recycledData;
                if (fOverflow == null || fOverflow.length < CharDataChunk.CHUNK_SIZE)
                    fOverflow = new char[CharDataChunk.CHUNK_SIZE];
                else
                    recycledData = null;
            }
            fMostRecentData = null;
        }
        while (true) {
            fOverflowOffset = 0;
            fOverflowEnd = 0;
            int capacity = CharDataChunk.CHUNK_SIZE;
            int result = 0;
            do {
                try {
                    result = fCharacterStream.read(fOverflow, fOverflowEnd, capacity);
                } catch (java.io.IOException ex) {
                    result = -1;
                }
                if (result == -1) {
                    //
                    // We have reached the end of the stream.
                    //
                    fCharacterStream.close();
                    fCharacterStream = null;
                    if (fMostRecentData == null) {
                        //
                        // There is no previous output data, so we know that all of the
                        // new input data will fit.
                        //
                        fMostRecentData = recycledData;
                        if (fMostRecentData == null || fMostRecentData.length < 1 + fOverflowEnd)
                            fMostRecentData = new char[1 + fOverflowEnd];
                        else
                            recycledData = null;
                        copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                        fOverflow = null;
                        fMostRecentData[fOutputOffset] = 0;
                    } else {
                        //
                        // Copy the input data to the end of the output buffer.
                        //
                        boolean alldone = copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                        if (alldone) {
                            if (fOverflowEnd == CharDataChunk.CHUNK_SIZE) {
                                //
                                // Special case - everything fit into the overflow buffer,
                                // except that there is no room for the nul char we use to
                                // indicate EOF.  Set the overflow buffer length to zero.
                                // On the next call to this method, we will detect this
                                // case and which we will handle above .
                                //
                                fCheckOverflow = true;
                                fOverflowOffset = 0;
                                fOverflowEnd = 0;
                            } else {
                                //
                                // It all fit into the output buffer.
                                //
                                fOverflow = null;
                                fMostRecentData[fOutputOffset] = 0;
                            }
                        } else {
                            //
                            // There is still input data left over, save the remaining data as
                            // the overflow buffer for the next call.
                            //
                            fCheckOverflow = true;
                        }
                    }
                    break;
                }
                if (result > 0) {
                    fOverflowEnd += result;
                    capacity -= result;
                }
            } while (capacity > 0);
            //
            //
            //
            if (result == -1)
                break;
            if (fMostRecentData != null) {
                boolean alldone = copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                if (fOutputOffset == CharDataChunk.CHUNK_SIZE) {
                    //
                    // We filled the output buffer.
                    //
                    if (!alldone) {
                        //
                        // The input buffer will become the next overflow buffer.
                        //
                        fCheckOverflow = true;
                    }
                    break;
                }
            } else {
                //
                // Now normalize the end-of-line characters and see if we need to read more
                // chars to fill up the buffer.
                //
                fMostRecentData = recycledData;
                if (fMostRecentData == null || fMostRecentData.length < CharDataChunk.CHUNK_SIZE)
                    fMostRecentData = new char[CharDataChunk.CHUNK_SIZE];
                else
                    recycledData = null;
                copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                if (fOutputOffset == CharDataChunk.CHUNK_SIZE) {
                    //
                    // The output buffer is full.  We can return now.
                    //
                    break;
                }
            }
            //
            // We will need to get another intput buffer to be able to fill the
            // overflow buffer completely.
            //
        }
        //
        // Update our instance variables
        //
        fLength += fOutputOffset;
        fCurrentIndex = 0;
        fCurrentChunk.setCharArray(fMostRecentData);
        return (fMostRecentChar = fMostRecentData[0]);
    }
    //
    // Copy and normalize chars from the overflow buffer into chars in our data buffer.
    //
    private boolean copyNormalize(char[] in, int inOffset, char[] out, int outOffset) throws Exception {
        //
        // Handle all edge cases before dropping into the inner loop.
        //
        int inEnd = fOverflowEnd;
        int outEnd = out.length;
        if (inOffset == inEnd)
            return true;
        char b = in[inOffset];
        if (fSkipLinefeed) {
            fSkipLinefeed = false;
            if (b == 0x0A) {
                if (++inOffset == inEnd)
                    return exitNormalize(inOffset, outOffset, true);
                b = in[inOffset];
            }
        }
        while (outOffset < outEnd) {
            //
            // Find the longest run that we can guarantee will not exceed the
            // bounds of the outer loop.
            //
            int inCount = inEnd - inOffset;
            int outCount = outEnd - outOffset;
            if (inCount > outCount)
                inCount = outCount;
            inOffset++;
            while (true) {
                while (b == 0x0D) {
                    out[outOffset++] = 0x0A;
                    if (inOffset == inEnd) {
                        fSkipLinefeed = true;
                        return exitNormalize(inOffset, outOffset, true);
                    }
                    b = in[inOffset];
                    if (b == 0x0A) {
                        if (++inOffset == inEnd)
                            return exitNormalize(inOffset, outOffset, true);
                        b = in[inOffset];
                    }
                    if (outOffset == outEnd)
                        return exitNormalize(inOffset, outOffset, false);
                    inCount = inEnd - inOffset;
                    outCount = outEnd - outOffset;
                    if (inCount > outCount)
                        inCount = outCount;
                    inOffset++;
                }
                while (true) {
                    out[outOffset++] = b;
                    if (--inCount == 0)
                        break;
                    b = in[inOffset++];
                    if (b == 0x0D)
                        break;
                }
                if (inCount == 0)
                    break;
            }
            if (inOffset == inEnd)
                break;
        }
        return exitNormalize(inOffset, outOffset, inOffset == inEnd);
    }
    //
    //
    //
    private boolean exitNormalize(int inOffset, int outOffset, boolean result) {
        fOverflowOffset = inOffset;
        fOutputOffset = outOffset;
        return result;
    }
}
"
org/apache/xerces/utils/StringPool.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

/**
 *
 * @version
 */
public final class StringPool {
    //
    // Debugging
    //
    private static final boolean DEBUG_ADDITIONS = false;
    /**
     * Constants
     */
    public static final int NULL_STRING = -1;   // null
    public static final int EMPTY_STRING = 0;   // """"
    /**
     *
     */
    public interface StringProducer {
        /**
         *
         */
        public String toString(int offset, int length);
        /**
         *
         */
        public void releaseString(int offset, int length);
        /**
         *
         */
        public boolean equalsString(int offset, int length, char[] strChars, int strOffset, int strLength);
    };
    //
    // Chunk size constants
    //
    private static final int INITIAL_CHUNK_SHIFT = 8;    // 2^8 = 256
    private static final int INITIAL_CHUNK_SIZE = (1 << INITIAL_CHUNK_SHIFT);
    private static final int CHUNK_SHIFT = 13;           // 2^13 = 8k
    private static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);
    private static final int CHUNK_MASK = CHUNK_SIZE - 1;
    private static final int INITIAL_CHUNK_COUNT = (1 << (16 - CHUNK_SHIFT));   // 2^16 = 64k
    //
    // Instance variables
    //
    //
    // String and Symbol arrays
    //
    private int fStringCount = 0;
    private int fStringFreeList = -1;
    private String[][] fString = new String[INITIAL_CHUNK_COUNT][];
    private StringPool.StringProducer[][] fStringProducer = new StringPool.StringProducer[INITIAL_CHUNK_COUNT][];
    private int[][] fOffset = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fLength = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fCharsOffset = new int[INITIAL_CHUNK_COUNT][];
    //
    // String Lists
    //
    private int fStringListCount = 0;
    private int fActiveStringList = -1;
    private int[][] fStringList = new int[INITIAL_CHUNK_COUNT][];
    //
    // Symbol Hashtable
    //
    private static final int INITIAL_BUCKET_SIZE = 4;
    private static final int HASHTABLE_SIZE = 128;
    private int[][] fSymbolTable = new int[HASHTABLE_SIZE][];
    //
    // Symbol Cache
    //
    private SymbolCache fSymbolCache = null;
    //
    //
    //
    public StringPool() {
        fSymbolCache = new SymbolCache();
        if (addSymbol("""") != EMPTY_STRING)
            throw new RuntimeException(""UTL002 cannot happen"");
    }
    //
    //
    //
    public void reset() {
        int chunk = 0;
        int index = 0;
        for (int i = 0; i < fStringCount; i++) {
            fString[chunk][index] = null;
            if (fStringProducer[chunk][index] != null)
                fStringProducer[chunk][index].releaseString(fOffset[chunk][index], fLength[chunk][index]);
            fStringProducer[chunk][index] = null;
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
        for (int i = 0; i < HASHTABLE_SIZE; i++)
            fSymbolTable[i] = null;
        fStringCount = 0;
        fStringFreeList = -1;
        fStringListCount = 0;
        fActiveStringList = -1;
        fSymbolCache.reset();
        fShuffleCount = 0;
        if (addSymbol("""") != EMPTY_STRING)
            throw new RuntimeException(""UTL002 cannot happen"");
    }
    //
    // String interfaces
    //
    private boolean ensureCapacity(int chunk, int index) {
        try {
            return fOffset[chunk][index] == 0;
        } catch (ArrayIndexOutOfBoundsException ex) {
            if (index == 0) {
                String[][] newString = new String[chunk * 2][];
                System.arraycopy(fString, 0, newString, 0, chunk);
                fString = newString;
                StringPool.StringProducer[][] newProducer = new StringPool.StringProducer[chunk * 2][];
                System.arraycopy(fStringProducer, 0, newProducer, 0, chunk);
                fStringProducer = newProducer;
                int[][] newInt = new int[chunk * 2][];
                System.arraycopy(fOffset, 0, newInt, 0, chunk);
                fOffset = newInt;
                newInt = new int[chunk * 2][];
                System.arraycopy(fLength, 0, newInt, 0, chunk);
                fLength = newInt;
                newInt = new int[chunk * 2][];
                System.arraycopy(fCharsOffset, 0, newInt, 0, chunk);
                fCharsOffset = newInt;
            } else {
                String[] newString = new String[index * 2];
                System.arraycopy(fString[chunk], 0, newString, 0, index);
                fString[chunk] = newString;
                StringPool.StringProducer[] newProducer = new StringPool.StringProducer[index * 2];
                System.arraycopy(fStringProducer[chunk], 0, newProducer, 0, index);
                fStringProducer[chunk] = newProducer;
                int[] newInt = new int[index * 2];
                System.arraycopy(fOffset[chunk], 0, newInt, 0, index);
                fOffset[chunk] = newInt;
                newInt = new int[index * 2];
                System.arraycopy(fLength[chunk], 0, newInt, 0, index);
                fLength[chunk] = newInt;
                newInt = new int[index * 2];
                System.arraycopy(fCharsOffset[chunk], 0, newInt, 0, index);
                fCharsOffset[chunk] = newInt;
                return true;
            }
        } catch (NullPointerException ex) {
        }
        fString[chunk] = new String[INITIAL_CHUNK_SIZE];
        fStringProducer[chunk] = new StringPool.StringProducer[INITIAL_CHUNK_SIZE];
        fOffset[chunk] = new int[INITIAL_CHUNK_SIZE];
        fLength[chunk] = new int[INITIAL_CHUNK_SIZE];
        fCharsOffset[chunk] = new int[INITIAL_CHUNK_SIZE];
        return true;
    }
    public int addString(String str) {
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        fString[chunk][index] = str;
        fStringProducer[chunk][index] = null;
        fOffset[chunk][index] = 0;
        fLength[chunk][index] = str.length();
        fCharsOffset[chunk][index] = -1;
        if (DEBUG_ADDITIONS)
            System.err.println(""addString("" + str + "") "" + stringIndex);
        return stringIndex;
    }
    public int addString(StringPool.StringProducer stringProducer, int offset, int length)
    {
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        fString[chunk][index] = null;
        fStringProducer[chunk][index] = stringProducer;
        fOffset[chunk][index] = offset;
        fLength[chunk][index] = length;
        fCharsOffset[chunk][index] = -1;
        if (DEBUG_ADDITIONS)
            System.err.println(""addString("" + stringProducer.toString(offset, length) + "") "" + stringIndex);
        return stringIndex;
    }
    //
    // Symbol interfaces
    //
    public SymbolCache getSymbolCache() {
        return fSymbolCache;
    }
    //private static int fShuffleCount = 0;
    private int fShuffleCount = 0;
    public void resetShuffleCount() {
        fShuffleCount = 0;
    }
    public void updateCacheLine(int symbolIndex, int totalMisses, int length) {
//System.err.println(""found symbol "" + toString(symbolIndex) + "" after "" + totalMisses + "" total misses ("" + (totalMisses/length) + "" misses per character)."");
        if (++fShuffleCount > 200) {
//            if (fShuffleCount == 201) System.out.println(""Stopped shuffling..."");
            return;
        }
//        if ((fShuffleCount % 10) == 0) System.out.println(""Shuffling pass "" + fShuffleCount + "" ..."");
        int chunk = symbolIndex >> CHUNK_SHIFT;
        int index = symbolIndex & CHUNK_MASK;
        int charsOffset = fCharsOffset[chunk][index];
        fSymbolCache.updateCacheLine(charsOffset, totalMisses, length);
    }
    public int createNonMatchingSymbol(int startOffset,
                                       int entry,
                                       int[] entries,
                                       int offset) throws Exception
    {
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        String str = fSymbolCache.createSymbol(stringIndex, startOffset, entry, entries, offset);
        int slen = str.length();
        fString[chunk][index] = str;
        fStringProducer[chunk][index] = null;
        fOffset[chunk][index] = -1;
        fLength[chunk][index] = slen;
        fCharsOffset[chunk][index] = startOffset;

        int hashcode = StringHasher.hashString(str, slen);
        int hc = hashcode % HASHTABLE_SIZE;
        int[] bucket = fSymbolTable[hc];
        hashSymbol(bucket, hashcode, chunk, index);
        if (DEBUG_ADDITIONS)
            System.err.println(""addSymbolNew("" + str + "") "" + stringIndex);
        return stringIndex;
    }
    private void hashSymbol(int[] bucket, int hashcode, int chunk, int index) {
        if (bucket == null) {
            bucket = new int[1 + (INITIAL_BUCKET_SIZE * 3)];
            bucket[0] = 1;
            bucket[1] = hashcode;
            bucket[2] = chunk;
            bucket[3] = index;
            int hc = hashcode % HASHTABLE_SIZE;
            fSymbolTable[hc] = bucket;
        } else {
            int count = bucket[0];
            int offset = 1 + (count * 3);
            if (offset == bucket.length) {
                int newSize = count + INITIAL_BUCKET_SIZE;
                int[] newBucket = new int[1 + (newSize * 3)];
                System.arraycopy(bucket, 0, newBucket, 0, offset);
                bucket = newBucket;
                int hc = hashcode % HASHTABLE_SIZE;
                fSymbolTable[hc] = bucket;
            }
            bucket[offset++] = hashcode;
            bucket[offset++] = chunk;
            bucket[offset++] = index;
            bucket[0] = ++count;
        }
    }
    public int addSymbol(String str) {
        int slen = str.length();
        int hashcode = StringHasher.hashString(str, slen);
        int hc = hashcode % HASHTABLE_SIZE;
        int[] bucket = fSymbolTable[hc];
        if (bucket != null) {
            int j = 1;
            for (int i = 0; i < bucket[0]; i++) {
                if (bucket[j] == hashcode) {
                    int chunk = bucket[j+1];
                    int index = bucket[j+2];
                    if (slen == fLength[chunk][index]) {
                        int symoff = fCharsOffset[chunk][index];
                        boolean match = true;
                        char[] symbolChars = fSymbolCache.getSymbolChars();
                        for (int k = 0; k < slen; k++) {
                            if (symbolChars[symoff++] != str.charAt(k)) {
                                match = false;
                                break;
                            }
                        }
                        if (match) {
                            return (chunk << CHUNK_SHIFT) + index;
                        }
                    }
                }
                j += 3;
            }
        }
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        fString[chunk][index] = str;
        fStringProducer[chunk][index] = null;
        fOffset[chunk][index] = -1;
        fLength[chunk][index] = slen;
        fCharsOffset[chunk][index] = fSymbolCache.addSymbolToCache(str, slen, stringIndex);

        hashSymbol(bucket, hashcode, chunk, index);
        if (DEBUG_ADDITIONS)
            System.err.println(""addSymbolNew("" + str + "") "" + stringIndex);
        return stringIndex;
    }
    public int addSymbol(StringPool.StringProducer stringProducer, int offset, int length, int hashcode) {
        int hc = hashcode % HASHTABLE_SIZE;
        int[] bucket = fSymbolTable[hc];
        if (bucket != null) {
            int j = 1;
            for (int i = 0; i < bucket[0]; i++) {
                if (bucket[j] == hashcode) {
                    int chunk = bucket[j+1];
                    int index = bucket[j+2];
                    char[] symbolChars = fSymbolCache.getSymbolChars();
                    if (stringProducer.equalsString(offset, length, symbolChars, fCharsOffset[chunk][index], fLength[chunk][index])) {
                        stringProducer.releaseString(offset, length);
                        return (chunk << CHUNK_SHIFT) + index;
                    }
                }
                j += 3;
            }
        }
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        String str = stringProducer.toString(offset, length);
        stringProducer.releaseString(offset, length);
        int slen = str.length();
        fString[chunk][index] = str;
        fStringProducer[chunk][index] = null;
        fOffset[chunk][index] = -1;
        fLength[chunk][index] = slen;
        fCharsOffset[chunk][index] = fSymbolCache.addSymbolToCache(str, slen, stringIndex);

        hashSymbol(bucket, hashcode, chunk, index);
        if (DEBUG_ADDITIONS)
            System.err.println(""addSymbol("" + str + "") "" + stringIndex);
        return stringIndex;
    }
    public int lookupSymbol(StringPool.StringProducer stringProducer, int offset, int length, int hashcode) {
        int hc = hashcode % HASHTABLE_SIZE;
        int[] bucket = fSymbolTable[hc];
        if (bucket != null) {
            int j = 1;
            for (int i = 0; i < bucket[0]; i++) {
                if (bucket[j] == hashcode) {
                    int chunk = bucket[j+1];
                    int index = bucket[j+2];
                    char[] symbolChars = fSymbolCache.getSymbolChars();
                    if (stringProducer.equalsString(offset, length, symbolChars, fCharsOffset[chunk][index], fLength[chunk][index])) {
                        return (chunk << CHUNK_SHIFT) + index;
                    }
                }
                j += 3;
            }
        }
        return -1;
    }
    public int addNewSymbol(String str, int hashcode) {
        int hc = hashcode % HASHTABLE_SIZE;
        int[] bucket = fSymbolTable[hc];
        int chunk;
        int index;
        int stringIndex;
        if (fStringFreeList != -1) {
            stringIndex = fStringFreeList;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            fStringFreeList = fOffset[chunk][index];
        } else {
            stringIndex = fStringCount++;
            chunk = stringIndex >> CHUNK_SHIFT;
            index = stringIndex & CHUNK_MASK;
            ensureCapacity(chunk, index);
        }
        int slen = str.length();
        fString[chunk][index] = str;
        fStringProducer[chunk][index] = null;
        fOffset[chunk][index] = -1;
        fLength[chunk][index] = slen;
        fCharsOffset[chunk][index] = fSymbolCache.addSymbolToCache(str, slen, stringIndex);

        hashSymbol(bucket, hashcode, chunk, index);
        if (DEBUG_ADDITIONS)
            System.err.println(""addSymbolNew("" + str + "") "" + stringIndex);
        return stringIndex;
    }
    public int addSymbol(int stringIndex) {
        if (stringIndex < 0 || stringIndex >= fStringCount)
            return -1;
        int chunk = stringIndex >> CHUNK_SHIFT;
        int index = stringIndex & CHUNK_MASK;
        if (fOffset[chunk][index] == -1)
            return stringIndex;
        String s = fString[chunk][index];
        if (s == null) {
            s = fStringProducer[chunk][index].toString(fOffset[chunk][index], fLength[chunk][index]);
            fStringProducer[chunk][index].releaseString(fOffset[chunk][index], fLength[chunk][index]);
            fString[chunk][index] = s;
            fStringProducer[chunk][index] = null;
        }
        return addSymbol(s);
    }
    //
    // Get characters for defined symbols
    //
    public class CharArrayRange {
        public char[] chars;
        public int offset;
        public int length;
    }
    public CharArrayRange createCharArrayRange() {
        return new CharArrayRange();
    }
    public void getCharArrayRange(int symbolIndex, CharArrayRange r) {
        if (symbolIndex < 0 || symbolIndex >= fStringCount) {
            r.chars = null;
            r.offset = -1;
            r.length = -1;
            return;
        }
        int chunk = symbolIndex >> CHUNK_SHIFT;
        int index = symbolIndex & CHUNK_MASK;
        r.chars = fSymbolCache.getSymbolChars();
        r.offset = fCharsOffset[chunk][index];
        r.length = fLength[chunk][index];
    }
    public boolean equalNames(int stringIndex1, int stringIndex2) {
        if (stringIndex1 == stringIndex2)
            return true;
        return false;
    }
    //
    // String list support
    //
    private boolean ensureListCapacity(int chunk, int index) {
        try {
            return fStringList[chunk][index] == 0;
        } catch (ArrayIndexOutOfBoundsException ex) {
            if (index == 0) {
                int[][] newInt = new int[chunk * 2][];
                System.arraycopy(fStringList, 0, newInt, 0, chunk);
                fStringList = newInt;
            } else {
                int[] newInt = new int[index * 2];
                System.arraycopy(fStringList[chunk], 0, newInt, 0, index);
                fStringList[chunk] = newInt;
                return true;
            }
        } catch (NullPointerException ex) {
        }
        fStringList[chunk] = new int[INITIAL_CHUNK_SIZE];
        return true;
    }
    public int startStringList() {
        fActiveStringList = fStringListCount;
        return fStringListCount;
    }
    public boolean addStringToList(int stringListIndex, int stringIndex) {
        if (stringIndex == -1 || stringListIndex != fActiveStringList)
            return false;
        int chunk = fStringListCount >> CHUNK_SHIFT;
        int index = fStringListCount & CHUNK_MASK;
        ensureListCapacity(chunk, index);
        fStringList[chunk][index] = stringIndex;
        fStringListCount++;
        return true;
    }
    public void finishStringList(int stringListIndex) {
        if (stringListIndex != fActiveStringList)
            return;
        int chunk = fStringListCount >> CHUNK_SHIFT;
        int index = fStringListCount & CHUNK_MASK;
        ensureListCapacity(chunk, index);
        fStringList[chunk][index] = -1;
        fActiveStringList = -1;
        fStringListCount++;
    }
    public int stringListLength(int stringListIndex) {
        int chunk = stringListIndex >> CHUNK_SHIFT;
        int index = stringListIndex & CHUNK_MASK;
        int count = 0;
        while (true) {
            if (fStringList[chunk][index] == -1)
                return count;
            count++;
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
    }
    public boolean stringInList(int stringListIndex, int stringIndex) {
        int chunk = stringListIndex >> CHUNK_SHIFT;
        int index = stringListIndex & CHUNK_MASK;
        while (true) {
            if (fStringList[chunk][index] == stringIndex)
                return true;
            if (fStringList[chunk][index] == -1)
                return false;
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
    }
    public String stringListAsString(int stringListIndex) {
        int chunk = stringListIndex >> CHUNK_SHIFT;
        int index = stringListIndex & CHUNK_MASK;
        StringBuffer sb = new StringBuffer();
        char sep = '(';
        while (fStringList[chunk][index] != -1) {
            sb.append(sep);
            sep = '|';
            sb.append(toString(fStringList[chunk][index]));
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
        if (sep == '|')
            sb.append(')');
        return sb.toString();
    }
    //
    //
    //
    private void releaseStringInternal(int chunk, int index) {
        fString[chunk][index] = null;
        fStringProducer[chunk][index] = null;
        fLength[chunk][index] = 0;
        //
        // REVISIT - not synchronized.
        //
        fOffset[chunk][index] = fStringFreeList;
        int offset = (chunk << CHUNK_SHIFT) + index;
        fStringFreeList = offset;
    }
    //
    //
    //
    public void releaseString(int stringIndex) {
        if (stringIndex < 0 || stringIndex >= fStringCount)
            return;
        int chunk = stringIndex >> CHUNK_SHIFT;
        int index = stringIndex & CHUNK_MASK;
        if (fOffset[chunk][index] != -1) {
            if (fStringProducer[chunk][index] != null)
                fStringProducer[chunk][index].releaseString(fOffset[chunk][index], fLength[chunk][index]);
            releaseStringInternal(chunk, index);
        }
    }
    //
    // Get String value.  Cache the result.
    //
    public String toString(int stringIndex) {
        if (stringIndex >= 0 && stringIndex < fString[0].length) {
            String result = fString[0][stringIndex];
            if (result != null) {
                return result;
            }
        }

        if (stringIndex < 0 || stringIndex >= fStringCount)
            return null;
        int chunk = stringIndex >> CHUNK_SHIFT;
        int index = stringIndex & CHUNK_MASK;
        String s = fString[chunk][index];
        if (s != null)
            return s;
        s = fStringProducer[chunk][index].toString(fOffset[chunk][index], fLength[chunk][index]);
        fStringProducer[chunk][index].releaseString(fOffset[chunk][index], fLength[chunk][index]);
        fString[chunk][index] = s;
        fStringProducer[chunk][index] = null;
        return s;
    }
    //
    //
    //
    public String orphanString(int stringIndex) {
        if (stringIndex < 0 || stringIndex >= fStringCount)
            return null;
        int chunk = stringIndex >> CHUNK_SHIFT;
        int index = stringIndex & CHUNK_MASK;
        String s = fString[chunk][index];
        if (s == null) {
            s = fStringProducer[chunk][index].toString(fOffset[chunk][index], fLength[chunk][index]);
            fStringProducer[chunk][index].releaseString(fOffset[chunk][index], fLength[chunk][index]);
            releaseStringInternal(chunk, index);
        } else if (fOffset[chunk][index] != -1) {
            releaseStringInternal(chunk, index);
        }
        return s;
    }
}
"
org/apache/xerces/readers/XMLEntityReaderFactory.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.StringPool;
import org.xml.sax.InputSource;
import java.io.InputStream;
import java.io.Reader;

/**
 * This is the factory interface used to create readers.
 *
 * @version
 */
public interface XMLEntityReaderFactory {
    /**
     * Adds a recognizer.
     *
     * @param recognizer The XML recognizer to add.
     */
    public void addRecognizer(XMLDeclRecognizer recognizer);

    /**
     * Set char data processing preference.
     */
    public void setSendCharDataAsCharArray(boolean flag);

    /**
     *
     */
    public void setAllowJavaEncodingName(boolean flag);

    /**
     *
     */
    public boolean getAllowJavaEncodingName();

    /**
     * Create an entity reader for the source.
     *
     * @param source The input source.
     * @param systemId The system identifier for the input.
     * @param xmlDecl <code>true</code> if an XMLDecl may be present; otherwise
     *                <code>false</code> if a TextDecl may be present.
     * @param stringPool The string pool.
     * @return The reader that will process the source.
     * @exception java.lang.Exception
     */
    public XMLEntityHandler.EntityReader createReader(XMLEntityHandler entityHandler,
                                                      XMLErrorReporter errorReporter,
                                                      InputSource source,
                                                      String systemId,
                                                      boolean xmlDecl,
                                                      StringPool stringPool) throws Exception;

    /**
     * Create an entity reader for a character stream.
     *
     * @param enityHandler The entity handler.
     * @param errorReporter The error reporter.
     * @param sendCharDataAsCharArray true if char data should be reported using
     *                                char arrays instead of string handles.
     * @param reader The character stream.
     * @param stringPool The string pool.
     * @return The reader that will process the character data.
     * @exception java.lang.Exception
     */
    public XMLEntityHandler.EntityReader createCharReader(XMLEntityHandler entityHandler,
                                                          XMLErrorReporter errorReporter,
                                                          boolean sendCharDataAsCharArray,
                                                          Reader reader,
                                                          StringPool stringPool) throws Exception;

    /**
     * Create an entity reader for a byte stream encoded in UTF-8.
     *
     * @param enityHandler The entity handler.
     * @param errorReporter The error reporter.
     * @param sendCharDataAsCharArray true if char data should be reported using
     *                                char arrays instead of string handles.
     * @param data The byte stream.
     * @param stringPool The string pool.
     * @return The reader that will process the UTF-8 data.
     * @exception java.lang.Exception
     */
    public XMLEntityHandler.EntityReader createUTF8Reader(XMLEntityHandler entityHandler,
                                                          XMLErrorReporter errorReporter,
                                                          boolean sendCharDataAsCharArray,
                                                          InputStream data,
                                                          StringPool stringPool) throws Exception;

    /**
     * Create an entity reader for data from a String.
     *
     * @param entityHandler The current entity handler.
     * @param errorReporter The current error reporter.
     * @param sendCharDataAsCharArray true if char data should be reported using
     *                                char arrays instead of string handles.
     * @param lineNumber The line number to return as our position.
     * @param columnNumber The column number to return as our position.
     * @param stringHandle The StringPool handle for the data to process.
     * @param stringPool The string pool.
     * @param addEnclosingSpaces If true, treat the data to process as if
     *                           there were a leading and trailing space
     *                           character enclosing the string data.
     * @return The reader that will process the string data.
     * @exception java.lang.Exception
     */
    public XMLEntityHandler.EntityReader createStringReader(XMLEntityHandler entityHandler,
                                                            XMLErrorReporter errorReporter,
                                                            boolean sendCharDataAsCharArray,
                                                            int lineNumber,
                                                            int columnNumber,
                                                            int stringHandle,
                                                            StringPool stringPool,
                                                            boolean addEnclosingSpaces) throws Exception;
}
"
org/apache/xerces/readers/XMLCatalogHandler.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * Interface for implementing basic catalog support in the parser.
 * To implement and use a Catalog, implement this interface and
 * install your catalog instance as the EntityResolver in the
 * parser's entity handler. For example:
 * <pre>
 *     XMLParser parser = new AnyParser();
 *     <font color=""blue"">parser.addCatalogHandler(new MyCatalog());</font>
 * </pre>
 * <p>
 * This default catalog implementation does not provide a method
 * for loading multiple catalogs from various input sources.
 * Instead, it is a convenient base class for other catalog
 * implementations.
 * <p>
 * To create a catalog implementation, simply extend this class
 * and implement the <tt>loadCatalog</tt> method. Public and system
 * identifier mappings can be stored and accessed using the 
 * convenient public methods on this class.
 *
 * @author  Andy Clark, IBM
 * @version
 *
 * @see org.xml.sax.EntityResolver
 */
public abstract class XMLCatalogHandler implements EntityResolver {

    /**
     * Loads the catalog stream specified by the given input source and
     * appends the contents to the catalog.
     *
     * @param source The catalog source.
     *
     * @exception java.lang.Exception Throws an exception if an error
     *                                occurs while loading the catalog source.
     */
    public abstract void loadCatalog(InputSource source) throws Exception;


    //
    // Data
    //

    /** Public identifier mappings. */
    private Hashtable publicMap = new Hashtable();

    /** System identifier mappings (aliases). */
    private Hashtable systemMap = new Hashtable();

    //
    // Public methods
    //

    /**
     * Adds a public to system identifier mapping.
     *
     * @param publicId The public identifier, or ""key"".
     * @param systemId The system identifier, or ""value"".
     */
    public void addPublicMapping(String publicId, String systemId) {
        publicMap.put(publicId, systemId);
    }

    /**
     * Removes a public identifier mapping.
     *
     * @param publicId The public identifier to remove.
     */
    public void removePublicMapping(System publicId) {
        publicMap.remove(publicId);
    }

    /** Returns an enumeration of public identifier mapping keys. */
    public Enumeration getPublicMappingKeys() {
        return publicMap.keys();
    }

    /**
     * Returns a public identifier mapping.
     *
     * @param publicId The public identifier, or ""key"".
     *
     * @return Returns the system identifier value or null if there
     *         is no mapping defined.
     */
    public String getPublicMapping(String publicId) {
        return (String)publicMap.get(publicId);
    }

    /**
     * Adds a system identifier alias.
     *
     * @param publicId The system identifier ""key"".
     * @param systemId The system identifier ""value"".
     */
    public void addSystemMapping(String systemId1, String systemId2) {
        systemMap.put(systemId1, systemId2);
    }

    /**
     * Removes a system identifier alias.
     *
     * @param systemId The system identifier to remove.
     */
    public void removeSystemMapping(String systemId) {
        systemMap.remove(systemId);
    }

    /** Returns an enumeration of system identifier mapping keys. */
    public Enumeration getSystemMappingKeys() {
        return systemMap.keys();
    }

    /**
     * Returns a system identifier alias.
     *
     * @param systemId The system identifier ""key"".
     *
     * @return Returns the system identifier alias value or null if there
     *         is no alias defined.
     */
    public String getSystemMapping(String systemId) {
        return (String)systemMap.get(systemId);
    }

    /**
     * Resolves external entities.
     *
     * @param publicId The public identifier used for entity resolution.
     * @param systemId If the publicId is not null, this systemId is
     *                 to be considered the default system identifier;
     *                 else a system identifier alias mapping is
     *                 requested.
     *
     * @return Returns the input source of the resolved entity or null
     *         if no resolution is possible.
     *
     * @exception org.xml.sax.SAXException Exception thrown on SAX error.
     * @exception java.io.IOException Exception thrown on i/o error. 
     */
    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException 
    {
        
        // public id -> system id
        if (publicId != null) {
            String value = getPublicMapping(publicId);
            if (value != null) {
                return new InputSource(value);
            }
        }

        // system id(1) -> system id(2)
        if (systemId != null) {
            String value = getSystemMapping(systemId);
            if (value == null) {
                value = systemId;
            }

            return new InputSource(value);
        }

        return null;

    }
}
"
org/apache/xerces/parsers/SAXParser.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.parsers;

import org.apache.xerces.framework.XMLAttrList;
import org.apache.xerces.framework.XMLContentSpec;
import org.apache.xerces.framework.XMLDocumentHandler;
import org.apache.xerces.framework.XMLParser;
import org.apache.xerces.readers.XMLEntityHandler;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;

import org.xml.sax.Attributes;
import org.xml.sax.AttributeList;
import org.xml.sax.ContentHandler;
import org.xml.sax.DocumentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.Parser;
import org.xml.sax.XMLReader;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;

// REVISIT: [SAX2beta] ContentHandler#skippedEntity(String)

/**
 * SAXParser provides a parser which implements the SAX1 and SAX2
 * parser APIs.
 *
 * @version $Id$
 */
public class SAXParser
    extends XMLParser
    implements Parser, XMLReader, XMLDocumentHandler, XMLDocumentHandler.DTDHandler {

    //
    // Constants
    //

    // private

    /** Features recognized by this parser. */
    private static final String RECOGNIZED_FEATURES[] = {
        // SAX2 core
        /*""http://xml.org/sax/features/normalize-text"",*/
        /*""http://xml.org/sax/features/use-locator"",*/
        ""http://xml.org/sax/features/namespace-prefixes"",
        ""http://xml.org/sax/features/string-interning"",
        // Xerces
    };

    /** Properties recognized by this parser. */
    private static final String RECOGNIZED_PROPERTIES[] = {
        // SAX2 core
        ""http://xml.org/sax/properties/lexical-handler"",
        ""http://xml.org/sax/properties/declaration-handler"",
        ""http://xml.org/sax/properties/dom-node"",
        // Xerces
    };

    // debugging

    /** Set to true and recompile to debug callbacks. */
    private static final boolean DEBUG_CALLBACKS = false;

    //
    // Data
    //

    // parser handlers

    /** Document handler. */
    private DocumentHandler fDocumentHandler;

    // parser/xmlreader handlers

    /** DTD handler. */
    private org.xml.sax.DTDHandler fDTDHandler;

    // xmlreader handlers

    /** Content handler. */
    private ContentHandler fContentHandler;

    /** Decl handler. */
    private DeclHandler fDeclHandler;

    /** Lexical handler. */
    private LexicalHandler fLexicalHandler;
    
    private boolean fNamespacePrefixes = false;

    // temp

    private transient AttributesImpl fAttributes = new AttributesImpl();

    //
    // Constructors
    //

    /** Default constructor. */
    public SAXParser() {
        try {
            //JR-defect 48 fix - turn on Namespaces
            setNamespaces(true);
        }
        catch (Exception e) {
            // ignore
        }
        initHandlers(true, this, this);
    }

    //
    // Public methods
    //

    // features and properties

    /**
     * Returns a list of features that this parser recognizes.
     * This method will never return null; if no features are
     * recognized, this method will return a zero length array.
     *
     * @see #isFeatureRecognized
     * @see #setFeature
     * @see #getFeature
     */
    public String[] getFeaturesRecognized() {

        // get features that super/this recognizes
        String superRecognized[] = super.getFeaturesRecognized();
        String thisRecognized[] = RECOGNIZED_FEATURES;

        // is one or the other the empty set?
        int thisLength = thisRecognized.length;
        if (thisLength == 0) {
            return superRecognized;
        }
        int superLength = superRecognized.length;
        if (superLength == 0) {
            return thisRecognized;
        }

        // combine the two lists and return
        String recognized[] = new String[superLength + thisLength];
        System.arraycopy(superRecognized, 0, recognized, 0, superLength);
        System.arraycopy(thisRecognized, 0, recognized, superLength, thisLength);
        return recognized;

    } // getFeaturesRecognized():String[]

    /**
     * Returns a list of properties that this parser recognizes.
     * This method will never return null; if no properties are
     * recognized, this method will return a zero length array.
     *
     * @see #isPropertyRecognized
     * @see #setProperty
     * @see #getProperty
     */
    public String[] getPropertiesRecognized() {

        // get properties that super/this recognizes
        String superRecognized[] = super.getPropertiesRecognized();
        String thisRecognized[] = RECOGNIZED_PROPERTIES;

        // is one or the other the empty set?
        int thisLength = thisRecognized.length;
        if (thisLength == 0) {
            return superRecognized;
        }
        int superLength = superRecognized.length;
        if (superLength == 0) {
            return thisRecognized;
        }

        // combine the two lists and return
        String recognized[] = new String[superLength + thisLength];
        System.arraycopy(superRecognized, 0, recognized, 0, superLength);
        System.arraycopy(thisRecognized, 0, recognized, superLength, thisLength);
        return recognized;

    }

    //
    // Protected methods
    //

    // SAX2 core features

    /**
     * <b>Note: Currently, the parser does not support this feature.</b>
     * Setting this feature to true will throw a SAXNotSupportedException.
     * <p>
     * Ensures that all consecutive text is returned in a single callback
     * to the DocumentHandler.characters or DocumentHandler.ignorableWhitespace
     * methods.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/normalize-text
     * <pre>
     *
     * @param normalize True to normalize; false not to normalize.
     *
     * @see #getNormalizeText
     * @see #setFeature
     */
    /*
    protected void setNormalizeText(boolean normalize) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (normalize) {
            throw new SAXNotSupportedException(""http://xml.org/sax/features/normalize-text"");
        }
    }
    */

    /**
     * <b>Note: This feature is always false.</b>
     * <p>
     * Returns true if the parser normalizes all consecutive text into
     * a single callback to the DocumentHandler.characters or
     * DocumentHandler.ignorableWhitespace methods.
     *
     * @see #setNormalizeText
     */
    /*
    protected boolean getNormalizeText() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return false;
    }
    */

    /**
     * <b>Note: Currently, this parser always sets the locator.</b>
     * Setting this feature to false will throw a SAXNotSupportedException.
     * <p>
     * Provide a Locator using the DocumentHandler.setDocumentLocator
     * callback (true), or explicitly do not provide one (false).
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/use-locator
     * </pre>
     *
     * @see #getUseLocator
     * @see #setFeature
     */
    /*
    protected void setUseLocator(boolean use) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (!use) {
            throw new SAXNotSupportedException(""http://xml.org/sax/features/use-locator"");
        }
    }
    */

    /**
     * <b>Note: This feature is always true.</b>
     * <p>
     * Returns true if the locator is always set.
     *
     * @see #setUseLocator
     */
    /*
    protected boolean getUseLocator() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return true;
    }
    */

    // SAX2 core properties

    /**
     * Set the DTD declaration event handler.
     * <p>
     * This method is the equivalent to the property:
     * <pre>
     * http://xml.org/sax/properties/declaration-handler
     * </pre>
     *
     * @param handler The new handler.
     *
     * @see #getDeclHandler
     * @see #setProperty
     */
    protected void setDeclHandler(DeclHandler handler) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(
                ""PAR011 Feature: http://xml.org/sax/properties/declaration-handler""
                +"" is not supported during parse.""
                +""\nhttp://xml.org/sax/properties/declaration-handler"");
        }
        fDeclHandler = handler;
    }

    /**
     * Returns the DTD declaration event handler.
     *
     * @see #setDeclHandler
     */
    protected DeclHandler getDeclHandler() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fDeclHandler;
    }

    /**
     * Set the lexical event handler.
     * <p>
     * This method is the equivalent to the property:
     * <pre>
     * http://xml.org/sax/properties/lexical-handler
     * </pre>
     *
     * @param handler lexical event handler
     *
     * @see #getLexicalHandler
     * @see #setProperty
     */
    protected void setLexicalHandler(LexicalHandler handler)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(
            ""PAR011 Feature: http://xml.org/sax/properties/lexical-handler""
            +"" is not supported during parse.""
            +""\nhttp://xml.org/sax/properties/lexical-handler"");
        }
        fLexicalHandler = handler;
    }

    /**
     * Returns the lexical handler.
     *
     * @see #setLexicalHandler
     */
    protected LexicalHandler getLexicalHandler() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fLexicalHandler;
    }

    //
    // Parser methods
    //

    /** Sets the document handler. */
    public void setDocumentHandler(DocumentHandler handler) {
        fDocumentHandler = handler;
    }

    //
    // Parser/XMLReader methods
    //

    /**
     * Allow an application to register a DTD event handler.
     *
     * <p>If the application does not register a DTD handler, all DTD
     * events reported by the SAX parser will be silently ignored.</p>
     *
     * <p>Applications may register a new or different handler in the
     * middle of a parse, and the SAX parser must begin using the new
     * handler immediately.</p>
     *
     * @param handler The DTD handler.
     * @exception java.lang.NullPointerException If the handler 
     *            argument is null.
     * @see #getDTDHandler
     */
    public void setDTDHandler(org.xml.sax.DTDHandler handler) {
        fDTDHandler = handler;
    }

    /**
     * Return the current DTD handler.
     *
     * @return The current DTD handler, or null if none
     *         has been registered.
     * @see #setDTDHandler
     */
    public org.xml.sax.DTDHandler getDTDHandler() {
        return fDTDHandler;
    }
    
    /**
     * Sets how the parser reports raw prefixed names,
     * and whether xmlns attributes are reported.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/namespaces-prefixes
     * <pre>
     *
     * @param process True to process namespaces; false to not process.
     *
     * @see #getNamespaces
     * @see #setFeature
     */
    protected void setNamespacePrefixes(boolean process) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n""+
                                               ""http://xml.org/sax/features/namespace-prefixes"");
        }
        fNamespacePrefixes = process;
    }

    /**
     * Returns the http://xml.org/features/namespace-prefixes
     * value.
     *
     * @see #setNamespacePrefixes
     */
    protected boolean getNamespacePrefixes() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fNamespacePrefixes;
    }
    

    //
    // XMLReader methods
    //

    /**
     * Set the state of any feature in a SAX2 parser.  The parser
     * might not recognize the feature, and if it does recognize
     * it, it might not be able to fulfill the request.
     *
     * @param featureId The unique identifier (URI) of the feature.
     * @param state The requested state of the feature (true or false).
     *
     * @exception SAXNotRecognizedException If the
     *            requested feature is not known.
     * @exception SAXNotSupportedException If the
     *            requested feature is known, but the requested
     *            state is not supported.
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            String feature = featureId.substring(SAX2_FEATURES_PREFIX.length());

            /*
            //
            // http://xml.org/sax/features/normalize-text
            //   Ensure that all consecutive text is returned in a single callback to
            //   DocumentHandler.characters or DocumentHandler.ignorableWhitespace
            //   (true) or explicitly do not require it (false).
            //
            if (feature.equals(""normalize-text"")) {
                setNormalizeText(state);
                return;
            }
            */
            /*
            //
            // http://xml.org/sax/features/use-locator
            //   Provide a Locator using the DocumentHandler.setDocumentLocator
            //   callback (true), or explicitly do not provide one (false).
            //
            if (feature.equals(""use-locator"")) {
                setUseLocator(state);
                return;
            }
            */

            // http://xml.org/sax/features/namespace-prefixes
            //   controls the reporting of raw prefixed names and Namespace 
            //   declarations (xmlns* attributes): when this feature is false 
            //   (the default), raw prefixed names may optionally be reported, 
            //   and xmlns* attributes must not be reported.
            //
            if (feature.equals(""namespace-prefixes"")) {
                setNamespacePrefixes(state);
                return;
            }
            // http://xml.org/sax/features/string-interning
            //   controls the use of java.lang.String#intern() for strings
            //   passed to SAX handlers.
            //
            if (feature.equals(""string-interning"")) {
                if (state) {
                    throw new SAXNotSupportedException(
                        ""PAR018 ""+state+"" state for feature \""""+featureId+""\"" is not supported.\n""+
                        state+'\t'+featureId
                        );
                }
                return;
            }
   
            //
            // Drop through and perform default processing
            //
        }

        //
        // Xerces Features
        //

        /*
        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            String feature = featureId.substring(XERCES_FEATURES_PREFIX.length());
            //
            // Drop through and perform default processing
            //
        }
        */

        //
        // Perform default processing
        //

        super.setFeature(featureId, state);

    } // setFeature(String,boolean)

    /**
     * Query the state of a feature.
     *
     * Query the current state of any feature in a SAX2 parser.  The
     * parser might not recognize the feature.
     *
     * @param featureId The unique identifier (URI) of the feature
     *                  being set.
     * @return The current state of the feature.
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested feature is not known.
     * @exception SAXNotSupportedException If the
     *            requested feature is known but not supported.
     */
    public boolean getFeature(String featureId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            String feature = featureId.substring(SAX2_FEATURES_PREFIX.length());

            /*
            //
            // http://xml.org/sax/features/normalize-text
            //   Ensure that all consecutive text is returned in a single callback to
            //   DocumentHandler.characters or DocumentHandler.ignorableWhitespace
            //   (true) or explicitly do not require it (false).
            //
            if (feature.equals(""normalize-text"")) {
                return getNormalizeText();
            }
            */
            /*
            //
            // http://xml.org/sax/features/use-locator
            //   Provide a Locator using the DocumentHandler.setDocumentLocator
            //   callback (true), or explicitly do not provide one (false).
            //
            if (feature.equals(""use-locator"")) {
                return getUseLocator();
            }
            */

            // http://xml.org/sax/features/namespace-prefixes
            //   controls the reporting of raw prefixed names and Namespace 
            //   declarations (xmlns* attributes): when this feature is false 
            //   (the default), raw prefixed names may optionally be reported, 
            //   and xmlns* attributes must not be reported.
            //
            if (feature.equals(""namespace-prefixes"")) {
                return getNamespacePrefixes();
            }
            // http://xml.org/sax/features/string-interning
            //   controls the use of java.lang.String#intern() for strings
            //   passed to SAX handlers.
            //
            if (feature.equals(""string-interning"")) {
                return false;
            }

            //
            // Drop through and perform default processing
            //
        }

        //
        // Xerces Features
        //

        /*
        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            //
            // Drop through and perform default processing
            //
        }
        */

        //
        // Perform default processing
        //

        return super.getFeature(featureId);

    } // getFeature(String):boolean

    /**
     * Set the value of any property in a SAX2 parser.  The parser
     * might not recognize the property, and if it does recognize
     * it, it might not support the requested value.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     * @param Object The value to which the property is being set.
     *
     * @exception SAXNotRecognizedException If the
     *            requested property is not known.
     * @exception SAXNotSupportedException If the
     *            requested property is known, but the requested
     *            value is not supported.
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 core properties
        //

        if (propertyId.startsWith(SAX2_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(SAX2_PROPERTIES_PREFIX.length());
            //
            // http://xml.org/sax/properties/lexical-handler
            // Value type: org.xml.sax.ext.LexicalHandler
            // Access: read/write, pre-parse only
            //   Set the lexical event handler.
            //
            if (property.equals(""lexical-handler"")) {
                try {
                    setLexicalHandler((LexicalHandler)value);
                }
                catch (ClassCastException e) {
                    throw new SAXNotSupportedException(
                    ""PAR012 For propertyID \""""
                    +propertyId+""\"", the value \""""
                    +value+""\"" cannot be cast to LexicalHandler.""
                    +'\n'+propertyId+'\t'+value+""\tLexicalHandler"");
                }
                return;
            }
            //
            // http://xml.org/sax/properties/declaration-handler
            // Value type: org.xml.sax.ext.DeclHandler
            // Access: read/write, pre-parse only
            //   Set the DTD declaration event handler.
            //
            if (property.equals(""declaration-handler"")) {
                try {
                    setDeclHandler((DeclHandler)value);
                }
                catch (ClassCastException e) {
                    throw new SAXNotSupportedException(
                    ""PAR012 For propertyID \""""
                    +propertyId+""\"", the value \""""
                    +value+""\"" cannot be cast to DeclHandler.""
                    +'\n'+propertyId+'\t'+value+""\tDeclHandler""
                    );
                }
                return;
            }
            //
            // http://xml.org/sax/properties/dom-node
            // Value type: DOM Node
            // Access: read-only
            //   Get the DOM node currently being visited, if the SAX parser is
            //   iterating over a DOM tree.  If the parser recognises and supports
            //   this property but is not currently visiting a DOM node, it should
            //   return null (this is a good way to check for availability before the
            //   parse begins).
            //
            if (property.equals(""dom-node"")) {
                throw new SAXNotSupportedException(
                    ""PAR013 Property \""""+propertyId+""\"" is read only.""
                    +'\n'+propertyId
                    ); // read-only property
            }
            //
            // Drop through and perform default processing
            //
        }

        //
        // Xerces Properties
        //

        /*
        else if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            //
            // Drop through and perform default processing
            //
        }
        */

        //
        // Perform default processing
        //

        super.setProperty(propertyId, value);

    } // setProperty(String,Object)

    /**
     * Query the value of a property.
     *
     * Return the current value of a property in a SAX2 parser.
     * The parser might not recognize the property.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     * @return The current value of the property.
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested property is not known.
     * @exception SAXNotSupportedException If the
     *            requested property is known but not supported.
     */
    public Object getProperty(String propertyId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 core properties
        //

        if (propertyId.startsWith(SAX2_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(SAX2_PROPERTIES_PREFIX.length());
            //
            // http://xml.org/sax/properties/lexical-handler
            // Value type: org.xml.sax.ext.LexicalHandler
            // Access: read/write, pre-parse only
            //   Set the lexical event handler.
            //
            if (property.equals(""lexical-handler"")) {
                return getLexicalHandler();
            }
            //
            // http://xml.org/sax/properties/declaration-handler
            // Value type: org.xml.sax.ext.DeclHandler
            // Access: read/write, pre-parse only
            //   Set the DTD declaration event handler.
            //
            if (property.equals(""declaration-handler"")) {
                return getDeclHandler();
            }
            //
            // http://xml.org/sax/properties/dom-node
            // Value type: DOM Node
            // Access: read-only
            //   Get the DOM node currently being visited, if the SAX parser is
            //   iterating over a DOM tree.  If the parser recognises and supports
            //   this property but is not currently visiting a DOM node, it should
            //   return null (this is a good way to check for availability before the
            //   parse begins).
            //
            if (property.equals(""dom-node"")) {
                throw new SAXNotSupportedException(
                ""PAR014 Cannot getProperty(\""""+propertyId
                +""\"". No DOM Tree exists.\n""+propertyId
                ); // we are not iterating a DOM tree
            }
            //
            // Drop through and perform default processing
            //
        }

        //
        // Xerces properties
        //

        /*
        else if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            //
            // Drop through and perform default processing
            //
        }
        */

        //
        // Perform default processing
        //

        return super.getProperty(propertyId);

    } // getProperty(String):Object

    /**
     * Allow an application to register a content event handler.
     *
     * <p>If the application does not register a content handler, all
     * content events reported by the SAX parser will be silently
     * ignored.</p>
     *
     * <p>Applications may register a new or different handler in the
     * middle of a parse, and the SAX parser must begin using the new
     * handler immediately.</p>
     *
     * @param handler The content handler.
     * @exception java.lang.NullPointerException If the handler 
     *            argument is null.
     * @see #getContentHandler
     */
    public void setContentHandler(ContentHandler handler) {
        if (handler == null) {
            throw new NullPointerException();
        }
        fContentHandler = handler;
    }

    /**
     * Return the current content handler.
     *
     * @return The current content handler, or null if none
     *         has been registered.
     * @see #setContentHandler
     */
    public ContentHandler getContentHandler() {
        return fContentHandler;
    }

    //
    // XMLParser methods
    //

    /**
     * This function will be called when a &lt;!DOCTYPE...&gt; declaration is
     * encountered.
     */
    public void startDTD(QName rootElement, int publicId, int systemId) throws Exception {
        if (fLexicalHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(rootElement.rawname);
            String pubid = fStringPool.toString(publicId);
            String sysid = fStringPool.toString(systemId);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""startDTD("" + name + "", "" + pubid + "", "" + sysid + "")"");
            }
            if (fLexicalHandler != null) {
                fLexicalHandler.startDTD(name, pubid, sysid);
            }
        }
    }

    /**
     *  This function will be called at the end of the DTD.
     */
    public void endDTD() throws Exception {
        if (DEBUG_CALLBACKS) {
            System.err.println(""endDTD()"");
        }
        if (fLexicalHandler != null) {
            fLexicalHandler.endDTD();
        }
    }

    /**
     * Report an element type declaration.
     *
     * The content model will consist of the string ""EMPTY"", the
     * string ""ANY"", or a parenthesised group, optionally followed
     * by an occurrence indicator.  The model will be normalized so
     * that all whitespace is removed.
     *
     * @param name The element type name.
     * @param model The content model as a normalized string.
     * @exception SAXException The application may raise an exception.
     */
    public void elementDecl(QName elementDecl, XMLContentSpec contentSpec) throws Exception {

        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(elementDecl.rawname);
            String contentModel = contentSpec.toString();

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""elementDecl("" + name + "", "" + contentModel + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.elementDecl(name, contentModel);
            }
        }

    }

    /**
     * Report an attribute type declaration.
     *
     * Only the effective (first) declaration for an attribute will
     * be reported.  The type will be one of the strings ""CDATA"",
     * ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"", ""ENTITY"",
     * ""ENTITIES"", or ""NOTATION"", or a parenthesized token group with
     * the separator ""|"" and all whitespace removed.
     *
     * @param eName The name of the associated element.
     * @param aName The name of the attribute.
     * @param type A string representing the attribute type.
     * @param valueDefault A string representing the attribute default
     *        (""#IMPLIED"", ""#REQUIRED"", or ""#FIXED"") or null if
     *        none of these applies.
     * @param value A string representing the attribute's default value,
     *        or null if there is none.
     * @exception SAXException The application may raise an exception.
     */
    public void attlistDecl(QName elementDecl, QName attributeDecl,
                            int attType, String enumString,
                            int attDefaultType,
                            int attDefaultValue) throws Exception
    {
        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String eName = fStringPool.toString(elementDecl.rawname);
            String aName = fStringPool.toString(attributeDecl.rawname);
            String aType;
            if (attType == fStringPool.addSymbol(""ENUMERATION""))
                aType = enumString;
            else
                aType = fStringPool.toString(attType);
            String aDefaultType;
            if (attDefaultType == StringPool.EMPTY_STRING)
                aDefaultType = null;
            else
                aDefaultType = fStringPool.toString(attDefaultType);
            String aDefaultValue = fStringPool.toString(attDefaultValue);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""attributeDecl("" +
                                    eName + "", "" +
                                    aName + "", "" +
                                    aType + "", "" +
                                    aDefaultType + "", "" +
                                    aDefaultValue + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.attributeDecl(eName, aName, aType, aDefaultType, aDefaultValue);
            }
        }
    }

    /**
     * Report an internal parameter entity declaration.
     */
    public void internalPEDecl(int entityName, int entityValue) throws Exception {

        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = ""%"" + fStringPool.toString(entityName);
            String value = fStringPool.toString(entityValue);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""internalEntityDecl("" + name + "", "" + value + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.internalEntityDecl(name, value);
            }
        }

    }

    /**
     * Report a parsed external parameter entity declaration.
     */
    public void externalPEDecl(int entityName, int publicId, int systemId) throws Exception {

        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = ""%"" + fStringPool.toString(entityName);
            String pubid = fStringPool.toString(publicId);
            String sysid = fStringPool.toString(systemId);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""externalEntityDecl("" + name + "", "" + pubid + "", "" + sysid + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.externalEntityDecl(name, pubid, sysid);
            }
        }

    }

    /**
     * Report an internal general entity declaration.
     */
    public void internalEntityDecl(int entityName, int entityValue) throws Exception {

        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(entityName);
            String value = fStringPool.toString(entityValue);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""internalEntityDecl("" + name + "", "" + value + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.internalEntityDecl(name, value);
            }
        }

    }

    /**
     * Report a parsed external general entity declaration.
     */
    public void externalEntityDecl(int entityName, int publicId, int systemId) throws Exception {

        if (fDeclHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(entityName);
            String pubid = fStringPool.toString(publicId);
            String sysid = fStringPool.toString(systemId);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""externalEntityDecl("" + name + "", "" + pubid + "", "" + sysid + "")"");
            }
            if (fDeclHandler != null) {
                fDeclHandler.externalEntityDecl(name, pubid, sysid);
            }
        }

    }

    /**
     * Receive notification of an unparsed entity declaration event.
     */
    public void unparsedEntityDecl(int entityName, int publicId, int systemId, int notationName) throws Exception {

        if (fDTDHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(entityName);
            String pubid = fStringPool.toString(publicId);
            String sysid = fStringPool.toString(systemId);
            String notation = fStringPool.toString(notationName);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""unparsedEntityDecl("" + name + "", "" + pubid + "", "" + sysid + "", "" + notation + "")"");
            }
            if (fDTDHandler != null) {
                fDTDHandler.unparsedEntityDecl(name, pubid, sysid, notation);
            }
        }

    }

    /**
     * Receive notification of a notation declaration event.
     */
    public void notationDecl(int notationName, int publicId, int systemId) throws Exception {

        if (fDTDHandler != null || DEBUG_CALLBACKS) {

            // strings
            String name = fStringPool.toString(notationName);
            String pubid = fStringPool.toString(publicId);
            String sysid = fStringPool.toString(systemId);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""notationDecl("" + name + "", "" + pubid + "", "" + sysid + "")"");
            }
            if (fDTDHandler != null) {
                fDTDHandler.notationDecl(name, pubid, sysid);
            }
        }

    }

    /** Start document. */
    public void startDocument() throws Exception {

        // perform callbacks
        if (DEBUG_CALLBACKS) {
            System.err.println(""setDocumentLocator(<locator>)"");
            System.err.println(""startDocument()"");
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.setDocumentLocator(getLocator());
            fDocumentHandler.startDocument();
        }
        if (fContentHandler != null) {
            fContentHandler.setDocumentLocator(getLocator());
            fContentHandler.startDocument();
        }

    } // startDocument()

    /** End document. */
    public void endDocument() throws Exception {

        // perform callback
        if (DEBUG_CALLBACKS) {
            System.err.println(""endDocument()"");
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.endDocument();
        }
        if (fContentHandler != null) {
            fContentHandler.endDocument();
        }

    } // endDocument()

    /** XML declaration. */
    public void xmlDecl(int versionIndex, int encodingIndex, int standaloneIndex) throws Exception {

        // perform callbacks
        if (DEBUG_CALLBACKS) {
            String notes = """";
            if (versionIndex != -1)
                notes += "" version='"" + fStringPool.toString(versionIndex) + ""'"";
            if (encodingIndex != -1)
                notes += "" encoding='"" + fStringPool.toString(encodingIndex) + ""'"";
            if (standaloneIndex != -1)
                notes += "" standalone='"" + fStringPool.toString(standaloneIndex) + ""'"";
            System.err.println(""xmlDecl(<?xml"" + notes + ""?>)"");
        }

        // release strings
        fStringPool.releaseString(versionIndex);
        fStringPool.releaseString(encodingIndex);
        fStringPool.releaseString(standaloneIndex);

    }

    /** Text declaration. */
    public void textDecl(int versionIndex, int encodingIndex) throws Exception {

        // perform callbacks
        if (DEBUG_CALLBACKS) {
            String notes = """";
            if (versionIndex != -1)
                notes += "" version='"" + fStringPool.toString(versionIndex) + ""'"";
            if (encodingIndex != -1)
                notes += "" encoding='"" + fStringPool.toString(encodingIndex) + ""'"";
            System.err.println(""textDecl(<?xml"" + notes + ""?>)"");
        }

        // release strings
        fStringPool.releaseString(versionIndex);
        fStringPool.releaseString(encodingIndex);
    }

    /**
     * Report the start of the scope of a namespace declaration.
     */
    public void startNamespaceDeclScope(int prefix, int uri) throws Exception {

        if (fContentHandler != null || DEBUG_CALLBACKS) {

            // strings
            String p = fStringPool.toString(prefix);
            String ns = fStringPool.toString(uri);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""startNamespaceDeclScope("" + p + "", "" + ns + "")"");
            }
            if (fContentHandler != null) {
                fContentHandler.startPrefixMapping(p, ns);
            }
        }

    }

    /**
     * Report the end of the scope of a namespace declaration.
     */
    public void endNamespaceDeclScope(int prefix) throws Exception {

        if (fContentHandler != null || DEBUG_CALLBACKS) {

            // strings
            String p = fStringPool.toString(prefix);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""endNamespaceDeclScope("" + p + "")"");
            }
            if (fContentHandler != null) {
                fContentHandler.endPrefixMapping(p);
            }
        }

    }
    
    /** New callback from DOM Level 2. There is no corresponding SAX callout for this yet. */
    public void internalSubset(int internalSubset) {
    }

    /** Start element */
    public void startElement(QName element, 
                             XMLAttrList attrList, int attrListIndex)
        throws Exception {

        // parameters
        String name = fStringPool.toString(element.rawname);
        AttributeList attrs = attrList.getAttributeList(attrListIndex);

        // perform callback
        if (DEBUG_CALLBACKS) {
            String atts = attrs.getLength() > 0 ? """" : "" "";
            for (int i = 0; i < attrs.getLength(); i++) {
                atts += "" "" + attrs.getName(i) + ""='"" + attrs.getValue(i) + ""'"";
            }
            System.err.println(""startElement("" + name + "","" + atts + "")"");
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.startElement(name, attrs);
        }
        if (fContentHandler != null) {
            boolean namespaces = getNamespaces();
            int uriIndex = element.uri;
            String uri = uriIndex != -1 && namespaces
                       ? fStringPool.toString(uriIndex) : """";
            int localIndex = element.localpart;
            String local = localIndex != -1 && namespaces
                         ? fStringPool.toString(localIndex) : """";
            String raw = name;
            fAttributes.clear();
            for (int attrIndex = attrList.getFirstAttr(attrListIndex); 
                 attrIndex != -1; 
                 attrIndex = attrList.getNextAttr(attrIndex)) {
                int attrNameIndex = attrList.getAttrName(attrIndex);
                int attrUriIndex = attrList.getAttrURI(attrIndex);
                String attrUri = attrUriIndex != -1 && namespaces
                               ? fStringPool.toString(attrUriIndex) : """";
                int attrLocalIndex = attrList.getAttrLocalpart(attrIndex);
                String attrLocal = attrLocalIndex != -1 && namespaces
                                 ? fStringPool.toString(attrLocalIndex) : """";
                String attrRaw = fStringPool.toString(attrNameIndex);
                String attrType = fStringPool.toString(attrList.getAttType(attrIndex));
                String attrValue = fStringPool.toString(attrList.getAttValue(attrIndex));
                //int attrPrefix = fStringPool.getPrefixForQName(attrNameIndex);
                int attrPrefix = attrList.getAttrPrefix(attrIndex);
                boolean namespacePrefixes = getNamespacePrefixes();
                if (!namespaces || namespacePrefixes || 
                    (attrPrefix != fStringPool.addSymbol(""xmlns"")
                    && attrLocalIndex != fStringPool.addSymbol(""xmlns"")
                    )) 
                    fAttributes.addAttribute(attrUri, attrLocal, attrRaw, 
                                            attrType, attrValue);
                    
            }
            fContentHandler.startElement(uri, local, raw, fAttributes);
        }

        // free attribute list
        attrList.releaseAttrList(attrListIndex);

    } // startElement(QName,XMLAttrList,int)

    /** End element. */
    public void endElement(QName element) throws Exception {

        // perform callback
        if (DEBUG_CALLBACKS) {
            System.err.println(""endElement("" + fStringPool.toString(element.rawname) + "")"");
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.endElement(fStringPool.toString(element.rawname));
        }
        if (fContentHandler != null) {
            boolean namespaces = getNamespaces();
            int uriIndex = element.uri;
            String uri = uriIndex != -1 && namespaces
                       ? fStringPool.toString(uriIndex) : """";
            int localIndex = element.localpart;
            String local = localIndex != -1 && namespaces
                         ? fStringPool.toString(localIndex) : """";
            String raw = fStringPool.toString(element.rawname);
            fContentHandler.endElement(uri, local, raw);
        }

    } // endElement(QName)

    /** Start entity reference. */
    public void startEntityReference(int entityName, int entityType, int entityContext) throws Exception {
        if (fLexicalHandler != null || DEBUG_CALLBACKS) {
            switch (entityType) {
            case XMLEntityHandler.ENTITYTYPE_INTERNAL_PE:
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL_PE:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""startEntity(%"" + fStringPool.toString(entityName) + "")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.startEntity(""%"" + fStringPool.toString(entityName));
                }
                break;
            case XMLEntityHandler.ENTITYTYPE_INTERNAL:
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""startEntity("" + fStringPool.toString(entityName) + "")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.startEntity(fStringPool.toString(entityName));
                }
                break;
            case XMLEntityHandler.ENTITYTYPE_UNPARSED:   // these are mentioned by name, not referenced
                throw new RuntimeException(
                    ""PAR015 startEntityReference(): ENTITYTYPE_UNPARSED"");
            case XMLEntityHandler.ENTITYTYPE_DOCUMENT:
                break;                  // not reported
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL_SUBSET:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""startEntity(\""[dtd]\"")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.startEntity(""[dtd]"");
                }
                break;
            }
        }
    }

    /** End entity reference. */
    public void endEntityReference(int entityName, int entityType, int entityContext) throws Exception {
        if (fLexicalHandler != null || DEBUG_CALLBACKS) {
            switch (entityType) {
            case XMLEntityHandler.ENTITYTYPE_INTERNAL_PE:
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL_PE:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""endEntity(%"" + fStringPool.toString(entityName) + "")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.endEntity(""%"" + fStringPool.toString(entityName));
                }
                break;
            case XMLEntityHandler.ENTITYTYPE_INTERNAL:
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""endEntity("" + fStringPool.toString(entityName) + "")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.endEntity(fStringPool.toString(entityName));
                }
                break;
            case XMLEntityHandler.ENTITYTYPE_UNPARSED:   // these are mentioned by name, not referenced
                throw new RuntimeException(""PAR016 endEntityReference(): ENTITYTYPE_UNPARSED"");
            case XMLEntityHandler.ENTITYTYPE_DOCUMENT:
                break;                  // not reported
            case XMLEntityHandler.ENTITYTYPE_EXTERNAL_SUBSET:
                if (DEBUG_CALLBACKS) {
                    System.err.println(""endEntity(\""[dtd]\"")"");
                }
                if (fLexicalHandler != null) {
                    fLexicalHandler.endEntity(""[dtd]"");
                }
                break;
            }
        }
    }

    /** Start CDATA section. */
    public void startCDATA() throws Exception {
        if (DEBUG_CALLBACKS) {
            System.err.println(""startCDATA()"");
        }
        if (fLexicalHandler != null) {
            fLexicalHandler.startCDATA();
        }
    }

    /** End CDATA section. */
    public void endCDATA() throws Exception {
        if (DEBUG_CALLBACKS) {
            System.err.println(""endCDATA()"");
        }
        if (fLexicalHandler != null) {
            fLexicalHandler.endCDATA();
        }
    }

    /** Not called. */
    public void characters(int dataIndex) throws Exception {
        throw new RuntimeException(""PAR017 cannot happen 5\n5"");
    }

    /** Not called. */
    public void ignorableWhitespace(int dataIndex) throws Exception {
        throw new RuntimeException(""PAR017 cannot happen 6\n6"");
    }

    /** Processing instruction. */
    public void processingInstruction(int piTarget, int piData) throws Exception {

        if (fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS) {
            //
            // REVISIT - I keep running into SAX apps that expect
            //   null data to be an empty string, which is contrary
            //   to the comment for this method in the SAX API.
            //

            // strings
            String target = fStringPool.orphanString(piTarget);
            String data = piData == -1 ? """" : fStringPool.orphanString(piData);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""processingInstruction("" + target + "", "" + data + "")"");
            }
            if (fDocumentHandler != null) {
                fDocumentHandler.processingInstruction(target, data);
            }
            if (fContentHandler != null) {
                fContentHandler.processingInstruction(target, data);
            }

        } 
        else {
            fStringPool.releaseString(piTarget);
            fStringPool.releaseString(piData);
        }

    }

    /** Comment. */
    public void comment(int dataIndex) throws Exception {

        if (fLexicalHandler != null || DEBUG_CALLBACKS) {

            // strings
            String data = fStringPool.orphanString(dataIndex);

            // perform callback
            if (DEBUG_CALLBACKS) {
                System.err.println(""comment("" + data + "")"");
            }
            if (fLexicalHandler != null) {
                fLexicalHandler.comment(data.toCharArray(), 0, data.length());
            }
        } else {
            fStringPool.releaseString(dataIndex);
        }
    }

    /** Characters. */
    public void characters(char ch[], int start, int length) throws Exception {

        // perform callback
        if (DEBUG_CALLBACKS) {
            System.err.println(""characters(<char-data>) length "" + length);
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.characters(ch, start, length);
        }
        if (fContentHandler != null) {
            fContentHandler.characters(ch, start, length);
        }

    }

    /** Ignorable whitespace. */
    public void ignorableWhitespace(char ch[], int start, int length) throws Exception {

        // perform callback
        if (DEBUG_CALLBACKS) {
            System.err.println(""ignorableWhitespace(<white-space>)"");
        }
        if (fDocumentHandler != null) {
            fDocumentHandler.ignorableWhitespace(ch, start, length);
        }
        if (fContentHandler != null) {
            fContentHandler.ignorableWhitespace(ch, start, length);
        }

    }

} // class SAXParser
"
org/apache/xerces/dom/DeferredDocumentTypeImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;
import org.apache.xerces.utils.StringPool;

/**
 * This class represents a Document Type <em>declaraction</em> in
 * the document itself, <em>not</em> a Document Type Definition (DTD).
 * An XML document may (or may not) have such a reference.
 * <P>
 * DocumentType is an Extended DOM feature, used in XML documents but
 * not in HTML.
 * <P>
 * Note that Entities and Notations are no longer children of the
 * DocumentType, but are parentless nodes hung only in their
 * appropriate NamedNodeMaps.
 * <P>
 * This area is UNDERSPECIFIED IN REC-DOM-Level-1-19981001
 * Most notably, absolutely no provision was made for storing
 * and using Element and Attribute information. Nor was the linkage
 * between Entities and Entity References nailed down solidly.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredDocumentTypeImpl
    extends DocumentTypeImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -2172579663227313509L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredDocumentTypeImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);
        syncChildren(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument;
        name = ownerDocument.getNodeNameString(fNodeIndex);

        // public and system ids
        StringPool pool = ownerDocument.getStringPool();
        int extraDataIndex = ownerDocument.getNodeValue(fNodeIndex);
        //ownerDocument.getNodeType(extraDataIndex);
        publicID = pool.toString(ownerDocument.getNodeName(extraDataIndex));
        systemID = pool.toString(ownerDocument.getNodeValue(extraDataIndex));
        internalSubset =
            pool.toString(ownerDocument.getLastChild(extraDataIndex));
    } // synchronizeData()

    /** Synchronizes the entities, notations, and elements. */
    protected void synchronizeChildren() {

        // no need to synchronize again
        syncChildren(false);

        // create new node maps
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument;

        entities  = new NamedNodeMapImpl(this, null);
        notations = new NamedNodeMapImpl(this, null);
        elements  = new NamedNodeMapImpl(this, null);

        // fill node maps
        DeferredNode last = null;
        for (int index = ownerDocument.getLastChild(fNodeIndex);
            index != -1;
            index = ownerDocument.getPrevSibling(index)) {

            DeferredNode node = ownerDocument.getNodeObject(index);
            int type = node.getNodeType();
            switch (type) {

                // internal, external, and unparsed entities
                case Node.ENTITY_NODE: {
                    entities.setNamedItem(node);
                    break;
                }

                // notations
                case Node.NOTATION_NODE: {
                    notations.setNamedItem(node);
                    break;
                }

                // element definitions
                case NodeImpl.ELEMENT_DEFINITION_NODE: {

                    // add element definition
                    elements.setNamedItem(node);

                    // add attributes to element definition
                    NamedNodeMap attrs = node.getAttributes();
                    for (int attrIndex = ownerDocument.getLastChild(node.getNodeIndex());
                         attrIndex != -1;
                         attrIndex = ownerDocument.getPrevSibling(attrIndex)) {
                        DeferredNode attr = ownerDocument.getNodeObject(attrIndex);
                        attrs.setNamedItem(attr);
                    }
                    break;
                }

                // elements
                case Node.ELEMENT_NODE: {
                    if (((DocumentImpl)getOwnerDocument()).allowGrammarAccess) {
                        insertBefore(node, last);
                        last = node;
                        break;
                    }
                }

                // NOTE: Should never get here! -Ac
                default: {
                    System.out.println(""DeferredDocumentTypeImpl#synchronizeInfo: node.getNodeType() = ""+node.getNodeType()+"", class = ""+node.getClass().getName());
                }
             }
        }

    } // synchronizeChildren()

} // class DeferredDocumentTypeImpl
"
org/apache/xerces/dom/NodeImpl.java,true," /*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import java.io.*;
import java.util.Enumeration;
import java.util.Vector;

import org.w3c.dom.*;

//import org.apache.xerces.domx.events.*;
import org.apache.xerces.dom.events.EventImpl;
import org.apache.xerces.dom.events.MutationEventImpl;
import org.w3c.dom.events.*;

/**
 * Node provides the basic structure of a DOM tree. It is never used
 * directly, but instead is subclassed to add type and data
 * information, and additional methods, appropriate to each node of
 * the tree. Only its subclasses should be instantiated -- and those,
 * with the exception of Document itself, only through a specific
 * Document's factory methods.
 * <P>
 * The Node interface provides shared behaviors such as siblings and
 * children, both for consistancy and so that the most common tree
 * operations may be performed without constantly having to downcast
 * to specific node types. When there is no obvious mapping for one of
 * these queries, it will respond with null.
 * Note that the default behavior is that children are forbidden. To
 * permit them, the subclass ParentNode overrides several methods.
 * <P>
 * NodeImpl also implements NodeList, so it can return itself in
 * response to the getChildNodes() query. This eliminiates the need
 * for a separate ChildNodeList object. Note that this is an
 * IMPLEMENTATION DETAIL; applications should _never_ assume that
 * this identity exists.
 * <P>
 * All nodes in a single document must originate
 * in that document. (Note that this is much tighter than ""must be
 * same implementation"") Nodes are all aware of their ownerDocument,
 * and attempts to mismatch will throw WRONG_DOCUMENT_ERR.
 * <P>
 * However, to save memory not all nodes always have a direct reference
 * to their ownerDocument. When a node is owned by another node it relies
 * on its owner to store its ownerDocument. Parent nodes always store it
 * though, so there is never more than one level of indirection.
 * And when a node doesn't have an owner, ownerNode refers to its
 * ownerDocument.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public abstract class NodeImpl
    implements Node, NodeList, EventTarget, Cloneable, Serializable {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -6316591992167219696L;

    // public

    /** Element definition node type. */
    public static final short ELEMENT_DEFINITION_NODE = -1;

    //
    // Data
    //

    // links

    protected NodeImpl ownerNode; // typically the parent but not always!

    // data

    protected short flags;

    protected final static short READONLY     = 0x1<<0;
    protected final static short SYNCDATA     = 0x1<<1;
    protected final static short SYNCCHILDREN = 0x1<<2;
    protected final static short OWNED        = 0x1<<3;
    protected final static short FIRSTCHILD   = 0x1<<4;
    protected final static short SPECIFIED    = 0x1<<5;
    protected final static short IGNORABLEWS  = 0x1<<6;
    protected final static short SETVALUE     = 0x1<<7;

    //
    // Constructors
    //

    /**
     * No public constructor; only subclasses of Node should be
     * instantiated, and those normally via a Document's factory methods
     * <p>
     * Every Node knows what Document it belongs to.
     */
    protected NodeImpl(DocumentImpl ownerDocument) {
        // as long as we do not have any owner, ownerNode is our ownerDocument
        ownerNode = ownerDocument;
    } // <init>(DocumentImpl)

    /** Constructor for serialization. */
    public NodeImpl() {}

    //
    // Node methods
    //

    /**
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public abstract short getNodeType();

    /**
     * the name of this node.
     */
    public abstract String getNodeName();
    
    /**
     * Returns the node value.
     */
    public String getNodeValue() {
        return null;            // overridden in some subclasses
    }

    /**
     * Sets the node value.
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR)
     */
    public void setNodeValue(String x) 
        throws DOMException {
        // Default behavior is to do nothing, overridden in some subclasses
    }

    /**
     * Adds a child node to the end of the list of children for this node.
     * Convenience shorthand for insertBefore(newChild,null).
     * @see #insertBefore(Node, Node)
     * <P>
     * By default we do not accept any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @returns newChild, in its new state (relocated, or emptied in the
     * case of DocumentNode.)
     *
     * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
     * type that shouldn't be a child of this node.
     *
     * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
     * different owner document than we do.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
     * read-only.
     */
    public Node appendChild(Node newChild) throws DOMException {
    	return insertBefore(newChild, null);
    }

    /**
     * Returns a duplicate of a given node. You can consider this a
     * generic ""copy constructor"" for nodes. The newly returned object should
     * be completely independent of the source object's subtree, so changes
     * in one after the clone has been made will not affect the other.
     * <P>
     * Note: since we never have any children deep is meaningless here,
     * ParentNode overrides this behavior.
     * @see ParentNode
     *
     * <p>
     * Example: Cloning a Text node will copy both the node and the text it
     * contains.
     * <p>
     * Example: Cloning something that has children -- Element or Attr, for
     * example -- will _not_ clone those children unless a ""deep clone""
     * has been requested. A shallow clone of an Attr node will yield an
     * empty Attr of the same name.
     * <p>
     * NOTE: Clones will always be read/write, even if the node being cloned
     * is read-only, to permit applications using only the DOM API to obtain
     * editable copies of locked portions of the tree.
     */
    public Node cloneNode(boolean deep) {

        if (syncData()) {
            synchronizeData();
	}
    	
    	NodeImpl newnode;
    	try {
            newnode = (NodeImpl)clone();
    	}
    	catch (CloneNotSupportedException e) {
//      Revisit : don't fail silently - but don't want to tie to parser guts
//            System.out.println(""UNEXPECTED ""+e);
            return null;
    	}
    	
        // Need to break the association w/ original kids
    	newnode.ownerNode      = ownerDocument();
        newnode.owned(false);

        // REVISIT: What to do when readOnly? -Ac
        newnode.readOnly(false);

    	return newnode;

    } // cloneNode(boolean):Node

    /**
     * Find the Document that this Node belongs to (the document in
     * whose context the Node was created). The Node may or may not
     * currently be part of that Document's actual contents.
     */
    public Document getOwnerDocument() {
        // if we have an owner simply forward the request
        // otherwise ownerNode is our ownerDocument
        if (owned()) {
            return ownerNode.ownerDocument();
        } else {
            return (Document) ownerNode;
        }
    }

    /**
     * same as above but returns internal type and this one is not overridden
     * by DocumentImpl to return null 
     */
    DocumentImpl ownerDocument() {
        // if we have an owner simply forward the request
        // otherwise ownerNode is our ownerDocument
        if (owned()) {
            return ownerNode.ownerDocument();
        } else {
            return (DocumentImpl) ownerNode;
        }
    }

    /**
     * NON-DOM
     * set the ownerDocument of this node
     */
    void setOwnerDocument(DocumentImpl doc) {
        if (syncData()) {
            synchronizeData();
        }
        // if we have an owner we rely on it to have it right
        // otherwise ownerNode is our ownerDocument
	if (!owned()) {
            ownerNode = doc;
        }
    }

    /**
     * Obtain the DOM-tree parent of this node, or null if it is not
     * currently active in the DOM tree (perhaps because it has just been
     * created or removed). Note that Document, DocumentFragment, and
     * Attribute will never have parents.
     */
    public Node getParentNode() {
        return null;            // overriden by ChildNode
    }

    /*
     * same as above but returns internal type
     */
    NodeImpl parentNode() {
        return null;
    }

    /** The next child of this node's parent, or null if none */
    public Node getNextSibling() {
        return null;            // default behavior, overriden in ChildNode
    }

    /** The previous child of this node's parent, or null if none */
    public Node getPreviousSibling() {
        return null;            // default behavior, overriden in ChildNode
    }

    ChildNode previousSibling() {
        return null;            // default behavior, overriden in ChildNode
    }

    /**
     * Return the collection of attributes associated with this node,
     * or null if none. At this writing, Element is the only type of node
     * which will ever have attributes.
     *
     * @see ElementImpl
     */
    public NamedNodeMap getAttributes() {
    	return null; // overridden in ElementImpl
    }

    /**
     * Test whether this node has any children. Convenience shorthand
     * for (Node.getFirstChild()!=null)
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     */
    public boolean hasChildNodes() {
        return false;
    }

    /**
     * Obtain a NodeList enumerating all children of this node. If there
     * are none, an (initially) empty NodeList is returned.
     * <p>
     * NodeLists are ""live""; as children are added/removed the NodeList
     * will immediately reflect those changes. Also, the NodeList refers
     * to the actual nodes, so changes to those nodes made via the DOM tree
     * will be reflected in the NodeList and vice versa.
     * <p>
     * In this implementation, Nodes implement the NodeList interface and
     * provide their own getChildNodes() support. Other DOMs may solve this
     * differently.
     */
    public NodeList getChildNodes() {
        return this;
    }

    /** The first child of this Node, or null if none.
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     */
    public Node getFirstChild() {
    	return null;
    }

    /** The first child of this Node, or null if none.
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     */
    public Node getLastChild() {
	return null;
    }

    /**
     * Move one or more node(s) to our list of children. Note that this
     * implicitly removes them from their previous parent.
     * <P>
     * By default we do not accept any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @param newChild The Node to be moved to our subtree. As a
     * convenience feature, inserting a DocumentNode will instead insert
     * all its children.
     *
     * @param refChild Current child which newChild should be placed
     * immediately before. If refChild is null, the insertion occurs
     * after all existing Nodes, like appendChild().
     *
     * @returns newChild, in its new state (relocated, or emptied in the
     * case of DocumentNode.)
     *
     * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
     * type that shouldn't be a child of this node, or if newChild is an
     * ancestor of this node.
     *
     * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
     * different owner document than we do.
     *
     * @throws DOMException(NOT_FOUND_ERR) if refChild is not a child of
     * this node.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
     * read-only.
     */
    public Node insertBefore(Node newChild, Node refChild) 
	throws DOMException {
	throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, 
				   ""DOM006 Hierarchy request error"");
    }

    /**
     * Remove a child from this Node. The removed child's subtree
     * remains intact so it may be re-inserted elsewhere.
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @return oldChild, in its new state (removed).
     *
     * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
     * this node.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
     * read-only.
     */
    public Node removeChild(Node oldChild) 
		throws DOMException {
	throw new DOMExceptionImpl(DOMException.NOT_FOUND_ERR, 
				   ""DOM008 Not found"");
    }

    /**
     * Make newChild occupy the location that oldChild used to
     * have. Note that newChild will first be removed from its previous
     * parent, if any. Equivalent to inserting newChild before oldChild,
     * then removing oldChild.
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @returns oldChild, in its new state (removed).
     *
     * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
     * type that shouldn't be a child of this node, or if newChild is
     * one of our ancestors.
     *
     * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
     * different owner document than we do.
     *
     * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
     * this node.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
     * read-only.
     */
    public Node replaceChild(Node newChild, Node oldChild)
        throws DOMException {
	throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR, 
				   ""DOM006 Hierarchy request error"");
    }

    //
    // NodeList methods
    //

    /**
     * NodeList method: Count the immediate children of this node
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @return int
     */
    public int getLength() {
	return 0;
    }

    /**
     * NodeList method: Return the Nth immediate child of this node, or
     * null if the index is out of bounds.
     * <P>
     * By default we do not have any children, ParentNode overrides this.
     * @see ParentNode
     *
     * @return org.w3c.dom.Node
     * @param Index int
     */
    public Node item(int index) {
	return null;
    }

    //
    // DOM2: methods, getters, setters
    //

    /**
     * Puts all <code>Text</code> nodes in the full depth of the sub-tree 
     * underneath this <code>Node</code>, including attribute nodes, into a 
     * ""normal"" form where only markup (e.g., tags, comments, processing 
     * instructions, CDATA sections, and entity references) separates 
     * <code>Text</code> nodes, i.e., there are no adjacent <code>Text</code> 
     * nodes.  This can be used to ensure that the DOM view of a document is 
     * the same as if it were saved and re-loaded, and is useful when 
     * operations (such as XPointer lookups) that depend on a particular 
     * document tree structure are to be used.In cases where the document 
     * contains <code>CDATASections</code>, the normalize operation alone may 
     * not be sufficient, since XPointers do not differentiate between 
     * <code>Text</code> nodes and <code>CDATASection</code> nodes.
     * <p>
     * Note that this implementation simply calls normalize() on this Node's
     * children. It is up to implementors or Node to override normalize()
     * to take action.
     */
    public void normalize() {
	/* by default we do not have any children,
	   ParentNode overrides this behavior */
    }

    /**
     * Introduced in DOM Level 2. <p>
     * Tests whether the DOM implementation implements a specific feature and that
     * feature is supported by this node.
     * @param feature       The package name of the feature to test. This is the
     *                      same name as what can be passed to the method
     *                      hasFeature on DOMImplementation.
     * @param version       This is the version number of the package name to
     *                      test. In Level 2, version 1, this is the string ""2.0"". If
     *                      the version is not specified, supporting any version of
     *                      the feature will cause the method to return true.
     * @return boolean      Returns true if this node defines a subtree within which the
     *                      specified feature is supported, false otherwise.
     * @since WD-DOM-Level-2-19990923
     */
    public boolean supports(String feature, String version)
    {
        return getOwnerDocument().getImplementation().hasFeature(feature,
                                                                 version);
    }

    /**
     * Introduced in DOM Level 2. <p>
     *
     * The namespace URI of this node, or null if it is unspecified. When this node
     * is of any type other than ELEMENT_NODE and ATTRIBUTE_NODE, this is always
     * null and setting it has no effect. <p>
     *
     * This is not a computed value that is the result of a namespace lookup based on
     * an examination of the namespace declarations in scope. It is merely the
     * namespace URI given at creation time.<p>
     *
     * For nodes created with a DOM Level 1 method, such as createElement
     * from the Document interface, this is null.
     * @since WD-DOM-Level-2-19990923
     * @see AttrNSImpl
     * @see ElementNSImpl
     */
    public String getNamespaceURI()
    {
        return null;
    }

    /**
     * Introduced in DOM Level 2. <p>
     *
     * The namespace prefix of this node, or null if it is unspecified. When this
     * node is of any type other than ELEMENT_NODE and ATTRIBUTE_NODE this is
     * always null and setting it has no effect.<p>
     *
     * For nodes created with a DOM Level 1 method, such as createElement
     * from the Document interface, this is null. <p>
     *
     * @since WD-DOM-Level-2-19990923
     * @see AttrNSImpl
     * @see ElementNSImpl
     */
    public String getPrefix()
    {
        return null;
    }

    /**
     *  Introduced in DOM Level 2. <p>
     *
     *  The namespace prefix of this node, or null if it is unspecified. When this
     *  node is of any type other than ELEMENT_NODE and ATTRIBUTE_NODE this is
     *  always null and setting it has no effect.<p>
     *
     *  For nodes created with a DOM Level 1 method, such as createElement
     *  from the Document interface, this is null.<p>
     *
     *  Note that setting this attribute changes the nodeName attribute, which holds the
     *  qualified name, as well as the tagName and name attributes of the Element
     *  and Attr interfaces, when applicable.<p>
     *
     * @throws INVALID_CHARACTER_ERR Raised if the specified
     *  prefix contains an invalid character.
     *
     * @since WD-DOM-Level-2-19990923
     * @see AttrNSImpl
     * @see ElementNSImpl
     */
    public void setPrefix(String prefix)
        throws DOMException
    {
	throw new DOMExceptionImpl(DOMException.NAMESPACE_ERR, 
				   ""DOM003 Namespace error"");
    }

    /**
     * Introduced in DOM Level 2. <p>
     *
     * Returns the local part of the qualified name of this node.
     * For nodes created with a DOM Level 1 method, such as createElement
     * from the Document interface, and for nodes of any type other than
     * ELEMENT_NODE and ATTRIBUTE_NODE this is the same as the nodeName
     * attribute.
     * @since WD-DOM-Level-2-19990923
     * @see AttrNSImpl
     * @see ElementNSImpl
     */
    public String             getLocalName()
    {
        return null;
    }
    
    
    //
    // EventTarget support (public and internal)
    //
	// Constants
	//
	/** Compile-time flag. If false, disables our code for
	    the DOM Level 2 Events module, perhaps allowing it
	    to be optimized out to save bytecodes.
	*/
	protected final static boolean MUTATIONEVENTS=true;
	
	/** The MUTATION_ values are parameters to the NON-DOM 
	    internalInsertBefore() and internalRemoveChild() operations,
	    allowing us to control which MutationEvents are generated.
	 */
	protected final static int MUTATION_NONE=0x00;
	protected final static int MUTATION_LOCAL=0x01;
	protected final static int MUTATION_AGGREGATE=0x02;
	protected final static int MUTATION_ALL=0xffff;
	/** NON-DOM INTERNAL: EventListeners currently registered at
	 * THIS NODE; preferably null if none.
	 */
    Vector nodeListeners=null;
	
	/* NON-DOM INTERNAL: Class LEntry is just a struct used to represent
	 * event listeners registered with this node. Copies of this object
	 * are hung from the nodeListeners Vector.
	 * <p>
	 * I considered using two vectors -- one for capture,
	 * one for bubble -- but decided that since the list of listeners 
	 * is probably short in most cases, it might not be worth spending
	 * the space. ***** REVISIT WHEN WE HAVE MORE EXPERIENCE.
	 */
	class LEntry
	{
	    String type;
	    EventListener listener;
	    boolean useCapture;
	    
	    /** NON-DOM INTERNAL: Constructor for Listener list Entry 
	     * @param type Event name (NOT event group!) to listen for.
	     * @param listener Who gets called when event is dispatched
	     * @param useCaptue True iff listener is registered on
	     *  capturing phase rather than at-target or bubbling
	     */
	    LEntry(String type,EventListener listener,boolean useCapture)
	    {
	        this.type=type;this.listener=listener;this.useCapture=useCapture;
	    }
	}; // LEntry
	
	/** Introduced in DOM Level 2. <p>
     * Register an event listener with this Node. A listener may be independently
     * registered as both Capturing and Bubbling, but may only be
     * registered once per role; redundant registrations are ignored.
     * @param type Event name (NOT event group!) to listen for.
	 * @param listener Who gets called when event is dispatched
	 * @param useCapture True iff listener is registered on
	 *  capturing phase rather than at-target or bubbling
	 */
	public void addEventListener(String type,EventListener listener,boolean useCapture)
	{
        // We can't dispatch to blank type-name, and of course we need
        // a listener to dispatch to
	    if(type==null || type.equals("""") || listener==null)
	        return;

	    // Each listener may be registered only once per type per phase.
	    // Simplest way to code that is to zap the previous entry, if any.
	    removeEventListener(type,listener,useCapture);
	    
	    if(nodeListeners==null) nodeListeners=new Vector();
	    nodeListeners.addElement(new LEntry(type,listener,useCapture));
	    
	    // Record active listener
	    LCount lc=LCount.lookup(type);
	    if(useCapture)
	        ++lc.captures;
	    else
	        ++lc.bubbles;
	} // addEventListener(String,EventListener,boolean) :void
	
	/** Introduced in DOM Level 2. <p>
     * Deregister an event listener previously registered with this Node. 
     * A listener must be independently removed from the 
     * Capturing and Bubbling roles. Redundant removals (of
     * listeners not currently registered for this role) are ignored.
     * @param type Event name (NOT event group!) to listen for.
	 * @param listener Who gets called when event is dispatched
	 * @param useCapture True iff listener is registered on
	 *  capturing phase rather than at-target or bubbling
	 */
	public void removeEventListener(String type,EventListener listener,boolean useCapture)
	{
	    // If this couldn't be a valid listener registration, ignore request
  	    if(nodeListeners==null || type==null || type.equals("""") || listener==null)
	        return;

        // Note that addListener has previously ensured that 
	    // each listener may be registered only once per type per phase.
        for(int i=nodeListeners.size()-1;i>=0;--i) // count-down is OK for deletions!
        {
            LEntry le=(LEntry)(nodeListeners.elementAt(i));
            if(le.useCapture==useCapture && le.listener==listener && 
                le.type.equals(type))
            {
                nodeListeners.removeElementAt(i);
                // Storage management: Discard empty listener lists
                if(nodeListeners.size()==0) nodeListeners=null;

	            // Remove active listener
	            LCount lc=LCount.lookup(type);
        	    if(useCapture)
	                --lc.captures;
        	    else
	                --lc.bubbles;
	                
                break;  // Found it; no need to loop farther.
            }
        }
	} // removeEventListener(String,EventListener,boolean) :void
	
	/** NON-DOM INTERNAL:
	    A finalizer has added to NodeImpl in order to correct the event-usage
	    counts of any remaining listeners before discarding the Node.
	    This isn't absolutely required, and finalizers are of dubious
	    reliability and have odd effects on some implementations of GC.
	    But given the expense of event generation and distribution it 
	    seems a worthwhile safety net.
	    ***** RECONSIDER at some future point.
	   */
	protected void finalize() throws Throwable
	{
	    super.finalize();
	    if(nodeListeners!=null)
            for(int i=nodeListeners.size()-1;i>=0;--i) // count-down is OK for deletions!
            {
                LEntry le=(LEntry)(nodeListeners.elementAt(i));
                LCount lc=LCount.lookup(le.type);
           	    if(le.useCapture)
	                --lc.captures;
                else
	                --lc.bubbles;
	        }
	}	

    /**
     * Introduced in DOM Level 2. <p>
     * Distribution engine for DOM Level 2 Events. 
     * <p>
     * Event propagation runs as follows:
     * <ol>
     * <li>Event is dispatched to a particular target node, which invokes
     *   this code. Note that the event's stopPropagation flag is
     *   cleared when dispatch begins; thereafter, if it has 
     *   been set before processing of a node commences, we instead
     *   immediately advance to the DEFAULT phase.
     * <li>The node's ancestors are established as destinations for events.
     *   For capture and bubble purposes, node ancestry is determined at 
     *   the time dispatch starts. If an event handler alters the document 
     *   tree, that does not change which nodes will be informed of the event. 
     * <li>CAPTURING_PHASE: Ancestors are scanned, root to target, for 
     *   Capturing listeners. If found, they are invoked (see below). 
     * <li>AT_TARGET: 
     *   Event is dispatched to NON-CAPTURING listeners on the
     *   target node. Note that capturing listeners on this node are _not_
     *   invoked.
     * <li>BUBBLING_PHASE: Ancestors are scanned, target to root, for
     *   non-capturing listeners. 
     * <li>Default processing: Some DOMs have default behaviors bound to specific
     *   nodes. If this DOM does, and if the event's preventDefault flag has
     *   not been set, we now return to the target node and process its
     *   default handler for this event, if any.
     * </ol>
     * <p>
     * Note that (de)registration of handlers during
     * processing of an event does not take effect during
     * this phase of this event; they will not be called until
     * the next time this node is visited by dispatchEvent.
     * <p>
     * If an event handler itself causes events to be dispatched, they are
     * processed synchronously, before processing resumes
     * on the event which triggered them. Please be aware that this may 
     * result in events arriving at listeners ""out of order"" relative
     * to the actual sequence of requests.
     * <p>
     * Note that our implementation resets the event's stop/prevent flags
     * when dispatch begins.
     * I believe the DOM's intent is that event objects be redispatchable,
     * though it isn't stated in those terms.
     * @param event the event object to be dispatched to 
     * registered EventListeners
     * @return true if the event's <code>preventDefault()</code>
     * method was invoked by an EventListener; otherwise false.
    */
	public boolean dispatchEvent(Event event)
    {
        if(event==null) return false;
        
        // Can't use anyone else's implementation, since there's no public
        // API for setting the event's processing-state fields.
        EventImpl evt=(EventImpl)event;

        // VALIDATE -- must have been initialized at least once, must have
        // a non-null non-blank name.
        if(!evt.initialized || evt.type==null || evt.type.equals(""""))
            throw new DOMExceptionImpl(DOMExceptionImpl.UNSPECIFIED_EVENT_TYPE,
				       ""DOM010 Unspecified event type"");
        
        // If nobody is listening for this event, discard immediately
        LCount lc=LCount.lookup(evt.getType());
        if(lc.captures+lc.bubbles+lc.defaults==0)
            return evt.preventDefault;

        // INITIALIZE THE EVENT'S DISPATCH STATUS
        // (Note that Event objects are reusable in our implementation;
        // that doesn't seem to be explicitly guaranteed in the DOM, but
        // I believe it is the intent.)
        evt.target=this;
        evt.stopPropagation=false;
        evt.preventDefault=false;
        
        // Capture pre-event parentage chain, not including target;
        // use pre-event-dispatch ancestors even if event handlers mutate
        // document and change the target's context.
        // Note that this is parents ONLY; events do not
        // cross the Attr/Element ""blood/brain barrier"". 
        // DOMAttrModified. which looks like an exception,
        // is issued to the Element rather than the Attr
        // and causes a _second_ DOMSubtreeModified in the Element's
        // tree.
        Vector pv=new Vector(10,10);
        Node p=this,n=p.getParentNode();
        while(n!=null)
        {
            pv.addElement(n);
            p=n;
            n=n.getParentNode();
        }
        
        //CAPTURING_PHASE:
        if(lc.captures>0)
        {
            evt.eventPhase=Event.CAPTURING_PHASE;
            //Ancestors are scanned, root to target, for 
            //Capturing listeners.
            for(int j=pv.size()-1;j>=0;--j)
            {
                if(evt.stopPropagation)
                    break;  // Someone set the flag. Phase ends.
                    
                // Handle all capturing listeners on this node
                NodeImpl nn=(NodeImpl)pv.elementAt(j);
                evt.currentNode=nn;
                if(nn.nodeListeners!=null)
                {
                    Vector nl=(Vector)(nn.nodeListeners.clone());
                    for(int i=nl.size()-1;i>=0;--i) // count-down more efficient
                    {
	                    LEntry le=(LEntry)(nl.elementAt(i));
                        if(le.useCapture && le.type.equals(evt.type))
                            try
                            {
    	                        le.listener.handleEvent(evt);
	                        }
	                        catch(Exception e)
	                        {
	                            // All exceptions are ignored.
	                        }
	                }
	            }
            }
        }
        
        //Both AT_TARGET and BUBBLE use non-capturing listeners.
        if(lc.bubbles>0)
        {
            //AT_TARGET PHASE: Event is dispatched to NON-CAPTURING listeners
            //on the target node. Note that capturing listeners on the target node 
            //are _not_ invoked, even during the capture phase.
            evt.eventPhase=Event.AT_TARGET;
            evt.currentNode=this;
            if(!evt.stopPropagation && nodeListeners!=null)
            {
                Vector nl=(Vector)nodeListeners.clone();
                for(int i=nl.size()-1;i>=0;--i) // count-down is more efficient
                {
                    LEntry le=(LEntry)nl.elementAt(i);
       	            if(le!=null && !le.useCapture && le.type.equals(evt.type))
   	                    try
   	                    {
                            le.listener.handleEvent(evt);
                        }
                        catch(Exception e)
                        {
                            // All exceptions are ignored.
                        }
	            }
            }
            //BUBBLING_PHASE: Ancestors are scanned, target to root, for
            //non-capturing listeners. If the event's preventBubbling flag has
            //been set before processing of a node commences, we instead
            //immediately advance to the default phase.
            //Note that not all events bubble.
            if(evt.bubbles) 
            {
                evt.eventPhase=Event.BUBBLING_PHASE;
                for(int j=0;j<pv.size();++j)
                {
                    if(evt.stopPropagation)
                        break;  // Someone set the flag. Phase ends.
                    
                    // Handle all bubbling listeners on this node
                    NodeImpl nn=(NodeImpl)pv.elementAt(j);
                    evt.currentNode=nn;
                    if(nn.nodeListeners!=null)
                    {
                        Vector nl=(Vector)(nn.nodeListeners.clone());
                        for(int i=nl.size()-1;i>=0;--i) // count-down more efficient
    	                {
	                        LEntry le=(LEntry)(nl.elementAt(i));
    	                    if(!le.useCapture && le.type.equals(evt.type))
            	                try
            	                {
	                                le.listener.handleEvent(evt);
	                            }
	                            catch(Exception e)
	                            {
	                                // All exceptions are ignored.
	                            }
	                    }
	                }
                }
            }
        }
        
        //DEFAULT PHASE: Some DOMs have default behaviors bound to specific
        //nodes. If this DOM does, and if the event's preventDefault flag has
        //not been set, we now return to the target node and process its
        //default handler for this event, if any.
        // No specific phase value defined, since this is DOM-internal
        if(lc.defaults>0 && (!evt.cancelable || !evt.preventDefault))
        {
            // evt.eventPhase=Event.DEFAULT_PHASE;
            // evt.currentNode=this;
            // DO_DEFAULT_OPERATION
        }

        return evt.preventDefault;        
    } // dispatchEvent(Event) :boolean


    /** NON-DOM INTERNAL: DOMNodeInsertedIntoDocument and ...RemovedFrom...
     * are dispatched to an entire subtree. This is the distribution code
     * therefor. They DO NOT bubble, thanks be, but may be captured.
     * <p>
     * ***** At the moment I'm being sloppy and using the normal
     * capture dispatcher on every node. This could be optimized hugely
     * by writing a capture engine that tracks our position in the tree to
     * update the capture chain without repeated chases up to root.
     * @param n node which was directly inserted or removed
     * @param e event to be sent to that node and its subtree
     */
    void dispatchEventToSubtree(ChildNode n,Event e)
    {
      if(MUTATIONEVENTS)
      {
	    if(nodeListeners==null || n==null)
            return;

	    // ***** Recursive implementation. This is excessively expensive,
	    // and should be replaced in conjunction with optimization
	    // mentioned above.
	    n.dispatchEvent(e);
	    if(n.getNodeType()==Node.ELEMENT_NODE)
	    {
	        NamedNodeMap a=n.getAttributes();
	        for(int i=a.getLength()-1;i>=0;--i)
	            dispatchEventToSubtree(((ChildNode)a.item(i)),e);
	    }
	    dispatchEventToSubtree((ChildNode)n.getFirstChild(),e);
	    dispatchEventToSubtree(n.nextSibling,e);
	  }
	} // dispatchEventToSubtree(NodeImpl,Event) :void

    /** NON-DOM INTERNAL: Return object for getEnclosingAttr. Carries
     * (two values, the Attr node affected (if any) and its previous 
     * string value. Simple struct, no methods.
     */
	class EnclosingAttr
	{
	    AttrImpl node;
	    String oldvalue;
	} //EnclosingAttr
	
	/** NON-DOM INTERNAL: Pre-mutation context check, in
	 * preparation for later generating DOMAttrModified events.
	 * Determines whether this node is within an Attr
	 * @return either a description of that Attr, or Null
	 * if none such. 
	 */
	EnclosingAttr getEnclosingAttr()
	{
      if(MUTATIONEVENTS)
      {
        NodeImpl eventAncestor=this;
        while(true)
        {
            if(eventAncestor==null)
                return null;
            int type=eventAncestor.getNodeType();
            if(type==Node.ATTRIBUTE_NODE)
            {
                EnclosingAttr retval=new EnclosingAttr();
                retval.node=(AttrImpl)eventAncestor;
                retval.oldvalue=retval.node.getNodeValue();
                return retval;
            }    
            else if(type==Node.ENTITY_REFERENCE_NODE)
                eventAncestor=eventAncestor.parentNode();
            else 
                return null;
                // Any other parent means we're not in an Attr
        }
      }
      return null; // Safety net, should never be reached
	} // getEnclosingAttr() :EnclosingAttr 

	
	/** NON-DOM INTERNAL: Convenience wrapper for calling
	 * dispatchAggregateEvents when the context was established
	 * by <code>getEnclosingAttr</code>.
	 * @param ea description of Attr affected by current operation
	 */
	void dispatchAggregateEvents(EnclosingAttr ea)
	{
	    if(ea!=null)
	        dispatchAggregateEvents(ea.node,ea.oldvalue);
        else
	        dispatchAggregateEvents(null,null);
	        
	} // dispatchAggregateEvents(EnclosingAttr) :void

	/** NON-DOM INTERNAL: Generate the ""aggregated"" post-mutation events
	 * DOMAttrModified and DOMSubtreeModified.
	 * Both of these should be issued only once for each user-requested
	 * mutation operation, even if that involves multiple changes to
	 * the DOM.
	 * For example, if a DOM operation makes multiple changes to a single
	 * Attr before returning, it would be nice to generate only one 
	 * DOMAttrModified, and multiple changes over larger scope but within
	 * a recognizable single subtree might want to generate only one 
	 * DOMSubtreeModified, sent to their lowest common ancestor. 
	 * <p>
	 * To manage this, use the ""internal"" versions of insert and remove
	 * with MUTATION_LOCAL, then make an explicit call to this routine
	 * at the higher level. Some examples now exist in our code.
	 *
	 * @param enclosingAttr The Attr node (if any) whose value has
	 * been changed as a result of the DOM operation. Null if none such.
	 * @param oldValue The String value previously held by the
	 * enclosingAttr. Ignored if none such.
	 */
	void dispatchAggregateEvents(AttrImpl enclosingAttr,String oldvalue)
	{
      if(MUTATIONEVENTS)
      {
	    if(nodeListeners==null)
            return;

	    // If we have to send DOMAttrModified (determined earlier),
	    // do so.
	    NodeImpl owner=null;
	    if(enclosingAttr!=null)
	    {
            LCount lc=LCount.lookup(MutationEventImpl.DOM_ATTR_MODIFIED);
	        if(lc.captures+lc.bubbles+lc.defaults>0)
	        {
                owner=((NodeImpl)(enclosingAttr.getOwnerElement()));
                if(owner!=null)
                {
                    MutationEvent me=
                        new MutationEventImpl();
                    //?????ownerDocument.createEvent(""MutationEvents"");
                    me.initMutationEvent(MutationEventImpl.DOM_ATTR_MODIFIED,true,false,
                       null,oldvalue,enclosingAttr.getNodeValue(),enclosingAttr.getNodeName());
                    owner.dispatchEvent(me);
                }
            }
        }
    
        // DOMSubtreeModified gets sent to the lowest common root of a
        // set of changes. 
        // ""This event is dispatched after all other events caused by the
        // mutation have been fired.""
        LCount lc=LCount.lookup(MutationEventImpl.DOM_SUBTREE_MODIFIED);
        if(lc.captures+lc.bubbles+lc.defaults>0)
        {
            MutationEvent me=
                    new MutationEventImpl();
                //?????ownerDocument.createEvent(""MutationEvents"");
            me.initMutationEvent(MutationEventImpl.DOM_SUBTREE_MODIFIED,true,false,
               null,null,null,null);
            
            
            // If we're within an Attr, DStM gets sent to the Attr
            // and to its owningElement. Otherwise we dispatch it
            // locally.
    	    if(enclosingAttr!=null)
    	    {
    	        enclosingAttr.dispatchEvent(me);
    	        if(owner!=null)
    	            owner.dispatchEvent(me);
    	    }
            else
                dispatchEvent(me);
        }
      }
	} //dispatchAggregateEvents(AttrImpl,String) :void


    //
    // Public methods
    //

    /**
     * NON-DOM: PR-DOM-Level-1-19980818 mentions readonly nodes in conjunction
     * with Entities, but provides no API to support this.
     * <P>
     * Most DOM users should not touch this method. Its anticpated use
     * is during construction of EntityRefernces, where it will be used to
     * lock the contents replicated from Entity so they can't be casually
     * altered. It _could_ be published as a DOM extension, if desired.
     * <P>
     * Note: since we never have any children deep is meaningless here,
     * ParentNode overrides this behavior.
     * @see ParentNode
     *
     * @param readOnly True or false as desired.
     * @param deep If true, children are also toggled. Note that this will
     *	not change the state of an EntityReference or its children,
     *  which are always read-only.
     */
    public void setReadOnly(boolean readOnly, boolean deep) {

        if (syncData()) {
            synchronizeData();
        }
    	readOnly(readOnly);

    } // setReadOnly(boolean,boolean)

    /**
     * NON-DOM: Returns true if this node is read-only. This is a
     * shallow check.
     */
    public boolean getReadOnly() {

        if (syncData()) {
            synchronizeData();
        }
        return readOnly();

    } // getReadOnly():boolean

    /**
     * NON-DOM: As an alternative to subclassing the DOM, this implementation
     * has been extended with the ability to attach an object to each node.
     * (If you need multiple objects, you can attach a collection such as a
     * vector or hashtable, then attach your application information to that.)
     * <p><b>Important Note:</b> You are responsible for removing references
     * to your data on nodes that are no longer used. Failure to do so will
     * prevent the nodes, your data is attached to, to be garbage collected
     * until the whole document is.
     *
     * @param data the object to store or null to remove any existing reference
     */
    public void setUserData(Object data) {
        ownerDocument().setUserData(this, data);
    }

    /**
     * NON-DOM:
     * Returns the user data associated to this node.
     */
    public Object getUserData() {
        return ownerDocument().getUserData(this);
    }

    //
    // Protected methods
    //

    /**
     * Denotes that this node has changed.
     */
    protected void changed() {} // overridden in subclasses

    /**
     * Returns the number of changes to this node.
     */
    protected int changes() {
        // overridden in subclasses
        throw new RuntimeException(
                    ""changes() called on a NodeImpl or one of its subclasses"" +
                    ""which doesn't really implement it"");
    }

    /**
     * Override this method in subclass to hook in efficient
     * internal data structure.
     */
    protected void synchronizeData() {}


    /*
     * Flags setters and getters
     */

    final boolean readOnly() {
        return (flags & READONLY) != 0;
    }

    final void readOnly(boolean value) {
        flags = (short) (value ? flags | READONLY : flags & ~READONLY);
    }

    final boolean syncData() {
        return (flags & SYNCDATA) != 0;
    }

    final void syncData(boolean value) {
        flags = (short) (value ? flags | SYNCDATA : flags & ~SYNCDATA);
    }

    final boolean syncChildren() {
        return (flags & SYNCCHILDREN) != 0;
    }

    final void syncChildren(boolean value) {
        flags = (short) (value ? flags | SYNCCHILDREN : flags & ~SYNCCHILDREN);
    }

    final boolean owned() {
        return (flags & OWNED) != 0;
    }

    final void owned(boolean value) {
        flags = (short) (value ? flags | OWNED : flags & ~OWNED);
    }

    final boolean firstChild() {
        return (flags & FIRSTCHILD) != 0;
    }

    final void firstChild(boolean value) {
        flags = (short) (value ? flags | FIRSTCHILD : flags & ~FIRSTCHILD);
    }

    final boolean specified() {
        return (flags & SPECIFIED) != 0;
    }

    final void specified(boolean value) {
        flags = (short) (value ? flags | SPECIFIED : flags & ~SPECIFIED);
    }

    final boolean ignorableWhitespace() {
        return (flags & IGNORABLEWS) != 0;
    }

    final void ignorableWhitespace(boolean value) {
        flags = (short) (value ? flags | IGNORABLEWS : flags & ~IGNORABLEWS);
    }

    final boolean setValue() {
        return (flags & SETVALUE) != 0;
    }

    final void setValue(boolean value) {
        flags = (short) (value ? flags | SETVALUE : flags & ~SETVALUE);
    }

    //
    // Object methods
    //

    /** NON-DOM method for debugging convenience. */
    public String toString() {
        return ""[""+getNodeName()+"": ""+getNodeValue()+""]"";
    }

    //
    // Serialization methods
    //

    /** Serialize object. */
    private void writeObject(ObjectOutputStream out) throws IOException {

        // synchronize data
        if (syncData()) {
            synchronizeData();
        }
        // write object
        out.defaultWriteObject();

    } // writeObject(ObjectOutputStream)

} // class NodeImpl
"
org/apache/xerces/dom/DeferredCDATASectionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * XML provides the CDATA markup to allow a region of text in which
 * most of the XML delimiter recognition does not take place. This is
 * intended to ease the task of quoting XML fragments and other
 * programmatic information in a document's text without needing to
 * escape these special characters. It's primarily a convenience feature
 * for those who are hand-editing XML.
 * <P>
 * CDATASection is an Extended DOM feature, and is not used in HTML 
 * contexts.
 * <P>
 * Within the DOM, CDATASections are treated essentially as Text
 * blocks. Their distinct type is retained in order to allow us to
 * properly recreate the XML syntax when we write them out.
 * <P>
 * Reminder: CDATA IS NOT A COMPLETELY GENERAL SOLUTION; it can't
 * quote its own end-of-block marking. If you need to write out a
 * CDATA that contains the ]]> sequence, it's your responsibility to
 * split that string over two successive CDATAs at that time.
 * <P>
 * CDATA does not participate in Element.normalize() processing.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredCDATASectionImpl 
    extends CDATASectionImpl 
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 1983580632355645726L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here. All other data,
     * can be requested from the ownerDocument via the index.
     */
    DeferredCDATASectionImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);

    } // <init>(DeferredDocumentImpl,int)
    
    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl) this.ownerDocument();
        data = ownerDocument.getNodeValueString(fNodeIndex);
        ignorableWhitespace(ownerDocument.getLastChild(fNodeIndex) == 1);

    } // synchronizeData()

} // class DeferredCDATASectionImpl
"
org/apache/xerces/dom/NotationImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Notations are how the Document Type Description (DTD) records hints
 * about the format of an XML ""unparsed entity"" -- in other words,
 * non-XML data bound to this document type, which some applications
 * may wish to consult when manipulating the document. A Notation
 * represents a name-value pair, with its nodeName being set to the
 * declared name of the notation.
 * <P>
 * Notations are also used to formally declare the ""targets"" of
 * Processing Instructions.
 * <P>
 * Note that the Notation's data is non-DOM information; the DOM only
 * records what and where it is.
 * <P>
 * See the XML 1.0 spec, sections 4.7 and 2.6, for more info.
 * <P>
 * Level 1 of the DOM does not support editing Notation contents.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class NotationImpl 
    extends NodeImpl 
    implements Notation {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -764632195890658402L;
    
    //
    // Data
    //

    /** Notation name. */
    protected String name;

    /** Public identifier. */
    protected String publicId;

    /** System identifier. */
    protected String systemId;

    //
    // Constructors
    //

    /** Factory constructor. */
    public NotationImpl(DocumentImpl ownerDoc, String name) {
    	super(ownerDoc);
        this.name = name;
    }
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.NOTATION_NODE;
    }

    /**
     * Returns the notation name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    //
    // Notation methods
    //

    /**
     * The Public Identifier for this Notation. If no public identifier
     * was specified, this will be null.  
     */
    public String getPublicId() {

        if (syncData()) {
            synchronizeData();
        }
    	return publicId;

    } // getPublicId():String

    /**
     * The System Identifier for this Notation. If no system identifier
     * was specified, this will be null.  
     */
    public String getSystemId() {

        if (syncData()) {
            synchronizeData();
        }
    	return systemId;

    } // getSystemId():String

    //
    // Public methods
    //

    /** 
     * NON-DOM: The Public Identifier for this Notation. If no public
     * identifier was specified, this will be null.  
     */
    public void setPublicId(String id) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR,
			""DOM001 Modification not allowed"");
        }
        if (syncData()) {
            synchronizeData();
        }
        publicId = id;

    } // setPublicId(String)

    /** 
     * NON-DOM: The System Identifier for this Notation. If no system
     * identifier was specified, this will be null.  
     */
    public void setSystemId(String id) {

    	if(readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR,
			""DOM001 Modification not allowed"");
        }
        if (syncData()) {
            synchronizeData();
        }
    	systemId = id;

    } // setSystemId(String)

} // class NotationImpl
"
org/apache/xerces/readers/XMLEntityReader.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;

/**
 * This is the class used by the scanner to process the XML data.
 *
 * @see org.apache.xerces.framework.XMLParser
 * @version $Id$
 */
abstract class XMLEntityReader implements XMLEntityHandler.EntityReader {
    /*
     * Instance variables.
     */
    protected XMLEntityHandler fEntityHandler = null;
    protected XMLErrorReporter fErrorReporter = null;
    protected boolean fSendCharDataAsCharArray;
    protected XMLEntityHandler.CharDataHandler fCharDataHandler = null;
    protected boolean fInCDSect = false;
    private boolean fStillActive = true;
    /*
     * These are updated directly by the subclass implementation.
     */
    protected int fCarriageReturnCounter = 1;
    protected int fLinefeedCounter = 1;
    protected int fCharacterCounter = 1;
    protected int fCurrentOffset = 0;
    /**
     * Constructor
     */
    protected XMLEntityReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray) {
        fEntityHandler = entityHandler;
        fErrorReporter = errorReporter;
        fSendCharDataAsCharArray = sendCharDataAsCharArray;
        fCharDataHandler = fEntityHandler.getCharDataHandler();
    }
    /**
     * Constructor
     */
    protected XMLEntityReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, int lineNumber, int columnNumber) {
        fEntityHandler = entityHandler;
        fErrorReporter = errorReporter;
        fSendCharDataAsCharArray = sendCharDataAsCharArray;
        fCharDataHandler = fEntityHandler.getCharDataHandler();
        fLinefeedCounter = lineNumber;
        fCharacterCounter = columnNumber;
    }
    protected void init(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, int lineNumber, int columnNumber) {
        fEntityHandler = entityHandler;
        fErrorReporter = errorReporter;
        fSendCharDataAsCharArray = sendCharDataAsCharArray;
        fCharDataHandler = fEntityHandler.getCharDataHandler();
        fLinefeedCounter = lineNumber;
        fCharacterCounter = columnNumber;
        fStillActive = true;
        fInCDSect = false;
        fCarriageReturnCounter = 1;
        fCurrentOffset = 0;
    }

    /**
     * Return the current offset within this reader.
     *
     * @return The offset.
     */
    public int currentOffset() {
        return fCurrentOffset;
    }

    /**
     * Return the line number of the current position within the document that we are processing.
     *
     * @return The current line number.
     */
    public int getLineNumber() {
        if (fLinefeedCounter > 1)
            return fLinefeedCounter;
        else
            return fCarriageReturnCounter;
    }

    /**
     * Return the column number of the current position within the document that we are processing.
     *
     * @return The current column number.
     */
    public int getColumnNumber() {
        return fCharacterCounter;
    }

    /**
     * This method is provided for scanner implementations.
     */
    public void setInCDSect(boolean inCDSect) {
        fInCDSect = inCDSect;
    }

    /**
     * This method is provided for scanner implementations.
     */
    public boolean getInCDSect() {
        return fInCDSect;
    }

    /**
     * This method is called by the reader subclasses at the end of input.
     */
    protected XMLEntityHandler.EntityReader changeReaders() throws Exception {
        XMLEntityHandler.EntityReader nextReader = null;
        if (fStillActive) {
            nextReader = fEntityHandler.changeReaders();
            fStillActive = false;
        }
        return nextReader;
    }
}
"
org/apache/xerces/validators/datatype/IllegalFacetValueException.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
 
package org.apache.xerces.validators.datatype;

/**
 * IllegalFacetValueException is thrown when a facet's value does not match its datatype
 *
 */
public class IllegalFacetValueException
    extends Exception {

    public IllegalFacetValueException() { super(); }
    public IllegalFacetValueException(String msg) { super(msg); }

}
"
org/apache/xerces/utils/CharDataChunk.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import org.apache.xerces.readers.XMLEntityHandler;

/**
 * This class provides the character buffers used by some of the
 * reader classes.  The instances of this class are reference
 * counted and placed upon a free list for reallocation when no
 * longer in use so that they are reclaimed faster and with less
 * overhead than using the garbage collector.
 *
 * @version
 */
public final class CharDataChunk implements StringPool.StringProducer {
    /**
     * Chunk size constants
     *
     * The reader classes use the chunk size directly for better performance.
     */
    public static final int CHUNK_SHIFT = 14;           // 2^14 = 16k
    public static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);
    public static final int CHUNK_MASK = CHUNK_SIZE - 1;
    /**
     * Public constructor (factory)
     *
     * If there are any free instances available, remove them from the
     * free list and reinitialize them.  If not, allocate a new one.
     *
     * @param stringPool The string pool.
     * @param prev The chunk that precedes this one, or null if this is
     *             the first chunk.
     * @return The instance reused or created.
     */
    public static CharDataChunk createChunk(StringPool stringPool, CharDataChunk prev) {

        CharDataChunk newChunk = null;
        synchronized (CharDataChunk.class) {
            newChunk = fgFreeChunks;
            if (newChunk != null) {
                fgFreeChunks = newChunk.fNextChunk;
            } else {
                newChunk = new CharDataChunk();
            }
        }
        newChunk.fStringPool = stringPool;
        newChunk.fRefCount = 1;             // account for the reference we return to the caller
        newChunk.fChunk = prev == null ? 0 : prev.fChunk + 1;
        newChunk.fNextChunk = null;
        newChunk.fPreviousChunk = prev;
        if (prev != null) {
            //
            // You might think that we should call prev.addRef() here,
            // and you would normally be correct.  However, the reader
            // that calls us is doing something like this:
            //
            //      fCurrentChunk = CharDataChunk.createChunk(fStringPool, fCurrentChunk);
            //
            // During this call, the fCurrentChunk changes from the
            // previous chunk to this chunk, losing the reference to
            // the previous chunk.  To avoid needing code like this:
            //
            //      CharDataChunk prevChunk = fCurrentChunk;
            //      fCurrentChunk = CharDataChunk.createChunk(fStringPool, prevChunk);
            //      prevChunk.releaseChunk();
            //
            // We ""adopt the reference"" to the previous chunk into our
            // fPreviousChunk field, since the addRef() followed by a
            // removeRef() from the caller after we return just cancel
            // each other out.  The previous chunk reference will go
            // away later when clearPreviousChunk is called.
            //
            prev.setNextChunk(newChunk);
        }
        return newChunk;
    }
    /**
     * Return the instance that contains the specified offset.
     *
     * This method must always be invoked on an instance that
     * contains the specified offset, or an instance the contains
     * an offset greater than, i.e. after, the instance we are
     * to return.
     *
     * @param offset The offset to find.
     * @return The instance containing the offset.
     */
    public CharDataChunk chunkFor(int offset) {
        int firstChunk = offset >> CHUNK_SHIFT;
        if (firstChunk == fChunk)
            return this;
        CharDataChunk dataChunk = fPreviousChunk;
        while (firstChunk != dataChunk.fChunk)
            dataChunk = dataChunk.fPreviousChunk;
        return dataChunk;
    }
    /**
     * Get the character array of this instance.
     *
     * The reader classes access the data of each instance directly.
     * This class only exists to manage the lifetime of the references
     * to each instance.  It is not intended to hide from the readers
     * the fact that each instance contains a buffer of character data.
     *
     * @return The character data.
     */
    public char[] toCharArray() {
        return fData;
    }
    /**
     * Set the character array for this instance.
     *
     * @param data The character data.
     */
    public void setCharArray(char[] data) {
        fData = data;
    }
    /**
     * Get the next chunk.
     *
     * @return The instance that follows this one in the list of chunks,
     *         or null if there is no such instance.
     */
    public CharDataChunk nextChunk() {
        return fNextChunk;
    }
    /**
     * Clean the previous chunk reference.
     *
     * When a reader has reached a point where it knows that it will no
     * longer call the addString, addSymbol, or append methods with an
     * offset that is contained within a chunk that precedes this one,
     * it will call this method to clear the reference from this chunk to
     * the one preceding it.  This allows the references between chunks
     * to be dropped as we go and allow the unused instances to be placed
     * upon the free list for reuse.
     *
     * @return <code>true</code> if we cleared the previous chunk pointer;
     *         otherwise <code>false</code> if the pointer is already null.
     */
    public boolean clearPreviousChunk() {
        if (fPreviousChunk != null) {
            fPreviousChunk.clearNextChunk();
            fPreviousChunk.removeRef();
            fPreviousChunk = null;
            return true;
        }
        return false;
    }
    /**
     * Release the reference to this chunk held by the reader that allocated
     * this instance.  Called at end of input to release the last chunk in the
     * list used by the reader.
     */
    public void releaseChunk() {
        removeRef();
    }
    /**
     * Add a range from this chunk to the <code>StringPool</code>
     *
     * @param offset the offset of the first character to be added
     * @param length the number of characters to add
     * @return the <code>StringPool</code> handle that was added.
     */
    public int addString(int offset, int length) {
        int chunk = offset >> CHUNK_SHIFT;
        if (chunk != fChunk) {
            if (fPreviousChunk == null)
                throw new RuntimeException(new ImplementationMessages().createMessage(null, ImplementationMessages.INT_PCN, 0, null));
            return fPreviousChunk.addString(offset, length);
        }
        int lastChunk = (offset + length - 1) >> CHUNK_SHIFT;
        if (chunk == lastChunk) {
            addRef();
            return fStringPool.addString(this, offset & CHUNK_MASK, length);
        }
        String str = toString(offset & CHUNK_MASK, length);
        return fStringPool.addString(str);
    }
    /**
     * Add a range from this chunk to the <code>StringPool</code> as a symbol
     *
     * @param offset the offset of the first character to be added
     * @param length the number of characters to add
     * @param hashcode hashcode to match to ensure uniqueness
     * @return the <code>StringPool</code> handle that was added.
     */
    public int addSymbol(int offset, int length, int hashcode) {
        int chunk = offset >> CHUNK_SHIFT;
        if (chunk != fChunk) {
            if (fPreviousChunk == null)
                throw new RuntimeException(new ImplementationMessages().createMessage(null, ImplementationMessages.INT_PCN, 0, null));
            return fPreviousChunk.addSymbol(offset, length, hashcode);
        }
        int lastChunk = (offset + length - 1) >> CHUNK_SHIFT;
        int index = offset & CHUNK_MASK;
        if (chunk == lastChunk) {
            if (hashcode == 0)
                hashcode = StringHasher.hashChars(fData, index, length);
            int symbol = fStringPool.lookupSymbol(this, offset & CHUNK_MASK, length, hashcode);
            if (symbol == -1) {
                String str = toString(offset & CHUNK_MASK, length);
                symbol = fStringPool.addNewSymbol(str, hashcode);
            }
            return symbol;
        }
        String str = toString(offset & CHUNK_MASK, length);
        return fStringPool.addSymbol(str);
    }
    /**
     * Append data from a <code>CharBuffer</code> to this chunk.
     *
     * @param charBuffer the buffer to be appended.
     * @param offset the offset of the first character to be appended.
     * @param length the number of characters to append.
     */
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        //
        // Setup for the operation.
        //
        CharDataChunk dataChunk = chunkFor(offset);
        int index = offset & CHUNK_MASK;
        int nbytes = (index + length <= CHUNK_SIZE) ? length : CHUNK_SIZE - index;
        //
        // Visit each Chunk in turn until we are done.
        //
        while (true) {
            charBuffer.append(dataChunk.fData, index, nbytes);
            length -= nbytes;
            if (length == 0)
                break;
            dataChunk = dataChunk.fNextChunk;
            index = 0;
            nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE;
        }
    }
    //
    // StringProducer interfaces
    //
    /**
     * Return a range of characters as a <code>String</code>.
     *
     * @param offset the offset of the first character to convert.
     * @param length the number of characters to convert.
     * @return the <code>String</code>
     */
    public String toString(int offset, int length) {
        if (offset + length <= CHUNK_SIZE) {
            //
            // All the chars are in the same chunk
            //
            return new String(fData, offset, length);
        }
        //
        // The data is spread across chunks, so we need to build it in pieces.
        //
        StringBuffer sb = new StringBuffer(length);
        //
        // Copy the partial data from the first chunk.
        //
        int nbytes = CHUNK_SIZE - offset;
        sb.append(fData, offset, nbytes);
        length -= nbytes;
        //
        // Use each chunk in turn until we are done.
        //
        CharDataChunk aChunk = fNextChunk;
        do {
            nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE;
            sb.append(aChunk.fData, 0, nbytes);
            length -= nbytes;
            aChunk = aChunk.fNextChunk;
        } while (length > 0);
        String retval = sb.toString();
        sb = null; // REVISIT - does this help gc ?
        return retval;
    }
    /**
     * Release a string from this chunk
     *
     * @param offset the offset of the first character to be released
     * @param length the number of characters to release.
     */
    public void releaseString(int offset, int length) {
        removeRef();
    }
    /**
     * Compare a range in this chunk and a range in a character array for equality
     *
     * @param offset the offset of the first character in the range in this chunk
     * @param length the number of characters in the range to compare
     * @param strChars the character array to compare
     * @param strOffset the offset of the first character in the range in strChars
     * @param strLength the number of characters to release.
     * @return true if the ranges are character-wise equal, otherwise false.
     */
    public boolean equalsString(int offset, int length, char[] strChars, int strOffset, int strLength) {
        if (length != strLength)
            return false;
        if (offset + length <= CHUNK_SIZE) {
            //
            // All the chars are in the same chunk
            //
            for (int i = 0; i < length; i++) {
                if (fData[offset++] != strChars[strOffset++])
                    return false;
            }
            return true;
        }
        //
        // Compare the partial data from the first chunk.
        //
        int nbytes = CHUNK_SIZE - offset;
        length -= nbytes;
        while (nbytes-- > 0) {
            if (fData[offset++] != strChars[strOffset++])
                return false;
        }
        //
        // Check each chunk in turn until we are done.
        //
        CharDataChunk aChunk = fNextChunk;
        do {
            offset = 0;
            nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE;
            length -= nbytes;
            while (nbytes-- > 0) {
                if (aChunk.fData[offset++] != strChars[strOffset++])
                    return false;
            }
            aChunk = aChunk.fNextChunk;
        } while (length > 0);
        return true;
    }
    //
    // Private methods
    //

    //
    // Constructor for factory method.
    //
    private CharDataChunk() {}
    //
    //
    //
    private void addRef() {
        fRefCount++;
    }
    //
    //
    //
    private void removeRef() {
        fRefCount--;
        if (fRefCount == 0) {
            fStringPool = null;
            fChunk = -1;
            fPreviousChunk = null;
            synchronized (CharDataChunk.class) {
                /*** Only keep one free chunk at a time! ***
                fNextChunk = fgFreeChunks;
                /***/
                fNextChunk = null;
                fgFreeChunks = this;
            }
        }
    }
    //
    //
    //
    private void clearNextChunk() {
        if (fNextChunk != null)
            fNextChunk.removeRef();
        fNextChunk = null;
    }
    //
    //
    //
    private void setNextChunk(CharDataChunk nextChunk) {
        if (fNextChunk != null) {
            throw new RuntimeException(""CharDataChunk::setNextChunk"");
        }
        nextChunk.addRef();
        fNextChunk = nextChunk;
    }
    //
    // Private instance variables.
    //
    private StringPool fStringPool;
    private int fRefCount;
    private int fChunk;
    private char[] fData = null;
    private CharDataChunk fNextChunk;
    private CharDataChunk fPreviousChunk;
    private static CharDataChunk fgFreeChunks = null;
}
"
org/apache/xerces/readers/UCSRecognizer.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.ChunkyByteArray;
import org.apache.xerces.utils.StringPool;

import java.io.IOException;

/**
 *
 * @version
 */
final class UCSRecognizer extends XMLDeclRecognizer {
    //
    //
    //
    public XMLEntityHandler.EntityReader recognize(XMLEntityReaderFactory readerFactory,
                                                   XMLEntityHandler entityHandler,
                                                   XMLErrorReporter errorReporter,
                                                   boolean sendCharDataAsCharArray,
                                                   StringPool stringPool,
                                                   ChunkyByteArray data,
                                                   boolean xmlDecl,
                                                   boolean allowJavaEncodingName) throws Exception
    {
        XMLEntityHandler.EntityReader reader = null;
        byte b0 = data.byteAt(0);
        if (b0 == 0) {
            int b1 = data.byteAt(1);
            if (b1 == 0) {
                if (data.byteAt(2) == 0 && data.byteAt(3) == '<')
                    reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS4B, stringPool);
            } else if (b1 == '<') {
                if (data.byteAt(2) == 0 && data.byteAt(3) == '?')
                    reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS2B_NOBOM, stringPool);
            }
        } else if (b0 == '<') {
            int b1 = data.byteAt(1);
            if (b1 == 0) {
                int b2 = data.byteAt(2);
                if (data.byteAt(3) == 0) {
                    if (b2 == 0)
                        reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS4L, stringPool);
                    else if (b2 == '?')
                        reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS2L_NOBOM, stringPool);
                }
            }
        } else if (b0 == (byte)0xfe) {
            if (data.byteAt(1) == (byte)0xff)
                reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS2B, stringPool);
        } else if (b0 == (byte)0xff) {
            if (data.byteAt(1) == (byte)0xfe)
                reader = new UCSReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, UCSReader.E_UCS2L, stringPool);
        }
        return reader;
    }
}
"
org/apache/xerces/dom/events/EventImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.xerces.dom.events;

import org.w3c.dom.events.*;
import org.w3c.dom.Node;

/** EventImpl is an implementation of the basic ""generic"" DOM Level 2 Event
    object. It may be subclassed by more specialized event sets.
    Note that in our implementation, events are re-dispatchable (dispatch
    clears the stopPropagation and preventDefault flags before it starts);
    I believe that is the DOM's intent but I don't see an explicit statement
    to this effect.
*/
public class EventImpl implements Event
{
    public String type=null;
    public EventTarget target;
    public Node currentNode;
    public short eventPhase;
    public boolean initialized=false, bubbles=true, cancelable=false;
    public boolean stopPropagation=false, preventDefault=false;
     
    protected long timeStamp = System.currentTimeMillis();

    /** The DOM doesn't deal with constructors, so instead we have an
        initializer call to set most of the read-only fields. The
        others are set, and reset, by the event subsystem during dispatch.
        <p>
        Note that init() -- and the subclass-specific initWhatever() calls --
        may be reinvoked. At least one initialization is required; repeated
        initializations overwrite the event with new values of their
        parameters.
    */
    public void initEvent(String eventTypeArg, boolean canBubbleArg, 
                        boolean cancelableArg)
    {
            type=eventTypeArg;
            bubbles=canBubbleArg;
            cancelable=cancelableArg;
            
            initialized=true;
    }
    
    /** @return true iff this Event is of a class and type which supports
        bubbling. In the generic case, this is True.
        */
    public boolean getBubbles()
    {
        return bubbles;
    }

    /** @return true iff this Event is of a class and type which (a) has a
        Default Behavior in this DOM, and (b)allows cancellation (blocking)
        of that behavior. In the generic case, this is False.
        */
    public boolean getCancelable()
    {
        return cancelable;
    }

    /** @return the Node (EventTarget) whose EventListeners are currently
        being processed. During capture and bubble phases, this may not be
        the target node. */
    public Node getCurrentNode()
    {
        return currentNode;
    }

    /** @return the current processing phase for this event -- 
        CAPTURING_PHASE, AT_TARGET, BUBBLING_PHASE. (There may be
        an internal DEFAULT_PHASE as well, but the users won't see it.) */
    public short getEventPhase()
    {
        return eventPhase;
    }

    /** @return the EventTarget (Node) to which the event was originally
        dispatched.
        */
    public EventTarget getTarget()
    {
        return target;
    }

    /** @return event name as a string
    */
    public String getType()
    {
        return type;
    }

    public long getTimeStamp() {
	return timeStamp;
    }

    /** Causes exit from in-progress event dispatch before the next
        currentNode is selected. Replaces the preventBubble() and 
        preventCapture() methods which were present in early drafts; 
        they may be reintroduced in future levels of the DOM. */
    public void stopPropagation()
    {
        stopPropagation=true;
    }

    /** Prevents any default processing built into the target node from
        occurring.
      */
    public void preventDefault()
    {
        preventDefault=true;
    }

}
"
org/xml/sax/EntityResolver.java,true,"// SAX entity resolver.
// No warranty; no copyright -- use this as you will.
// $Id: EntityResolver.java,v 1.4 2000/05/05 17:46:19 david Exp $

package org.xml.sax;

import java.io.IOException;


/**
 * Basic interface for resolving entities.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>If a SAX application needs to implement customized handling
 * for external entities, it must implement this interface and
 * register an instance with the SAX driver using the
 * {@link org.xml.sax.XMLReader#setEntityResolver setEntityResolver}
 * method.</p>
 *
 * <p>The XML reader will then allow the application to intercept any
 * external entities (including the external DTD subset and external
 * parameter entities, if any) before including them.</p>
 *
 * <p>Many SAX applications will not need to implement this interface,
 * but it will be especially useful for applications that build
 * XML documents from databases or other specialised input sources,
 * or for applications that use URI types other than URLs.</p>
 *
 * <p>The following resolver would provide the application
 * with a special character stream for the entity with the system
 * identifier ""http://www.myhost.com/today"":</p>
 *
 * <pre>
 * import org.xml.sax.EntityResolver;
 * import org.xml.sax.InputSource;
 *
 * public class MyResolver implements EntityResolver {
 *   public InputSource resolveEntity (String publicId, String systemId)
 *   {
 *     if (systemId.equals(""http://www.myhost.com/today"")) {
 *              // return a special input source
 *       MyReader reader = new MyReader();
 *       return new InputSource(reader);
 *     } else {
 *              // use the default behaviour
 *       return null;
 *     }
 *   }
 * }
 * </pre>
 *
 * <p>The application can also use this interface to redirect system
 * identifiers to local URIs or to look up replacements in a catalog
 * (possibly by using the public identifier).</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser#setEntityResolver
 * @see org.xml.sax.InputSource
 */
public interface EntityResolver {
    
    
    /**
     * Allow the application to resolve external entities.
     *
     * <p>The Parser will call this method before opening any external
     * entity except the top-level document entity (including the
     * external DTD subset, external entities referenced within the
     * DTD, and external entities referenced within the document
     * element): the application may request that the parser resolve
     * the entity itself, that it use an alternative URI, or that it
     * use an entirely different input source.</p>
     *
     * <p>Application writers can use this method to redirect external
     * system identifiers to secure and/or local URIs, to look up
     * public identifiers in a catalogue, or to read an entity from a
     * database or other input source (including, for example, a dialog
     * box).</p>
     *
     * <p>If the system identifier is a URL, the SAX parser must
     * resolve it fully before reporting it to the application.</p>
     *
     * @param publicId The public identifier of the external entity
     *        being referenced, or null if none was supplied.
     * @param systemId The system identifier of the external entity
     *        being referenced.
     * @return An InputSource object describing the new input source,
     *         or null to request that the parser open a regular
     *         URI connection to the system identifier.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException A Java-specific IO exception,
     *            possibly the result of creating a new InputStream
     *            or Reader for the InputSource.
     * @see org.xml.sax.InputSource
     */
    public abstract InputSource resolveEntity (String publicId,
					       String systemId)
	throws SAXException, IOException;
    
}

// end of EntityResolver.java
"
org/apache/xerces/readers/StringReader.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLCharacterProperties;

import org.xml.sax.Locator;
import org.xml.sax.InputSource;
import java.io.IOException;

/**
 * Reader for processing internal entity replacement text.
 * <p>
 * This reader processes data contained within strings kept
 * in the string pool.  It provides the support for both
 * general and parameter entities.  The location support
 * as we are processing the replacement text is somewhat
 * poor and needs to be updated when ""nested locations""
 * have been implemented.
 * <p>
 * For efficiency, we return instances of this class to a
 * free list and reuse those instances to process other
 * strings.
 *
 * @version $id$
 */
final class StringReader extends XMLEntityReader {
    /**
     * Allocate a string reader
     *
     * @param entityHandler The current entity handler.
     * @param errorReporter The current error reporter.
     * @param sendCharDataAsCharArray true if char data should be reported using
     *                                char arrays instead of string handles.
     * @param lineNumber The line number to return as our position.
     * @param columnNumber The column number to return as our position.
     * @param stringHandle The StringPool handle for the data to process.
     * @param stringPool The string pool.
     * @param addEnclosingSpaces If true, treat the data to process as if
     *                           there were a leading and trailing space
     *                           character enclosing the string data.
     * @return The reader that will process the string data.
     */
    public static StringReader createStringReader(XMLEntityHandler entityHandler,
                                                  XMLErrorReporter errorReporter,
                                                  boolean sendCharDataAsCharArray,
                                                  int lineNumber,
                                                  int columnNumber,
                                                  int stringHandle,
                                                  StringPool stringPool,
                                                  boolean addEnclosingSpaces)
    {
        StringReader reader = null;
        synchronized (StringReader.class) {
            reader = fgFreeReaders;
            if (reader == null) {
                return new StringReader(entityHandler, errorReporter, sendCharDataAsCharArray, lineNumber, columnNumber,
                                        stringHandle, stringPool, addEnclosingSpaces);
            }
            fgFreeReaders = reader.fNextFreeReader;
        }
        reader.init(entityHandler, errorReporter, sendCharDataAsCharArray, lineNumber, columnNumber,
                    stringHandle, stringPool, addEnclosingSpaces);
        return reader;
    }
    //
    //
    //
    private StringReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter,
                         boolean sendCharDataAsCharArray, int lineNumber, int columnNumber,
                         int stringHandle, StringPool stringPool, boolean addEnclosingSpaces)
    {
        super(entityHandler, errorReporter, sendCharDataAsCharArray, lineNumber, columnNumber);
        fStringPool = stringPool;
        fData = fStringPool.toString(stringHandle);
        fCurrentOffset = 0;
        fEndOffset = fData.length();
        if (addEnclosingSpaces) {
            fMostRecentChar = ' ';
            fCurrentOffset--;
            oweTrailingSpace = hadTrailingSpace = true;
        } else {
            fMostRecentChar = fEndOffset == 0 ? -1 : fData.charAt(0);
        }
    }
    private void init(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter,
                      boolean sendCharDataAsCharArray, int lineNumber, int columnNumber,
                      int stringHandle, StringPool stringPool, boolean addEnclosingSpaces)
    {
        super.init(entityHandler, errorReporter, sendCharDataAsCharArray, lineNumber, columnNumber);
        fStringPool = stringPool;
        fData = fStringPool.toString(stringHandle);
        fCurrentOffset = 0;
        fEndOffset = fData.length();
        fNextFreeReader = null;
        if (addEnclosingSpaces) {
            fMostRecentChar = ' ';
            fCurrentOffset--;
            oweTrailingSpace = hadTrailingSpace = true;
        } else {
            fMostRecentChar = fEndOffset == 0 ? -1 : fData.charAt(0);
            oweTrailingSpace = hadTrailingSpace = false;
        }
    }
    //
    //
    //
    public int addString(int offset, int length) {
        if (length == 0)
            return 0;
        return fStringPool.addString(fData.substring(offset, offset + length));
    }
    //
    //
    //
    public int addSymbol(int offset, int length) {
        if (length == 0)
            return 0;
        return fStringPool.addSymbol(fData.substring(offset, offset + length));
    }
    //
    //
    //
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        boolean addSpace = false;
        for (int i = 0; i < length; i++) {
            try {
                charBuffer.append(fData.charAt(offset++));
            } catch (StringIndexOutOfBoundsException ex) {
                if (offset == fEndOffset + 1 && hadTrailingSpace) {
                    charBuffer.append(' ');
                } else {
                    System.err.println(""StringReader.append()"");
                    throw ex;
                }
            }
        }
    }
    //
    //
    //
    private int loadNextChar() {
        if (++fCurrentOffset >= fEndOffset) {
            if (oweTrailingSpace) {
                oweTrailingSpace = false;
                fMostRecentChar = ' ';
            } else {
                fMostRecentChar = -1;
            }
        } else {
            fMostRecentChar = fData.charAt(fCurrentOffset);
        }
        return fMostRecentChar;
    }
    //
    //
    //
    public XMLEntityHandler.EntityReader changeReaders() throws Exception {
        XMLEntityHandler.EntityReader nextReader = super.changeReaders();
        synchronized (StringReader.class) {
            fNextFreeReader = fgFreeReaders;
            fgFreeReaders = this;
        }
        return nextReader;
    }
    //
    //
    //
    public boolean lookingAtChar(char chr, boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch != chr) {
            if (ch == -1) {
                return changeReaders().lookingAtChar(chr, skipPastChar);
            }
            return false;
        }
        if (skipPastChar) {
            if (++fCurrentOffset >= fEndOffset) {
                if (oweTrailingSpace) {
                    oweTrailingSpace = false;
                    fMostRecentChar = ' ';
                } else {
                    fMostRecentChar = -1;
                }
            } else {
                fMostRecentChar = fData.charAt(fCurrentOffset);
            }
        }
        return true;
    }
    //
    //
    //
    public boolean lookingAtValidChar(boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0xD800) {
            if (ch < 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D) {
                if (ch == -1)
                    return changeReaders().lookingAtValidChar(skipPastChar);
                return false;
            }
            if (skipPastChar) {
                if (++fCurrentOffset >= fEndOffset) {
                    if (oweTrailingSpace) {
                        oweTrailingSpace = false;
                        fMostRecentChar = ' ';
                    } else {
                        fMostRecentChar = -1;
                    }
                } else {
                    fMostRecentChar = fData.charAt(fCurrentOffset);
                }
            }
            return true;
        }
        if (ch > 0xFFFD) {
            return false;
        }
        if (ch < 0xDC00) {
            if (fCurrentOffset + 1 >= fEndOffset) {
                return false;
            }
            ch = fData.charAt(fCurrentOffset + 1);
            if (ch < 0xDC00 || ch >= 0xE000) {
                return false;
            } else if (!skipPastChar) {
                return true;
            } else {
                fCurrentOffset++;
            }
        } else if (ch < 0xE000) {
            return false;
        }
        if (skipPastChar) {
            if (++fCurrentOffset >= fEndOffset) {
                if (oweTrailingSpace) {
                    oweTrailingSpace = false;
                    fMostRecentChar = ' ';
                } else {
                    fMostRecentChar = -1;
                }
            } else {
                fMostRecentChar = fData.charAt(fCurrentOffset);
            }
        }
        return true;
    }
    //
    //
    //
    public boolean lookingAtSpace(boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch > 0x20)
            return false;
        if (ch == 0x20 || ch == 0x0A || ch == 0x0D || ch == 0x09) {
            if (skipPastChar) {
                loadNextChar();
            }
            return true;
        }
        if (ch == -1) {
            return changeReaders().lookingAtSpace(skipPastChar);
        }
        return false;
    }
    //
    //
    //
    public void skipToChar(char chr) throws Exception {
        //
        // REVISIT - this will skip invalid characters without reporting them.
        //
        int ch = fMostRecentChar;
        while (true) {
            if (ch == chr)
                return;
            if (ch == -1) {
                changeReaders().skipToChar(chr);
                return;
            }
            ch = loadNextChar();
        }
    }
    //
    //
    //
    public void skipPastSpaces() throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1) {
            changeReaders().skipPastSpaces();
            return;
        }
        while (true) {
            if (ch > 0x20 || (ch != 0x20 && ch != 0x0A && ch != 0x09 && ch != 0x0D)) {
                fMostRecentChar = ch;
                return;
            }
            if (++fCurrentOffset >= fEndOffset) {
                changeReaders().skipPastSpaces();
                return;
            }
            ch = fData.charAt(fCurrentOffset);
        }
    }
    //
    //
    //
    public void skipPastName(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0x80) {
            if (ch == -1 || XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0)
                return;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
                return;
        }
        while (true) {
            ch = loadNextChar();
            if (fastcheck == ch)
                return;
            if (ch < 0x80) {
                if (ch == -1 || XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    return;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    return;
            }
        }
    }
    //
    //
    //
    public void skipPastNmtoken(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        while (true) {
            if (fastcheck == ch)
                return;
            if (ch < 0x80) {
                if (ch == -1 || XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    return;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    return;
            }
            ch = loadNextChar();
        }
    }
    //
    //
    //
    public boolean skippedString(char[] s) throws Exception {
        int ch = fMostRecentChar;
        if (ch != s[0]) {
            if (ch == -1)
                return changeReaders().skippedString(s);
            return false;
        }
        if (fCurrentOffset + s.length > fEndOffset)
            return false;
        for (int i = 1; i < s.length; i++) {
            if (fData.charAt(fCurrentOffset + i) != s[i])
                return false;
        }
        fCurrentOffset += (s.length - 1);
        loadNextChar();
        return true;
    }
    //
    //
    //
    public int scanInvalidChar() throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1)
            return changeReaders().scanInvalidChar();
        loadNextChar();
        return ch;
    }
    //
    //
    //
    public int scanCharRef(boolean hex) throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1)
            return changeReaders().scanCharRef(hex);
        int num = 0;
        if (hex) {
            if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
        } else {
            if (ch < '0' || ch > '9')
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - '0';
        }
        boolean toobig = false;
        while (true) {
            ch = loadNextChar();
            if (ch == -1)
                return XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED;
            if (hex) {
                if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                    break;
            } else {
                if (ch < '0' || ch > '9')
                    break;
            }
            if (hex) {
                int dig = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
                num = (num << 4) + dig;
            } else {
                int dig = ch - '0';
                num = (num * 10) + dig;
            }
            if (num > 0x10FFFF) {
                toobig = true;
                num = 0;
            }
        }
        if (ch != ';')
            return XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED;
        loadNextChar();
        if (toobig)
            return XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE;
        return num;
    }
    //
    //
    //
    public int scanStringLiteral() throws Exception {
        boolean single;
        if (!(single = lookingAtChar('\'', true)) && !lookingAtChar('\""', true)) {
            return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
        }
        int offset = fCurrentOffset;
        char qchar = single ? '\'' : '\""';
        while (!lookingAtChar(qchar, false)) {
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR;
            }
        }
        int stringIndex = addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true); // move past qchar
        return stringIndex;
    }
    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    //                   | ""'"" ([^<&'] | Reference)* ""'""
    //
    public int scanAttValue(char qchar, boolean asSymbol) throws Exception
    {
        int offset = fCurrentOffset;
        while (true) {
            if (lookingAtChar(qchar, false)) {
                break;
            }
            if (lookingAtChar(' ', true)) {
                continue;
            }
            if (lookingAtSpace(false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('&', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('<', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_LESSTHAN;
            }
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.ATTVALUE_RESULT_INVALID_CHAR;
            }
        }
        int result = asSymbol ? addSymbol(offset, fCurrentOffset - offset) : addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true);
        return result;
    }
    //
    //  [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                      | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    // The values in the following table are defined as:
    //
    //      0 - not special
    //      1 - quote character
    //      2 - reference
    //      3 - peref
    //      4 - invalid
    //
    public static final byte fgAsciiEntityValueChar[] = {
        4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 0, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        0, 0, 1, 0, 0, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, // '\""', '%', '&', '\''
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public int scanEntityValue(int qchar, boolean createString) throws Exception
    {
        int offset = fCurrentOffset;
        int ch = fMostRecentChar;
        while (true) {
            if (ch == -1) {
                changeReaders(); // do not call next reader, our caller may need to change the parameters
                return XMLEntityHandler.ENTITYVALUE_RESULT_END_OF_INPUT;
            }
            if (ch < 0x80) {
                switch (fgAsciiEntityValueChar[ch]) {
                case 1: // quote char
                    if (ch == qchar) {
                        if (!createString)
                            return XMLEntityHandler.ENTITYVALUE_RESULT_FINISHED;
                        int length = fCurrentOffset - offset;
                        int result = length == 0 ? StringPool.EMPTY_STRING : addString(offset, length);
                        loadNextChar();
                        return result;
                    }
                    // the other quote character is not special
                    // fall through
                case 0: // non-special char
                    if (++fCurrentOffset >= fEndOffset) {
                        if (oweTrailingSpace) {
                            oweTrailingSpace = false;
                            ch = fMostRecentChar = ' ';
                        } else {
                            ch = fMostRecentChar = -1;
                        }
                    } else {
                        ch = fMostRecentChar = fData.charAt(fCurrentOffset);
                    }
                    continue;
                case 2: // reference
                    return XMLEntityHandler.ENTITYVALUE_RESULT_REFERENCE;
                case 3: // peref
                    return XMLEntityHandler.ENTITYVALUE_RESULT_PEREF;
                case 4: // invalid
                    return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
                }
            } else if (ch < 0xD800) {
                ch = loadNextChar();
            } else if (ch >= 0xE000 && (ch <= 0xFFFD || (ch >= 0x10000 && ch <= 0x10FFFF))) {
                //
                // REVISIT - needs more code to check surrogates.
                //
                ch = loadNextChar();
            } else {
                return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
            }
        }
    }
    //
    //
    //
    public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1) {
            return changeReaders().scanExpectedName(fastcheck, expectedName);
        }
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        int nameOffset = fCurrentOffset;
        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
            return false;
        while (true) {
            ch = loadNextChar();
            if (fastcheck == ch)
                break;
            if (ch == -1)
                break;
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                break;
        }
        int nameIndex = fStringPool.addSymbol(fData.substring(nameOffset, fCurrentOffset));
        // DEFECT !! check name against expected name

        return true;
    }
    //
    //
    //
    public void scanQName(char fastcheck, QName qname) throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1) {
            changeReaders().scanQName(fastcheck, qname);
            return;
        }
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        int nameOffset = fCurrentOffset;
        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0) {
            qname.clear();
            return;
        }
        while (true) {
            ch = loadNextChar();
            if (fastcheck == ch)
                break;
            if (ch == -1)
                break;
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                break;
        }

        qname.clear();
        qname.rawname = fStringPool.addSymbol(fData.substring(nameOffset, fCurrentOffset));
        int index = fData.indexOf(':', nameOffset);
        if (index != -1) {
            qname.prefix = fStringPool.addSymbol(fData.substring(nameOffset, index));
        }
        qname.localpart = fStringPool.addSymbol(fData.substring(index, fCurrentOffset));

    } // scanQName(char,QName)

    //
    //
    //
    public int scanName(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1) {
            return changeReaders().scanName(fastcheck);
        }
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        int nameOffset = fCurrentOffset;
        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
            return -1;
        while (true) {
            if (++fCurrentOffset >= fEndOffset) {
                if (oweTrailingSpace) {
                    oweTrailingSpace = false;
                    fMostRecentChar = ' ';
                } else {
                    fMostRecentChar = -1;
                }
                break;
            }
            ch = fMostRecentChar = fData.charAt(fCurrentOffset);
            if (fastcheck == ch)
                break;
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                break;
        }
        int nameIndex = fStringPool.addSymbol(fData.substring(nameOffset, fCurrentOffset));
        return nameIndex;
    }
    //
    // There are no leading/trailing space checks here because scanContent cannot
    // be called on a parameter entity reference value.
    //
    private int recognizeMarkup(int ch) throws Exception {
        if (ch == -1) {
            return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
        }
        switch (ch) {
        case '?':
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_PI;
        case '!':
            ch = loadNextChar();
            if (ch == -1) {
                fCurrentOffset -= 2;
                loadNextChar();
                return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
            }
            if (ch == '-') {
                ch = loadNextChar();
                if (ch == -1) {
                    fCurrentOffset -= 3;
                    loadNextChar();
                    return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                }
                if (ch == '-') {
                    loadNextChar();
                    return XMLEntityHandler.CONTENT_RESULT_START_OF_COMMENT;
                }
                break;
            }
            if (ch == '[') {
                for (int i = 0; i < 6; i++) {
                    ch = loadNextChar();
                    if (ch == -1) {
                        fCurrentOffset -= (3 + i);
                        loadNextChar();
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                    }
                    if (ch != cdata_string[i]) {
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
                    }
                }
                loadNextChar();
                return XMLEntityHandler.CONTENT_RESULT_START_OF_CDSECT;
            }
            break;
        case '/':
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG;
        default:
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ELEMENT;
        }
        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
    }
    private int recognizeReference(int ch) throws Exception {
        if (ch == -1) {
            return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
        }
        //
        // [67] Reference ::= EntityRef | CharRef
        // [68] EntityRef ::= '&' Name ';'
        // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
        //
        if (ch == '#') {
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_CHARREF;
        } else {
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ENTITYREF;
        }
    }
    public int scanContent(QName element) throws Exception {
        int ch = fMostRecentChar;
        if (ch == -1) {
            return changeReaders().scanContent(element);
        }
        int offset = fCurrentOffset;
        if (ch < 0x80) {
            switch (XMLCharacterProperties.fgAsciiWSCharData[ch]) {
            case 0:
                ch = loadNextChar();
                break;
            case 1:
                ch = loadNextChar();
                if (!fInCDSect) {
                    return recognizeMarkup(ch);
                }
                break;
            case 2:
                ch = loadNextChar();
                if (!fInCDSect) {
                    return recognizeReference(ch);
                }
                break;
            case 3:
                ch = loadNextChar();
                if (ch == ']' && fCurrentOffset + 1 < fEndOffset && fData.charAt(fCurrentOffset + 1) == '>') {
                    loadNextChar();
                    loadNextChar();
                    return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                }
                break;
            case 4:
                return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
            case 5:
                do {
                    ch = loadNextChar();
                    if (ch == -1) {
                        callCharDataHandler(offset, fEndOffset, true);
                        return changeReaders().scanContent(element);
                    }
                } while (ch == 0x20 || ch == 0x0A || ch == 0x0D || ch == 0x09);
                if (ch < 0x80) {
                    switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                    case 0:
                        ch = loadNextChar();
                        break;
                    case 1:
                        ch = loadNextChar();
                        if (!fInCDSect) {
                            callCharDataHandler(offset, fCurrentOffset - 1, true);
                            return recognizeMarkup(ch);
                        }
                        break;
                    case 2:
                        ch = loadNextChar();
                        if (!fInCDSect) {
                            callCharDataHandler(offset, fCurrentOffset - 1, true);
                            return recognizeReference(ch);
                        }
                        break;
                    case 3:
                        ch = loadNextChar();
                        if (ch == ']' && fCurrentOffset + 1 < fEndOffset && fData.charAt(fCurrentOffset + 1) == '>') {
                            callCharDataHandler(offset, fCurrentOffset - 1, true);
                            loadNextChar();
                            loadNextChar();
                            return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                        }
                        break;
                    case 4:
                        callCharDataHandler(offset, fCurrentOffset, true);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                } else {
                    if (ch == 0xFFFE || ch == 0xFFFF) {
                        callCharDataHandler(offset, fCurrentOffset, true);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                    ch = loadNextChar();
                }
            }
        } else {
            if (ch == 0xFFFE || ch == 0xFFFF) {
                callCharDataHandler(offset, fCurrentOffset, false);
                return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
            }
            ch = loadNextChar();
        }
        while (true) {
            if (ch == -1) {
                callCharDataHandler(offset, fEndOffset, false);
                return changeReaders().scanContent(element);
            }
            if (ch >= 0x80)
                break;
            if (XMLCharacterProperties.fgAsciiCharData[ch] != 0)
                break;
            ch = loadNextChar();
        }
        while (true) { // REVISIT - EOF check ?
            if (ch < 0x80) {
                switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                case 0:
                    ch = loadNextChar();
                    break;
                case 1:
                    ch = loadNextChar();
                    if (!fInCDSect) {
                        callCharDataHandler(offset, fCurrentOffset - 1, false);
                        return recognizeMarkup(ch);
                    }
                    break;
                case 2:
                    ch = loadNextChar();
                    if (!fInCDSect) {
                        callCharDataHandler(offset, fCurrentOffset - 1, false);
                        return recognizeReference(ch);
                    }
                    break;
                case 3:
                    ch = loadNextChar();
                    if (ch == ']' && fCurrentOffset + 1 < fEndOffset && fData.charAt(fCurrentOffset + 1) == '>') {
                        callCharDataHandler(offset, fCurrentOffset - 1, false);
                        loadNextChar();
                        loadNextChar();
                        return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                    }
                    break;
                case 4:
                    callCharDataHandler(offset, fCurrentOffset, false);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            } else {
                if (ch == 0xFFFE || ch == 0xFFFF) {
                    callCharDataHandler(offset, fCurrentOffset, false);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
                ch = loadNextChar();
            }
            if (ch == -1) {
                callCharDataHandler(offset, fCurrentOffset, false);
                return changeReaders().scanContent(element);
            }
        }
    }
    //
    //
    //
    private void callCharDataHandler(int offset, int endOffset, boolean isWhitespace) throws Exception {
        int length = endOffset - offset;
        if (!fSendCharDataAsCharArray) {
            int stringIndex = addString(offset, length);
            if (isWhitespace)
                fCharDataHandler.processWhitespace(stringIndex);
            else
                fCharDataHandler.processCharacters(stringIndex);
            return;
        }
        if (isWhitespace)
            fCharDataHandler.processWhitespace(fData.toCharArray(), offset, length);
        else
            fCharDataHandler.processCharacters(fData.toCharArray(), offset, length);
    }
    //
    //
    //
    private static final char[] cdata_string = { 'C','D','A','T','A','[' };
    //
    //
    //
    private StringPool fStringPool = null;
    private String fData = null;
    private int fEndOffset;
    private boolean hadTrailingSpace = false;
    private boolean oweTrailingSpace = false;
    private int fMostRecentChar;
    private StringReader fNextFreeReader = null;
    private static StringReader fgFreeReaders = null;
    private boolean fCalledCharPropInit = false;
}
"
org/xml/sax/InputSource.java,true,"// SAX input source.
// No warranty; no copyright -- use this as you will.
// $Id: InputSource.java,v 1.5 2000/05/05 17:46:48 david Exp $

package org.xml.sax;

import java.io.Reader;
import java.io.InputStream;

/**
 * A single input source for an XML entity.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This class allows a SAX application to encapsulate information
 * about an input source in a single object, which may include
 * a public identifier, a system identifier, a byte stream (possibly
 * with a specified encoding), and/or a character stream.</p>
 *
 * <p>There are two places that the application will deliver this
 * input source to the parser: as the argument to the Parser.parse
 * method, or as the return value of the EntityResolver.resolveEntity
 * method.</p>
 *
 * <p>The SAX parser will use the InputSource object to determine how
 * to read XML input.  If there is a character stream available, the
 * parser will read that stream directly; if not, the parser will use
 * a byte stream, if available; if neither a character stream nor a
 * byte stream is available, the parser will attempt to open a URI
 * connection to the resource identified by the system
 * identifier.</p>
 *
 * <p>An InputSource object belongs to the application: the SAX parser
 * shall never modify it in any way (it may modify a copy if 
 * necessary).</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser#parse
 * @see org.xml.sax.EntityResolver#resolveEntity
 * @see java.io.InputStream
 * @see java.io.Reader
 */
public class InputSource {
    
    /**
     * Zero-argument default constructor.
     *
     * @see #setPublicId
     * @see #setSystemId
     * @see #setByteStream
     * @see #setCharacterStream
     * @see #setEncoding
     */
    public InputSource ()
    {
    }
    
    
    /**
     * Create a new input source with a system identifier.
     *
     * <p>Applications may use setPublicId to include a 
     * public identifier as well, or setEncoding to specify
     * the character encoding, if known.</p>
     *
     * <p>If the system identifier is a URL, it must be full resolved.</p>
     *
     * @param systemId The system identifier (URI).
     * @see #setPublicId
     * @see #setSystemId
     * @see #setByteStream
     * @see #setEncoding
     * @see #setCharacterStream
     */
    public InputSource (String systemId)
    {
	setSystemId(systemId);
    }
    
    
    /**
     * Create a new input source with a byte stream.
     *
     * <p>Application writers may use setSystemId to provide a base 
     * for resolving relative URIs, setPublicId to include a 
     * public identifier, and/or setEncoding to specify the object's
     * character encoding.</p>
     *
     * @param byteStream The raw byte stream containing the document.
     * @see #setPublicId
     * @see #setSystemId
     * @see #setEncoding
     * @see #setByteStream
     * @see #setCharacterStream
     */
    public InputSource (InputStream byteStream)
    {
	setByteStream(byteStream);
    }
    
    
    /**
     * Create a new input source with a character stream.
     *
     * <p>Application writers may use setSystemId() to provide a base 
     * for resolving relative URIs, and setPublicId to include a 
     * public identifier.</p>
     *
     * <p>The character stream shall not include a byte order mark.</p>
     *
     * @see #setPublicId
     * @see #setSystemId
     * @see #setByteStream
     * @see #setCharacterStream
     */
    public InputSource (Reader characterStream)
    {
	setCharacterStream(characterStream);
    }
    
    
    /**
     * Set the public identifier for this input source.
     *
     * <p>The public identifier is always optional: if the application
     * writer includes one, it will be provided as part of the
     * location information.</p>
     *
     * @param publicId The public identifier as a string.
     * @see #getPublicId
     * @see org.xml.sax.Locator#getPublicId
     * @see org.xml.sax.SAXParseException#getPublicId
     */
    public void setPublicId (String publicId)
    {
	this.publicId = publicId;
    }
    
    
    /**
     * Get the public identifier for this input source.
     *
     * @return The public identifier, or null if none was supplied.
     * @see #setPublicId
     */
    public String getPublicId ()
    {
	return publicId;
    }
    
    
    /**
     * Set the system identifier for this input source.
     *
     * <p>The system identifier is optional if there is a byte stream
     * or a character stream, but it is still useful to provide one,
     * since the application can use it to resolve relative URIs
     * and can include it in error messages and warnings (the parser
     * will attempt to open a connection to the URI only if
     * there is no byte stream or character stream specified).</p>
     *
     * <p>If the application knows the character encoding of the
     * object pointed to by the system identifier, it can register
     * the encoding using the setEncoding method.</p>
     *
     * <p>If the system ID is a URL, it must be fully resolved.</p>
     *
     * @param systemId The system identifier as a string.
     * @see #setEncoding
     * @see #getSystemId
     * @see org.xml.sax.Locator#getSystemId
     * @see org.xml.sax.SAXParseException#getSystemId
     */
    public void setSystemId (String systemId)
    {
	this.systemId = systemId;
    }
    
    
    /**
     * Get the system identifier for this input source.
     *
     * <p>The getEncoding method will return the character encoding
     * of the object pointed to, or null if unknown.</p>
     *
     * <p>If the system ID is a URL, it will be fully resolved.</p>
     *
     * @return The system identifier.
     * @see #setSystemId
     * @see #getEncoding
     */
    public String getSystemId ()
    {
	return systemId;
    }
    
    
    /**
     * Set the byte stream for this input source.
     *
     * <p>The SAX parser will ignore this if there is also a character
     * stream specified, but it will use a byte stream in preference
     * to opening a URI connection itself.</p>
     *
     * <p>If the application knows the character encoding of the
     * byte stream, it should set it with the setEncoding method.</p>
     *
     * @param byteStream A byte stream containing an XML document or
     *        other entity.
     * @see #setEncoding
     * @see #getByteStream
     * @see #getEncoding
     * @see java.io.InputStream
     */
    public void setByteStream (InputStream byteStream)
    {
	this.byteStream = byteStream;
    }
    
    
    /**
     * Get the byte stream for this input source.
     *
     * <p>The getEncoding method will return the character
     * encoding for this byte stream, or null if unknown.</p>
     *
     * @return The byte stream, or null if none was supplied.
     * @see #getEncoding
     * @see #setByteStream
     */
    public InputStream getByteStream ()
    {
	return byteStream;
    }
    
    
    /** 
     * Set the character encoding, if known.
     *
     * <p>The encoding must be a string acceptable for an
     * XML encoding declaration (see section 4.3.3 of the XML 1.0
     * recommendation).</p>
     *
     * <p>This method has no effect when the application provides a
     * character stream.</p>
     *
     * @param encoding A string describing the character encoding.
     * @see #setSystemId
     * @see #setByteStream
     * @see #getEncoding
     */
    public void setEncoding (String encoding)
    {
	this.encoding = encoding;
    }
    
    
    /**
     * Get the character encoding for a byte stream or URI.
     *
     * @return The encoding, or null if none was supplied.
     * @see #setByteStream
     * @see #getSystemId
     * @see #getByteStream
     */
    public String getEncoding ()
    {
	return encoding;
    }
    
    
    /**
     * Set the character stream for this input source.
     *
     * <p>If there is a character stream specified, the SAX parser
     * will ignore any byte stream and will not attempt to open
     * a URI connection to the system identifier.</p>
     *
     * @param characterStream The character stream containing the
     *        XML document or other entity.
     * @see #getCharacterStream
     * @see java.io.Reader
     */
    public void setCharacterStream (Reader characterStream)
    {
	this.characterStream = characterStream;
    }
    
    
    /**
     * Get the character stream for this input source.
     *
     * @return The character stream, or null if none was supplied.
     * @see #setCharacterStream
     */
    public Reader getCharacterStream ()
    {
	return characterStream;
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Internal state.
    ////////////////////////////////////////////////////////////////////
    
    private String publicId;
    private String systemId;
    private InputStream byteStream;
    private String encoding;
    private Reader characterStream;
    
}

// end of InputSource.java
"
org/apache/xerces/validators/datatype/UnknownFacetException.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
 
package org.apache.xerces.validators.datatype;

/**
 * UnknownFacetException is thrown when a facet which not one of the datatype facets
 * is supplied to a datatype validator.
 */
public class UnknownFacetException
    extends Exception {

    public UnknownFacetException() { super(); }
    public UnknownFacetException(String msg) { super(msg); }

}
"
org/apache/xerces/dom/DeferredAttrImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

/*
 * WARNING: because java doesn't support multi-inheritance some code is
 * duplicated. If you're changing this file you probably want to change
 * DeferredAttrNSImpl.java at the same time.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

import org.apache.xerces.utils.StringPool;

/**
 * Attribute represents an XML-style attribute of an
 * Element. Typically, the allowable values are controlled by its
 * declaration in the Document Type Definition (DTD) governing this
 * kind of document.
 * <P>
 * If the attribute has not been explicitly assigned a value, but has
 * been declared in the DTD, it will exist and have that default. Only
 * if neither the document nor the DTD specifies a value will the
 * Attribute really be considered absent and have no value; in that
 * case, querying the attribute will return null.
 * <P>
 * Attributes may have multiple children that contain their data. (XML
 * allows attributes to contain entity references, and tokenized
 * attribute types such as NMTOKENS may have a child for each token.)
 * For convenience, the Attribute object's getValue() method returns
 * the string version of the attribute's value.
 * <P>
 * Attributes are not children of the Elements they belong to, in the
 * usual sense, and have no valid Parent reference. However, the spec
 * says they _do_ belong to a specific Element, and an INUSE exception
 * is to be thrown if the user attempts to explicitly share them
 * between elements.
 * <P>
 * Note that Elements do not permit attributes to appear to be shared
 * (see the INUSE exception), so this object's mutability is
 * officially not an issue.
 * <P>
 * DeferredAttrImpl inherits from AttrImpl which does not support
 * Namespaces. DeferredAttrNSImpl, which inherits from AttrNSImpl, does.
 * @see DeferredAttrNSImpl
 *
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public final class DeferredAttrImpl
    extends AttrImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 6903232312469148636L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredAttrImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);
        syncChildren(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl) this.ownerDocument;
        int elementTypeName = ownerDocument.getNodeName(fNodeIndex);
        StringPool pool = ownerDocument.getStringPool();
        name = pool.toString(elementTypeName);
        specified(ownerDocument.getNodeValue(fNodeIndex) == 1);

    } // synchronizeData()

    /**
     * Synchronizes the node's children with the internal structure.
     * Fluffing the children at once solves a lot of work to keep
     * the two structures in sync. The problem gets worse when
     * editing the tree -- this makes it a lot easier.
     */
    protected void synchronizeChildren() {
        synchronizeChildren(fNodeIndex);
    } // synchronizeChildren()

} // class DeferredAttrImpl
"
org/apache/xerces/utils/StringHasher.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

/**
 * Algorithm used to hash char arrays (strings).
 *
 * This class was created after it was discovered that parsing some
 * documents was unexpectedly slow due to many different strings
 * hashing to the same 32-bit value using the java.lang.String hash
 * algorithm.
 *
 * The trick seems to be the shift of the top eight bits of the hashcode
 * back down to the bottom to keep them from being rolled out.
 *
 * @version
 */
public final class StringHasher {
    /**
     * generate a hashcode for a String
     *
     * @param str the String to hash
     * @param strLength the length of the String to hash
     * @return hashcode for the String
     */
    public static int hashString(String str, int strLength) {
        int hashcode = 0;
        for (int i = 0; i < strLength; i++) {
            int top = hashcode >> 24;
            hashcode += ((hashcode * 37) + top + ((int)str.charAt(i)));
        }
        hashcode = (hashcode & 0x7fffffff);
        return (hashcode == 0) ? 1 : hashcode;
    }
    /**
     * generate a hashcode for a character array
     *
     * @param chars the array to hash
     * @param offset the offset to start hashing
     * @param length the length of characters to hash
     * @return hashcode for the character array
     */
    public static int hashChars(char[] chars, int offset, int length) {
        int hashcode = 0;
        for (int i = 0; i < length; i++) {
            int top = hashcode >> 24;
            hashcode += ((hashcode * 37) + top + ((int)(chars[offset++] & 0xFFFF)));
        }
        hashcode = (hashcode & 0x7fffffff);
        return (hashcode == 0) ? 1 : hashcode;
    }
    /**
     * generate partially completed character hashcode.
     * this is mean to be iterated over individual characters in order to generate
     * a full hash value
     * @see #finishHash(int)
     *
     * @param hashcode a partially completed character hashcode
     * @param ch the character to hash
     * @return a partially completed character hashcode
     */
    public static int hashChar(int hashcode, int ch) {
        int top = hashcode >> 24;
        hashcode += ((hashcode * 37) + top + ch);
        return hashcode;
    }
    /**
     * finish hashing a partically completed character hashcode
     * @see #hashChar(int,int)
     * 
     * @param hashcode a partially completed character hashcode
     * @return a character hashcode
     */
    public static int finishHash(int hashcode) {
        hashcode = (hashcode & 0x7fffffff);
        return (hashcode == 0) ? 1 : hashcode;
    }
}
"
org/xml/sax/HandlerBase.java,true,"// SAX default handler base class.
// No warranty; no copyright -- use this as you will.
// $Id: HandlerBase.java,v 1.5 2000/05/05 17:46:37 david Exp $

package org.xml.sax;

/**
 * Default base class for handlers.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This class implements the default behaviour for four SAX1
 * interfaces: EntityResolver, DTDHandler, DocumentHandler,
 * and ErrorHandler.  It is now obsolete, but is included in SAX2 to
 * support legacy SAX1 applications.  SAX2 applications should use
 * the {@link org.xml.sax.helpers.DefaultHandler DefaultHandler}
 * class instead.</p>
 *
 * <p>Application writers can extend this class when they need to
 * implement only part of an interface; parser writers can
 * instantiate this class to provide default handlers when the
 * application has not supplied its own.</p>
 *
 * <p>Note that the use of this class is optional.</p>
 *
 * @deprecated This class works with the deprecated
 *             {@link org.xml.sax.DocumentHandler DocumentHandler}
 *             interface.  It has been replaced by the SAX2
 *             {@link org.xml.sax.helpers.DefaultHandler DefaultHandler}
 *             class.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.EntityResolver
 * @see org.xml.sax.DTDHandler
 * @see org.xml.sax.DocumentHandler
 * @see org.xml.sax.ErrorHandler
 */
public class HandlerBase
    implements EntityResolver, DTDHandler, DocumentHandler, ErrorHandler
{
    

    ////////////////////////////////////////////////////////////////////
    // Default implementation of the EntityResolver interface.
    ////////////////////////////////////////////////////////////////////
    
    /**
     * Resolve an external entity.
     *
     * <p>Always return null, so that the parser will use the system
     * identifier provided in the XML document.  This method implements
     * the SAX default behaviour: application writers can override it
     * in a subclass to do special translations such as catalog lookups
     * or URI redirection.</p>
     *
     * @param publicId The public identifer, or null if none is
     *                 available.
     * @param systemId The system identifier provided in the XML 
     *                 document.
     * @return The new input source, or null to require the
     *         default behaviour.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.EntityResolver#resolveEntity
     */
    public InputSource resolveEntity (String publicId, String systemId)
	throws SAXException
    {
	return null;
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Default implementation of DTDHandler interface.
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Receive notification of a notation declaration.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass if they wish to keep track of the notations
     * declared in a document.</p>
     *
     * @param name The notation name.
     * @param publicId The notation public identifier, or null if not
     *                 available.
     * @param systemId The notation system identifier.
     * @see org.xml.sax.DTDHandler#notationDecl
     */
    public void notationDecl (String name, String publicId, String systemId)
    {
	// no op
    }
    
    
    /**
     * Receive notification of an unparsed entity declaration.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to keep track of the unparsed entities
     * declared in a document.</p>
     *
     * @param name The entity name.
     * @param publicId The entity public identifier, or null if not
     *                 available.
     * @param systemId The entity system identifier.
     * @param notationName The name of the associated notation.
     * @see org.xml.sax.DTDHandler#unparsedEntityDecl
     */
    public void unparsedEntityDecl (String name, String publicId,
				    String systemId, String notationName)
    {
	// no op
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Default implementation of DocumentHandler interface.
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Receive a Locator object for document events.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass if they wish to store the locator for use
     * with other document events.</p>
     *
     * @param locator A locator for all SAX document events.
     * @see org.xml.sax.DocumentHandler#setDocumentLocator
     * @see org.xml.sax.Locator
     */
    public void setDocumentLocator (Locator locator)
    {
	// no op
    }
    
    
    /**
     * Receive notification of the beginning of the document.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to take specific actions at the beginning
     * of a document (such as allocating the root node of a tree or
     * creating an output file).</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#startDocument
     */
    public void startDocument ()
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of the end of the document.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to take specific actions at the beginning
     * of a document (such as finalising a tree or closing an output
     * file).</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#endDocument
     */
    public void endDocument ()
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of the start of an element.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to take specific actions at the start of
     * each element (such as allocating a new tree node or writing
     * output to a file).</p>
     *
     * @param name The element type name.
     * @param attributes The specified or defaulted attributes.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#startElement
     */
    public void startElement (String name, AttributeList attributes)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of the end of an element.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to take specific actions at the end of
     * each element (such as finalising a tree node or writing
     * output to a file).</p>
     *
     * @param name The element type name.
     * @param attributes The specified or defaulted attributes.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#endElement
     */
    public void endElement (String name)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of character data inside an element.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method to take specific actions for each chunk of character data
     * (such as adding the data to a node or buffer, or printing it to
     * a file).</p>
     *
     * @param ch The characters.
     * @param start The start position in the character array.
     * @param length The number of characters to use from the
     *               character array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#characters
     */
    public void characters (char ch[], int start, int length)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of ignorable whitespace in element content.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method to take specific actions for each chunk of ignorable
     * whitespace (such as adding data to a node or buffer, or printing
     * it to a file).</p>
     *
     * @param ch The whitespace characters.
     * @param start The start position in the character array.
     * @param length The number of characters to use from the
     *               character array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#ignorableWhitespace
     */
    public void ignorableWhitespace (char ch[], int start, int length)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of a processing instruction.
     *
     * <p>By default, do nothing.  Application writers may override this
     * method in a subclass to take specific actions for each
     * processing instruction, such as setting status variables or
     * invoking other methods.</p>
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if
     *             none is supplied.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.DocumentHandler#processingInstruction
     */
    public void processingInstruction (String target, String data)
	throws SAXException
    {
	// no op
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Default implementation of the ErrorHandler interface.
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Receive notification of a parser warning.
     *
     * <p>The default implementation does nothing.  Application writers
     * may override this method in a subclass to take specific actions
     * for each warning, such as inserting the message in a log file or
     * printing it to the console.</p>
     *
     * @param e The warning information encoded as an exception.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.ErrorHandler#warning
     * @see org.xml.sax.SAXParseException
     */
    public void warning (SAXParseException e)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Receive notification of a recoverable parser error.
     *
     * <p>The default implementation does nothing.  Application writers
     * may override this method in a subclass to take specific actions
     * for each error, such as inserting the message in a log file or
     * printing it to the console.</p>
     *
     * @param e The warning information encoded as an exception.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.ErrorHandler#warning
     * @see org.xml.sax.SAXParseException
     */
    public void error (SAXParseException e)
	throws SAXException
    {
	// no op
    }
    
    
    /**
     * Report a fatal XML parsing error.
     *
     * <p>The default implementation throws a SAXParseException.
     * Application writers may override this method in a subclass if
     * they need to take specific actions for each fatal error (such as
     * collecting all of the errors into a single report): in any case,
     * the application must stop all regular processing when this
     * method is invoked, since the document is no longer reliable, and
     * the parser may no longer report parsing events.</p>
     *
     * @param e The error information encoded as an exception.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.ErrorHandler#fatalError
     * @see org.xml.sax.SAXParseException
     */
    public void fatalError (SAXParseException e)
	throws SAXException
    {
	throw e;
    }
    
}

// end of HandlerBase.java
"
org/xml/sax/helpers/ParserFactory.java,true,"// SAX parser factory.
// No warranty; no copyright -- use this as you will.
// $Id: ParserFactory.java,v 1.4 2000/05/05 17:50:13 david Exp $

package org.xml.sax.helpers;

import java.lang.ClassNotFoundException;
import java.lang.IllegalAccessException;
import java.lang.InstantiationException;
import java.lang.SecurityException;
import java.lang.ClassCastException;

import org.xml.sax.Parser;


/**
 * Java-specific class for dynamically loading SAX parsers.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p><strong>Note:</strong> This class is designed to work with the now-deprecated
 * SAX1 {@link org.xml.sax.Parser Parser} class.  SAX2 applications should use
 * {@link org.xml.sax.helpers.XMLReaderFactory XMLReaderFactory} instead.</p>
 *
 * <p>ParserFactory is not part of the platform-independent definition
 * of SAX; it is an additional convenience class designed
 * specifically for Java XML application writers.  SAX applications
 * can use the static methods in this class to allocate a SAX parser
 * dynamically at run-time based either on the value of the
 * `org.xml.sax.parser' system property or on a string containing the class
 * name.</p>
 *
 * <p>Note that the application still requires an XML parser that
 * implements SAX1.</p>
 *
 * @deprecated This class works with the deprecated
 *             {@link org.xml.sax.Parser Parser}
 *             interface.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser
 * @see java.lang.Class
 */
public class ParserFactory {
    
    
    /**
     * Private null constructor.
     */
    private ParserFactory ()
    {
    }
    
    
    /**
     * Create a new SAX parser using the `org.xml.sax.parser' system property.
     *
     * <p>The named class must exist and must implement the
     * {@link org.xml.sax.Parser Parser} interface.</p>
     *
     * @exception java.lang.NullPointerException There is no value
     *            for the `org.xml.sax.parser' system property.
     * @exception java.lang.ClassNotFoundException The SAX parser
     *            class was not found (check your CLASSPATH).
     * @exception IllegalAccessException The SAX parser class was
     *            found, but you do not have permission to load
     *            it.
     * @exception InstantiationException The SAX parser class was
     *            found but could not be instantiated.
     * @exception java.lang.ClassCastException The SAX parser class
     *            was found and instantiated, but does not implement
     *            org.xml.sax.Parser.
     * @see #makeParser(java.lang.String)
     * @see org.xml.sax.Parser
     */
    public static Parser makeParser ()
	throws ClassNotFoundException,
	IllegalAccessException, 
	InstantiationException,
	NullPointerException,
	ClassCastException
    {
	String className = System.getProperty(""org.xml.sax.parser"");
	if (className == null) {
	    throw new NullPointerException(""No value for sax.parser property"");
	} else {
	    return makeParser(className);
	}
    }
    
    
    /**
     * Create a new SAX parser object using the class name provided.
     *
     * <p>The named class must exist and must implement the
     * {@link org.xml.sax.Parser Parser} interface.</p>
     *
     * @param className A string containing the name of the
     *                  SAX parser class.
     * @exception java.lang.ClassNotFoundException The SAX parser
     *            class was not found (check your CLASSPATH).
     * @exception IllegalAccessException The SAX parser class was
     *            found, but you do not have permission to load
     *            it.
     * @exception InstantiationException The SAX parser class was
     *            found but could not be instantiated.
     * @exception java.lang.ClassCastException The SAX parser class
     *            was found and instantiated, but does not implement
     *            org.xml.sax.Parser.
     * @see #makeParser()
     * @see org.xml.sax.Parser
     */
    public static Parser makeParser (String className)
	throws ClassNotFoundException,
	IllegalAccessException, 
	InstantiationException,
	ClassCastException
    {
	return (Parser)(Class.forName(className).newInstance());
    }
    
}

// end of ParserFactory.java
"
org/apache/xerces/validators/datatype/IllegalFacetException.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
 
package org.apache.xerces.validators.datatype;

/**
 * IllegalFacetException is thrown when the supplied facet is not allowed 
 * for a datatype
 */
public class IllegalFacetException
    extends Exception {

    public IllegalFacetException() { super(); }
    public IllegalFacetException(String msg) { super(msg); }

}
"
org/apache/xerces/validators/schema/DatatypeContentModel.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.schema;

import org.apache.xerces.framework.XMLContentSpec;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.validators.common.Grammar;
import org.apache.xerces.validators.common.XMLContentModel;
import org.apache.xerces.validators.common.InsertableElementsInfo;
import org.apache.xerces.validators.datatype.DatatypeValidator;
import org.apache.xerces.validators.datatype.InvalidDatatypeValueException;
import org.apache.xerces.utils.QName;

/**
 * DatatypeContentModel provides a content model that knows
 * how to check content against datatypes
 * @version $Id:
 */
public class DatatypeContentModel implements XMLContentModel
{
    TraverseSchema.DatatypeValidatorRegistry fDatatypeRegistry = null;
    Grammar fGrammar = null;
    StringPool fStringPool = null;
    int fChild = -1;

    // -----------------------------------------------------------------------
    //  Constructors
    // -----------------------------------------------------------------------

    /**
     */
    public DatatypeContentModel(  TraverseSchema.DatatypeValidatorRegistry reg,
                                  Grammar grammar,
                                  StringPool stringPool,
                                  int childIndex)
    {
        fDatatypeRegistry = reg;
        fGrammar = grammar;
        fStringPool = stringPool;
        fChild = childIndex;
    }


    // -----------------------------------------------------------------------
    //  Public, inherited methods
    // -----------------------------------------------------------------------
    
    /**
     * Check that the specified content is valid according to this
     * content model. This method can also be called to do 'what if' 
     * testing of content models just to see if they would be valid.
     * <p>
     * A value of -1 in the children array indicates a PCDATA node. All other 
     * indexes will be positive and represent child elements. The count can be
     * zero, since some elements have the EMPTY content model and that must be 
     * confirmed.
     *
     * @param childCount The number of entries in the <code>children</code> array.
     * @param children The children of this element.  Each integer is an index within
     *                 the <code>StringPool</code> of the child element name.  An index
     *                 of -1 is used to indicate an occurrence of non-whitespace character
     *                 data.
     *
     * @return The value -1 if fully valid, else the 0 based index of the child
     *         that first failed. If the value returned is equal to the number
     *         of children, then the specified children are valid but additional
     *         content is required to reach a valid ending state.
     *
     * @exception Exception Thrown on error.
     */
    public int validateContent(int childCount, QName[] children) throws Exception
    {
        boolean DEBUG_DATATYPES = false;
/*
        if (DEBUG_DATATYPES) {
            System.out.println(""Checking content of datatype"");
            String strTmp = fStringPool.toString(elementTypeIndex);
            int contentSpecIndex = fElementDeclPool.getContentSpec(elementIndex);
            XMLContentSpec csn = new XMLContentSpec();
            fElementDeclPool.getContentSpecNode(contentSpecIndex, csn);
            String contentSpecString = fStringPool.toString(csn.value);
            System.out.println
            (
                ""Name: ""
                + strTmp
                + "", Count: ""
                + childCount
                + "", ContentSpec: ""
                + contentSpecString
            );
            for (int index = 0; index < childCount && index < 10; index++) {
                if (index == 0) System.out.print(""  ("");
                String childName = (children[index] == -1) ? ""#PCDATA"" : fStringPool.toString(children[index]);
                if (index + 1 == childCount)
                    System.out.println(childName + "")"");
                else if (index + 1 == 10)
                    System.out.println(childName + "",...)"");
                else
                    System.out.print(childName + "","");
            }
        }
*/
        try { // REVISIT - integrate w/ error handling
            XMLContentSpec cs = new XMLContentSpec();
	    fGrammar.getContentSpec(fChild,cs);
            String type = fStringPool.toString(cs.value);
            DatatypeValidator v = fDatatypeRegistry.getValidatorFor(type);
            if (v != null) 
                v.validate(fStringPool.toString(children[0].localpart));
            else
                System.out.println(""No validator for datatype ""+type);
        } catch (InvalidDatatypeValueException idve) {
            throw idve;
            // System.out.println(""Incorrect datatype: ""+idve.getMessage());
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(""Internal error in datatype validation"");
        }
        return -1;
/*
        //
        //  According to the type of operation, we do the correct type of
        //  content check.
        //
        switch(fOp)
        {
            case XMLContentSpec.CONTENTSPECNODE_LEAF :
                // If there is not a child, then report an error at index 0
                if (childCount == 0)
                    return 0;

                // If the 0th child is not the right kind, report an error at 0
                if (children[0] != fFirstChild)
                    return 0;

                // If more than one child, report an error at index 1
                if (childCount > 1)
                    return 1;
                break;

            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE :
                //
                //  If there is one child, make sure its the right type. If not,
                //  then its an error at index 0.
                //
                if ((childCount == 1) && (children[0] != fFirstChild))
                    return 0;

                //
                //  If the child count is greater than one, then obviously
                //  bad, so report an error at index 1.
                //
                if (childCount > 1)
                    return 1;
                break;

            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE :
                //
                //  If the child count is zero, that's fine. If its more than
                //  zero, then make sure that all children are of the element
                //  type that we stored. If not, report the index of the first
                //  failed one.
                //
                if (childCount > 0)
                {
                    for (int index = 0; index < childCount; index++)
                    {
                        if (children[index] != fFirstChild)
                            return index;
                    }
                }
                break;

            case XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE :
                //
                //  If the child count is zero, that's an error so report
                //  an error at index 0.
                //
                if (childCount == 0)
                    return 0;

                //
                //  Otherwise we have to check them all to make sure that they
                //  are of the correct child type. If not, then report the index
                //  of the first one that is not.
                //
                for (int index = 0; index < childCount; index++)
                {
                    if (children[index] != fFirstChild)
                        return index;
                }
                break;

            case XMLContentSpec.CONTENTSPECNODE_CHOICE :
                //
                //  There must be one and only one child, so if the element count
                //  is zero, return an error at index 0.
                //
                if (childCount == 0)
                    return 0;

                // If the zeroth element isn't one of our choices, error at 0
                if ((children[0] != fFirstChild) && (children[0] != fSecondChild))
                    return 0;

                // If there is more than one element, then an error at 1
                if (childCount > 1)
                    return 1;
                break;

            case XMLContentSpec.CONTENTSPECNODE_SEQ :
                //
                //  There must be two children and they must be the two values
                //  we stored, in the stored order.
                //
                if (childCount == 2) {
                    if (children[0] != fFirstChild)
                        return 0;

                    if (children[1] != fSecondChild)
                        return 1;
                }
                else {
                    if (childCount > 2) {
                        return 2;
                    }

                    return childCount;
                }

                break;

            default :
                throw new CMException(ErrorCode.VAL_CST);
        }

        // We survived, so return success status
        return -1;
*/
    }

    /**
     * Returns information about which elements can be placed at a particular point
     * in the passed element's content model.
     * <p>
     * Note that the incoming content model to test must be valid at least up to
     * the insertion point. If not, then -1 will be returned and the info object
     * will not have been filled in.
     * <p>
     * If, on return, the info.isValidEOC flag is set, then the 'insert after'
     * element is a valid end of content. In other words, nothing needs to be
     * inserted after it to make the parent element's content model valid.
     *
     * @param fullyValid Only return elements that can be inserted and still
     *                   maintain the validity of subsequent elements past the
     *                   insertion point (if any).  If the insertion point is at
     *                   the end, and this is true, then only elements that can
     *                   be legal final states will be returned.
     * @param info An object that contains the required input data for the method,
     *             and which will contain the output information if successful.
     *
     * @return The value -1 if fully valid, else the 0 based index of the child
     *         that first failed before the insertion point. If the value 
     *         returned is equal to the number of children, then the specified
     *         children are valid but additional content is required to reach a
     *         valid ending state.
     *
     * @see InsertableElementsInfo
     */
    public int whatCanGoHere(boolean                    fullyValid
                            , InsertableElementsInfo    info) throws Exception
    {
        return -1;
/*
        //
        //  For this one, having the empty slot at the insertion point is 
        //  a problem. So lets compress the array down. We know that it has
        //  to have at least the empty slot at the insertion point.
        //
        for (int index = info.insertAt; index < info.childCount; index++)
            info.curChildren[index] = info.curChildren[index+1];
        info.childCount--;
        
        //
        //  Check the validity of the existing contents. If this is less than
        //  the insert at point, then return failure index right now
        //
        final int failedIndex = validateContent(info.childCount, info.curChildren);
        if ((failedIndex != -1) && (failedIndex < info.insertAt))
            return failedIndex;

        // Set any stuff we can know right off the bat for all cases
        info.canHoldPCData = false;

        // See how many children we can possibly report
        if ((fOp == XMLContentSpec.CONTENTSPECNODE_LEAF)
        ||  (fOp == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE)
        ||  (fOp == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE)
        ||  (fOp == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE))
        {
            info.resultsCount = 1;
        }
         else if ((fOp == XMLContentSpec.CONTENTSPECNODE_CHOICE)
              ||  (fOp == XMLContentSpec.CONTENTSPECNODE_SEQ))
        {
            info.resultsCount = 2;
        }
         else
        {
            throw new CMException(ErrorCode.VAL_CST);
        }

        //
        //  If the outgoing arrays are too small or null, create new ones. These
        //  have to be at least the size of the results count.
        //
        if ((info.results == null) || (info.results.length < info.resultsCount))
            info.results = new boolean[info.resultsCount];

        if ((info.possibleChildren == null)
        ||  (info.possibleChildren.length < info.resultsCount))
        {
            info.possibleChildren = new int[info.resultsCount];
        }

        //
        //  Fill in the possible children array, and set all of the associated
        //  results entries to defaults of false.
        //
        info.possibleChildren[0] = fFirstChild;
        info.results[0] = false;
        if (info.resultsCount == 2)
        {
            info.possibleChildren[1] = fSecondChild;
            info.results[1] = false;
        }

        //
        //  Set some defaults so that it does not have to be done redundantly
        //  below in each case.
        //
        info.isValidEOC = false;

        //
        //  Now, for each spec type, lets do the grunt work required. Each of
        //  them is pretty simple, its just making sure of corner cases.
        //
        //  We know its valid up to the insert point at least and we know that
        //  the insert point is never past the number of children, so this releaves
        //  a lot of checking below.
        //
        switch(fOp)
        {
            case XMLContentSpec.CONTENTSPECNODE_LEAF :
            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE :
                //
                //  If there are no current children, then insert at has to be
                //  zero, so we can have the one leaf element inserted here.
                //
                if (info.childCount == 0)
                {
                    info.results[0] = true;
                }
                 else if (info.childCount > 0)
                {
                    //
                    //  If the child count is greater than zero, then inserting
                    //  anything cannot be fully valid. But, if not fully valid
                    //  checking, it is ok as long as inserting at zero.
                    //
                    if (!fullyValid && (info.insertAt == 0))
                        info.results[0] = true;
                }

                if (fOp == XMLContentSpec.CONTENTSPECNODE_LEAF)
                {
                    // If the insert point is 1, then EOC is valid there
                    if (info.insertAt == 0)
                        info.isValidEOC = true;
                }
                 else
                {
                    // Its zero or one, so EOC is valid in either case
                    info.isValidEOC = true;
                }
                break;

            case XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE :
            case XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE :
                //
                //  The one child is always possible to insert, regardless of
                //  where. The fully valid flag never comes into play since it
                //  cannot become invalid by inserting any number of new
                //  instances of the one element.
                //
                info.results[0] = true;

                //
                //  Its zero/one or more, so EOC is valid in either case but only
                //  after the 0th index for one or more.
                //
                if ((fOp == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE)
                ||  (info.insertAt > 0))
                {
                    info.isValidEOC = true;
                }
                break;

            case XMLContentSpec.CONTENTSPECNODE_CHOICE :
                //
                //  If the insert point is zero, then either of the two children
                //  can be inserted, unless fully valid is set and there are
                //  already any children.
                //
                if (info.insertAt == 0)
                {
                    if (!fullyValid && (info.childCount == 0))
                    {
                        info.results[0] = true;
                        info.results[1] = true;
                    }
                }

                // EOC is only valid at the end
                if (info.insertAt == 1)
                    info.isValidEOC = true;
                break;

            case XMLContentSpec.CONTENTSPECNODE_SEQ :
                //
                //  If the insert at is 0, then the first one valid. Else its
                //  the second one.
                //
                if (info.insertAt == 0)
                {
                    //
                    //  If fully valid check, then if there are two children,
                    //  it cannot be valid. If there is one child, it must be
                    //  equal to the second child of the pattern since it will
                    //  get pushed up (which means it was a pattern like (x|x)
                    //  which is kinda wierd.)
                    //
                    if (fullyValid)
                    {
                        if (info.childCount == 1)
                            info.results[0] = info.curChildren[0] == fSecondChild;
                    }
                     else
                    {
                        info.results[0] = true;
                    }
                }
                 else if (info.insertAt == 1)
                {
                    // If fully valid, then there cannot be two existing children
                    if (!fullyValid || (info.childCount == 1))
                        info.results[1] = true;
                }

                // EOC is only valid at the end
                if (info.insertAt == 2)
                    info.isValidEOC = true;
                break;

            default :
                throw new CMException(ErrorCode.VAL_CST);
        }

        // We survived, so return success status
        return -1;
  */
    }
  };
"
org/w3c/dom/ProcessingInstruction.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>ProcessingInstruction</code> interface represents a  ""processing 
 * instruction"", used in XML as a way to keep processor-specific information 
 * in the text of the document.
 */
public interface ProcessingInstruction extends Node {
    /**
     *  The target of this processing instruction. XML defines this as being 
     * the first token following the markup that begins the processing 
     * instruction.
     */
    public String getTarget();

    /**
     *  The content of this processing instruction. This is from the first non 
     * white space character after the target to the character immediately 
     * preceding the <code>?&gt;</code> .
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     */
    public String getData();
    public void setData(String data)
                          throws DOMException;

}

"
org/apache/xerces/msg/XMLMessages.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.msg;

import java.util.ListResourceBundle;

/**
 * This file contains error and warning messages related to XML
 * The messages are arranged in key and value tuples in a ListResourceBundle.
 *
 * @version
 */
public class XMLMessages extends ListResourceBundle {
    /** The list resource bundle contents. */
    public static final Object CONTENTS[][] = {
// Internal message formatter messages
        { ""BadMajorCode"", ""The majorCode parameter to createMessage was out of bounds."" },
        { ""FormatFailed"", ""An internal error occurred while formatting the following message:\n  "" },
// Document messages
    // 2.1 Well-Formed XML Documents
        { ""RootElementRequired"", ""The root element is required in a well-formed document."" },
    // 2.2 Characters
        { ""InvalidCharInCDSect"", ""An invalid XML character (Unicode: 0x{0}) was found in the CDATA section."" },
        { ""InvalidCharInContent"", ""An invalid XML character (Unicode: 0x{0}) was found in the element content of the document."" },
        { ""TwoColonsInQName"", ""An invalid second ':' was found in the element type or attribute name."" },
        { ""InvalidCharInMisc"", ""An invalid XML character (Unicode: 0x{0}) was found in markup after the end of the element content."" },
        { ""InvalidCharInProlog"", ""An invalid XML character (Unicode: 0x{0}) was found in the prolog of the document."" },
        { ""InvalidCharInXMLDecl"", ""An invalid XML character (Unicode: 0x{0}) was found in the XML declaration."" },
    // 2.4 Character Data and Markup
        { ""CDEndInContent"", ""The character sequence \""]]>\"" must not appear in content unless used to mark the end of a CDATA section."" },
    // 2.7 CDATA Sections
        { ""CDSectUnterminated"", ""The CDATA section must end with \""]]>\""."" },
    // 2.8 Prolog and Document Type Declaration
        { ""XMLDeclMustBeFirst"", ""The XML declaration may only appear at the very beginning of the document."" },
        { ""EqRequiredInXMLDecl"", ""The ''='' character must follow \""{0}\"" in the XML declaration."" },
        { ""QuoteRequiredInXMLDecl"",  ""The value following \""{0}\"" in the XML declaration must be a quoted string."" },
        { ""XMLDeclUnterminated"", ""The XML declaration must end with \""?>\""."" },
        { ""VersionInfoRequired"", ""The version is required in the XML declaration."" },
        { ""MarkupNotRecognizedInProlog"", ""The markup in the document preceding the root element must be well-formed."" },
        { ""MarkupNotRecognizedInMisc"", ""The markup in the document following the root element must be well-formed."" },
    // 2.9 Standalone Document Declaration
        { ""SDDeclInvalid"", ""The standalone document declaration value must be \""yes\"" or \""no\"", not \""{0}\""."" },
    // 2.12 Language Identification
        { ""XMLLangInvalid"", ""The xml:lang attribute value \""{0}\"" is an invalid language identifier."" },
    // 3. Logical Structures
        { ""ETagRequired"", ""The element type \""{0}\"" must be terminated by the matching end-tag \""</{0}>\""."" },
    // 3.1 Start-Tags, End-Tags, and Empty-Element Tags
        { ""ElementUnterminated"", ""Element type \""{0}\"" must be followed by either attribute specifications, \"">\"" or \""/>\""."" },
        { ""EqRequiredInAttribute"", ""Attribute name \""{0}\"" must be followed by the ''='' character."" },
        { ""AttributeNotUnique"", ""Attribute \""{1}\"" was already specified for element \""{0}\""."" },
        { ""ETagUnterminated"", ""The end-tag for element type \""{0}\"" must end with a ''>'' delimiter."" },
        { ""MarkupNotRecognizedInContent"", ""The content of elements must consist of well-formed character data or markup."" },
    // 4.1 Character and Entity References
        { ""ReferenceUnterminated"", ""The reference must be terminated by a ';' delimiter."" },
    // 4.3.2 Well-Formed Parsed Entities
        { ""ReferenceNotInOneEntity"", ""The reference must be entirely contained within the same parsed entity."" },
        { ""ElementEntityMismatch"", ""The element \""{0}\"" must start and end within the same entity."" },
// Messages common to Document and DTD
    // 2.2 Characters
        { ""InvalidCharInAttValue"", ""An invalid XML character (Unicode: 0x{2}) was found in the value of attribute \""{1}\""."" },
        { ""InvalidCharInComment"", ""An invalid XML character (Unicode: 0x{0}) was found in the comment."" },
        { ""InvalidCharInPI"", ""An invalid XML character (Unicode: 0x{0}) was found in the processing instruction."" },
        { ""InvalidCharInInternalSubset"", ""An invalid XML character (Unicode: 0x{0}) was found in the internal subset of the DTD."" },
        { ""InvalidCharInTextDecl"", ""An invalid XML character (Unicode: 0x{0}) was found in the text declaration."" },
    // 2.3 Common Syntactic Constructs
        { ""QuoteRequiredInAttValue"", ""The value of attribute \""{1}\"" must begin with either a single or double quote character."" },
        { ""LessthanInAttValue"", ""The value of attribute \""{1}\"" must not contain the ''<'' character."" },
        { ""AttributeValueUnterminated"", ""The value for attribute \""{1}\"" must end with the matching quote character."" },
    // 2.5 Comments
        { ""DashDashInComment"", ""The string \""--\"" is not permitted within comments."" },
        { ""CommentUnterminated"", ""The comment must end with \""-->\""."" },
    // 2.6 Processing Instructions
        { ""PITargetRequired"", ""The processing instruction must begin with the name of the target."" },
        { ""SpaceRequiredInPI"", ""White space is required between the processing instruction target and data."" },
        { ""PIUnterminated"", ""The processing instruction must end with \""?>\""."" },
        { ""ReservedPITarget"", ""The processing instruction target matching \""[xX][mM][lL]\"" is not allowed."" },
    // 2.8 Prolog and Document Type Declaration
        { ""VersionInfoInvalid"", ""Invalid version \""{0}\""."" },
        { ""VersionNotSupported"", ""XML version \""{0}\"" is not supported."" },
    // 4.1 Character and Entity References
        { ""DigitRequiredInCharRef"", ""A decimal representation must immediately follow the \""&#\"" in a character reference."" },
        { ""HexdigitRequiredInCharRef"", ""A hexadecimal representation must immediately follow the \""&#x\"" in a character reference."" },
        { ""SemicolonRequiredInCharRef"", ""The character reference must end with the ';' delimiter."" },
        { ""InvalidCharRef"", ""Character reference \""&#{0}\"" is an invalid XML character."" },
        { ""NameRequiredInReference"", ""The entity name must immediately follow the '&' in the entity reference."" },
        { ""SemicolonRequiredInReference"", ""The reference to entity \""{0}\"" must end with the '';'' delimiter."" },
    // 4.3.1 The Text Declaration
        { ""TextDeclMustBeFirst"", ""The text declaration may only appear at the very beginning of the external parsed entity."" },
        { ""EqRequiredInTextDecl"", ""The ''='' character must follow \""{0}\"" in the text declaration."" },
        { ""QuoteRequiredInTextDecl"", ""The value following \""{0}\"" in the text declaration must be a quoted string."" },
        { ""SpaceRequiredInTextDecl"", ""White space is required between the version and the encoding declaration."" },
        { ""TextDeclUnterminated"", ""The text declaration must end with \""?>\""."" },
        { ""EncodingDeclRequired"", ""The encoding declaration is required in the text declaration."" },
    // 4.3.2 Well-Formed Parsed Entities
        { ""CommentNotInOneEntity"", ""The comment must be entirely contained within the same parsed entity."" },
        { ""PINotInOneEntity"", ""The processing instruction must be entirely contained within the same parsed entity."" },
    // 4.3.3 Character Encoding in Entities
        { ""EncodingDeclInvalid"", ""Invalid encoding name \""{0}\""."" },
// DTD Messages
    // 2.2 Characters
        { ""InvalidCharInEntityValue"", ""An invalid XML character (Unicode: 0x{0}) was found in the literal entity value."" },
        { ""InvalidCharInExternalSubset"", ""An invalid XML character (Unicode: 0x{0}) was found in the external subset of the DTD."" },
        { ""InvalidCharInIgnoreSect"", ""An invalid XML character (Unicode: 0x{0}) was found in the excluded conditional section."" },
        { ""InvalidCharInPublicID"", ""An invalid XML character (Unicode: 0x{0}) was found in the public identifier."" },
        { ""InvalidCharInSystemID"", ""An invalid XML character (Unicode: 0x{0}) was found in the system identifier."" },
    // 2.3 Common Syntactic Constructs
        { ""QuoteRequiredInSystemID"", ""The system identifier must begin with either a single or double quote character."" },
        { ""SystemIDUnterminated"", ""The system identifier must end with the matching quote character."" },
        { ""QuoteRequiredInPublicID"", ""The public identifier must begin with either a single or double quote character."" },
        { ""PublicIDUnterminated"", ""The public identifier must end with the matching quote character."" },
        { ""PubidCharIllegal"", ""The character (Unicode: 0x{0}) is not permitted in the public identifier."" },
    // 2.8 Prolog and Document Type Declaration
        { ""MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL"", ""White space is required after \""<!DOCTYPE\"" in the document type declaration."" },
        { ""MSG_ROOT_ELEMENT_TYPE_REQUIRED"", ""The root element type must appear after \""<!DOCTYPE\"" in the document type declaration."" },
        { ""DoctypedeclUnterminated"", ""The document type declaration for root element type \""{0}\"" must end with ''>''."" },
        { ""PEReferenceWithinMarkup"", ""The parameter entity reference \""%{0};\"" cannot occur within markup in the internal subset of the DTD."" },
        { ""MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"", ""The markup declarations contained or pointed to by the document type declaration must be well-formed."" },
    // 2.10 White Space Handling
        { ""MSG_XML_SPACE_DECLARATION_ILLEGAL"", ""The attribute declaration for \""xml:space\"" must be given as an enumerated type whose only possible values are \""default\"" and \""preserve\""."" },
    // 3.2 Element Type Declarations
        { ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL"", ""White space is required after \""<!ELEMENT\"" in the element type declaration."" },
        { ""MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL"", ""The element type is required in the element type declaration."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL"", ""White space is required after the element type \""{0}\"" in the element type declaration."" },
        { ""MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL"", ""The constraint is required after the element type \""{0}\"" in the element type declaration."" },
        { ""ElementDeclUnterminated"", ""The declaration for element type \""{0}\"" must end with ''>''."" },
    // 3.2.1 Element Content
        { ""MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"", ""A ''('' character or an element type is required in the declaration of element type \""{0}\""."" },
        { ""MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"", ""A '')'' is required in the declaration of element type \""{0}\""."" },
    // 3.2.2 Mixed Content
        { ""MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT"", ""An element type is required in the declaration of element type \""{0}\""."" },
        { ""MSG_CLOSE_PAREN_REQUIRED_IN_MIXED"", ""A '')'' is required in the declaration of element type \""{0}\""."" },
        { ""MixedContentUnterminated"", ""The mixed content model \""{0}\"" must end with \"")*\"" when the types of child elements are constrained."" },
    // 3.3 Attribute-List Declarations
        { ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL"", ""White space is required after \""<!ATTLIST\"" in the attribute-list declaration."" },
        { ""MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL"", ""The element type is required in the attribute-list declaration."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF"", ""White space is required before the attribute name in the attribute-list declaration for element \""{0}\""."" },
        { ""AttNameRequiredInAttDef"", ""The attribute name must be specified in the attribute-list declaration for element \""{0}\""."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF"", ""White space is required before the attribute type in the declaration of attribute \""{1}\"" for element \""{0}\""."" },
        { ""AttTypeRequiredInAttDef"", ""The attribute type is required in the declaration of attribute \""{1}\"" for element \""{0}\""."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF"", ""White space is required before the attribute default in the declaration of attribute \""{1}\"" for element \""{0}\""."" },
    // 3.3.1 Attribute Types
        { ""MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE"", ""White space must appear after \""NOTATION\"" in the \""{1}\"" attribute declaration."" },
        { ""MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE"", ""The ''('' character must follow \""NOTATION\"" in the \""{1}\"" attribute declaration."" },
        { ""MSG_NAME_REQUIRED_IN_NOTATIONTYPE"", ""The notation name is required in the notation type list for the \""{1}\"" attribute declaration."" },
        { ""NotationTypeUnterminated"", ""The notation type list must end with '')'' in the \""{1}\"" attribute declaration."" },
        { ""MSG_NMTOKEN_REQUIRED_IN_ENUMERATION"", ""The name token is required in the enumerated type list for the \""{1}\"" attribute declaration."" },
        { ""EnumerationUnterminated"", ""The enumerated type list must end with '')'' in the \""{1}\"" attribute declaration."" },
    // 3.3.2 Attribute Defaults
        { ""MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL"", ""White space must appear after \""FIXED\"" in the \""{1}\"" attribute declaration."" },
    // 3.4 Conditional Sections
        { ""IncludeSectUnterminated"", ""The included conditional section must end with \""]]>\""."" },
        { ""IgnoreSectUnterminated"", ""The excluded conditional section must end with \""]]>\""."" },
    // 4.1 Character and Entity References
        { ""NameRequiredInPEReference"", ""The entity name must immediately follow the '%' in the parameter entity reference."" },
        { ""SemicolonRequiredInPEReference"", ""The parameter entity reference \""%{0};\"" must end with the '';'' delimiter."" },
    // 4.2 Entity Declarations
        { ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL"", ""White space is required after \""<!ENTITY\"" in the entity declaration."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL"", ""White space is required between \""<!ENTITY\"" and the '%' character in the parameter entity declaration."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL"", ""White space is required between the '%' and the entity name in the parameter entity declaration."" },
        { ""MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL"", ""The name of the entity is required in the entity declaration."" },
        { ""MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"", ""White space is required between the entity name \""{0}\"" and the definition in the entity declaration."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL"", ""White space is required between \""NDATA\"" and the notation name in the declaration for the entity \""{0}\""."" },
        { ""MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL"", ""The notation name is required after \""NDATA\"" in the declaration for the entity \""{0}\""."" },
        { ""EntityDeclUnterminated"", ""The declaration for the entity \""{0}\"" must end with ''>''."" },
    // 4.2.2 External Entities
        { ""ExternalIDRequired"", ""The external entity declaration must begin with either \""SYSTEM\"" or \""PUBLIC\""."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID"", ""White space is required between \""PUBLIC\"" and the public identifier."" },
        { ""MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID"", ""White space is required between the public identifier and the system identifier."" },
        { ""MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID"", ""White space is required between \""SYSTEM\"" and the system identifier."" },
        { ""MSG_URI_FRAGMENT_IN_SYSTEMID"", ""The fragment identifier should not be specified as part of the system identifier \""{0}\""."" },
    // 4.7 Notation Declarations
        { ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL"", ""White space is required after \""<!NOTATION\"" in the notation declaration."" },
        { ""MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL"", ""The name of the notation is required in the notation declaration."" },
        { ""MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL"", ""White space is required after the notation name \""{0}\"" in the notation declaration."" },
        { ""NotationDeclUnterminated"", ""The declaration for the notation \""{0}\"" must end with ''>''."" },
// Validation messages
        { ""DuplicateTypeInMixedContent"", ""The element type \""{0}\"" was already specified in this content model."" },
        { ""ENTITIESInvalid"", ""Attribute value \""{1}\"" of type ENTITIES must be the names of one or more unparsed entities."" },
        { ""ENTITYInvalid"", ""Attribute value \""{1}\"" of type ENTITY must be the name of an unparsed entity."" },
        { ""IDDefaultTypeInvalid"", ""The ID attribute \""{0}\"" must have a declared default of \""#IMPLIED\"" or \""#REQUIRED\""."" },
        { ""IDInvalid"", ""Attribute value \""{1}\"" of type ID must be a name."" },
        { ""IDNotUnique"", ""Attribute value \""{1}\"" of type ID must be unique within the document."" },
        { ""IDREFInvalid"", ""Attribute value \""{1}\"" of type IDREF must be a name."" },
        { ""IDREFSInvalid"", ""Attribute value \""{0}\"" of type IDREFS must be one or more names."" },
        { ""ImproperDeclarationNesting"", ""The replacement text of parameter entity \""{0}\"" must include properly nested declarations."" },
        { ""ImproperGroupNesting"", ""The replacement text of parameter entity \""{0}\"" must include properly nested pairs of parentheses."" },
        { ""MSG_ATTRIBUTE_NOT_DECLARED"", ""Attribute \""{1}\"" must be declared for element type \""{0}\""."" },
        { ""MSG_ATTRIBUTE_VALUE_NOT_IN_LIST"", ""Attribute \""{0}\"" with value \""{1}\"" must have a value from the list \""{2}\""."" },
        { ""MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE"", ""The value \""{1}\"" of attribute \""{0}\"" must not be changed by normalization (to \""{2}\"") in a standalone document."" },
        { ""MSG_CONTENT_INCOMPLETE"", ""The content of element type \""{0}\"" is incomplete, it must match \""{1}\""."" },
        { ""MSG_CONTENT_INVALID"", ""The content of element type \""{0}\"" must match \""{1}\""."" },
        { ""MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED"", ""Attribute \""{1}\"" for element type \""{0}\"" has a default value and must be specified in a standalone document."" },
        { ""MSG_DUPLICATE_ATTDEF"", ""Attribute \""{1}\"" is already declared for element type \""{0}\""."" },
        { ""MSG_ELEMENT_ALREADY_DECLARED"", ""Element type \""{0}\"" must not be declared more than once."" },
        { ""MSG_ELEMENT_NOT_DECLARED"", ""Element type \""{0}\"" must be declared."" },
        { ""MSG_ELEMENT_WITH_ID_REQUIRED"", ""An element with the identifier \""{0}\"" must appear in the document."" },
        { ""MSG_EXTERNAL_ENTITY_NOT_PERMITTED"", ""The reference to external entity \""{0}\"" is not permitted in a standalone document."" },
        { ""MSG_FIXED_ATTVALUE_INVALID"", ""Attribute \""{1}\"" with value \""{2}\"" must have a value of \""{3}\""."" },
        { ""MSG_MORE_THAN_ONE_ID_ATTRIBUTE"", ""Element type \""{0}\"" already has attribute \""{1}\"" of type ID, a second attribute \""{2}\"" of type ID is not permitted."" },
        { ""MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE"", ""Element type \""{0}\"" already has attribute \""{1}\"" of type NOTATION, a second attribute \""{2}\"" of type NOTATION is not permitted."" },
        { ""MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE"", ""The notation \""{2}\"" must be declared when referenced in the notation type list for attribute \""{1}\""."" },
        { ""MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL"", ""The notation \""{1}\"" must be declared when referenced in the unparsed entity declaration for \""{0}\""."" },
        { ""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"", ""The reference to entity \""{0}\"" declared in an external parsed entity is not permitted in a standalone document."" },
        { ""MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED"", ""Attribute \""{1}\"" is required and must be specified for element type \""{0}\""."" },
        { ""MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE"", ""White space must not occur between elements declared in an external parsed entity with element content in a standalone document."" },
        { ""NMTOKENInvalid"", ""Attribute value \""{1}\"" of type NMTOKEN must be a name token."" },
        { ""NMTOKENSInvalid"", ""Attribute value \""{0}\"" of type NMTOKENS must be one or more name tokens."" },
        { ""RootElementTypeMustMatchDoctypedecl"", ""Document root element \""{1}\"", must match DOCTYPE root \""{0}\""."" },
        { ""UndeclaredElementInContentSpec"", ""The content model of element \""{0}\"" refers to the undeclared element \""{1}\""."" },
// Entity related messages
    // 3.1 Start-Tags, End-Tags, and Empty-Element Tags
        { ""ReferenceToExternalEntity"", ""The external entity reference \""&{0};\"" is not permitted in an attribute value."" },
    // 4.1 Character and Entity References
        { ""EntityNotDeclared"", ""The entity \""{0}\"" was referenced, but not declared."" },
        { ""ReferenceToUnparsedEntity"", ""The unparsed entity reference \""&{0};\"" is not permitted."" },
        { ""RecursiveReference"", ""Recursive reference \""&{0};\"". (Reference path: {1})"" },
        { ""RecursivePEReference"", ""Recursive reference \""%{0};\"". (Reference path: {1})"" },
    // 4.3.3 Character Encoding in Entities
        { ""EncodingNotSupported"", ""The encoding \""{0}\"" is not supported."" },
        { ""EncodingRequired"", ""A parsed entity not encoded in either UTF-8 or UTF-16 must contain an encoding declaration."" },
// Namespaces support
    // 4. Using Qualified Names
        { ""PrefixDeclared"", ""The namespace prefix \""{0}\"" was not declared."" },
        { ""MSG_ATT_DEFAULT_INVALID"", ""The defaultValue \""{1}\"" of attribute \""{0}\"" is not legal as for the lexical constraints of this attribute type."" },
    };

    /** Returns the list resource bundle contents. */
    public Object[][] getContents() {
        return CONTENTS;
    }
}
"
org/xml/sax/SAXNotRecognizedException.java,true,"// SAXNotRecognizedException.java - unrecognized feature or value.
// Written by David Megginson, sax@megginson.com
// NO WARRANTY!  This class is in the Public Domain.

// $Id: SAXNotRecognizedException.java,v 1.4 2000/05/05 17:47:28 david Exp $


package org.xml.sax;


/**
 * Exception class for an unrecognized identifier.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>An XMLReader will throw this exception when it finds an
 * unrecognized feature or property identifier; SAX applications and
 * extensions may use this class for other, similar purposes.</p>
 *
 * @since SAX 2.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.SAXNotSupportedException
 */
public class SAXNotRecognizedException extends SAXException
{

    /**
     * Construct a new exception with the given message.
     *
     * @param message The text message of the exception.
     */
    public SAXNotRecognizedException (String message)
    {
	super(message);
    }

}

// end of SAXNotRecognizedException.java
"
org/apache/xerces/msg/ImplementationMessages.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.msg;

/**
 * <p>
 * This file contains error and warning messages used by the Apache
 * Xerces parser. The messages are arranged in key and value
 * tuples in a ListResourceBundle.
 *
 * @version
 */
public class ImplementationMessages
    extends java.util.ListResourceBundle
    {
    /** The list resource bundle contents. */
    public static final Object CONTENTS[][] = {
// Internal message formatter messages
        { ""BadMajorCode"", ""The majorCode parameter to createMessage was out of bounds."" },
        { ""FormatFailed"", ""An internal error occurred while formatting the following message:\n  "" },
// Xerces implementation defined errors
        { ""ENC4"", ""Invalid UTF-8 code. (byte: 0x{0})"" },
        { ""ENC5"", ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1})"" },
        { ""ENC6"", ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2})"" },
        { ""ENC7"", ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2} 0x{3})"" },
        { ""FileNotFound"", ""File \""{0}\"" not found."" },
        { ""VAL_BST"", ""Invalid ContentSpecNode.NODE_XXX value for binary op CMNode"" },
        { ""VAL_CMSI"", ""Invalid CMStateSet bit index"" },
        { ""VAL_CST"", ""Unknown ContentSpecNode.NODE_XXX value"" },
        { ""VAL_LST"", ""Invalid ContentSpecNode.NODE_XXX value for leaf CMNode"" },
        { ""VAL_NIICM"", ""Only * unary ops should be in the internal content model tree""},
        { ""VAL_NPCD"", ""PCData node found in non-mixed model content"" },
        { ""VAL_UST"", ""Invalid ContentSpecNode.NODE_XXX value for unary op CMNode"" },
        { ""VAL_WCGHI"", ""The input to whatCanGoHere() is inconsistent"" },
        { ""INT_DCN"", ""Internal Error: dataChunk == NULL"" },
        { ""INT_PCN"", ""Internal Error: fPreviousChunk == NULL"" },
        { ""FatalError"", ""Stopping after fatal error: {0}"" },
    };

    /** Returns the list resource bundle contents. */
    public Object[][] getContents() {
        return CONTENTS;
    }

} // class Message
"
org/apache/xerces/validators/datatype/DatatypeMessageProvider.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.datatype;

import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.ResourceBundle;
import org.apache.xerces.utils.XMLMessageProvider;

public class DatatypeMessageProvider implements XMLMessageProvider {
    /**
     * The domain of messages concerning the XML Schema: Datatypes specification.
     */
    public static final String DATATYPE_DOMAIN = ""http://www.w3.org/TR/xml-schema-2"";

    /**
     * Set the locale used for error messages
     *
     * @param locale the new locale
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }
    /**
     * get the local used for error messages
     *
     * @return the locale
     */
    public Locale getLocale() {
        return fLocale;
    }

    /**
     * Creates a message from the specified key and replacement
     * arguments, localized to the given locale.
     *
     * @param locale    The requested locale of the message to be
     *                  created.
     * @param key       The key for the message text.
     * @param args      The arguments to be used as replacement text
     *                  in the message created.
     */
    public String createMessage(Locale locale, int majorCode, int minorCode, Object args[]) {
        boolean throwex = false;
        if (fResourceBundle == null || locale != fLocale) {
            if (locale != null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.DatatypeMessages"", locale);
            if (fResourceBundle == null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.DatatypeMessages"");
        }
        if (majorCode < 0 || majorCode >= fgMessageKeys.length) {
            majorCode = MSG_BAD_MAJORCODE;
            throwex = true;
        }
        String msgKey = fgMessageKeys[majorCode];
        String msg = fResourceBundle.getString(msgKey);
        if (args != null) {
            try {
                msg = java.text.MessageFormat.format(msg, args);
            } catch (Exception e) {
                msg = fResourceBundle.getString(fgMessageKeys[MSG_FORMAT_FAILURE]);
                msg += "" "" + fResourceBundle.getString(msgKey);
            }
        }

        if (throwex) {
            throw new RuntimeException(msg);
        }
        return msg;
    }
    //
    //
    //
    private Locale fLocale = null;
    private ResourceBundle fResourceBundle = null;
    //
    // Major Codes
    //
    public static final int 
        MSG_BAD_MAJORCODE = 0,              //  majorCode parameter to createMessage was out of bounds
        MSG_FORMAT_FAILURE = 1,             //  exception thrown during messageFormat call
        NotBoolean = 2,
        NotDecimal = 3,
        FacetsInconsistent = 4,
        IllegalFacetValue = 5,
        IllegalDecimalFacet = 6,
        UnknownFacet = 7,
        InvalidEnumValue = 8,
        OutOfBounds = 9,
        NotAnEnumValue = 10,
        NotInteger = 11,
        IllegalIntegerFacet = 12,
        NotReal = 13,
        IllegalRealFacet = 14,
        ScaleLargerThanPrecision = 15,
        PrecisionExceeded = 16,
        ScaleExceeded = 17,
       // ...
        MSG_MAX_CODE = 18;

    //
    // Minor Codes
    //
    public static final int
        MSG_NONE = 0;

    public static final String[] fgMessageKeys = {
        ""BadMajorCode"",                 //   0, ""The majorCode parameter to createMessage was out of bounds.""
        ""FormatFailed"",                 //   1, ""An internal error occurred while formatting the following message:""
        ""NotBoolean"",                   //   2, ""{0} is not a boolean""
        ""NotDecimal"",                   //   3, ""{0} is not a decimal""
        ""FacetsInconsistent"",           //   4, ""Facets are inconsistent with base type""
        ""IllegalFacetValue"",            //   5, ""Illegal value {0} for facet {1}.""
        ""IllegalDecimalFacet"",          //   6, ""Illegal Facet for decimal type""
        ""UnknownFacet"",                 //   7, ""Unknown Facet: {0}""
        ""InvalidEnumValue"",             //   8, ""Invalid value for Enum constant: {0}""
        ""OutOfBounds"",                  //   9, ""{0} is out of bounds.""
        ""NotAnEnumValue"",               //  10, ""{0} is not one of the specified enum values.""
        ""NotInteger"",                   //  11, ""{0} is not an integer.""
        ""IllegalIntegerFacet"",          //  12, ""Illegal Facet for Integer type.""
        ""NotReal"",                      //  13, ""{0} is not a double.""
        ""IllegalRealFacet"",             //  14, ""Illegal Facet for Real type.""
        ""ScaleLargerThanPrecision"",     //  15, ""Scale Facet must be less than or equal to Precision Facet""
        ""PrecisionExceeded"",            //  16, ""{0} has exceeded the precision Facet {1}""},
        ""ScaleExceeded"",                //  17, ""{0} has execeed the scale Facet {1}""},
    };

}
"
org/apache/xerces/validators/datatype/InvalidDatatypeValueException.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
 
package org.apache.xerces.validators.datatype;

/**
 * InvalidDatatypeValueException is thrown when data value doesn't match it's datatype
 *
 */
public class InvalidDatatypeValueException
    extends Exception {

    public InvalidDatatypeValueException() { super(); }
    public InvalidDatatypeValueException(String msg) { super(msg); }

}
"
org/w3c/dom/DocumentType.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  Each <code>Document</code> has a <code>doctype</code> attribute whose 
 * value is either <code>null</code> or a <code>DocumentType</code> object. 
 * The <code>DocumentType</code> interface in the DOM Core provides an 
 * interface to the list of entities that are defined for the document, and 
 * little else because the effect of namespaces and the various XML schema 
 * efforts on DTD representation are not clearly understood as of this 
 * writing.
 * <p> The DOM Level 2 doesn't support editing <code>DocumentType</code> nodes.
 */
public interface DocumentType extends Node {
    /**
     *  The name of DTD; i.e., the name immediately following the 
     * <code>DOCTYPE</code> keyword.
     */
    public String getName();

    /**
     *  A <code>NamedNodeMap</code> containing the general entities, both 
     * external and internal, declared in the DTD. Parameter entities are not 
     *  contained. Duplicates are discarded. For example in:
     * <pre>
     * &lt;!DOCTYPE ex SYSTEM ""ex.dtd"" [
     *   &lt;!ENTITY foo ""foo""&gt;
     *   &lt;!ENTITY bar ""bar""&gt;
     *   &lt;!ENTITY bar ""bar2""&gt;
     *   &lt;!ENTITY % baz ""baz""&gt;
     * ]&gt;
     * &lt;ex/&gt;</pre>
     *   the interface 
     * provides access to <code>foo</code> and the first declaration of 
     * <code>bar</code> but not the second declaration of  <code>bar</code> 
     * or <code>baz</code> . Every node in this map also implements the 
     * <code>Entity</code> interface.
     * <br> The DOM Level 2 does not support editing entities, therefore 
     * <code>entities</code> cannot be altered in any way.
     */
    public NamedNodeMap getEntities();

    /**
     *  A <code>NamedNodeMap</code> containing  the notations declared in the 
     * DTD. Duplicates are discarded. Every node in this map also implements 
     * the <code>Notation</code> interface.
     * <br> The DOM Level 2 does not support editing notations, therefore 
     * <code>notations</code> cannot be altered in any way.
     */
    public NamedNodeMap getNotations();

    /**
     *  The public identifier of the external subset.
     * @since DOM Level 2
     */
    public String getPublicId();

    /**
     *  The system identifier of the external subset.
     * @since DOM Level 2
     */
    public String getSystemId();

    /**
     *  The internal subset as a string.
     * @since DOM Level 2
     */
    public String getInternalSubset();

}

"
org/apache/xerces/readers/AbstractCharReader.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.CharDataChunk;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringHasher;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLCharacterProperties;
import org.apache.xerces.utils.ImplementationMessages;
import org.xml.sax.SAXParseException;
import java.util.Vector;

/**
 * An abstract class for readers that process input data as characters.
 * <p>
 * This is the base class of the CharReader and UTF8CharReader classes.
 * The CharReader classes fills in the ""chunks"" of data to process from
 * a character stream (java.io.Reader).  The UTF8CharReader performs
 * its own UTF-8 transcoding to fill in the data from an InputStream.
 *
 * @version $Id$
 */
abstract class AbstractCharReader extends XMLEntityReader {

    /**
     * Subclass constructor
     *
     * @param entityHandler The entity handler.
     * @param errorReporter The error reporter.
     * @param sendCharDataAsCharArray true if char data should be reported using
     *                                char arrays instead of string handles.
     * @param stringPool The string pool.
     */
    protected AbstractCharReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, StringPool stringPool) {
        super(entityHandler, errorReporter, sendCharDataAsCharArray);
        fStringPool = stringPool;
        fCurrentChunk = CharDataChunk.createChunk(fStringPool, null);
    }

    //
    // These instance variables are referenced and updated directly
    // by our subclass from the fillCurrentChunk() method.
    //
    protected CharDataChunk fCurrentChunk = null;
    protected int fCurrentIndex = 0;
    protected char[] fMostRecentData = null;
    protected int fMostRecentChar = 0;
    protected int fLength = 0;

    /**
     * Fill the current chunk the next buffer worth of data.
     *
     * This method should replace any 0xD,0xA sequence with a single
     * 0xA character, and replace single 0xD characters with a 0xA
     * character.  This is described in the spec under section 2.11,
     * ""End-of-Line Handling"".
     * 
     * @return The value of the first character available for processing.
     * @exception java.lang.Exception
     */
    protected abstract int fillCurrentChunk() throws Exception;

    /**
     * Delay reporting an error message.
     *
     * If there is an error detected in the underlying input stream during
     * the fillCurrentChunk method, the error is described here and will be
     * reported when we reach that offset during normal processing.  The
     * subclass should place a character with a value of zero at that offset,
     * which will be detected here as an invalid character.  When the invalid
     * character is scanned, we will generate the deferred exception.
     *
     * @param errorCode the errorCode to report
     * @param args an array of arguments needed to generate a good error message
     * @param offset the position in the reader where the error occured
     */
    protected void deferException(int errorCode, Object[] args, int offset) {
        if (fDeferredErrors == null)
            fDeferredErrors = new Vector();
        DeferredError de = new DeferredError(errorCode, args, offset);
        fDeferredErrors.addElement(de);
    }

    /**
     * Change readers at end of input.
     *
     * We override our superclass method to release the final chunk
     * of the input data before handing off to the next reader.
     *
     * @return The next reader used to continue processing the document.
     */
    protected XMLEntityHandler.EntityReader changeReaders() throws Exception {
        XMLEntityHandler.EntityReader nextReader = super.changeReaders();
        fCurrentChunk.releaseChunk();
        fCurrentChunk = null;
        return nextReader;
    }

    //
    // XMLEntityHandler.EntityReader implementation
    //
    // The first five methods of the interface are implemented
    // in the XMLEntityHandler base class for us, namely
    //
    //    public int currentOffset();
    //    public int getLineNumber();
    //    public int getColumnNumber();
    //    public void setInCDSect(boolean inCDSect);
    //    public boolean getInCDSect();
    //

    /**
     * Append the characters processed by this reader associated with <code>offset</code> and
     * <code>length</code> to the <code>CharBuffer</code>.
     *
     * @param charBuffer The <code>CharBuffer</code> to append the characters to.
     * @param offset The offset within this reader where the copy should start.
     * @param length The length within this reader where the copy should stop.
     */
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        fCurrentChunk.append(charBuffer, offset, length);
    }

    /**
     * Add a string to the <code>StringPool</code> from the characters scanned using this
     * reader as described by <code>offset</code> and <code>length</code>.
     *
     * @param offset The offset within this reader where the characters start.
     * @param length The length within this reader where the characters end.
     * @return The <code>StringPool</code> handle for the string.
     */
    public int addString(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addString(offset, length);
    }

    /**
     * Add a symbol to the <code>StringPool</code> from the characters scanned using this
     * reader as described by <code>offset</code> and <code>length</code>.
     *
     * @param offset The offset within this reader where the characters start.
     * @param length The length within this reader where the characters end.
     * @return The <code>StringPool</code> handle for the symbol.
     */
    public int addSymbol(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addSymbol(offset, length, 0);
    }

    /**
     *
     */
    public boolean lookingAtChar(char chr, boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch != chr) {
            if (ch == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtChar(chr, skipPastChar);
                }
            }
            return false;
        }
        if (skipPastChar) {
            fCharacterCounter++;
            fCurrentOffset++;
            if (++fCurrentIndex == CharDataChunk.CHUNK_SIZE)
                slowLoadNextChar();
            else
                fMostRecentChar = fMostRecentData[fCurrentIndex] & 0xFFFF;
        }
        return true;
    }

    /**
     *
     */
    public boolean lookingAtValidChar(boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0xD800) {
            if (ch >= 0x20 || ch == 0x09) {
                if (skipPastChar) {
                    fCharacterCounter++;
                    loadNextChar();
                }
                return true;
            }
            if (ch == 0x0A) {
                if (skipPastChar) {
                    fLinefeedCounter++;
                    fCharacterCounter = 1;
                    loadNextChar();
                }
                return true;
            }
            if (ch == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtValidChar(skipPastChar);
                }
            }
            return false;
        }
        if (ch > 0xFFFD) {
            return false;
        }
        if (ch < 0xDC00) {
            CharDataChunk savedChunk = fCurrentChunk;
            int savedIndex = fCurrentIndex;
            int savedOffset = fCurrentOffset;
            ch = loadNextChar();
            boolean valid = (ch >= 0xDC00 && ch < 0xE000);
            if (!valid || !skipPastChar) {
                fCurrentChunk = savedChunk;
                fCurrentIndex = savedIndex;
                fCurrentOffset = savedOffset;
                fMostRecentData = savedChunk.toCharArray();
                fMostRecentChar = fMostRecentData[savedIndex] & 0xFFFF;
                return valid;
            }
        } else if (ch < 0xE000) {
            return false;
        }
        if (skipPastChar) {
            fCharacterCounter++;
            loadNextChar();
        }
        return true;
    }

    /**
     *
     */
    public boolean lookingAtSpace(boolean skipPastChar) throws Exception {
        int ch = fMostRecentChar;
        if (ch > 0x20)
            return false;
        if (ch == 0x20 || ch == 0x09) {
            if (!skipPastChar)
                return true;
            fCharacterCounter++;
        } else if (ch == 0x0A) {
            if (!skipPastChar)
                return true;
            fLinefeedCounter++;
            fCharacterCounter = 1;
        } else {
            if (ch == 0) { // REVISIT - should we be checking this here ?
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtSpace(skipPastChar);
                }
            }
            return false;
        }
        fCurrentOffset++;
        if (++fCurrentIndex == CharDataChunk.CHUNK_SIZE)
            slowLoadNextChar();
        else
            fMostRecentChar = fMostRecentData[fCurrentIndex] & 0xFFFF;
        return true;
    }

    /**
     *
     */
    public void skipToChar(char chr) throws Exception {
        //
        // REVISIT - this will skip invalid characters without reporting them.
        //
        int ch = fMostRecentChar;
        while (true) {
            if (ch == chr)
                return;
            if (ch == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    changeReaders().skipToChar(chr);
                    return;
                }
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch >= 0xD800 && ch < 0xDC00) {
                fCharacterCounter++;
                ch = loadNextChar();
                if (ch < 0xDC00 || ch >= 0xE000)
                    continue;
            } else
                fCharacterCounter++;
            ch = loadNextChar();
        }
    }

    /**
     *
     */
    public void skipPastSpaces() throws Exception {
        int ch = fMostRecentChar;
        while (true) {
            if (ch == 0x20 || ch == 0x09) {
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else {
                if (ch == 0 && atEOF(fCurrentOffset + 1))
                    changeReaders().skipPastSpaces();
                return;
            }
            ch = loadNextChar();
        }
    }

    /**
     *
     */
    public void skipPastName(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0)
                return;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
                return;
        }
        while (true) {
            fCharacterCounter++;
            ch = loadNextChar();
            if (fastcheck == ch)
                return;
            if (ch < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    return;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    return;
            }
        }
    }

    /**
     *
     */
    public void skipPastNmtoken(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        while (true) {
            if (fastcheck == ch)
                return;
            if (ch < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    return;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    return;
            }
            fCharacterCounter++;
            ch = loadNextChar();
        }
    }

    /**
     *
     */
    public boolean skippedString(char[] s) throws Exception {
        int length = s.length;
        char[] data = fMostRecentData;
        int index = fCurrentIndex;
        if (index + length <= CharDataChunk.CHUNK_SIZE) {
            for (int i = 0; i < length; i++) {
                if (data[index++] != s[i])
                    return false;
            }
            fCharacterCounter += length;
            fCurrentOffset += length;
            fCurrentIndex = index;
            if (index == CharDataChunk.CHUNK_SIZE)
                slowLoadNextChar();
            else
                fMostRecentChar = data[index] & 0xFFFF;
            return true;
        }
        CharDataChunk dataChunk = fCurrentChunk;
        int offset = fCurrentOffset;
        int savedIndex = index;
        int i = 0;
        while (index < CharDataChunk.CHUNK_SIZE) {
            if (data[index++] != s[i++])
                return false;
        }
        slowLoadNextChar();
        data = fMostRecentData;
        index = 0;
        while (i < length) {
            if (data[index++] != s[i++]) {
                fCurrentChunk = dataChunk;
                fCurrentIndex = savedIndex;
                fCurrentOffset = offset;
                fMostRecentData = dataChunk.toCharArray();
                fMostRecentChar = fMostRecentData[savedIndex] & 0xFFFF;
                return false;
            }
        }
        fCharacterCounter += length;
        fCurrentOffset += length;
        fCurrentIndex = index;
        if (index == CharDataChunk.CHUNK_SIZE)
            slowLoadNextChar();
        else
            fMostRecentChar = data[index] & 0xFFFF;
        return true;
    }

    /**
     *
     */
    public int scanInvalidChar() throws Exception {
        int ch = fMostRecentChar;
        if (ch == 0x0A) {
            fLinefeedCounter++;
            fCharacterCounter = 1;
            loadNextChar();
        } else if (ch == 0) {
            if (atEOF(fCurrentOffset + 1)) {
                return changeReaders().scanInvalidChar();
            }
            if (fDeferredErrors != null) {
                for (int i = 0; i < fDeferredErrors.size(); i++) {
                    DeferredError de = (DeferredError)fDeferredErrors.elementAt(i);
                    if (de.offset == fCurrentIndex) {
                        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                                   ImplementationMessages.XERCES_IMPLEMENTATION_DOMAIN,
                                                   de.errorCode,
                                                   0,
                                                   de.args,
                                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
                        fDeferredErrors.removeElementAt(i);
                        fCharacterCounter++;
                        loadNextChar();
                        return -1;
                    }
                }
            }
            fCharacterCounter++;
            loadNextChar();
        } else {
            fCharacterCounter++;
            if (ch >= 0xD800 && ch < 0xDC00) {
                int ch2 = loadNextChar();
                if (ch2 >= 0xDC00 && ch2 < 0xE000) {
                    ch = ((ch-0xD800)<<10)+(ch2-0xDC00)+0x10000;
                    loadNextChar();
                }
            } else
                loadNextChar();
        }
        return ch;
    }

    /**
     *
     */
    public int scanCharRef(boolean hex) throws Exception {
        int ch = fMostRecentChar;
        if (ch == 0) {
            if (atEOF(fCurrentOffset + 1)) {
                return changeReaders().scanCharRef(hex);
            }
            return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
        }
        int num = 0;
        if (hex) {
            if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
        } else {
            if (ch < '0' || ch > '9')
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - '0';
        }
        fCharacterCounter++;
        loadNextChar();
        boolean toobig = false;
        while (true) {
            ch = fMostRecentChar;
            if (ch == 0)
                break;
            if (hex) {
                if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                    break;
            } else {
                if (ch < '0' || ch > '9')
                    break;
            }
            fCharacterCounter++;
            loadNextChar();
            if (hex) {
                int dig = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
                num = (num << 4) + dig;
            } else {
                int dig = ch - '0';
                num = (num * 10) + dig;
            }
            if (num > 0x10FFFF) {
                toobig = true;
                num = 0;
            }
        }
        if (ch != ';')
            return XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED;
        fCharacterCounter++;
        loadNextChar();
        if (toobig)
            return XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE;
        return num;
    }

    /**
     *
     */
    public int scanStringLiteral() throws Exception {
        boolean single;
        if (!(single = lookingAtChar('\'', true)) && !lookingAtChar('\""', true)) {
            return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
        }
        int offset = fCurrentOffset;
        char qchar = single ? '\'' : '\""';
        while (!lookingAtChar(qchar, false)) {
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR;
            }
        }
        int stringIndex = addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true); // move past qchar
        return stringIndex;
    }

    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    //                   | ""'"" ([^<&'] | Reference)* ""'""
    //
    /**
     *
     */
    public int scanAttValue(char qchar, boolean asSymbol) throws Exception
    {
        int offset = fCurrentOffset;
        while (true) {
            if (lookingAtChar(qchar, false)) {
                break;
            }
            if (lookingAtChar(' ', true)) {
                continue;
            }
            if (lookingAtSpace(false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('&', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('<', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_LESSTHAN;
            }
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.ATTVALUE_RESULT_INVALID_CHAR;
            }
        }
        int result = asSymbol ? addSymbol(offset, fCurrentOffset - offset) : addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true);
        return result;
    }

    //
    //  [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                      | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    /**
     *
     */
    public int scanEntityValue(int qchar, boolean createString) throws Exception
    {
        int offset = fCurrentOffset;
        while (true) {
            if (atEOF(fCurrentOffset + 1)) {
                changeReaders();
                return XMLEntityHandler.ENTITYVALUE_RESULT_END_OF_INPUT;
            }
            if (qchar != -1 && lookingAtChar((char)qchar, false)) {
                if (!createString)
                    return XMLEntityHandler.ENTITYVALUE_RESULT_FINISHED;
                break;
            }
            if (lookingAtChar('&', false)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_REFERENCE;
            }
            if (lookingAtChar('%', false)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_PEREF;
            }
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
            }
        }
        int result = addString(offset, fCurrentOffset - offset);
        lookingAtChar((char)qchar, true);
        return result;
    }

    /**
     *
     */
    public int scanName(char fastcheck) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0)
                return -1;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
                return -1;
        }
        int offset = fCurrentOffset;
        int index = fCurrentIndex;
        char[] data = fMostRecentData;
        if (++index == CharDataChunk.CHUNK_SIZE) {
            slowLoadNextChar();
            index = 0;
            data = fMostRecentData;
        }
        fCharacterCounter++;
        fCurrentOffset++;
        int hashcode = 0;
        while (true) {
            hashcode = StringHasher.hashChar(hashcode, ch);
            ch = data[index] & 0xFFFF;
            if (fastcheck == ch)
                break;
            if (ch < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    break;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    break;
            }
            if (++index == CharDataChunk.CHUNK_SIZE) {
                slowLoadNextChar();
                index = 0;
                data = fMostRecentData;
            }
            fCharacterCounter++;
            fCurrentOffset++;
        }
        fCurrentIndex = index;
        fMostRecentChar = ch;
        hashcode = StringHasher.finishHash(hashcode);
        int length = fCurrentOffset - offset;
        int nameIndex = fCurrentChunk.addSymbol(offset, length, hashcode);
        return nameIndex;
    }

    /**
     *
     */
    public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws Exception {
        char[] expected = expectedName.chars;
        int offset = expectedName.offset;
        int len = expectedName.length;
        int ch = fMostRecentChar;
        for (int i = 0; i < len; i++) {
            if (ch != expected[offset++]) {
                skipPastNmtoken(fastcheck);
                return false;
            }
            fCharacterCounter++;
            fCurrentOffset++;
            if (++fCurrentIndex == CharDataChunk.CHUNK_SIZE)
                ch = slowLoadNextChar();
            else
                ch = (fMostRecentChar = fMostRecentData[fCurrentIndex] & 0xFFFF);
        }
        if (ch == fastcheck)
            return true;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                return true;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                return true;
        }
        skipPastNmtoken(fastcheck);
        return false;
    }

    /**
     *
     */
    public void scanQName(char fastcheck, QName qname) throws Exception {
        int ch = fMostRecentChar;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0) {
                qname.clear();
                return;
            }
            if (ch == ':') {
                qname.clear();
                return;
            }
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0) {
                qname.clear();
                return;
            }
        }
        int offset = fCurrentOffset;
        int index = fCurrentIndex;
        char[] data = fMostRecentData;
        if (++index == CharDataChunk.CHUNK_SIZE) {
            slowLoadNextChar();
            index = 0;
            data = fMostRecentData;
        }
        fCharacterCounter++;
        fCurrentOffset++;
        int hashcode = 0;
        int prefixend = -1;
        while (true) {
            hashcode = StringHasher.hashChar(hashcode, ch);
            ch = data[index] & 0xFFFF;
            if (fastcheck == ch)
                break;
            if (ch < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    break;
                if (ch == ':') {
                    if (prefixend != -1)
                        break;
                    prefixend = fCurrentOffset;
                    //
                    // We need to peek ahead one character.  If the next character is not a
                    // valid initial name character, or is another colon, then we cannot meet
                    // both the Prefix and LocalPart productions for the QName production,
                    // which means that there is no Prefix and we need to terminate the QName
                    // at the first colon.
                    //
                    if (index + 1 == CharDataChunk.CHUNK_SIZE) {
                        CharDataChunk savedChunk = fCurrentChunk;
                        int savedOffset = fCurrentOffset;
                        ch = slowLoadNextChar();
                        fCurrentChunk = savedChunk;
                        fCurrentOffset = savedOffset;
                        fMostRecentData = savedChunk.toCharArray();
                    } else
                        ch = data[index + 1] & 0xFFFF;
                    boolean lpok = true;
                    if (ch < 0x80) {
                        if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0 || ch == ':')
                            lpok = false;
                    } else {
                        if (!fCalledCharPropInit) {
                            XMLCharacterProperties.initCharFlags();
                            fCalledCharPropInit = true;
                        }
                        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
                            lpok = false;
                    }
                    ch = ':';
                    if (!lpok) {
                        prefixend = -1;
                        break;
                    }
                }
            } else {
                if (fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    break;
            }
            if (++index == CharDataChunk.CHUNK_SIZE) {
                slowLoadNextChar();
                index = 0;
                data = fMostRecentData;
            }
            fCharacterCounter++;
            fCurrentOffset++;
        }
        fCurrentIndex = index;
        fMostRecentChar = ch;
        hashcode = StringHasher.finishHash(hashcode);
        int length = fCurrentOffset - offset;
        qname.rawname = fCurrentChunk.addSymbol(offset, length, hashcode);
        qname.prefix = prefixend == -1 ? -1 : addSymbol(offset, prefixend - offset);
        qname.localpart = prefixend == -1 ? qname.rawname : addSymbol(prefixend + 1, fCurrentOffset - (prefixend + 1));
        qname.uri = -1;

    } // scanQName(char,QName)

    //
    // [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
    //
    /**
     *
     */
    public int scanContent(QName element) throws Exception {
        if (fCallClearPreviousChunk && fCurrentChunk.clearPreviousChunk())
            fCallClearPreviousChunk = false;
        int charDataOffset = fCurrentOffset;
        int ch = fMostRecentChar;
        if (ch < 0x80) {
            switch (XMLCharacterProperties.fgAsciiWSCharData[ch]) {
            case 0:
                fCharacterCounter++;
                ch = loadNextChar();
                break;
            case 1: // '<'
                fCharacterCounter++;
                ch = loadNextChar();
                if (!fInCDSect) {
                    return recognizeMarkup(ch);
                }
                break;
            case 2: // '&'
                fCharacterCounter++;
                ch = loadNextChar();
                if (!fInCDSect) {
                    return recognizeReference(ch);
                }
                break;
            case 3: // ']'
                fCharacterCounter++;
                ch = loadNextChar();
                if (ch != ']')
                    break;
                if (fCurrentIndex + 1 == CharDataChunk.CHUNK_SIZE) {
                    CharDataChunk dataChunk = fCurrentChunk;
                    int index = fCurrentIndex;
                    int offset = fCurrentOffset;
                    if (loadNextChar() != '>') {
                        fCurrentChunk = dataChunk;
                        fCurrentIndex = index;
                        fCurrentOffset = offset;
                        fMostRecentData = dataChunk.toCharArray();
                        fMostRecentChar = ']';
                        break;
                    }
                } else {
                    if (fMostRecentData[fCurrentIndex + 1] != '>')
                        break;
                    fCurrentIndex++;
                    fCurrentOffset++;
                }
                loadNextChar();
                fCharacterCounter += 2;
                return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
            case 4: // invalid char
                if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                    changeReaders();
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                }
                return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
            case 5:
                do {
                    if (ch == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                    } else
                        fCharacterCounter++;
                    ch = loadNextChar();
                } while (ch == 0x20 || ch == 0x09 || ch == 0x0A);
                if (ch < 0x80) {
                    switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                    case 0:
                        fCharacterCounter++;
                        ch = loadNextChar();
                        break;
                    case 1: // '<'
                        if (!fInCDSect) {
                            callCharDataHandler(charDataOffset, fCurrentOffset, true);
                            fCharacterCounter++;
                            ch = loadNextChar();
                            return recognizeMarkup(ch);
                        }
                        fCharacterCounter++;
                        ch = loadNextChar();
                        break;
                    case 2: // '&'
                        if (!fInCDSect) {
                            callCharDataHandler(charDataOffset, fCurrentOffset, true);
                            fCharacterCounter++;
                            ch = loadNextChar();
                            return recognizeReference(ch);
                        }
                        fCharacterCounter++;
                        ch = loadNextChar();
                        break;
                    case 3: // ']'
                        int endOffset = fCurrentOffset;
                        ch = loadNextChar();
                        if (ch != ']') {
                            fCharacterCounter++;
                            break;
                        }
                        if (fCurrentIndex + 1 == CharDataChunk.CHUNK_SIZE) {
                            CharDataChunk dataChunk = fCurrentChunk;
                            int index = fCurrentIndex;
                            int offset = fCurrentOffset;
                            if (loadNextChar() != '>') {
                                fCurrentChunk = dataChunk;
                                fCurrentIndex = index;
                                fCurrentOffset = offset;
                                fMostRecentData = dataChunk.toCharArray();
                                fMostRecentChar = ']';
                                fCharacterCounter++;
                                break;
                            }
                        } else {
                            if (fMostRecentData[fCurrentIndex + 1] != '>') {
                                fCharacterCounter++;
                                break;
                            }
                            fCurrentIndex++;
                            fCurrentOffset++;
                        }
                        loadNextChar();
                        callCharDataHandler(charDataOffset, endOffset, true);
                        fCharacterCounter += 3;
                        return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                    case 4: // invalid char
                        callCharDataHandler(charDataOffset, fCurrentOffset, true);
                        if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                            changeReaders();
                            return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                        }
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                } else if (!skipMultiByteCharData(ch)) {
                    callCharDataHandler(charDataOffset, fCurrentOffset, true);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
                break;
            }
        } else if (!skipMultiByteCharData(ch)) {
            return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
        }
        ch = skipAsciiCharData();
        while (true) {
            if (ch < 0x80) {
                switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                case 0:
                    fCharacterCounter++;
                    ch = loadNextChar();
                    break;
                case 1: // '<'
                    if (!fInCDSect) {
                        callCharDataHandler(charDataOffset, fCurrentOffset, false);
                        fCharacterCounter++;
                        ch = loadNextChar();
                        return recognizeMarkup(ch);
                    }
                    fCharacterCounter++;
                    ch = loadNextChar();
                    break;
                case 2: // '&'
                    if (!fInCDSect) {
                        callCharDataHandler(charDataOffset, fCurrentOffset, false);
                        fCharacterCounter++;
                        ch = loadNextChar();
                        return recognizeReference(ch);
                    }
                    fCharacterCounter++;
                    ch = loadNextChar();
                    break;
                case 3: // ']'
                    int endOffset = fCurrentOffset;
                    ch = loadNextChar();
                    if (ch != ']') {
                        fCharacterCounter++;
                        break;
                    }
                    if (fCurrentIndex + 1 == CharDataChunk.CHUNK_SIZE) {
                        CharDataChunk dataChunk = fCurrentChunk;
                        int index = fCurrentIndex;
                        int offset = fCurrentOffset;
                        if (loadNextChar() != '>') {
                            fCurrentChunk = dataChunk;
                            fCurrentIndex = index;
                            fCurrentOffset = offset;
                            fMostRecentData = dataChunk.toCharArray();
                            fMostRecentChar = ']';
                            fCharacterCounter++;
                            break;
                        }
                    } else {
                        if (fMostRecentData[fCurrentIndex + 1] != '>') {
                            fCharacterCounter++;
                            break;
                        }
                        fCurrentIndex++;
                        fCurrentOffset++;
                    }
                    loadNextChar();
                    callCharDataHandler(charDataOffset, endOffset, false);
                    fCharacterCounter += 3;
                    return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                case 4: // invalid char
                    if (ch == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                        ch = loadNextChar();
                        break;
                    }
                    callCharDataHandler(charDataOffset, fCurrentOffset, false);
                    if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                        changeReaders();
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                    }
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            } else {
                if (!skipMultiByteCharData(ch)) {
                    callCharDataHandler(charDataOffset, fCurrentOffset, false);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
                ch = fMostRecentChar;
            }
        }
    }

    //
    // Private data members
    //
    private static final char[] cdata_string = { 'C','D','A','T','A','[' };
    private StringPool fStringPool = null;
    private boolean fCalledCharPropInit = false;
    private boolean fCallClearPreviousChunk = true;
    private Vector fDeferredErrors = null;

    //
    // Private classes
    //
    private class DeferredError {
        int errorCode;
        Object[] args;
        int offset;
        DeferredError(int ec, Object[] a, int o) {
            errorCode = ec;
            args = a;
            offset = o;
        }
    }

    //
    // Private methods
    //

    /*
     * Return a result code for scanContent when the character data
     * ends with a less-than character.
     */
    private int recognizeMarkup(int ch) throws Exception {
        switch (ch) {
        case 0:
            return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
        case '?':
            fCharacterCounter++;
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_PI;
        case '!':
            fCharacterCounter++;
            ch = loadNextChar();
            if (ch == 0) {
                fCharacterCounter--;
                fCurrentOffset--;
                return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
            }
            if (ch == '-') {
                fCharacterCounter++;
                ch = loadNextChar();
                if (ch == 0) {
                    fCharacterCounter -= 2;
                    fCurrentOffset -= 2;
                    return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                }
                if (ch == '-') {
                    fCharacterCounter++;
                    loadNextChar();
                    return XMLEntityHandler.CONTENT_RESULT_START_OF_COMMENT;
                }
                break;
            }
            if (ch == '[') {
                for (int i = 0; i < 6; i++) {
                    fCharacterCounter++;
                    ch = loadNextChar();
                    if (ch == 0) {
                        fCharacterCounter -= (2 + i);
                        fCurrentOffset -= (2 + i);
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                    }
                    if (ch != cdata_string[i]) {
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
                    }
                }
                fCharacterCounter++;
                loadNextChar();
                return XMLEntityHandler.CONTENT_RESULT_START_OF_CDSECT;
            }
            break;
        case '/':
            fCharacterCounter++;
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG;
        default:
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ELEMENT;
        }
        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
    }

    /*
     * Return a result code for scanContent when the character data
     * ends with an ampersand character.
     */
    private int recognizeReference(int ch) throws Exception {
        if (ch == 0) {
            return XMLEntityHandler.CONTENT_RESULT_REFERENCE_END_OF_INPUT;
        }
        //
        // [67] Reference ::= EntityRef | CharRef
        // [68] EntityRef ::= '&' Name ';'
        // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
        //
        if (ch == '#') {
            fCharacterCounter++;
            loadNextChar();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_CHARREF;
        } else {
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ENTITYREF;
        }
    }

    /*
     * Skip over a multi-byte character.
     */
    private boolean skipMultiByteCharData(int ch) throws Exception {
        if (ch < 0xD800) {
            loadNextChar();
            return true;
        }
        if (ch > 0xFFFD)
            return false;
        if (ch >= 0xDC00 && ch < 0xE000)
            return false;
        if (ch >= 0xD800 && ch < 0xDC00) {
            CharDataChunk savedChunk = fCurrentChunk;
            int savedIndex = fCurrentIndex;
            int savedOffset = fCurrentOffset;
            ch = loadNextChar();
            if (ch < 0xDC00 || ch >= 0xE000) {
                fCurrentChunk = savedChunk;
                fCurrentIndex = savedIndex;
                fCurrentOffset = savedOffset;
                fMostRecentData = savedChunk.toCharArray();
                fMostRecentChar = fMostRecentData[savedIndex] & 0xFFFF;
                return false;
            }
        }
        loadNextChar();
        return true;
    }

    /*
     * Skip over contiguous ascii character data.
     *
     * @return the character skipped
     * @exception java.lang.Exception
     */
    private int skipAsciiCharData() throws Exception {
        int index = fCurrentIndex;
        int offset = fCurrentOffset - index;
        while (true) {
            char[] data = fMostRecentData;
            while (index < CharDataChunk.CHUNK_SIZE) {
                int ch = data[index] & 0xFFFF;
                if (ch >= 0x80) {
                    fCurrentOffset = offset + index;
                    fCurrentIndex = index;
                    fMostRecentChar = ch;
                    return ch;
                }
                if (XMLCharacterProperties.fgAsciiCharData[ch] == 0) {
                    fCharacterCounter++;
                } else if (ch == 0x0A) {
                    fLinefeedCounter++;
                    fCharacterCounter = 1;
                } else {
                    fCurrentOffset = offset + index;
                    fCurrentIndex = index;
                    fMostRecentChar = ch;
                    return ch;
                }
                index++;
            }
            offset += index;
            slowLoadNextChar();
            index = 0;
        }
    }

    /*
     * Report character data to the parser through the entity handler interface.
     *
     * @param offset the offset of the start of the character data
     * @param endOffset the offset of the end of the character data
     * @param isWhitespace true if the character data is whitespace
     * @exception java.lang.Exception
     */
    private void callCharDataHandler(int offset, int endOffset, boolean isWhitespace) throws Exception {

        int length = endOffset - offset;
        if (!fSendCharDataAsCharArray) {
            int stringIndex = addString(offset, length);
            if (isWhitespace)
                fCharDataHandler.processWhitespace(stringIndex);
            else
                fCharDataHandler.processCharacters(stringIndex);
            return;
        }

        CharDataChunk dataChunk = fCurrentChunk.chunkFor(offset);
        int index = offset & CharDataChunk.CHUNK_MASK;
        if (index + length <= CharDataChunk.CHUNK_SIZE) {
            //
            // All the chars are in the same chunk
            //
            if (length != 0) {
                if (isWhitespace)
                    fCharDataHandler.processWhitespace(dataChunk.toCharArray(), index, length);
                else
                    fCharDataHandler.processCharacters(dataChunk.toCharArray(), index, length);
            }
            return;
        }

        //
        // The data is spread across chunks.
        //
        int count = length;
        int nbytes = CharDataChunk.CHUNK_SIZE - index;
        if (isWhitespace)
            fCharDataHandler.processWhitespace(dataChunk.toCharArray(), index, nbytes);
        else
            fCharDataHandler.processCharacters(dataChunk.toCharArray(), index, nbytes);
        count -= nbytes;

        //
        // Use each Chunk in turn until we are done.
        //
        do {
            dataChunk = dataChunk.nextChunk();
            if (dataChunk == null) {
                throw new RuntimeException(new ImplementationMessages().createMessage(null, ImplementationMessages.INT_DCN, 0, null));
            }
            nbytes = count <= CharDataChunk.CHUNK_SIZE ? count : CharDataChunk.CHUNK_SIZE;
            if (isWhitespace)
                fCharDataHandler.processWhitespace(dataChunk.toCharArray(), 0, nbytes);
            else
                fCharDataHandler.processCharacters(dataChunk.toCharArray(), 0, nbytes);
            count -= nbytes;
        } while (count > 0);
    }

    /*
     * Advance the reader's notion of where it is, moving on to the next chunk.
     *
     * @return The next character that will be processed.
     * @exception java.lang.Exception
     */
    private int slowLoadNextChar() throws Exception {
        fCallClearPreviousChunk = true;
        if (fCurrentChunk.nextChunk() != null) {
            fCurrentChunk = fCurrentChunk.nextChunk();
            fCurrentIndex = 0;
            fMostRecentData = fCurrentChunk.toCharArray();
            return (fMostRecentChar = fMostRecentData[fCurrentIndex] & 0xFFFF);
        } else {
            fCurrentChunk = CharDataChunk.createChunk(fStringPool, fCurrentChunk);
            return fillCurrentChunk();
        }
    }

    /*
     * Advance the reader's notion of where it is
     *
     * @return The next character that will be processed.
     * @exception java.lang.Exception
     */
    private int loadNextChar() throws Exception {
        fCurrentOffset++;
        if (++fCurrentIndex == CharDataChunk.CHUNK_SIZE)
            return slowLoadNextChar();
        return (fMostRecentChar = fMostRecentData[fCurrentIndex] & 0xFFFF);
    }

    /*
     * Would the reader be at end of file at a given offset?
     *
     * @param offset the offset to test for being at EOF
     * @return true if being at offset would mean being at or beyond EOF
     */
    private boolean atEOF(int offset) {
        return (offset > fLength);
    }

}
"
org/apache/xerces/dom/DeferredElementImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

/*
 * WARNING: because java doesn't support multi-inheritance some code is
 * duplicated. If you're changing this file you probably want to change
 * DeferredElementNSImpl.java at the same time.
 */

package org.apache.xerces.dom;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.xerces.utils.StringPool;

import org.w3c.dom.*;

/**
 * Elements represent most of the ""markup"" and structure of the
 * document.  They contain both the data for the element itself
 * (element name and attributes), and any contained nodes, including
 * document text (as children).
 * <P>
 * Elements may have Attributes associated with them; the API for this is
 * defined in Node, but the function is implemented here. In general, XML
 * applications should retrive Attributes as Nodes, since they may contain
 * entity references and hence be a fairly complex sub-tree. HTML users will
 * be dealing with simple string values, and convenience methods are provided
 * to work in terms of Strings.
 * <P>
 * DeferredElementImpl inherits from ElementImpl which does not support
 * Namespaces. DeferredElementNSImpl, which inherits from ElementNSImpl, does.
 * @see DeferredElementNSImpl
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredElementImpl
    extends ElementImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -7670981133940934842L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here. All
     * other data, can be requested from the ownerDocument via the index.
     */
    DeferredElementImpl(DeferredDocumentImpl ownerDoc, int nodeIndex) {
        super(ownerDoc, null);

        fNodeIndex = nodeIndex;
        syncChildren(true);

    } // <init>(DocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public final int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected final void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument;
        int elementTypeName = ownerDocument.getNodeName(fNodeIndex);
        StringPool pool = ownerDocument.getStringPool();
        name = pool.toString(elementTypeName);

        // attributes
        setupDefaultAttributes();
        int index = ownerDocument.getNodeValue(fNodeIndex);
        if (index != -1) {
            NamedNodeMap attrs = getAttributes();
            do {
                NodeImpl attr = (NodeImpl)ownerDocument.getNodeObject(index);
                attrs.setNamedItem(attr);
                index = ownerDocument.getPrevSibling(index);
            } while (index != -1);
        }

    } // synchronizeData()

    protected final void synchronizeChildren() {
        synchronizeChildren(fNodeIndex);
    } // synchronizeChildren()

} // class DeferredElementImpl
"
org/apache/xerces/dom/CDATASectionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * XML provides the CDATA markup to allow a region of text in which
 * most of the XML delimiter recognition does not take place. This is
 * intended to ease the task of quoting XML fragments and other
 * programmatic information in a document's text without needing to
 * escape these special characters. It's primarily a convenience feature
 * for those who are hand-editing XML.
 * <P>
 * CDATASection is an Extended DOM feature, and is not used in HTML 
 * contexts.
 * <P>
 * Within the DOM, CDATASections are treated essentially as Text
 * blocks. Their distinct type is retained in order to allow us to
 * properly recreate the XML syntax when we write them out.
 * <P>
 * Reminder: CDATA IS NOT A COMPLETELY GENERAL SOLUTION; it can't
 * quote its own end-of-block marking. If you need to write out a
 * CDATA that contains the ]]> sequence, it's your responsibility to
 * split that string over two successive CDATAs at that time.
 * <P>
 * CDATA does not participate in Element.normalize() processing.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class CDATASectionImpl 
    extends TextImpl 
    implements CDATASection {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 2372071297878177780L;

    //
    // Constructors
    //

    /** Factory constructor for creating a CDATA section. */
    public CDATASectionImpl(DocumentImpl ownerDoc, String data) {
        super(ownerDoc, data);
    }  
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.CDATA_SECTION_NODE;
    }
  
    /** Returns the node name. */
    public String getNodeName() {
        return ""#cdata-section"";
    }

} // class CDATASectionImpl
"
org/w3c/dom/EntityReference.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 * <code>EntityReference</code> objects may be inserted into the structure 
 * model when an entity reference is in the source document, or when the user 
 * wishes to insert an entity reference. Note that character references and 
 * references to predefined entities are considered to be expanded by the 
 * HTML or XML processor so that characters are represented by their Unicode 
 * equivalent rather than by an entity reference. Moreover, the XML processor 
 * may completely expand references to entities while building the structure 
 * model, instead of providing <code>EntityReference</code> objects. If it 
 * does provide such objects, then for a given <code>EntityReference</code> 
 * node, it may be that there is no <code>Entity</code> node representing the 
 * referenced entity. If such an <code>Entity</code> exists, then the child 
 * list of the <code>EntityReference</code> node is in general the same as 
 * that of the <code>Entity</code> node. They may differ when an entity 
 * contains an unbound  namespace prefix . In such a case, because the 
 * namespace prefix resolution depends on where the entity reference is, the 
 * descendants of the <code>EntityReference</code> node may be bound to 
 * different  namespace URIs .
 * <p> As with the <code>Entity</code> node, all descendants of the 
 * <code>EntityReference</code> are readonly.
 */
public interface EntityReference extends Node {
}

"
org/xml/sax/DTDHandler.java,true,"// SAX DTD handler.
// No warranty; no copyright -- use this as you will.
// $Id: DTDHandler.java,v 1.4 2000/05/05 17:46:02 david Exp $

package org.xml.sax;

/**
 * Receive notification of basic DTD-related events.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>If a SAX application needs information about notations and
 * unparsed entities, then the application implements this 
 * interface and registers an instance with the SAX parser using 
 * the parser's setDTDHandler method.  The parser uses the 
 * instance to report notation and unparsed entity declarations to 
 * the application.</p>
 *
 * <p>Note that this interface includes only those DTD events that
 * the XML recommendation <em>requires</em> processors to report:
 * notation and unparsed entity declarations.</p>
 *
 * <p>The SAX parser may report these events in any order, regardless
 * of the order in which the notations and unparsed entities were
 * declared; however, all DTD events must be reported after the
 * document handler's startDocument event, and before the first
 * startElement event.</p>
 *
 * <p>It is up to the application to store the information for 
 * future use (perhaps in a hash table or object tree).
 * If the application encounters attributes of type ""NOTATION"",
 * ""ENTITY"", or ""ENTITIES"", it can use the information that it
 * obtained through this interface to find the entity and/or
 * notation corresponding with the attribute value.</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser#setDTDHandler
 * @see org.xml.sax.HandlerBase 
 */
public interface DTDHandler {
    
    
    /**
     * Receive notification of a notation declaration event.
     *
     * <p>It is up to the application to record the notation for later
     * reference, if necessary.</p>
     *
     * <p>At least one of publicId and systemId must be non-null.
     * If a system identifier is present, and it is a URL, the SAX
     * parser must resolve it fully before passing it to the
     * application through this event.</p>
     *
     * <p>There is no guarantee that the notation declaration will be
     * reported before any unparsed entities that use it.</p>
     *
     * @param name The notation name.
     * @param publicId The notation's public identifier, or null if
     *        none was given.
     * @param systemId The notation's system identifier, or null if
     *        none was given.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #unparsedEntityDecl
     * @see org.xml.sax.AttributeList
     */
    public abstract void notationDecl (String name,
				       String publicId,
				       String systemId)
	throws SAXException;
    
    
    /**
     * Receive notification of an unparsed entity declaration event.
     *
     * <p>Note that the notation name corresponds to a notation
     * reported by the {@link #notationDecl notationDecl} event.  
     * It is up to the application to record the entity for later 
     * reference, if necessary.</p>
     *
     * <p>If the system identifier is a URL, the parser must resolve it
     * fully before passing it to the application.</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @param name The unparsed entity's name.
     * @param publicId The entity's public identifier, or null if none
     *        was given.
     * @param systemId The entity's system identifier.
     * @param notation name The name of the associated notation.
     * @see #notationDecl
     * @see org.xml.sax.AttributeList
     */
    public abstract void unparsedEntityDecl (String name,
					     String publicId,
					     String systemId,
					     String notationName)
	throws SAXException;
    
}

// end of DTDHandler.java
"
org/w3c/dom/Node.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>Node</code> interface is the primary datatype for the entire 
 * Document Object Model. It represents a single node in the document tree. 
 * While all objects implementing the <code>Node</code> interface expose 
 * methods for dealing with children, not all objects implementing the 
 * <code>Node</code> interface may have children. For example, 
 * <code>Text</code> nodes may not have children, and adding children to such 
 * nodes results in a <code>DOMException</code> being raised.
 * <p> The attributes <code>nodeName</code> , <code>nodeValue</code> and 
 * <code>attributes</code> are included as a mechanism to get at node 
 * information without casting down to the specific derived interface. In 
 * cases where there is no obvious mapping of these attributes for a specific 
 * <code>nodeType</code> (e.g., <code>nodeValue</code> for an 
 * <code>Element</code> or <code>attributes</code> for a <code>Comment</code> 
 * ), this returns <code>null</code> . Note that the specialized interfaces 
 * may contain additional and more convenient mechanisms to get and set the 
 * relevant information.
 */
public interface Node {
    // NodeType
    public static final short ELEMENT_NODE              = 1;
    public static final short ATTRIBUTE_NODE            = 2;
    public static final short TEXT_NODE                 = 3;
    public static final short CDATA_SECTION_NODE        = 4;
    public static final short ENTITY_REFERENCE_NODE     = 5;
    public static final short ENTITY_NODE               = 6;
    public static final short PROCESSING_INSTRUCTION_NODE = 7;
    public static final short COMMENT_NODE              = 8;
    public static final short DOCUMENT_NODE             = 9;
    public static final short DOCUMENT_TYPE_NODE        = 10;
    public static final short DOCUMENT_FRAGMENT_NODE    = 11;
    public static final short NOTATION_NODE             = 12;

    /**
     *  The name of this node, depending on its type; see the table above. 
     */
    public String getNodeName();

    /**
     *  The value of this node, depending on its type; see the table above. 
     * When it is defined to be <code>null</code> , setting it has no effect.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     * @exception DOMException
     *    DOMSTRING_SIZE_ERR: Raised when it would return more characters 
     *   than fit in a <code>DOMString</code> variable on the implementation 
     *   platform.
     */
    public String getNodeValue()
                                  throws DOMException;
    public void setNodeValue(String nodeValue)
                                  throws DOMException;

    /**
     *  A code representing the type of the underlying object, as defined 
     * above.
     */
    public short getNodeType();

    /**
     *  The parent of this node. All nodes, except <code>Attr</code> , 
     * <code>Document</code> , <code>DocumentFragment</code> , 
     * <code>Entity</code> , and <code>Notation</code> may have a parent. 
     * However, if a	node has just been created and not yet added to the 
     * tree, or if it has been removed from the tree, this is 
     * <code>null</code> .
     */
    public Node getParentNode();

    /**
     *  A <code>NodeList</code> that contains all children of this node. If 
     * there are no children, this is a <code>NodeList</code> containing no 
     * nodes. The content of the returned <code>NodeList</code> is ""live"" in 
     * the sense that, for instance, changes to the children of the node 
     * object that it	was created from are immediately reflected in the nodes 
     * returned by the <code>NodeList</code> accessors; it is not a static 
     * snapshot of the content of the node. This is true for every 
     * <code>NodeList</code> , including the ones returned by the 
     * <code>getElementsByTagName</code> method.
     */
    public NodeList getChildNodes();

    /**
     *  The first child of this node. If there is no such node, this returns 
     * <code>null</code> .
     */
    public Node getFirstChild();

    /**
     *  The last child of this node. If there is no such node, this returns 
     * <code>null</code> .
     */
    public Node getLastChild();

    /**
     *  The node immediately preceding this node. If there is no such node, 
     * this returns <code>null</code> .
     */
    public Node getPreviousSibling();

    /**
     *  The node immediately following this node. If there is no such node, 
     * this returns <code>null</code> .
     */
    public Node getNextSibling();

    /**
     *  A <code>NamedNodeMap</code> containing the attributes of this node (if 
     * it is an <code>Element</code> ) or <code>null</code> otherwise. 
     */
    public NamedNodeMap getAttributes();

    /**
     *  The <code>Document</code> object associated with this node. This is 
     * also the <code>Document</code> object used to create new nodes. When 
     * this node is a <code>Document</code> or a <code>DocumentType</code> 
     * which is not used with any <code>Document</code> yet, this is 
     * <code>null</code> .
     * @version DOM Level 2
     */
    public Document getOwnerDocument();

    /**
     *  Inserts the node <code>newChild</code> before the existing child node 
     * <code>refChild</code> . If <code>refChild</code> is <code>null</code> 
     * , insert <code>newChild</code> at the end of the list of children.
     * <br> If <code>newChild</code> is a <code>DocumentFragment</code> 
     * object, all of its children are inserted, in the same order, before 
     * <code>refChild</code> . If the <code>newChild</code> is already in the 
     * tree, it is first removed.
     * @param newChild  The node to insert.
     * @param refChild  The reference node, i.e., the node before which the 
     *   new node must be inserted.
     * @return  The node being inserted.
     * @exception DOMException
     *    HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does 
     *   not allow children of the type of the <code>newChild</code> node, or 
     *   if the node to insert is one of this node's ancestors.
     *   <br> WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created 
     *   from a different document than the one that created this node.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the node 
     *   being inserted is readonly.
     *   <br> NOT_FOUND_ERR: Raised if <code>refChild</code> is not a child 
     *   of this node.
     */
    public Node insertBefore(Node newChild, 
                             Node refChild)
                             throws DOMException;

    /**
     *  Replaces the child node <code>oldChild</code> with 
     * <code>newChild</code> in the list of children, and returns the 
     * <code>oldChild</code> node.
     * <br> If <code>newChild</code> is a <code>DocumentFragment</code> object,
     *  <code>oldChild</code> is replaced by all of the 
     * <code>DocumentFragment</code> children, which are inserted in the same 
     * order. If the <code>newChild</code> is already in the tree, it is 
     * first removed.
     * @param newChild  The new node to put in the child list.
     * @param oldChild  The node being replaced in the list.
     * @return  The node replaced.
     * @exception DOMException
     *    HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does 
     *   not allow children of the type of the <code>newChild</code> node, or 
     *   if the node to put in is one of this node's ancestors.
     *   <br> WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created 
     *   from a different document than the one that created this node.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the new 
     *   node is readonly.
     *   <br> NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child 
     *   of this node.
     */
    public Node replaceChild(Node newChild, 
                             Node oldChild)
                             throws DOMException;

    /**
     *  Removes the child node indicated by <code>oldChild</code> from the 
     * list of children, and returns it.
     * @param oldChild  The node being removed.
     * @return  The node removed.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child 
     *   of this node.
     */
    public Node removeChild(Node oldChild)
                            throws DOMException;

    /**
     *  Adds the node <code>newChild</code> to the end of the list of children 
     * of this node. If the <code>newChild</code> is already in the tree, it 
     * is first removed.
     * @param newChild  The node to add. If it is a  
     *   <code>DocumentFragment</code> object, the entire contents of the 
     *   document fragment are moved into the child list of this node
     * @return  The node added.
     * @exception DOMException
     *    HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does 
     *   not allow children of the type of the <code>newChild</code> node, or 
     *   if the node to append is one of this node's ancestors.
     *   <br> WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created 
     *   from a different document than the one that created this node.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the node 
     *   being appended is readonly.
     */
    public Node appendChild(Node newChild)
                            throws DOMException;

    /**
     *  This is a convenience method to allow easy determination of whether a 
     * node has any children.
     * @return  <code>true</code> if the node has any children, 
     *   <code>false</code> if the node has no children.
     */
    public boolean hasChildNodes();

    /**
     *  Returns a duplicate of this node, i.e., serves as a generic copy 
     * constructor for nodes. The duplicate node has no parent; (
     * <code>parentNode</code> returns <code>null</code> .).
     * <br> Cloning an <code>Element</code> copies all attributes and their 
     * values, including those generated by the XML processor to represent 
     * defaulted attributes, but this method does not copy any text it 
     * contains unless it is a deep clone, since the text is contained in a 
     * child <code>Text</code> node. Cloning any other type of node simply 
     * returns a copy of this node.
     * <br> Note that cloning an immutable subtree results in a mutable copy, 
     * but the children of an <code>EntityReference</code> clone are readonly.
     * @param deep  If <code>true</code> , recursively clone the subtree under 
     *   the specified node; if <code>false</code> , clone only the node 
     *   itself (and its attributes, if it is an <code>Element</code> ).  
     * @return  The duplicate node.
     */
    public Node cloneNode(boolean deep);

    /**
     *  Puts all <code>Text</code> nodes in the full depth of the sub-tree 
     * underneath this <code>Node</code> , including attribute nodes, into a 
     * ""normal"" form where only markup (e.g., tags, comments, processing 
     * instructions, CDATA sections, and entity references) separates 
     * <code>Text</code> nodes, i.e., there are neither adjacent 
     * <code>Text</code> nodes nor empty <code>Text</code> nodes. This can be 
     * used to ensure that the DOM view  of a document is the same as if it 
     * were saved and re-loaded, and is useful when operations (such as 
     * XPointer lookups) that depend on a particular document tree structure 
     * are to be used. In cases where the document contains 
     * <code>CDATASections</code> , the normalize operation alone may not be 
     * sufficient, since XPointers do not differentiate between 
     * <code>Text</code> nodes and <code>CDATASection</code> nodes.
     * @since DOM Level 2
     */
    public void normalize();

    /**
     *  Tests whether the DOM implementation implements a specific feature and 
     * that feature is supported by this node.
     * @param feature  The name of the feature to test. This is the same name 
     *   which can be passed to the method <code>hasFeature</code> on 
     *   <code>DOMImplementation</code> .
     * @param version  This is the version number of the feature to test. In 
     *   Level 2, version 1, this is the string ""2.0"". If the version is not 
     *   specified, supporting any version of the feature will cause the 
     *   method to return <code>true</code> .
     * @return  Returns <code>true</code> if the specified feature is supported
     *    on this node, <code>false</code> otherwise.
     * @since DOM Level 2
     */
    public boolean supports(String feature, 
                            String version);

    /**
     *  The  namespace URI of this node, or <code>null</code> if it is 
     * unspecified.
     * <br> This is not a computed value that is the result of a namespace 
     * lookup based on an examination of the namespace declarations in scope. 
     * It is merely the namespace URI given at creation time.
     * <br> For nodes of any type other than <code>ELEMENT_NODE</code> and 
     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1 
     * method, such as <code>createElement</code> from the 
     * <code>Document</code> interface, this is always <code>null</code> . 
     * Per the  Namespaces in XML Specification  an attribute does not 
     * inherit its namespace from the element it is attached to. If an 
     * attribute is not explicitly given a namespace, it simply has no 
     * namespace.
     * @since DOM Level 2
     */
    public String getNamespaceURI();

    /**
     *  The  namespace prefix of this node, or <code>null</code> if it is 
     * unspecified.
     * <br> Note that setting this attribute, when permitted, changes the 
     * <code>nodeName</code> attribute, which holds the  qualified name , as 
     * well as the <code>tagName</code> and <code>name</code> attributes of 
     * the <code>Element</code> and <code>Attr</code> interfaces, when 
     * applicable.
     * <br> Note also that changing the prefix of an attribute that is known to
     *  have a default value, does not make a new attribute with the default 
     * value and the original prefix appear, since the 
     * <code>namespaceURI</code> and <code>localName</code> do not change.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified prefix contains an 
     *   illegal character.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> NAMESPACE_ERR: Raised if the specified <code>prefix</code> is 
     *   malformed, if the <code>namespaceURI</code> of this node is 
     *   <code>null</code> , if the specified prefix is ""xml"" and the 
     *   <code>namespaceURI</code> of this node is different from 
     *   ""http://www.w3.org/XML/1998/namespace"", if this node is an attribute 
     *   and the specified prefix is ""xmlns"" and the <code>namespaceURI</code>
     *    of this node is different from ""http://www.w3.org/2000/xmlns/"", or 
     *   if this node is an attribute and the <code>qualifiedName</code> of 
     *   this node is ""xmlns""  .
     * @since DOM Level 2
     */
    public String getPrefix();
    public void setPrefix(String prefix)
                            throws DOMException;

    /**
     *  Returns the local part of the  qualified name of this node.
     * <br> For nodes created with a DOM Level 1 method, such as 
     * <code>createElement</code> from the <code>Document</code> interface, 
     * it is <code>null</code> .
     * @since DOM Level 2
     */
    public String getLocalName();

}

"
org/apache/xerces/dom/DeferredCommentImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Represents an XML (or HTML) comment.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredCommentImpl 
    extends CommentImpl 
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 6498796371083589338L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here. All other data,
     * can be requested from the ownerDocument via the index.
     */
    DeferredCommentImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);

    } // <init>(DeferredDocumentImpl,int)
    
    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl) this.ownerDocument();
        data = ownerDocument.getNodeValueString(fNodeIndex);

    } // synchronizeData()

} // class DeferredCommentImpl
"
org/apache/xerces/dom/DeferredTextImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Text nodes hold the non-markup, non-Entity content of
 * an Element or Attribute.
 * <P>
 * When a document is first made available to the DOM, there is only
 * one Text object for each block of adjacent plain-text. Users (ie,
 * applications) may create multiple adjacent Texts during editing --
 * see {@link Element#normalize} for discussion.
 * <P>
 * Note that CDATASection is a subclass of Text. This is conceptually
 * valid, since they're really just two different ways of quoting
 * characters when they're written out as part of an XML stream.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredTextImpl
    extends TextImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 2310613872100393425L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredTextImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the underlying data. */
    protected void synchronizeData() {

        // no need for future synchronizations
        syncData(false);

        // get initial text value
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl) this.ownerDocument();
        data = ownerDocument.getNodeValueString(fNodeIndex);

        // revisit: we only normalize text nodes with Elements as parents.
        int parent = -1;
        if (getNodeType() == Node.TEXT_NODE &&
            (parent = ownerDocument.getParentNode(fNodeIndex)) != -1 &&
            ownerDocument.getNodeType(parent) == Node.ELEMENT_NODE) {

            int realPrev = ownerDocument.getRealPrevSibling(fNodeIndex);
            int type     = ownerDocument.getNodeType(realPrev);
            if (realPrev != -1 && type == Node.TEXT_NODE) {
                StringBuffer sb = new StringBuffer(data);
                while (realPrev != -1 && type == Node.TEXT_NODE) {
                    sb.insert(0, ownerDocument.getNodeValueString(realPrev));
                    realPrev = ownerDocument.getRealPrevSibling(realPrev);
                    type = ownerDocument.getNodeType(realPrev);
                }
                data = sb.toString();
            }
        }

        // ignorable whitespace
        ignorableWhitespace(ownerDocument.getLastChild(fNodeIndex) == 1);

    } // synchronizeData()

} // class DeferredTextImpl
"
org/w3c/dom/Entity.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  This interface represents an entity, either parsed or unparsed, in an XML 
 * document. Note that this models the entity itself  not the entity 
 * declaration. <code>Entity</code> declaration modeling has been left for a 
 * later Level of the DOM specification.
 * <p> The <code>nodeName</code> attribute that is inherited from 
 * <code>Node</code> contains the name of the entity.
 * <p> An XML processor may choose to completely expand entities before  the 
 * structure model is passed to the DOM; in this case there will be no 
 * <code>EntityReference</code> nodes in the document tree.
 * <p> XML does not mandate that a non-validating XML processor read and 
 * process entity declarations made in the external subset or declared in 
 * external parameter entities. This means that parsed entities declared in 
 * the external subset need not be expanded by some classes of applications, 
 * and that the replacement value of the entity may not be available. When the
 *  replacement value is available, the corresponding  <code>Entity</code> 
 * node's child list represents the structure of that replacement text. 
 * Otherwise, the child list is empty.
 * <p> The DOM Level 2 does not support editing <code>Entity</code> nodes; if 
 * a user wants to make changes to the contents of an <code>Entity</code> , 
 * every related <code>EntityReference</code> node has to be replaced in the 
 * structure model by a clone of the <code>Entity</code> 's contents, and 
 * then the desired changes must be made to each of those clones instead. All 
 * the descendants of an <code>Entity</code> node are readonly.
 * <p> An <code>Entity</code> node does not have any parent. If the entity 
 * contains an unbound  namespace prefix , the <code>namespaceURI</code> of 
 * the corresponding node in the <code>Entity</code> node subtree is 
 * <code>null</code> . The same is true for <code>EntityReference</code> 
 * nodes that refer to this entity, when they are created using the 
 * <code>createEntityReference</code> method of the <code>Document</code> 
 * interface. The DOM Level 2 does not support any mechanism to resolve 
 * namespace prefixes.
 */
public interface Entity extends Node {
    /**
     *  The public identifier associated with the entity, if specified. If the 
     * public identifier was not specified, this is <code>null</code> .
     */
    public String getPublicId();

    /**
     *  The system identifier associated with the entity, if specified. If the 
     * system identifier was not specified, this is <code>null</code> .
     */
    public String getSystemId();

    /**
     *  For unparsed entities, the name of the notation for the entity. For 
     * parsed entities, this is <code>null</code> . 
     */
    public String getNotationName();

}

"
org/apache/xerces/dom/EntityReferenceImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * EntityReference models the XML &entityname; syntax, when used for
 * entities defined by the DOM. Entities hardcoded into XML, such as
 * character entities, should instead have been translated into text
 * by the code which generated the DOM tree.
 * <P>
 * An XML processor has the alternative of fully expanding Entities
 * into the normal document tree. If it does so, no EntityReference nodes
 * will appear.
 * <P>
 * Similarly, non-validating XML processors are not required to read
 * or process entity declarations made in the external subset or
 * declared in external parameter entities. Hence, some applications
 * may not make the replacement value available for Parsed Entities 
 * of these types.
 * <P>
 * EntityReference behaves as a read-only node, and the children of 
 * the EntityReference (which reflect those of the Entity, and should
 * also be read-only) give its replacement value, if any. They are 
 * supposed to automagically stay in synch if the DocumentType is 
 * updated with new values for the Entity.
 * <P>
 * The defined behavior makes efficient storage difficult for the DOM
 * implementor. We can't just look aside to the Entity's definition
 * in the DocumentType since those nodes have the wrong parent (unless
 * we can come up with a clever ""imaginary parent"" mechanism). We
 * must at least appear to clone those children... which raises the
 * issue of keeping the reference synchronized with its parent.
 * This leads me back to the ""cached image of centrally defined data""
 * solution, much as I dislike it.
 * <P>
 * For now I have decided, since REC-DOM-Level-1-19980818 doesn't
 * cover this in much detail, that synchronization doesn't have to be
 * considered while the user is deep in the tree. That is, if you're
 * looking within one of the EntityReferennce's children and the Entity
 * changes, you won't be informed; instead, you will continue to access
 * the same object -- which may or may not still be part of the tree.
 * This is the same behavior that obtains elsewhere in the DOM if the
 * subtree you're looking at is deleted from its parent, so it's
 * acceptable here. (If it really bothers folks, we could set things
 * up so deleted subtrees are walked and marked invalid, but that's
 * not part of the DOM's defined behavior.)
 * <P>
 * As a result, only the EntityReference itself has to be aware of
 * changes in the Entity. And it can take advantage of the same
 * structure-change-monitoring code I implemented to support
 * DeepNodeList.
 * 
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class EntityReferenceImpl 
    extends ChildAndParentNode
    implements EntityReference {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -7381452955687102062L;
    
    //
    // Data
    //

    /** Name of Entity referenced */
    protected String name;

    /** Entity changes. */
	//protected int entityChanges = -1;	

    /** Enable synchronize. */
    //protected boolean fEnableSynchronize = false;

    //
    // Constructors
    //

    /** Factory constructor. */
    public EntityReferenceImpl(DocumentImpl ownerDoc, String name) {
    	super(ownerDoc);
        this.name = name;
        readOnly(true);
    }
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.ENTITY_REFERENCE_NODE;
    }

    /**
     * Returns the name of the entity referenced
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    // REVISIT: Return original entity reference code. -Ac

    /**
     * Perform synchronize() before accessing children.
     * 
     * @return org.w3c.dom.NodeList
     */
    public NodeList getChildNodes() {
    	synchronize();
    	return super.getChildNodes();
    }

    /**
     * Perform synchronize() before accessing children.
     * 
     * @return org.w3c.dom.NodeList
     */
    public Node getFirstChild() {
    	synchronize();
    	return super.getFirstChild();
    }

    /**
     * Perform synchronize() before accessing children.
     * 
     * @return org.w3c.dom.NodeList
     */
    public Node getLastChild() {
    	synchronize();
    	return super.getLastChild();
    }

    /**
     * Query the number of children in the entity definition.
     * (A bit more work than asking locally, but may be able to avoid
     * or defer building the clone subtree.)
     *
     * @return org.w3c.dom.NodeList
     */
    public int getLength() {
        synchronize();
    	return super.getLength();
    }

    /**
     * Returns whether this node has any children.
     * @return boolean
     */
    public boolean hasChildNodes() {
    	synchronize();
    	return super.hasChildNodes();
    }

    /** Returns the node at the given index. */
    public Node item(int index) {
    	synchronize();
    	return super.item(index);
    }


    /**
     * EntityReference's children are a reflection of those defined in the
     * named Entity. This method creates them if they haven't been created yet.
     * This doesn't really support editing the Entity though.
     */
    protected void synchronize() {
        if (firstChild != null) {
            return;
        }
    	DocumentType doctype;
    	NamedNodeMap entities;
    	EntityImpl entDef;
    	if (null != (doctype = getOwnerDocument().getDoctype()) && 
            null != (entities = doctype.getEntities())) {
            
            entDef = (EntityImpl)entities.getNamedItem(getNodeName());

            // No Entity by this name, stop here.
            if (entDef == null)
                return;

            // If entity's definition exists, clone its kids
            readOnly(false);
            for (Node defkid = entDef.getFirstChild();
                 defkid != null;
                 defkid = defkid.getNextSibling()) {
                Node newkid = defkid.cloneNode(true);
                insertBefore(newkid,null);
            }
            setReadOnly(true, true);
    	}
    }


    /**
     * Enable the synchronize method which may do cloning. This method is enabled
     * when the parser is done with an EntityReference.
    /***
    // revisit: enable editing of Entity
    public void enableSynchronize(boolean enableSynchronize) {
        fEnableSynchronize= enableSynchronize;
    }
    /***/

    /**
     * EntityReference's children are a reflection of those defined in the
     * named Entity. This method updates them if the Entity is changed.
     * <P>
     * It is unclear what the least-cost resynch mechanism is.
     * If we expect the kids to be shallow, and/or expect changes
     * to the Entity contents to be rare, wiping them all out
     * and recloning is simplest.
     * <P>
     * If we expect them to be deep,
     * it might be better to first decide which kids (if any)
     * persist, and keep the ones (if any) that are unchanged
     * rather than doing all the work of cloning them again.
     * But that latter gets into having to convolve the two child lists,
     * insert new information in the right order (and possibly reorder
     * the existing kids), and a few other complexities that I really
     * don't want to deal with in this implementation.
     * <P>
     * Note that if we decide that we need to update the EntityReference's
     * contents, we have to turn off the readOnly flag temporarily to do so.
     * When we get around to adding multitasking support, this whole method
     * should probably be an atomic operation.
     * 
     * @see DocumentTypeImpl
     * @see EntityImpl
     */
     // The Xerces parser invokes callbacks for startEnityReference
     // the parsed value of the entity EACH TIME, so it is actually 
     // easier to create the nodes through the callbacks rather than
     // clone the Entity.
    /***
    // revisit: enable editing of Entity
    private void synchronize() {
        if (!fEnableSynchronize) {
            return;
        }
    	DocumentType doctype;
    	NamedNodeMap entities;
    	EntityImpl entDef;
    	if (null != (doctype = getOwnerDocument().getDoctype()) && 
    		null != (entities = doctype.getEntities())) {
            
    		entDef = (EntityImpl)entities.getNamedItem(getNodeName());

    		// No Entity by this name. If we had a change count, reset it.
    		if(null==entDef)
    			entityChanges=-1;

    		// If no kids availalble, wipe any pre-existing children.
    		// (See discussion above.)
    		// Note that we have to use the superclass to avoid recursion
    		// through Synchronize.
    		readOnly=false;
    		if(null==entDef || !entDef.hasChildNodes())
    			for(Node kid=super.getFirstChild();
    				kid!=null;
    				kid=super.getFirstChild())
    				removeChild(kid);

    		// If entity's definition changed, clone its kids
    		// (See discussion above.)
    		if(null!=entDef && entDef.changes!=entityChanges) {
    			for(Node defkid=entDef.getFirstChild();
    				defkid!=null;
    				defkid=defkid.getNextSibling()) {
                    
    				NodeImpl newkid=(NodeImpl) defkid.cloneNode(true);
    				newkid.setReadOnly(true,true);
    				insertBefore(newkid,null);
    			}
    			entityChanges=entDef.changes;
    		}
    		readOnly=true;
    	}
    }
     /***/
    
} // class EntityReferenceImpl
"
org/apache/xerces/dom/ElementImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import java.io.*;
import java.util.Enumeration;
import java.util.Vector;

import org.w3c.dom.*;

/**
 * Elements represent most of the ""markup"" and structure of the
 * document.  They contain both the data for the element itself
 * (element name and attributes), and any contained nodes, including
 * document text (as children).
 * <P>
 * Elements may have Attributes associated with them; the API for this is
 * defined in Node, but the function is implemented here. In general, XML
 * applications should retrive Attributes as Nodes, since they may contain
 * entity references and hence be a fairly complex sub-tree. HTML users will
 * be dealing with simple string values, and convenience methods are provided
 * to work in terms of Strings.
 * <P>
 * ElementImpl does not support Namespaces. ElementNSImpl, which inherits from
 * it, does.
 * @see ElementNSImpl
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class ElementImpl
    extends ChildAndParentNode
    implements Element {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 3717253516652722278L;
    //
    // Data
    //

    /** Element name. */
    protected String name;

    /** Attributes. */
    protected NamedNodeMapImpl attributes;

    //
    // Constructors
    //

    /** Factory constructor. */
    public ElementImpl(DocumentImpl ownerDoc, String name) {
    	super(ownerDoc);
        this.name = name;
        syncData(true);         // synchronizeData will initialize attributes
    }

    // for ElementNSImpl
    protected ElementImpl() {}
    
    //
    // Node methods
    //

    
    /**
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.ELEMENT_NODE;
    }

    /**
     * Returns the element name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    /**
     * Retrieve all the Attributes as a set. Note that this API is inherited
     * from Node rather than specified on Element; in fact only Elements will
     * ever have Attributes, but they want to allow folks to ""blindly"" operate
     * on the tree as a set of Nodes.
     */
    public NamedNodeMap getAttributes() {

        if (syncData()) {
            synchronizeData();
        }

        return attributes;

    } // getAttributes():NamedNodeMap

    /**
     * Return a duplicate copy of this Element. Note that its children
     * will not be copied unless the ""deep"" flag is true, but Attributes
     * are <i>always</i> replicated.
     *
     * @see org.w3c.dom.Node#cloneNode(boolean)
     */
    public Node cloneNode(boolean deep) {

        if (syncData()) {
            synchronizeData();
        }

    	ElementImpl newnode = (ElementImpl) super.cloneNode(deep);
    	// Replicate NamedNodeMap rather than sharing it.
    	newnode.attributes = attributes.cloneMap(newnode);
    	return newnode;

    } // cloneNode(boolean):Node


    /**
     * NON-DOM
     * set the ownerDocument of this node, its children, and its attributes
     */
    void setOwnerDocument(DocumentImpl doc) {
	super.setOwnerDocument(doc);
	attributes.setOwnerDocument(doc);
    }

    //
    // Element methods
    //

    /**
     * Look up a single Attribute by name. Returns the Attribute's
     * string value, or an empty string (NOT null!) to indicate that the
     * name did not map to a currently defined attribute.
     * <p>
     * Note: Attributes may contain complex node trees. This method
     * returns the ""flattened"" string obtained from Attribute.getValue().
     * If you need the structure information, see getAttributeNode().
     */
    public String getAttribute(String name) {

        if (syncData()) {
            synchronizeData();
        }

        Attr attr = (Attr)(attributes.getNamedItem(name));
        return (attr == null) ? """" : attr.getValue();

    } // getAttribute(String):String


    /**
     * Look up a single Attribute by name. Returns the Attribute Node,
     * so its complete child tree is available. This could be important in
     * XML, where the string rendering may not be sufficient information.
     * <p>
     * If no matching attribute is available, returns null.
     */
    public Attr getAttributeNode(String name) {

        if (syncData()) {
            synchronizeData();
        }

        return (Attr)attributes.getNamedItem(name);

    } // getAttributeNode(String):Attr
    

    /**
     * Returns a NodeList of all descendent nodes (children,
     * grandchildren, and so on) which are Elements and which have the
     * specified tag name.
     * <p>
     * Note: NodeList is a ""live"" view of the DOM. Its contents will
     * change as the DOM changes, and alterations made to the NodeList
     * will be reflected in the DOM.
     *
     * @param tagname The type of element to gather. To obtain a list of
     * all elements no matter what their names, use the wild-card tag
     * name ""*"".
     *
     * @see DeepNodeListImpl
     */
    public NodeList getElementsByTagName(String tagname) {
    	return new DeepNodeListImpl(this,tagname);
    }

    /**
     * Returns the name of the Element. Note that Element.nodeName() is
     * defined to also return the tag name.
     * <p>
     * This is case-preserving in XML. HTML should uppercasify it on the
     * way in.
     */
    public String getTagName() {
        if (syncData()) {
            synchronizeData();
        }
    	return name;
    }

    /**
     * In ""normal form"" (as read from a source file), there will never be two
     * Text children in succession. But DOM users may create successive Text
     * nodes in the course of manipulating the document. Normalize walks the
     * sub-tree and merges adjacent Texts, as if the DOM had been written out
     * and read back in again. This simplifies implementation of higher-level
     * functions that may want to assume that the document is in standard form.
     * <p>
     * To normalize a Document, normalize its top-level Element child.
     * <p>
     * As of PR-DOM-Level-1-19980818, CDATA -- despite being a subclass of
     * Text -- is considered ""markup"" and will _not_ be merged either with
     * normal Text or with other CDATASections.
     */
    public void normalize() {

    	Node kid, next;
    	for (kid = getFirstChild(); kid != null; kid = next) {
    		next = kid.getNextSibling();

    		// If kid and next are both Text nodes (but _not_ CDATASection,
    		// which is a subclass of Text), they can be merged.
    		if (next != null
			 && kid.getNodeType() == Node.TEXT_NODE
			 && next.getNodeType() == Node.TEXT_NODE)
    	    {
    			((Text)kid).appendData(next.getNodeValue());
    			removeChild(next);
    			next = kid; // Don't advance; there might be another.
    		}

    		// Otherwise it might be an Element, which is handled recursively
    		else if (kid.getNodeType() ==  Node.ELEMENT_NODE) {
                ((Element)kid).normalize();
            }
        }

    	// changed() will have occurred when the removeChild() was done,
    	// so does not have to be reissued.

    } // normalize()

    /**
     * Remove the named attribute from this Element. If the removed
     * Attribute has a default value, it is immediately replaced thereby.
     * <P>
     * The default logic is actually implemented in NamedNodeMapImpl.
     * PR-DOM-Level-1-19980818 doesn't fully address the DTD, so some
     * of this behavior is likely to change in future versions. ?????
     * <P>
     * Note that this call ""succeeds"" even if no attribute by this name
     * existed -- unlike removeAttributeNode, which will throw a not-found
     * exception in that case.
     *	
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
     * readonly.
     */
    public void removeAttribute(String name) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    		
        if (syncData()) {
            synchronizeData();
        }

    	AttrImpl att = (AttrImpl) attributes.getNamedItem(name);
    	// Remove it (and let the NamedNodeMap recreate the default, if any)
    	if (att != null) {
            attributes.removeNamedItem(name);
    	}

    } // removeAttribute(String)

  
    /**
     * Remove the specified attribute/value pair. If the removed
     * Attribute has a default value, it is immediately replaced.
     * <p>
     * NOTE: Specifically removes THIS NODE -- not the node with this
     * name, nor the node with these contents. If the specific Attribute
     * object passed in is not stored in this Element, we throw a
     * DOMException.  If you really want to remove an attribute by name,
     * use removeAttribute().
     *
     * @return the Attribute object that was removed.
     * @throws DOMException(NOT_FOUND_ERR) if oldattr is not an attribute of
     * this Element.
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
     * readonly.
     */
    public Attr removeAttributeNode(Attr oldAttr)
        throws DOMException
        {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    		
        if (syncData()) {
            synchronizeData();
        }

    	AttrImpl found = (AttrImpl) attributes.getNamedItem(oldAttr.getName());

    	// If it is in fact the right object, remove it (and let the
    	// NamedNodeMap recreate the default, if any)

    	if (found == oldAttr) {
            attributes.removeNamedItem(oldAttr.getName());
            return found;
    	}

        throw new DOMExceptionImpl(DOMException.NOT_FOUND_ERR, 
                                   ""DOM008 Not found"");

    } // removeAttributeNode(Attr):Attr

   
    /**
     * Add a new name/value pair, or replace the value of the existing
     * attribute having that name.
     *
     * Note: this method supports only the simplest kind of Attribute,
     * one whose value is a string contained in a single Text node.
     * If you want to assert a more complex value (which XML permits,
     * though HTML doesn't), see setAttributeNode().
     *
     * The attribute is created with specified=true, meaning it's an
     * explicit value rather than inherited from the DTD as a default.
     * Again, setAttributeNode can be used to achieve other results.
     *
     * @throws DOMException(INVALID_NAME_ERR) if the name is not acceptable.
     * (Attribute factory will do that test for us.)
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
     * readonly.
     */
    public void setAttribute(String name, String value) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }

        if (syncData()) {
            synchronizeData();
        }

    	AttrImpl newAttr = (AttrImpl) getAttributeNode(name);
        if (newAttr == null) {
            newAttr = (AttrImpl) getOwnerDocument().createAttribute(name);
            attributes.setNamedItem(newAttr);
        }
    	newAttr.setNodeValue(value);

    } // setAttribute(String,String)
 
    /**
     * Add a new attribute/value pair, or replace the value of the
     * existing attribute with that name.
     * <P>
     * This method allows you to add an Attribute that has already been
     * constructed, and hence avoids the limitations of the simple
     * setAttribute() call. It can handle attribute values that have
     * arbitrarily complex tree structure -- in particular, those which
     * had entity references mixed into their text.
     *
     * @throws DOMException(INUSE_ATTRIBUTE_ERR) if the Attribute object
     * has already been assigned to another Element.
     */
    public Attr setAttributeNode(Attr newAttr)
        throws DOMException
        {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    	
        if (syncData()) {
            synchronizeData();
        }

    	if (ownerDocument.errorChecking && !(newAttr instanceof AttrImpl)) {
    		throw new DOMExceptionImpl(DOMException.WRONG_DOCUMENT_ERR, 
    		                           ""DOM005 Wrong document"");
        }

    	AttrImpl na = (AttrImpl) newAttr;
    	AttrImpl oldAttr = (AttrImpl) attributes.getNamedItem(newAttr.getName());

    	// This will throw INUSE if necessary
    	attributes.setNamedItem(na);

    	return oldAttr;

    } // setAttributeNode(Attr):Attr
    
    //
    // DOM2: Namespace methods
    //

    /**
     * Introduced in DOM Level 2. <p>
     *
     * Retrieves an attribute value by local name and namespace URI. 
     *
     * @param namespaceURI
     *                      The namespace URI of the attribute to
     *                      retrieve.
     * @param localName     The local name of the attribute to retrieve.
     * @return String       The Attr value as a string, or null
     *                      if that attribute
     *                      does not have a specified or default value.
     * @since WD-DOM-Level-2-19990923
     */
    public String getAttributeNS(String namespaceURI, String localName) {

        if (syncData()) {
            synchronizeData();
        }

        Attr attr = (Attr)(attributes.getNamedItemNS(namespaceURI, localName));
        return (attr == null) ? null : attr.getValue();

    } // getAttributeNS(String,String):String
    
    /**
     * Introduced in DOM Level 2. <p>
     *
     *  Adds a new attribute. 
     *  If the given namespaceURI is null or an empty string and
     *  the qualifiedName has a prefix that is ""xml"", the new attribute is bound to the
     *  predefined namespace ""http://www.w3.org/XML/1998/namespace"" [Namespaces].
     *  If an attribute with the same local name and namespace URI is already present on
     *  the element, its prefix is changed to be the prefix part of the qualifiedName, and
     *  its value is changed to be the value parameter. This value is a simple string, it is not
     *  parsed as it is being set. So any markup (such as syntax to be recognized as an
     *  entity reference) is treated as literal text, and needs to be appropriately escaped by
     *  the implementation when it is written out. In order to assign an attribute value that
     *  contains entity references, the user must create an Attr node plus any Text and
     *  EntityReference nodes, build the appropriate subtree, and use
     *  setAttributeNodeNS or setAttributeNode to assign it as the value of an
     *  attribute.
     * @param namespaceURI
     *                          The namespace URI of the attribute to create
     *                          or alter. 
     * @param localName         The local name of the attribute to create or
     *                          alter.
     * @param value             The value to set in string form.
     * @throws                  INVALID_CHARACTER_ERR: Raised if the specified
     *                          name contains an invalid character.
     *
     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this
     *                          node is readonly.
     *
     * @throws                  NAMESPACE_ERR: Raised if the qualifiedName
     *                          has a prefix that is ""xml"" and the namespaceURI is
     *                          neither null nor an empty string nor
     *                          ""http://www.w3.org/XML/1998/namespace"", or if the
     *                          qualifiedName has a prefix that is ""xmlns"" but the
     *                          namespaceURI is neither null nor an empty string, or
     *                          if if the qualifiedName has a prefix different from
     *                          ""xml"" and ""xmlns"" and the namespaceURI is null or an
     *                          empty string.
     * @since WD-DOM-Level-2-19990923
     */
    public void setAttributeNS(String namespaceURI, String localName, String value) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }

        if (syncData()) {
            synchronizeData();
        }
    	AttrImpl newAttr = (AttrImpl)
            getAttributeNodeNS(namespaceURI, localName);
        if (newAttr == null) {
            newAttr = (AttrImpl)
                getOwnerDocument().createAttributeNS(namespaceURI, localName);
            attributes.setNamedItemNS(newAttr);
    	}
    	newAttr.setNodeValue(value);

    } // setAttributeNS(String,String,String)
    
    /**
     * Introduced in DOM Level 2. <p>
     *
     * Removes an attribute by local name and namespace URI. If the removed
     * attribute has a default value it is immediately replaced.
     * The replacing attribute has the same namespace URI and local name, 
     * as well as the original prefix.<p>
     *
     * @param namespaceURI  The namespace URI of the attribute to remove.
     *                      
     * @param localName     The local name of the attribute to remove.
     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this
     *                          node is readonly.
     * @since WD-DOM-Level-2-19990923
     */
    public void removeAttributeNS(String namespaceURI, String localName) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    		
        if (syncData()) {
            synchronizeData();
        }

    	AttrImpl att = (AttrImpl) attributes.getNamedItemNS(namespaceURI, localName);
    	// Remove it (and let the NamedNodeMap recreate the default, if any)
    	if (att != null) {
            attributes.removeNamedItemNS(namespaceURI, localName);
    	}

    } // removeAttributeNS(String,String)
    
    /**
     * Retrieves an Attr node by local name and namespace URI. 
     *
     * @param namespaceURI  The namespace URI of the attribute to
     *                      retrieve. 
     * @param localName     The local name of the attribute to retrieve.
     * @return Attr         The Attr node with the specified attribute 
     *                      local name and namespace
     *                      URI or null if there is no such attribute.
     * @since WD-DOM-Level-2-19990923
     */
    public Attr getAttributeNodeNS(String namespaceURI, String localName){

        if (syncData()) {
            synchronizeData();
        }

        return (Attr)attributes.getNamedItemNS( namespaceURI, localName);

    } // getAttributeNodeNS(String,String):Attr
 
    /**
     * Introduced in DOM Level 2. <p>
     *
     * Adds a new attribute. If an attribute with that local name and 
     * namespace URI is already present in the element, it is replaced 
     * by the new one.
     *
     * @param Attr      The Attr node to add to the attribute list. When 
     *                  the Node has no namespaceURI, this method behaves 
     *                  like setAttributeNode.
     * @return Attr     If the newAttr attribute replaces an existing attribute with the same
     *                  local name and namespace URI, the previously existing Attr node is
     *                  returned, otherwise null is returned.
     * @throws          WRONG_DOCUMENT_ERR: Raised if newAttr
     *                  was created from a different document than the one that
     *                  created the element.
     *
     * @throws          NO_MODIFICATION_ALLOWED_ERR: Raised if
     *                  this node is readonly.
     *
     * @throws          INUSE_ATTRIBUTE_ERR: Raised if newAttr is
     *                  already an attribute of another Element object. The
     *                  DOM user must explicitly clone Attr nodes to re-use
     *                  them in other elements.
     * @since WD-DOM-Level-2-19990923
     */
    public Attr setAttributeNodeNS(Attr newAttr)
        throws DOMException
        {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    	
        if (syncData()) {
            synchronizeData();
        }

    	if (ownerDocument.errorChecking && !(newAttr instanceof AttrImpl)) {
    		throw new DOMExceptionImpl(DOMException.WRONG_DOCUMENT_ERR, 
    		""DOM005 Wrong document"");
        }

    	AttrImpl na = (AttrImpl) newAttr;
    	AttrImpl oldAttr = (AttrImpl) attributes.getNamedItemNS(na.getNamespaceURI(), na.getLocalName());

    	// This will throw INUSE if necessary
    	attributes.setNamedItem(na);

    	return oldAttr;

    } // setAttributeNodeNS(Attr):Attr
    
    /**
     * Introduced in DOM Level 2. <p>
     */
    public boolean hasAttribute(String name) {
        return getAttribute(name) != null;
    }

    /**
     * Introduced in DOM Level 2. <p>
     */
    public boolean hasAttributeNS(String namespaceURI, String localName) {
        return getAttributeNS(namespaceURI, localName) != null;
    }

    /**
     * Introduced in DOM Level 2. <p>
     *
     * Returns a NodeList of all the Elements with a given local name and
     * namespace URI in the order in which they would be encountered in a preorder
     * traversal of the Document tree, starting from this node.
     *
     * @param namespaceURI The namespace URI of the elements to match
     *                     on. The special value ""*"" matches all
     *                     namespaces. When it is null or an empty
     *                     string, this method behaves like
     *                     getElementsByTagName.
     * @param localName    The local name of the elements to match on.
     *                     The special value ""*"" matches all local names.
     * @return NodeList    A new NodeList object containing all the matched Elements.
     * @since WD-DOM-Level-2-19990923
     */
    public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
    	return new DeepNodeListImpl(this, namespaceURI, localName);
    }

    //
    // Public methods
    //

    /**
     * NON-DOM: Subclassed to flip the attributes' readonly switch as well.
     * @see NodeImpl#setReadOnly
     */
    public void setReadOnly(boolean readOnly, boolean deep) {
    	super.setReadOnly(readOnly,deep);
    	attributes.setReadOnly(readOnly,true);
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // attributes
        setupDefaultAttributes();

    } // synchronizeData()

    /** Setup the default attributes. */
    protected void setupDefaultAttributes() {

    	// If there is an ElementDefintion, set its Attributes up as
    	// shadows behind our own.
    	NamedNodeMapImpl defaultAttrs = null;
    	DocumentTypeImpl doctype = (DocumentTypeImpl)ownerDocument.getDoctype();
    	if (doctype != null) {
    		ElementDefinitionImpl eldef =
                (ElementDefinitionImpl)doctype.getElements()
                                              .getNamedItem(getNodeName());
    		if (eldef != null) {
    			defaultAttrs = (NamedNodeMapImpl)eldef.getAttributes();
            }
        }

        // create attributes
    	attributes = new NamedNodeMapImpl(this, defaultAttrs);

    } // setupAttributes(DocumentImpl)

} // class ElementImpl
"
org/apache/xerces/dom/TextImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Text nodes hold the non-markup, non-Entity content of
 * an Element or Attribute.
 * <P>
 * When a document is first made available to the DOM, there is only
 * one Text object for each block of adjacent plain-text. Users (ie,
 * applications) may create multiple adjacent Texts during editing --
 * see {@link Element#normalize} for discussion.
 * <P>
 * Note that CDATASection is a subclass of Text. This is conceptually
 * valid, since they're really just two different ways of quoting
 * characters when they're written out as part of an XML stream.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class TextImpl 
    extends CharacterDataImpl 
    implements CharacterData, Text {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -5294980852957403469L;
    
    //
    // Constructors
    //

    /** Factory constructor. */
    public TextImpl(DocumentImpl ownerDoc, String data) {
        super(ownerDoc, data);
    }  
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.TEXT_NODE;
    }

    /** Returns the node name. */
    public String getNodeName() {
        return ""#text"";
    }

    /**
     * NON-DOM: Set whether this Text is ignorable whitespace.
     */
    public void setIgnorableWhitespace(boolean ignore) {

        if (syncData()) {
            synchronizeData();
        }
        ignorableWhitespace(ignore);

    } // setIgnorableWhitespace(boolean)
    

    /**
     * NON-DOM: Returns whether this Text is ignorable whitespace.
     */
    public boolean isIgnorableWhitespace() {

        if (syncData()) {
            synchronizeData();
        }
        return ignorableWhitespace();

    } // isIgnorableWhitespace():boolean
    
    //
    // Text methods
    //

    /** 
     * Break a text node into two sibling nodes.  (Note that if the
     * current node has no parent, they won't wind up as ""siblings"" --
     * they'll both be orphans.)
     *
     * @param offset The offset at which to split. If offset is at the
     * end of the available data, the second node will be empty.
     *
     * @returns A reference to the new node (containing data after the
     * offset point). The original node will contain data up to that
     * point.
     *
     * @throws DOMException(INDEX_SIZE_ERR) if offset is <0 or >length.
     *
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is read-only.
     */
    public Text splitText(int offset) 
        throws DOMException {

    	if (readOnly()) {
            throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }

        if (syncData()) {
            synchronizeData();
        }
    	if (offset < 0 || offset > data.length() - 1) {
            throw new DOMExceptionImpl(DOMException.INDEX_SIZE_ERR, 
                                       ""DOM004 Index out of bounds"");
        }
    		
        // split text into two separate nodes
    	Text newText =
            getOwnerDocument().createTextNode(data.substring(offset));
    	setNodeValue(data.substring(0, offset));

        // insert new text node
        Node parentNode = getParentNode();
    	if (parentNode != null) {
    		parentNode.insertBefore(newText, nextSibling);
        }

    	return newText;

    } // splitText(int):Text

} // class TextImpl
"
org/apache/xerces/domx/DOMException.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
 
package org.apache.xerces.domx; 

/**
 * DOM operations only raise exceptions in ""exceptional"" circumstances, i.e.,
 * when an operation is impossible to perform (either for logical reasons,
 * because data is lost, or  because the implementation has become unstable).
 * In general, DOM methods return specific error values in ordinary
 * processing situation, such as out-of-bound errors when using
 * <code>NodeList</code>.
 * <p>Implementations may raise other exceptions under other circumstances.
 * For example, implementations may raise an implementation-dependent
 * exception if a <code>null</code> argument is passed.
 * <p>Some languages and object systems do not support the concept of
 * exceptions. For such systems, error conditions may be indicated using
 * native error reporting mechanisms. For some bindings, for example, methods
 * may return error codes similar to those listed in the corresponding method
 * descriptions.
 */
public abstract class DOMException extends org.w3c.dom.DOMException {
  // DOM has named these but hasn't values yet. Stopgap:
  public static final short           UNSPECIFIED_EVENT_TYPE= 100;
  public static final short           UNSUPPORTED_EVENT_TYPE= 101;

 
  public DOMException(short code, String message) {
         super(code,message);
  }
}
"
org/w3c/dom/DocumentFragment.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 * <code>DocumentFragment</code> is a ""lightweight"" or ""minimal"" 
 * <code>Document</code> object. It is very common to want to be able to 
 * extract a portion of a document's tree or to create a new fragment of a 
 * document. Imagine implementing a user command like cut or rearranging a 
 * document by moving fragments around. It is desirable to have an object 
 * which can hold such fragments and it is quite natural to use a Node for 
 * this purpose. While it is true that a <code>Document</code> object could 
 * fulfill this role, a <code>Document</code> object can potentially be a 
 * heavyweight object, depending on the underlying implementation. What is 
 * really needed for this is a very lightweight object. 
 * <code>DocumentFragment</code> is such an object.
 * <p> Furthermore, various operations -- such as inserting nodes as children 
 * of another <code>Node</code> -- may take <code>DocumentFragment</code> 
 * objects as arguments;  this results in all the child nodes of the 
 * <code>DocumentFragment</code> being moved to the child list of this node.
 * <p> The children of a <code>DocumentFragment</code> node are zero or more 
 * nodes representing the tops of any sub-trees defining the structure of the 
 * document. <code>DocumentFragment</code> nodes do not need to be 
 * well-formed XML documents (although they do need to follow the rules 
 * imposed upon well-formed XML parsed entities, which can have multiple top 
 * nodes). For example, a <code>DocumentFragment</code> might have only one 
 * child and that child node could be a <code>Text</code> node. Such a 
 * structure model represents neither an HTML document nor a well-formed XML 
 * document.
 * <p> When a <code>DocumentFragment</code> is inserted into a 
 * <code>Document</code> (or indeed any other <code>Node</code> that may take 
 * children) the children of the <code>DocumentFragment</code> and not the 
 * <code>DocumentFragment</code> itself are inserted into the 
 * <code>Node</code> . This makes the <code>DocumentFragment</code> very 
 * useful when the user wishes to create nodes that are siblings; the 
 * <code>DocumentFragment</code> acts as the parent of these nodes so that 
 * the user can use the standard methods from the <code>Node</code> 
 * interface, such as <code>insertBefore</code> and <code>appendChild</code> .
 */
public interface DocumentFragment extends Node {
}

"
org/apache/xerces/readers/UTF8CharReader.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.CharDataChunk;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.ImplementationMessages;
import java.io.InputStream;

/**
 * Simple character-based version of a UTF8 reader.
 *
 * This class is not commonly used, but is provided as a much simplified
 * example of the UTF8Reader class that uses the AbstractCharReader to
 * perform all of the reader functions except for filling each buffer
 * of the character data when needed (fillCurrentChunk).  We read the
 * input data from an InputStream and perform end-of-line normalization
 * as we process that data.
 *
 * @version
 */
final class UTF8CharReader extends AbstractCharReader {
    //
    //
    //
    UTF8CharReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, InputStream dataStream, StringPool stringPool) throws Exception {
        super(entityHandler, errorReporter, sendCharDataAsCharArray, stringPool);
        fInputStream = dataStream;
        fillCurrentChunk();
    }
    //
    //
    //
    private InputStream fInputStream = null;
    //
    // When we fill a chunk there may be data that was read from the
    // input stream that has not been ""processed"".  We need to save
    // that data, and any in-progress state, between the calls to
    // fillCurrentChunk() in these instance variables.  
    //
    private boolean fCheckOverflow = false;
    private byte[] fOverflow = null;
    private int fOverflowOffset = 0;
    private int fOverflowEnd = 0;
    private int fOutputOffset = 0;
    private boolean fSkipLinefeed = false;
    private int fPartialMultiByteIn = 0;
    private byte[] fPartialMultiByteChar = new byte[3];
    private int fPartialSurrogatePair = 0;
    private boolean fPartialMultiByteResult = false;
    //
    //
    //
    protected int fillCurrentChunk() throws Exception {
        //
        // See if we can find a way to reuse the buffer that may have been returned
        // with a recyled data chunk.
        //
        char[] recycledData = fCurrentChunk.toCharArray();
        //
        // If we have overflow from the last call, normalize from where
        // we left off, copying into the front of the output buffer.
        //
        fOutputOffset = 0;
        if (fCheckOverflow) {
            //
            // The fOverflowEnd should always be equal to CHUNK_SIZE, unless we hit
            // EOF during the previous call.  Copy the remaining data to the front
            // of the buffer and return it as the final chunk.
            //
            fMostRecentData = recycledData;
            if (fOverflowEnd < CharDataChunk.CHUNK_SIZE) {
                recycledData = null;
                if (fOverflowEnd > 0) {
                    if (fMostRecentData == null || fMostRecentData.length < 1 + fOverflowEnd - fOverflowOffset)
                        fMostRecentData = new char[1 + fOverflowEnd - fOverflowOffset];
                    copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                } else {
                    if (fMostRecentData == null)
                        fMostRecentData = new char[1];
                }
                fMostRecentData[fOutputOffset] = 0;
                //
                // Update our instance variables
                //
                fOverflow = null;
                fLength += fOutputOffset;
                fCurrentIndex = 0;
                fCurrentChunk.setCharArray(fMostRecentData);
                return (fMostRecentChar = fMostRecentData[0]);
            }
            if (fMostRecentData == null || fMostRecentData.length < CharDataChunk.CHUNK_SIZE)
                fMostRecentData = new char[CharDataChunk.CHUNK_SIZE];
            else
                recycledData = null;
            copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
            fCheckOverflow = false;
        } else {
            if (fOverflow == null)
                fOverflow = new byte[CharDataChunk.CHUNK_SIZE];
            fMostRecentData = null;
        }
        while (true) {
            fOverflowOffset = 0;
            fOverflowEnd = 0;
            int capacity = CharDataChunk.CHUNK_SIZE;
            int result = 0;
            do {
                try {
                    result = fInputStream.read(fOverflow, fOverflowEnd, capacity);
                } catch (java.io.IOException ex) {
                    result = -1;
                }
                if (result == -1) {
                    //
                    // We have reached the end of the stream.
                    //
                    fInputStream.close();
                    fInputStream = null;
                    if (fMostRecentData == null) {
                        //
                        // There is no previous output data, so we know that all of the
                        // new input data will fit.
                        //
                        fMostRecentData = recycledData;
                        if (fMostRecentData == null || fMostRecentData.length < 1 + fOverflowEnd)
                            fMostRecentData = new char[1 + fOverflowEnd];
                        else
                            recycledData = null;
                        copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                        fOverflow = null;
                        fMostRecentData[fOutputOffset] = 0;
                    } else {
                        //
                        // Copy the input data to the end of the output buffer.
                        //
                        boolean alldone = copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                        if (alldone) {
                            if (fOverflowEnd == CharDataChunk.CHUNK_SIZE) {
                                //
                                // Special case - everything fit into the overflow buffer,
                                // except that there is no room for the nul char we use to
                                // indicate EOF.  Set the overflow buffer length to zero.
                                // On the next call to this method, we will detect this
                                // case and which we will handle above .
                                //
                                fCheckOverflow = true;
                                fOverflowOffset = 0;
                                fOverflowEnd = 0;
                            } else {
                                //
                                // It all fit into the output buffer.
                                //
                                fOverflow = null;
                                fMostRecentData[fOutputOffset] = 0;
                            }
                        } else {
                            //
                            // There is still input data left over, save the remaining data as
                            // the overflow buffer for the next call.
                            //
                            fCheckOverflow = true;
                        }
                    }
                    break;
                }
                if (result > 0) {
                    fOverflowEnd += result;
                    capacity -= result;
                }
            } while (capacity > 0);
            //
            //
            //
            if (result == -1)
                break;
            if (fMostRecentData != null) {
                boolean alldone = copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                if (fOutputOffset == CharDataChunk.CHUNK_SIZE) {
                    //
                    // We filled the output buffer.
                    //
                    if (!alldone) {
                        //
                        // The input buffer will become the next overflow buffer.
                        //
                        fCheckOverflow = true;
                    }
                    break;
                }
            } else {
                //
                // Now normalize the end-of-line characters and see if we need to read more
                // bytes to fill up the buffer.
                //
                fMostRecentData = recycledData;
                if (fMostRecentData == null || fMostRecentData.length < CharDataChunk.CHUNK_SIZE)
                    fMostRecentData = new char[CharDataChunk.CHUNK_SIZE];
                else
                    recycledData = null;
                copyNormalize(fOverflow, fOverflowOffset, fMostRecentData, fOutputOffset);
                if (fOutputOffset == CharDataChunk.CHUNK_SIZE) {
                    //
                    // The output buffer is full.  We can return now.
                    //
                    break;
                }
            }
            //
            // We will need to get another intput buffer to be able to fill the
            // overflow buffer completely.
            //
        }
        //
        // Update our instance variables
        //
        fLength += fOutputOffset;
        fCurrentIndex = 0;
        fCurrentChunk.setCharArray(fMostRecentData);
        return (fMostRecentChar = fMostRecentData[0]);
    }
    //
    // Copy and normalize bytes from the overflow buffer into chars in our data buffer.
    //
    private boolean copyNormalize(byte[] in, int inOffset, char[] out, int outOffset) throws Exception {
        //
        // Handle all edge cases before dropping into the inner loop.
        //
        int inEnd = fOverflowEnd;
        int outEnd = out.length;
        if (inOffset == inEnd)
            return true;
        byte b = in[inOffset];
        if (fSkipLinefeed) {
            fSkipLinefeed = false;
            if (b == 0x0A) {
                if (++inOffset == inEnd)
                    return exitNormalize(inOffset, outOffset, true);
                b = in[inOffset];
            }
        } else if (fPartialMultiByteIn > 0) {
            if (!handlePartialMultiByteChar(b, in, inOffset, inEnd, out, outOffset, outEnd))
                return fPartialMultiByteResult;
            inOffset = fOverflowOffset;
            outOffset = fOutputOffset;
            b = in[inOffset];
        }
        while (outOffset < outEnd) {
            //
            // Find the longest run that we can guarantee will not exceed the
            // bounds of the outer loop.
            //
            int inCount = inEnd - inOffset;
            int outCount = outEnd - outOffset;
            if (inCount > outCount)
                inCount = outCount;
            inOffset++;
            while (true) {
                while (b == 0x0D || b < 0) {
                    if (b == 0x0D) {
                        out[outOffset++] = 0x0A;
                        if (inOffset == inEnd) {
                            fSkipLinefeed = true;
                            return exitNormalize(inOffset, outOffset, true);
                        }
                        b = in[inOffset];
                        if (b == 0x0A) {
                            if (++inOffset == inEnd)
                                return exitNormalize(inOffset, outOffset, true);
                            b = in[inOffset];
                        }
                        if (outOffset == outEnd)
                            return exitNormalize(inOffset, outOffset, false);
                    } else {
                        if (!handleMultiByteChar(b, in, inOffset, inEnd, out, outOffset, outEnd))
                            return fPartialMultiByteResult;
                        inOffset = fOverflowOffset;
                        outOffset = fOutputOffset;
                        b = in[inOffset];
                    }
                    inCount = inEnd - inOffset;
                    outCount = outEnd - outOffset;
                    if (inCount > outCount)
                        inCount = outCount;
                    inOffset++;
                }
                while (true) {
                    out[outOffset++] = (char)b;
                    if (--inCount == 0)
                        break;
                    b = in[inOffset++];
                    if (b == 0x0D || b < 0)
                        break;
                }
                if (inCount == 0)
                    break;
            }
            if (inOffset == inEnd)
                break;
        }
        return exitNormalize(inOffset, outOffset, inOffset == inEnd);
    }
    //
    //
    //
    private boolean exitNormalize(int inOffset, int outOffset, boolean result) {
        fOverflowOffset = inOffset;
        fOutputOffset = outOffset;
        return result;
    }
    //
    //
    //
    private void savePartialMultiByte(int inCount, byte bz, byte by, byte bx) {
        fPartialMultiByteIn = inCount;
        fPartialMultiByteChar[--inCount] = bz;
        fPartialMultiByteChar[--inCount] = by;
        fPartialMultiByteChar[--inCount] = bx;
    }
    private void savePartialMultiByte(int inCount, byte bz, byte by) {
        fPartialMultiByteIn = inCount;
        fPartialMultiByteChar[--inCount] = bz;
        fPartialMultiByteChar[--inCount] = by;
    }
    private void savePartialMultiByte(int inCount, byte bz) {
        fPartialMultiByteIn = inCount;
        fPartialMultiByteChar[--inCount] = bz;
    }
    private boolean handleMultiByteChar(byte b, byte[] in, int inOffset, int inEnd, char[] out, int outOffset, int outEnd) throws Exception {
        if (inOffset == inEnd) {
            savePartialMultiByte(1, b);
            fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
            return false;
        }
        byte b1 = in[inOffset++];
        if ((b1 & 0xc0) != 0x80) {
            Object[] args = {
                Integer.toHexString(b & 0xff),
                Integer.toHexString(b1 & 0xff)
            };
            deferException(ImplementationMessages.ENC5, args, outOffset);
            out[outOffset++] = 0;
            return exitNormalize(inOffset, outOffset, true);
        }
        if ((b & 0xe0) == 0xc0) { // 110yyyyy 10xxxxxx
            int ch = ((0x1f & b)<<6) + (0x3f & b1);
            out[outOffset++] = (char)ch;
            if (inOffset == inEnd || outOffset == outEnd) {
                fPartialMultiByteResult = exitNormalize(inOffset, outOffset, inOffset == inEnd);
                return false;
            }
        } else {
            if (inOffset == inEnd) {
                savePartialMultiByte(2, b1, b);
                fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                return false;
            }
            byte b2 = in[inOffset++];
            if ((b2 & 0xc0) != 0x80) {
                Object[] args = {
                    Integer.toHexString(b & 0xff),
                    Integer.toHexString(b1 & 0xff),
                    Integer.toHexString(b2 & 0xff)
                };
                deferException(ImplementationMessages.ENC6, args, outOffset);
                out[outOffset++] = 0;
                return exitNormalize(inOffset, outOffset, true);
            }
            if ((b & 0xf0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                int ch = ((0x0f & b)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                out[outOffset++] = (char)ch;
                if (inOffset == inEnd || outOffset == outEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, inOffset == inEnd);
                    return false;
                }
            } else {
                if ((b & 0xf8) != 0xf0) {
                    Object[] args = { Integer.toHexString(b & 0xff) };
                    deferException(ImplementationMessages.ENC4, args, outOffset);
                    out[outOffset++] = 0;
                    return exitNormalize(inOffset, outOffset, true);
                }
                if (inOffset == inEnd) {
                    savePartialMultiByte(3, b2, b1, b);
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                    return false;
                }
                byte b3 = in[inOffset++];
                if ((b3 & 0xc0) != 0x80) {
                    Object[] args = {
                        Integer.toHexString(b & 0xff),
                        Integer.toHexString(b1 & 0xff),
                        Integer.toHexString(b2 & 0xff),
                        Integer.toHexString(b3 & 0xff)
                    };
                    deferException(ImplementationMessages.ENC7, args, outOffset);
                    out[outOffset++] = 0;
                    return exitNormalize(inOffset, outOffset, true);
                }
                int ch = ((0x0f & b)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3);
                if (ch >= 0x10000) {
                    out[outOffset++] = (char)(((ch-0x00010000)>>10)+0xd800);
                    ch = (((ch-0x00010000)&0x3ff)+0xdc00);
                    if (outOffset == outEnd) {
                        fPartialSurrogatePair = ch;
                        fPartialMultiByteResult = exitNormalize(inOffset, outOffset, inOffset == inEnd);
                        return false;
                    }
                }
                out[outOffset++] = (char)ch;
                if (inOffset == inEnd || outOffset == outEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, inOffset == inEnd);
                    return false;
                }
            }
        }
        return exitNormalize(inOffset, outOffset, true);
    }
    private boolean handlePartialMultiByteChar(byte b, byte[] in, int inOffset, int inEnd, char[] out, int outOffset, int outEnd) throws Exception {
        if (outOffset == outEnd) {
            fPartialMultiByteResult = exitNormalize(inOffset, outOffset, inOffset == inEnd);
            return false;
        }
        if (fPartialMultiByteIn == 4) {
            out[outOffset++] = (char)fPartialSurrogatePair;
            if (outOffset == outEnd) {
                fPartialMultiByteResult = exitNormalize(inOffset, outOffset, false);
                return false;
            }
            fOutputOffset = outOffset;
            return true;
        }
        int byteIn = fPartialMultiByteIn;
        fPartialMultiByteIn = 0;
        byte b1 = 0;
        byte b2 = 0;
        byte b3 = 0;
        switch (byteIn) {
        case 1: b1 = b; break;
        case 2: b2 = b; break;
        case 3: b3 = b; break;
        }
        int i = byteIn;
        switch (byteIn) {
        case 3:
            b2 = fPartialMultiByteChar[--i];
        case 2:
            b1 = fPartialMultiByteChar[--i];
        case 1:
            b = fPartialMultiByteChar[--i];
        }
        switch (byteIn) {
        case 1:
            if ((b1 & 0xc0) != 0x80) {
                Object[] args = {
                    Integer.toHexString(b),
                    Integer.toHexString(b1)
                };
                deferException(ImplementationMessages.ENC5, args, outOffset);
                out[outOffset++] = 0;
                break;
            }
            // fall through
        case 2:
            if ((b & 0xe0) == 0xc0) { // 110yyyyy 10xxxxxx
                int ch = ((0x1f & b)<<6) + (0x3f & b1);
                out[outOffset++] = (char)ch;
                if (outOffset == outEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, false);
                    return false;
                }
                if (byteIn < 2 && ++inOffset == inEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                    return false;
                }
                break;
            }
            if (byteIn < 2) {
                if (++inOffset == inEnd) {
                    savePartialMultiByte(2, b1);
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                    return false;
                }
                b2 = in[inOffset];
            }
            if ((b2 & 0xc0) != 0x80) {
                Object[] args = {
                    Integer.toHexString(b),
                    Integer.toHexString(b1),
                    Integer.toHexString(b2)
                };
                deferException(ImplementationMessages.ENC6, args, outOffset);
                out[outOffset++] = 0;
                break;
            }
            // fall through
        case 3:
            if ((b & 0xf0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                int ch = ((0x0f & b)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                out[outOffset++] = (char)ch;
                if (outOffset == outEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, false);
                    return false;
                }
                if (byteIn < 3 && ++inOffset == inEnd) {
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                    return false;
                }
                break;
            }
            if (byteIn < 3) {
                if ((b & 0xf8) != 0xf0) {
                    Object[] args = { Integer.toHexString(b) };
                    deferException(ImplementationMessages.ENC4, args, outOffset);
                    out[outOffset++] = 0;
                    break;
                }
                if (++inOffset == inEnd) {
                    savePartialMultiByte(3, b2, b1);
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                    return false;
                }
                b3 = in[inOffset];
            }
            if ((b3 & 0xc0) != 0x80) {
                Object[] args = {
                    Integer.toHexString(b),
                    Integer.toHexString(b1),
                    Integer.toHexString(b2),
                    Integer.toHexString(b3)
                };
                deferException(ImplementationMessages.ENC7, args, outOffset);
                out[outOffset++] = 0;
                break;
            }
            int ch = ((0x0f & b)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3);
            if (ch >= 0x10000) {
                out[outOffset++] = (char)(((ch-0x00010000)>>10)+0xd800);
                ch = (((ch-0x00010000)&0x3ff)+0xdc00);
                if (outOffset == outEnd) {
                    fPartialSurrogatePair = ch;
                    fPartialMultiByteResult = exitNormalize(inOffset, outOffset, false);
                    return false;
                }
            }
            out[outOffset++] = (char)ch;
            if (outOffset == outEnd) {
                fPartialMultiByteResult = exitNormalize(inOffset, outOffset, false);
                return false;
            }
            if (++inOffset == inEnd) {
                fPartialMultiByteResult = exitNormalize(inOffset, outOffset, true);
                return false;
            }
            break;
        }
        return exitNormalize(inOffset, outOffset, true);
    }
}
"
org/xml/sax/helpers/AttributeListImpl.java,true,"// SAX default implementation for AttributeList.
// No warranty; no copyright -- use this as you will.
// $Id: AttributeListImpl.java,v 1.4 2000/05/05 17:49:14 david Exp $

package org.xml.sax.helpers;

import org.xml.sax.AttributeList;

import java.util.Vector;


/**
 * Default implementation for AttributeList.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>AttributeList implements the deprecated SAX1 {@link
 * org.xml.sax.AttributeList AttributeList} interface, and has been
 * replaced by the new SAX2 {@link org.xml.sax.helpers.AttributesImpl
 * AttributesImpl} interface.</p>
 *
 * <p>This class provides a convenience implementation of the SAX
 * {@link org.xml.sax.AttributeList AttributeList} interface.  This 
 * implementation is useful both for SAX parser writers, who can use 
 * it to provide attributes to the application, and for SAX application 
 * writers, who can use it to create a persistent copy of an element's 
 * attribute specifications:</p>
 *
 * <pre>
 * private AttributeList myatts;
 *
 * public void startElement (String name, AttributeList atts)
 * {
 *              // create a persistent copy of the attribute list
 *              // for use outside this method
 *   myatts = new AttributeListImpl(atts);
 *   [...]
 * }
 * </pre>
 *
 * <p>Please note that SAX parsers are not required to use this
 * class to provide an implementation of AttributeList; it is
 * supplied only as an optional convenience.  In particular, 
 * parser writers are encouraged to invent more efficient
 * implementations.</p>
 *
 * @deprecated This class implements a deprecated interface,
 *             {@link org.xml.sax.AttributeList AttributeList};
 *             that interface has been replaced by
 *             {@link org.xml.sax.Attributes Attributes},
 *             which is implemented in the
 *             {@link org.xml.sax.helpers.AttributesImpl 
 *            AttributesImpl} helper class.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.AttributeList
 * @see org.xml.sax.DocumentHandler#startElement 
 */
public class AttributeListImpl implements AttributeList
{
    
    /**
     * Create an empty attribute list.
     *
     * <p>This constructor is most useful for parser writers, who
     * will use it to create a single, reusable attribute list that
     * can be reset with the clear method between elements.</p>
     *
     * @see #addAttribute
     * @see #clear
     */
    public AttributeListImpl ()
    {
    }
    
    
    /**
     * Construct a persistent copy of an existing attribute list.
     *
     * <p>This constructor is most useful for application writers,
     * who will use it to create a persistent copy of an existing
     * attribute list.</p>
     *
     * @param atts The attribute list to copy
     * @see org.xml.sax.DocumentHandler#startElement
     */
    public AttributeListImpl (AttributeList atts)
    {
	setAttributeList(atts);
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Methods specific to this class.
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Set the attribute list, discarding previous contents.
     *
     * <p>This method allows an application writer to reuse an
     * attribute list easily.</p>
     *
     * @param atts The attribute list to copy.
     */
    public void setAttributeList (AttributeList atts)
    {
	int count = atts.getLength();
	
	clear();
	
	for (int i = 0; i < count; i++) {
	    addAttribute(atts.getName(i), atts.getType(i), atts.getValue(i));
	}
    }
    
    
    /**
     * Add an attribute to an attribute list.
     *
     * <p>This method is provided for SAX parser writers, to allow them
     * to build up an attribute list incrementally before delivering
     * it to the application.</p>
     *
     * @param name The attribute name.
     * @param type The attribute type (""NMTOKEN"" for an enumeration).
     * @param value The attribute value (must not be null).
     * @see #removeAttribute
     * @see org.xml.sax.DocumentHandler#startElement
     */
    public void addAttribute (String name, String type, String value)
    {
	names.addElement(name);
	types.addElement(type);
	values.addElement(value);
    }
    
    
    /**
     * Remove an attribute from the list.
     *
     * <p>SAX application writers can use this method to filter an
     * attribute out of an AttributeList.  Note that invoking this
     * method will change the length of the attribute list and
     * some of the attribute's indices.</p>
     *
     * <p>If the requested attribute is not in the list, this is
     * a no-op.</p>
     *
     * @param name The attribute name.
     * @see #addAttribute
     */
    public void removeAttribute (String name)
    {
	int i = names.indexOf(name);
	
	if (i >= 0) {
	    names.removeElementAt(i);
	    types.removeElementAt(i);
	    values.removeElementAt(i);
	}
    }
    
    
    /**
     * Clear the attribute list.
     *
     * <p>SAX parser writers can use this method to reset the attribute
     * list between DocumentHandler.startElement events.  Normally,
     * it will make sense to reuse the same AttributeListImpl object
     * rather than allocating a new one each time.</p>
     *
     * @see org.xml.sax.DocumentHandler#startElement
     */
    public void clear ()
    {
	names.removeAllElements();
	types.removeAllElements();
	values.removeAllElements();
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Implementation of org.xml.sax.AttributeList
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Return the number of attributes in the list.
     *
     * @return The number of attributes in the list.
     * @see org.xml.sax.AttributeList#getLength
     */
    public int getLength ()
    {
	return names.size();
    }
    
    
    /**
     * Get the name of an attribute (by position).
     *
     * @param i The position of the attribute in the list.
     * @return The attribute name as a string, or null if there
     *         is no attribute at that position.
     * @see org.xml.sax.AttributeList#getName(int)
     */
    public String getName (int i)
    {
	if (i < 0) {
	    return null;
	}
	try {
	    return (String)names.elementAt(i);
	} catch (ArrayIndexOutOfBoundsException e) {
	    return null;
	}
    }
    
    
    /**
     * Get the type of an attribute (by position).
     *
     * @param i The position of the attribute in the list.
     * @return The attribute type as a string (""NMTOKEN"" for an
     *         enumeration, and ""CDATA"" if no declaration was
     *         read), or null if there is no attribute at
     *         that position.
     * @see org.xml.sax.AttributeList#getType(int)
     */
    public String getType (int i)
    {
	if (i < 0) {
	    return null;
	}
	try {
	    return (String)types.elementAt(i);
	} catch (ArrayIndexOutOfBoundsException e) {
	    return null;
	}
    }
    
    
    /**
     * Get the value of an attribute (by position).
     *
     * @param i The position of the attribute in the list.
     * @return The attribute value as a string, or null if
     *         there is no attribute at that position.
     * @see org.xml.sax.AttributeList#getValue(int)
     */
    public String getValue (int i)
    {
	if (i < 0) {
	    return null;
	}
	try {
	    return (String)values.elementAt(i);
	} catch (ArrayIndexOutOfBoundsException e) {
	    return null;
	}
    }
    
    
    /**
     * Get the type of an attribute (by name).
     *
     * @param name The attribute name.
     * @return The attribute type as a string (""NMTOKEN"" for an
     *         enumeration, and ""CDATA"" if no declaration was
     *         read).
     * @see org.xml.sax.AttributeList#getType(java.lang.String)
     */
    public String getType (String name)
    {
	return getType(names.indexOf(name));
    }
    
    
    /**
     * Get the value of an attribute (by name).
     *
     * @param name The attribute name.
     * @see org.xml.sax.AttributeList#getValue(java.lang.String)
     */
    public String getValue (String name)
    {
	return getValue(names.indexOf(name));
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Internal state.
    ////////////////////////////////////////////////////////////////////

    Vector names = new Vector();
    Vector types = new Vector();
    Vector values = new Vector();

}

// end of AttributeListImpl.java
"
org/w3c/dom/Comment.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  This interface inherits from <code>CharacterData</code> and represents the 
 * content of a comment, i.e., all the characters between the starting '
 * <code>&lt;!--</code> ' and ending '<code>--&gt;</code> '. Note that this 
 * is the definition of a comment in XML, and, in practice, HTML, although 
 * some HTML tools may implement the full SGML comment structure.
 */
public interface Comment extends CharacterData {
}

"
org/apache/xerces/utils/NamespacesScope.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

/**
 * NamespacesScope provides a data structure for mapping namespace prefixes
 * to their URI's.  The mapping accurately reflects the scoping of namespaces
 * at a particular instant in time.
 */
public class NamespacesScope {
    /**
     * NamespacesHandler allows a client to be notified when namespace scopes change
     */
    public interface NamespacesHandler {
        /**
         * startNamespaceDeclScope is called when a new namespace scope is created
         *
         * @param prefix the StringPool handle of the namespace prefix being declared
         * @param uri the StringPool handle of the namespace's URI
         * @exception java.lang.Exception
         */
        public void startNamespaceDeclScope(int prefix, int uri) throws Exception;
        /**
         * endNamespaceDeclScope is called when a namespace scope ends
         * 
         * @param prefix the StringPool handle of the namespace prefix going out of scope
         * @exception java.lang.Exception
         */
        public void endNamespaceDeclScope(int prefix) throws Exception;
    }
    public NamespacesScope(NamespacesHandler handler) {
        fHandler = handler;
        fNamespaceMappings[0] = new int[9];
        fNamespaceMappings[0][0] = 1;
    }
    /**
     * set the namespace URI for given prefix
     *
     * @param prefix the StringPool handler of the prefix
     * @param namespace the StringPool handle of the namespace URI
     */
    public void setNamespaceForPrefix(int prefix, int namespace) throws Exception {
        int offset = fNamespaceMappings[fElementDepth][0];
        if (offset == fNamespaceMappings[fElementDepth].length) {
            int[] newMappings = new int[offset + 8];
            System.arraycopy(fNamespaceMappings[fElementDepth], 0, newMappings, 0, offset);
            fNamespaceMappings[fElementDepth] = newMappings;
        }
        fNamespaceMappings[fElementDepth][offset++] = prefix;
        fNamespaceMappings[fElementDepth][offset++] = namespace;
        fNamespaceMappings[fElementDepth][0] = offset;
        if (fElementDepth > 0)
            fHandler.startNamespaceDeclScope(prefix, namespace);
    }
    /**
     * retreive the namespace URI for a prefix
     *
     * @param prefix the StringPool handle of the prefix
     */
    public int getNamespaceForPrefix(int prefix) {
        for (int depth = fElementDepth; depth >= 0; depth--) {
            int offset = fNamespaceMappings[depth][0];
            for (int i = 1; i < offset; i += 2) {
                if (prefix == fNamespaceMappings[depth][i]) {
                    return fNamespaceMappings[depth][i+1];
                }
            }
        }
        return -1;
    }
    /**
     *  Add a new namespace mapping
     */
    public void increaseDepth() throws Exception {
        fElementDepth++;
        if (fElementDepth == fNamespaceMappings.length) {
            int[][] newMappings = new int[fElementDepth + 8][];
            System.arraycopy(fNamespaceMappings, 0, newMappings, 0, fElementDepth);
            fNamespaceMappings = newMappings;
        }
        if (fNamespaceMappings[fElementDepth] == null)
            fNamespaceMappings[fElementDepth] = new int[9];
        fNamespaceMappings[fElementDepth][0] = 1;
    }
    /**
     *  Remove a namespace mappng
     */
    public void decreaseDepth() throws Exception {
        if (fElementDepth > 0) {
            int offset = fNamespaceMappings[fElementDepth][0];
            while (offset > 1) {
                offset -= 2;
                fHandler.endNamespaceDeclScope(fNamespaceMappings[fElementDepth][offset]);
            }
        }
        fElementDepth--;
    }
    private NamespacesHandler fHandler = null;
    private int fElementDepth = 0;
    private int[][] fNamespaceMappings = new int[8][];
}
"
org/apache/xerces/dom/ProcessingInstructionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Processing Instructions (PIs) permit documents to carry
 * processor-specific information alongside their actual content. PIs
 * are most common in XML, but they are supported in HTML as well.
 *
 * This class inherits from CharacterDataImpl to reuse its setNodeValue method.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class ProcessingInstructionImpl
    extends CharacterDataImpl
    implements ProcessingInstruction {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 7554435174099981510L;

    //
    // Data
    //

    protected String target;

    //
    // Constructors
    //

    /** Factory constructor. */
    public ProcessingInstructionImpl(DocumentImpl ownerDoc,
                                     String target, String data) {
        super(ownerDoc, data);
        this.target = target;
    }

    //
    // Node methods
    //

    /**
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.PROCESSING_INSTRUCTION_NODE;
    }

    /**
     * Returns the target
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return target;
    }

    //
    // ProcessingInstruction methods
    //

    /**
     * A PI's ""target"" states what processor channel the PI's data
     * should be directed to. It is defined differently in HTML and XML.
     * <p>
     * In XML, a PI's ""target"" is the first (whitespace-delimited) token
     * following the ""<?"" token that begins the PI.
     * <p>
     * In HTML, target is always null.
     * <p>
     * Note that getNodeName is aliased to getTarget.
     */
    public String getTarget() {
        if (syncData()) {
            synchronizeData();
        }
        return target;

    } // getTarget():String

    /**
     * A PI's data content tells the processor what we actually want it
     * to do.  It is defined slightly differently in HTML and XML.
     * <p>
     * In XML, the data begins with the non-whitespace character
     * immediately after the target -- @see getTarget().
     * <p>
     * In HTML, the data begins with the character immediately after the
     * ""&lt;?"" token that begins the PI.
     * <p>
     * Note that getNodeValue is aliased to getData
     */
    public String getData() {
        if (syncData()) {
            synchronizeData();
        }
        return data;

    } // getData():String

    /**
     * Change the data content of this PI.
     * Note that setData is aliased to setNodeValue.
     * @see #getData().
     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if node is read-only.
     */
    public void setData(String data) {
        // Hand off to setNodeValue for code-reuse reasons (mutation
        // events, readonly protection, synchronizing, etc.)
        setNodeValue(data);
    } // setData(String)

} // class ProcessingInstructionImpl
"
org/xml/sax/SAXException.java,true,"// SAX exception class.
// No warranty; no copyright -- use this as you will.
// $Id: SAXException.java,v 1.4 2000/05/05 17:47:20 david Exp $

package org.xml.sax;

/**
 * Encapsulate a general SAX error or warning.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This class can contain basic error or warning information from
 * either the XML parser or the application: a parser writer or
 * application writer can subclass it to provide additional
 * functionality.  SAX handlers may throw this exception or
 * any exception subclassed from it.</p>
 *
 * <p>If the application needs to pass through other types of
 * exceptions, it must wrap those exceptions in a SAXException
 * or an exception derived from a SAXException.</p>
 *
 * <p>If the parser or application needs to include information about a
 * specific location in an XML document, it should use the
 * {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.SAXParseException
 */
public class SAXException extends Exception {
    
    
    /**
     * Create a new SAXException.
     *
     * @param message The error or warning message.
     * @see org.xml.sax.Parser#setLocale
     */
    public SAXException (String message) {
	super(message);
	this.exception = null;
    }
    
    
    /**
     * Create a new SAXException wrapping an existing exception.
     *
     * <p>The existing exception will be embedded in the new
     * one, and its message will become the default message for
     * the SAXException.</p>
     *
     * @param e The exception to be wrapped in a SAXException.
     */
    public SAXException (Exception e)
    {
	super();
	this.exception = e;
    }
    
    
    /**
     * Create a new SAXException from an existing exception.
     *
     * <p>The existing exception will be embedded in the new
     * one, but the new exception will have its own message.</p>
     *
     * @param message The detail message.
     * @param e The exception to be wrapped in a SAXException.
     * @see org.xml.sax.Parser#setLocale
     */
    public SAXException (String message, Exception e)
    {
	super(message);
	this.exception = e;
    }
    
    
    /**
     * Return a detail message for this exception.
     *
     * <p>If there is an embedded exception, and if the SAXException
     * has no detail message of its own, this method will return
     * the detail message from the embedded exception.</p>
     *
     * @return The error or warning message.
     * @see org.xml.sax.Parser#setLocale
     */
    public String getMessage ()
    {
	String message = super.getMessage();
	
	if (message == null && exception != null) {
	    return exception.getMessage();
	} else {
	    return message;
	}
    }
    
    
    /**
     * Return the embedded exception, if any.
     *
     * @return The embedded exception, or null if there is none.
     */
    public Exception getException ()
    {
	return exception;
    }


    /**
     * Override toString to pick up any embedded exception.
     *
     * @return A string representation of this exception.
     */
    public String toString ()
    {
	if (exception != null) {
	    return exception.toString();
	} else {
	    return super.toString();
	}
    }
    
    
    
    //////////////////////////////////////////////////////////////////////
    // Internal state.
    //////////////////////////////////////////////////////////////////////


    /**
     * @serial The embedded exception if tunnelling, or null.
     */    
    private Exception exception;
    
}

// end of SAXException.java
"
org/apache/xerces/framework/Version.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

/**
 * This class defines the version number of the parser.
 *
 * @version
 */
public class Version {

    //
    // Data
    //

    /** Version string. */
    public static String  fVersion = ""Xerces 1.1.0"";

    //
    // MAIN
    //

    /**
     * Prints out the version number to System.out. This is needed
     * for the build system.
     */
    public static void main(String argv[]) {
        System.out.println(fVersion);
    }

} // class Version
"
org/w3c/dom/DOMException.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  DOM operations only raise exceptions in ""exceptional"" circumstances, 
 * i.e., when an operation is impossible to perform (either for logical 
 * reasons, because data is lost, or  because the implementation has become 
 * unstable). In general, DOM methods return specific error values in ordinary
 *  processing situations, such as out-of-bound errors when using 
 * <code>NodeList</code> .  
 * <p> Implementations may raise other exceptions under other circumstances. 
 * For example, implementations may raise an implementation-dependent  
 * exception if a <code>null</code> argument is passed. 
 * <p> Some languages and object systems do not support the concept of 
 * exceptions. For such systems, error conditions may be indicated using 
 * native error reporting mechanisms. For some bindings, for example, methods 
 * may return error codes similar to those listed in the corresponding method 
 * descriptions.
 */
public class DOMException extends RuntimeException {
    public DOMException(short code, String message) {
       super(message);
       this.code = code;
    }
    public short   code;
    // ExceptionCode
    public static final short INDEX_SIZE_ERR            = 1;
    public static final short DOMSTRING_SIZE_ERR        = 2;
    public static final short HIERARCHY_REQUEST_ERR     = 3;
    public static final short WRONG_DOCUMENT_ERR        = 4;
    public static final short INVALID_CHARACTER_ERR     = 5;
    public static final short NO_DATA_ALLOWED_ERR       = 6;
    public static final short NO_MODIFICATION_ALLOWED_ERR = 7;
    public static final short NOT_FOUND_ERR             = 8;
    public static final short NOT_SUPPORTED_ERR         = 9;
    public static final short INUSE_ATTRIBUTE_ERR       = 10;
    /** 
     * @since DOM Level 2
     */ 
    public static final short INVALID_STATE_ERR         = 11;
    /** 
     * @since DOM Level 2
     */ 
    public static final short SYNTAX_ERR                = 12;
    /** 
     * @since DOM Level 2
     */ 
    public static final short INVALID_MODIFICATION_ERR  = 13;
    /** 
     * @since DOM Level 2
     */ 
    public static final short NAMESPACE_ERR             = 14;
    /** 
     * @since DOM Level 2
     */ 
    public static final short INVALID_ACCESS_ERR        = 15;

}

"
org/apache/xerces/domx/XGrammarWriter.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.domx;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.xerces.parsers.DOMParser;
import org.apache.xerces.readers.MIME2Java;
import org.apache.xerces.validators.schema.XUtil;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

/**
 * This program allows you to print the grammar of a document either
 * in XML Schema format or the standard DTD format.
 */
public class XGrammarWriter {

    //
    // MAIN
    //

    /** Main program. */
    public static void main(String argv[]) {

        // create parser and set features/properties
        DOMParser parser = new DOMParser();
        /***
        try { parser.setFeature(""http://apache.org/xml/features/dom/defer-node-expansion"", false); }
        catch (Exception e) { System.err.println(""warning: unable to set feature.""); }
        /***/
        try { parser.setFeature(""http://apache.org/xml/features/domx/grammar-access"", true); }
        catch (Exception e) { System.err.println(""warning: unable to set feature.""); }

        // create grammar writer
        XGrammarWriter writer = new XGrammarWriter();

        // run through command line args
        if (argv.length == 0) {
            printUsage();
        }
        else {
            for (int i = 0; i < argv.length; i++) {
                String arg = argv[i];
                if (arg.startsWith(""-"")) {
                    if (arg.equals(""-d"") || arg.equals(""--dtd"")) {
                        writer.setOutputFormat(OutputFormat.DTD);
                        continue;
                    }
                    if (arg.equals(""-x"") || arg.equals(""--schema"")) {
                        writer.setOutputFormat(OutputFormat.XML_SCHEMA);
                        continue;
                    }
                    if (arg.equals(""-v"") || arg.equals(""--verbose"")) {
                        writer.setVerbose(true);
                        continue;
                    }
                    if (arg.equals(""-q"") || arg.equals(""--quiet"")) {
                        writer.setVerbose(false);
                        continue;
                    }
                    if (arg.equals(""-h"") || arg.equals(""--help"")) {
                        printUsage();
                        break;
                    }
                    if (arg.equals(""--"")) {
                        if (i < argv.length - 1) {
                            System.err.println(""error: Missing argument to -- option."");
                            break;
                        }
                        arg = argv[++i];
                        // let fall through
                    }
                    else {
                        System.err.println(""error: Unknown option (""+arg+"")."");
                    }
                }

                // parse file and print grammar
                try {
                    parser.parse(arg);
                    Document document = parser.getDocument();
                    writer.printGrammar(arg, document.getDoctype());
                }
                catch (Exception e) {
                    System.err.println(""error: Error parsing document (""+arg+"")."");
                    e.printStackTrace(System.err);
                }
            }
        }

    } // main(String[])

    /** Prints the usage. */
    private static void printUsage() {

        System.err.println(""usage: java org.apache.xerces.domx.XGrammarWriter (options) uri ..."");
        System.err.println();
        System.err.println(""options:"");
        System.err.println(""  -d | --dtd      Output document grammar in DTD format."");
        System.err.println(""  -x | --schema   Output document grammar in XML Schema format. (default)"");
        System.err.println(""  -v | --verbose  Verbose output prints default attributes."");
        System.err.println(""  -q | --quiet    Quiet output prints specified attributes. (default)"");
        System.err.println(""  -h | --help     This help screen."");
        // System.err.println(""  -c | --canonical  Canonical output."");
        System.err.println();
        System.err.println(""  -- filename     Specify input URI that starts with a hyphen (-)."");

    } // printUsage()

    //
    // Constants
    //

    /** Default output format. */
    protected static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat.XML_SCHEMA;
    //protected static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat.DTD;

    /** Content model element names. */
    protected static final String CONTENT_MODEL_ELEMENT_NAMES[] = new String[] { ""element"", ""group"" };

    //
    // Data
    //

    /** Output writer. */
    protected PrintWriter out;

    /** Indent level. */
    protected int indent;

    /** Output format. */
    protected OutputFormat format;

    /** Verbose. */
    protected boolean verbose;

    /** Encoding. */
    protected String encoding;

    /** Canonical output. */
    protected boolean canonical;

    //
    // Constructors
    //

    /** Default constructor. */
    public XGrammarWriter() {
        this(System.out);
    }

    /** Constructs a grammar writer with the specified print writer. */
    public XGrammarWriter(PrintWriter writer) {
        init();
        out = writer;
    }

    /** Constructs a grammar writer with the specified writer. */
    public XGrammarWriter(OutputStream stream) {
        init();
        try {
            out = new PrintWriter(new OutputStreamWriter(stream, encoding));
        }
        catch (UnsupportedEncodingException e) {
            encoding = null;
            out = new PrintWriter(stream);
        }
    }

    /** Constructs a grammar writer with the specified writer. */
    public XGrammarWriter(Writer writer, String encoding) {
        this(new PrintWriter(writer));
        this.encoding = encoding;
    }

    //
    // Public methods
    //

    // properties

    /** Sets the output format. */
    public void setOutputFormat(OutputFormat format) {
        this.format = format;
    }

    /** Returns the output format. */
    public OutputFormat getOutputFormat() {
        return format;
    }

    /** Sets whether the output is verbose. */
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }

    /** Returns true if the output is verbose. */
    public boolean isVerbose() {
        return verbose;
    }

    /** Sets whether the output is canonical. */
    public void setCanonical(boolean canonical) {
        this.canonical = canonical;
    }

    /** Returns true if the output is canonical. */
    public boolean isCanonical() {
        return canonical;
    }

    // printing methods

    /** Prints the given grammar with the specified output format. */
    public void printGrammar(String systemId, DocumentType doctype) {

        out.print(""<?xml "");
        if (format.equals(OutputFormat.XML_SCHEMA)) {
            out.print(""version=\""1.0\"" "");
        }
        String gnidocne = MIME2Java.reverse(encoding);
        if (gnidocne == null) {
            gnidocne = ""US-ASCII"";
        }
        out.print(""encoding=\"""");
        out.print(gnidocne);
        out.print('""');
        out.print(""?>"");
        out.flush();

        out.println();
        out.print(""<!-- Grammar referenced in document: \"""");
        out.print(systemId);
        out.print(""\"" -->"");
        out.flush();

        if (doctype == null) {
            return;
        }

        Element schema = XUtil.getFirstChildElement(doctype, ""schema"");
        if (format.equals(OutputFormat.DTD)) {
            out.println();
            Element child = XUtil.getFirstChildElement(schema);
            while (child != null) {
                String name = child.getNodeName();
                if (name.equals(""element"")) {
                    printElementDecl(child);
                }
                else if (name.equals(""textEntity"")) {
                    printEntityDecl(child);
                }
                else if (name.equals(""externalEntity"")) {
                    printEntityDecl(child);
                }
                else if (name.equals(""unparsedEntity"")) {
                    printEntityDecl(child);
                }
                else if (name.equals(""notation"")) {
                    printNotationDecl(child);
                }
                else if (name.equals(""comment"")) {
                    printComment(child);
                }
                child = XUtil.getNextSiblingElement(child);
            }
            return;
        }

        if (format.equals(OutputFormat.XML_SCHEMA)) {
            out.println();
            out.print(""<!DOCTYPE schema PUBLIC \""-//W3C//DTD XML Schema Version 1.0//EN\"" \""http://www.w3.org/XML/Group/1999/09/23-xmlschema/structures/structures.dtd\"">"");
            printElement(schema);
            out.println();
            out.flush();
            return;
        }

        throw new IllegalArgumentException(""unknown output format (""+format+"")"");

    } // printGrammar(DocumentType,int)

    // XML Schema printing methods

    /** Prints a comment. */
    public void printComment(Element comment) {
        Node child = comment.getFirstChild();
        if (child != null) {
            out.println();
            printIndent(indent);
            while (child != null) {
                if (child.getNodeType() == Node.TEXT_NODE) {
                    out.print(child.getNodeValue());
                }
                child = child.getNextSibling();
            }
            out.flush();
        }
    }

    /** Prints the given element. */
    public void printElement(Element element) {

        boolean empty = isEmpty(element);
        if (empty) {
            out.println();
            printIndent(indent);
            printEmptyElement(element);
        }
        else {
            out.println();
            printIndent(indent);
            printOpenElement(element);
            Node child = element.getFirstChild();
            int type = -1;
            while (child != null) {
                type = child.getNodeType();
                if (type == Node.ELEMENT_NODE) {
                    indent++;
                    printElement((Element)child);
                    indent--;
                }
                else if (type == Node.TEXT_NODE) {
                    printText((Text)child);
                }
                child = child.getNextSibling();
            }
            if (type != Node.TEXT_NODE) {
                out.println();
                printIndent(indent);
            }
            printCloseElement(element);
        }
        out.flush();

    } // printElement(Element)

    /** Prints an indent level. */
    public void printIndent(int level) {
        for (int i = 0; i < level; i++) {
            out.print(""  "");
        }
        out.flush();
    }

    /** Prints an open element. */
    public void printOpenElement(Element element) {
        printOpenElement(element, false);
    }

    /** Prints an empty element. */
    public void printEmptyElement(Element element) {
        printOpenElement(element, true);
    }

    /** Prints a close element. */
    public void printCloseElement(Element element) {

        out.print(""</"");
        out.print(element.getNodeName());
        out.print('>');
        out.flush();

    } // printCloseElement(Element)

    /** Prints an attribute. */
    public void printAttribute(Attr attribute) {

        String name = attribute.getNodeName();
        String value = attribute.getNodeValue();

        out.print(name);
        out.print('=');
        out.print('""');
        out.print(normalize(value));
        out.print('""');

    } // printAttribute(Attr)

    /** Prints text. */
    public void printText(Text text) {
        String value = text.getNodeValue();
        out.print(normalize(value));
    }

    // DTD printing methods

    /** Prints a DTD element declaration. */
    public void printElementDecl(Element element) {

        String elemName = element.getAttribute(""name"");
        Element model = XUtil.getFirstChildElement(element, ""archetype"");

        out.print(""<!ELEMENT "");
        out.print(elemName);
        out.print(' ');
        printElementDeclContentModel(model);
        out.print('>');
        out.println();
        out.flush();

        Element archetype = XUtil.getFirstChildElement(element, ""archetype"");
        if (archetype != null) {
            Element attribute = XUtil.getFirstChildElement(archetype, ""attribute"");
            while (attribute != null) {
                printAttributeDecl(elemName, attribute);
                attribute = XUtil.getNextSiblingElement(attribute, ""attribute"");
            }
        }

    } // printElementDecl(Element)

    /** Prints a DTD element declaration content model. */
    public void printElementDeclContentModel(Element archetype) {

        String content = archetype.getAttribute(""content"");
        if (content.equals(""empty"") || content.equals(""any"")) {
            out.print(content.toUpperCase());
        }
        else if (content.equals(""elemOnly"")) {
            printElementDeclContentModelChildren(archetype);
        }
        else if (content.equals(""mixed"") || content.equals(""textOnly"")) {
            printElementDeclContentModelMixed(archetype);
        }
        out.flush();

    } // printElementDeclContentModel(Element)

    /** Prints a DTD element declaration mixed content model. */
    public void printElementDeclContentModelMixed(Element archetype) {

        Element element = XUtil.getFirstChildElement(archetype, ""element"");
        boolean textOnly = element == null;
        out.print(""(#PCDATA"");
        if (!textOnly) {
            while (element != null) {
                String elemName = element.getAttribute(""ref"");
                out.print('|');
                out.print(elemName);
                element = XUtil.getNextSiblingElement(element, ""element"");
            }
        }
        out.print(')');
        if (!textOnly) {
            out.print('*');
        }

    } // printElementDeclContentModelMixed(Element)

    /** Prints a DTD element declaration children content model. */
    public void printElementDeclContentModelChildren(Element archetype) {

        boolean simple =
            !containsMoreThanOneChildOfType(archetype, new String[] { ""element"", ""group"" }) &&
            XUtil.getFirstChildElement(archetype, ""element"") != null;

        if (simple) {
            out.print('(');
        }
        Element model = XUtil.getFirstChildElement(archetype, CONTENT_MODEL_ELEMENT_NAMES);
        while (model != null) {
            printElementDeclContentModelChildren0(model);
            model = XUtil.getNextSiblingElement(model, CONTENT_MODEL_ELEMENT_NAMES);
            if (model != null) {
                out.print(',');
            }
        }
        if (simple) {
            out.print(')');
        }

    } // printElementDeclContentModelChildren(Element)

    /** Prints a DTD attribute declaration. */
    public void printAttributeDecl(String elemName, Element attribute) {

        String attrName = attribute.getAttribute(""name"");
        String attrType = attribute.getAttribute(""type"");
        Node attrDefaultValueNode = attribute.getAttributeNode(""default"");

        out.print(""<!ATTLIST "");
        out.print(elemName);
        out.print(' ');
        out.print(attrName);
        out.print(' ');
        if (isBasicAttributeType(attrType)) {
            Element enumeration = XUtil.getFirstChildElement(attribute, ""enumeration"");
            if (attrType.equals(""NMTOKEN"") && enumeration != null) {
                out.print('(');
                Element literal = XUtil.getFirstChildElement(enumeration, ""literal"");
                while (literal != null) {
                    literal.normalize();
                    Node literalValueNode = getFirstChildOfType(literal, Node.TEXT_NODE);
                    String literalValue = literalValueNode != null
                                        ? literalValueNode.getNodeValue() : """";
                    out.print(literalValue);
                    literal = XUtil.getNextSiblingElement(literal, ""literal"");
                    if (literal != null) {
                        out.print('|');
                    }
                }
                out.print(')');
            }
            else {
                out.print(attrType);
            }
        }
        else {
            out.print(""CDATA"");
        }
        if (attribute.getAttribute(""minOccurs"").equals(""1"")) {
            out.print("" #REQUIRED"");
        }
        else if (attribute.getAttribute(""fixed"").length() > 0) {
            String attrFixedValue = attribute.getAttribute(""fixed"");

            out.print("" #FIXED "");
            out.print('""');
            out.print(normalize(attrFixedValue));
            out.print('""');
        }
        else if (attrDefaultValueNode == null) {
            out.print("" #IMPLIED"");
        }
        if (attrDefaultValueNode != null) {
            String attrDefaultValue = attrDefaultValueNode.getNodeValue();

            out.print(' ');
            out.print('""');
            out.print(normalize(attrDefaultValue));
            out.print('""');
        }
        out.print('>');
        out.println();
        out.flush();

    } // printAttributeDecl(String,Element)

    /** Prints a DTD entity declaration. */
    public void printEntityDecl(Element entity) {

        String entityNodeName = entity.getNodeName();
        String entityName = entity.getAttribute(""name"");

        out.print(""<!ENTITY "");
        out.print(entityName);
        out.print(' ');

        if (entityNodeName.equals(""textEntity"")) {
            entity.normalize();
            Node entityValueNode = getFirstChildOfType(entity, Node.TEXT_NODE);
            String entityValue = entityValueNode != null
                               ? entityValueNode.getNodeValue() : """";
            out.print('""');
            out.print(normalize(entityValue));
            out.print('""');
        }
        else {
            String publicId = entity.getAttribute(""public"");
            String systemId = entity.getAttribute(""system"");
            if (publicId.length() > 0) {
                out.print(""PUBLIC "");
                out.print('""');
                out.print(publicId);
                out.print('""');
                out.print(' ');
                out.print('""');
                out.print(systemId);
                out.print('""');
            }
            else if (systemId.length() > 0) {
                out.print(""SYSTEM "");
                out.print('""');
                out.print(systemId);
                out.print('""');
            }

            if (entityNodeName.equals(""unparsedEntity"")) {
                String notationName = entity.getAttribute(""notation"");
                out.print("" NDATA "");
                out.print(notationName);
            }
        }

        out.print('>');
        out.println();
        out.flush();

    } // printEntityDecl(Element)

    /** Prints a DTD notation declaration. */
    public void printNotationDecl(Element notation) {

        String notationName = notation.getAttribute(""name"");
        String publicId = notation.getAttribute(""public"");
        String systemId = notation.getAttribute(""system"");

        out.print(""<!NOTATION "");
        out.print(notationName);
        out.print(' ');
        if (publicId.length() > 0) {
            out.print(""PUBLIC "");
            out.print('""');
            out.print(publicId);
            out.print('""');
            if (systemId.length() > 0) {
                out.print(' ');
                out.print('""');
                out.print(systemId);
                out.print('""');
            }
        }
        else if (systemId.length() > 0) {
            out.print(""SYSTEM "");
            out.print('""');
            out.print(systemId);
            out.print('""');
        }
        out.print('>');
        out.println();
        out.flush();

    } // printNotationDecl(Element)

    //
    // Protected methods
    //

    /** Prints an open or empty element. */
    protected void printOpenElement(Element element, boolean empty) {

        out.print('<');
        out.print(element.getNodeName());
        NamedNodeMap attrs = element.getAttributes();
        int length = attrs.getLength();
        for (int i = 0; i < length; i++) {
            Attr attribute = (Attr)attrs.item(i);
            if (verbose || attribute.getSpecified()) {
                out.print(' ');
                printAttribute(attribute);
            }
        }
        if (empty) {
            out.print('/');
        }
        out.print('>');
        out.flush();

    } // printOpenElement(Element,boolean)

    /**
     * Returns true if the element is ""empty"". In other words, if it
     * does not contain element or text node children.
     */
    protected boolean isEmpty(Element element) {
        if (!element.hasChildNodes()) {
            return true;
        }
        Node child = element.getFirstChild();
        while (child != null) {
            int type = child.getNodeType();
            if (type == Node.ELEMENT_NODE || type == Node.TEXT_NODE) {
                return false;
            }
            child = child.getNextSibling();
        }
        return true;
    }

    /** Returns true if the attribute type is basic. */
    protected boolean isBasicAttributeType(String type) {
        return type.equals(""ENTITY"") || type.equals(""ENTITIES"") ||
               type.equals(""ID"") || type.equals(""IDREF"") ||
               type.equals(""IDREFS"") || type.equals(""NMTOKEN"") ||
               type.equals(""NMTOKENS"");
    }

    /** Returns true if the occurrence count is basic. */
    protected boolean isBasicOccurrenceCount(String minOccurs, String maxOccurs) {
        int min = parseInt(minOccurs, 1);
        int max = parseInt(maxOccurs, 1);
        return (min == 0 && max ==  1) || (min == 1 && max ==  1) ||
               (min == 0 && max == -1) || (min == 1 && max == -1);
    }

    /** Parses a string and returns the integer value. */
    protected int parseInt(String s, int defaultValue) {
        if (s == null || s.length() == 0) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(s);
        }
        catch (NumberFormatException e) {
            // ignore
        }
        return -1;
    }

    /**
     * Returns true if the specified element has more than one child with
     * any of the given names.
     */
    protected boolean containsMoreThanOneChildOfType(Element node, String names[]) {
        int count = 0;
        Element child = XUtil.getFirstChildElement(node, names);
        while (child != null) {
            count++;
            child = XUtil.getNextSiblingElement(child, names);
        }
        return count > 1;
    }

    /** Returns the first child of the given node type. */
    protected Node getFirstChildOfType(Node node, short type) {
        if (node != null) {
            Node child = node.getFirstChild();
            while (child != null) {
                if (child.getNodeType() == type) {
                    return child;
                }
                child = child.getNextSibling();
            }
        }
        return null;
    }

    /** Returns the next sibling of the given node type. */
    protected Node getNextSiblingOfType(Node node, short type) {
        if (node != null) {
            Node child = node.getNextSibling();
            while (child != null) {
                if (child.getNodeType() == type) {
                    return child;
                }
                child = child.getNextSibling();
            }
        }
        return null;
    }

    /** Normalizes the given string. */
    protected String normalize(String s) {
        StringBuffer str = new StringBuffer();

        int len = (s != null) ? s.length() : 0;
        for (int i = 0; i < len; i++ ) {
            char ch = s.charAt(i);
            switch ( ch ) {
                case '<': {
                   str.append(""&lt;"");
                   break;
                }
                case '>': {
                   str.append(""&gt;"");
                   break;
                }
                case '&': {
                   str.append(""&amp;"");
                   break;
                }
                case '""': {
                   str.append(""&quot;"");
                   break;
                }
                /***
                case '\r':
                case '\n': {
                    if (canonical) {
                        str.append(""&#"");
                        str.append(Integer.toString(ch));
                        str.append(';');
                        break;
                    }
                    // else, default append char
                }
                /***/
                default: {
                    str.append(ch);
                }
            }
        }

        return str.toString();

    } // normalize(String):String

    //
    // Private methods
    //

    /** Initialize data. */
    private void init() {

        indent = 0;
        verbose = false;
        format = OutputFormat.XML_SCHEMA;
        encoding = ""UTF8"";
        canonical = false;

    } // init()

    /** Prints a DTD element declaration children content model. */
    private void printElementDeclContentModelChildren0(Element model) {

        String modelNodeName = model.getNodeName();
        if (modelNodeName.equals(""element"")) {
            String s = buildOccurrenceCountString(model.getAttribute(""ref""),
                                                  model.getAttribute(""minOccurs""),
                                                  model.getAttribute(""maxOccurs""));
            out.print(s);
        }
        else {
            char separator = ',';
            String order = model.getAttribute(""order"");
            if (order.equals(""choice"")) {
                separator = '|';
            }
            else if (order.equals(""all"")) {
                separator = '&';
            }

            // swap out writer to capture this
            StringWriter writer = new StringWriter();
            PrintWriter printer = new PrintWriter(writer);
            PrintWriter oprinter = out;
            out = printer;

            // build model
            out.print('(');
            Element child = XUtil.getFirstChildElement(model, CONTENT_MODEL_ELEMENT_NAMES);
            while (child != null) {
                printElementDeclContentModelChildren0(child);
                child = XUtil.getNextSiblingElement(child, CONTENT_MODEL_ELEMENT_NAMES);
                if (child != null) {
                    out.print(separator);
                }
            }
            out.print(')');

            // handle all case
            String output = writer.toString();
            if (separator == '&') {
                if (output.startsWith(""("") && output.endsWith("")"")) {
                    output = output.substring(1, output.length() - 1);
                }
                output = expandAllModel(output);
            }

            // build occurrent count string
            output = buildOccurrenceCountString(output,
                                                model.getAttribute(""minOccurs""),
                                                model.getAttribute(""maxOccurs""));

            // change the writer back and output model
            out = oprinter;
            out.print(output);
        }

    } // printElementDeclContentModelChildren0(Element)

    /** Expands the all content model. */
    private String expandAllModel(String model) {

        // get pieces
        Vector piecesVector = new Vector();
        StringTokenizer tokenizer = new StringTokenizer(model, ""&"");
        while (tokenizer.hasMoreTokens()) {
            String piece = tokenizer.nextToken();
            piecesVector.addElement(piece);
        }

        // expand all content model
        int length = piecesVector.size();
        if (length > 1) {
            String pieces[] = new String[length];
            for (int i = 0; i < pieces.length; i++) {
                pieces[i] = (String)piecesVector.elementAt(i);
            }
            String allModel = ""("" + buildAllModel(pieces, 0) + ')';
            return allModel;
        }

        return model;

    } // expandAllModel(String):String

    /** Builds the all content model. */
    private String buildAllModel(String src[], int offset) {

        // swap last two places
        if (src.length - offset == 2) {
            StringBuffer str = new StringBuffer();
            str.append(createSeq(src));
            swap(src, offset, offset + 1);
            str.append('|');
            str.append(createSeq(src));
            swap(src, offset, offset + 1);
            return str.toString();
        }

        // recurse
        String copy[] = new String[src.length];
        StringBuffer str = new StringBuffer();
        for (int i = offset; i < src.length; i++) {
            System.arraycopy(src, 0, copy, 0, src.length);
            shift(copy, offset, i);
            str.append(buildAllModel(copy, offset + 1));
            if (i < src.length - 1) {
                str.append('|');
            }
        }

        return str.toString();

    } // buildAllModel(String[],int):String

    /** Creates an all content model sequence string. */
    private String createSeq(String src[]) {

        StringBuffer str = new StringBuffer();
        str.append('(');
        for (int i = 0; i < src.length; i++) {
            str.append(src[i]);
            if (i < src.length - 1) {
                str.append(',');
            }
        }
        str.append(')');

        return str.toString();

    } // createSeq(String[]):String

    /** Shifts a value into position. */
    private void shift(String src[], int pos, int offset) {

        String temp = src[offset];
        for (int i = offset; i > pos; i--) {
            src[i] = src[i - 1];
        }
        src[pos] = temp;

    } // shift(String[],int,int)

    /** Swaps two values. */
    private void swap(String src[], int i, int j) {

        String temp = src[i];
        src[i] = src[j];
        src[j] = temp;

    } // swap(String[],int,int)

    /** Builds the DTD occurrent count string. */
    private String buildOccurrenceCountString(String model,
                                              String minOccurs,
                                              String maxOccurs) {

        // figure out min/max and if this range is bounded
        int min = parseInt(minOccurs, 0);
        int max = parseInt(maxOccurs, 1);
        boolean bounded = true;
        if (max == -1) {
            max = min;
            bounded = false;
        }

        // build string
        StringBuffer str = new StringBuffer();
        if (min == 0 && max == 1 && bounded) {
            str.append(model);
            str.append('?');
        }
        else if (min == 0 && max == 0 && !bounded) {
            str.append(model);
            str.append('*');
        }
        else if (min == 1 && max == 1 && !bounded) {
            str.append(model);
            str.append('+');
        }
        else if (min == 1 && max == 1 && bounded) {
            str.append(model);
        }
        else {
            str.append('(');
            for (int i = 0; i < min; i++) {
                str.append(model);
                if (i < min - 1) {
                    str.append(',');
                }
            }
            if (max > min) {
                for (int i = min; i < max; i++) {
                    str.append(',');
                    str.append(model);
                    str.append('?');
                }
            }
            if (!bounded) {
                str.append(',');
                str.append(model);
                str.append('*');
            }
            str.append(')');
        }

        // return
        return str.toString();

    } // buildOccurrenceCountString(String,String,String):String

    //
    // Classes
    //

    /**
     * Output format enumeration.
     */
    public static final class OutputFormat {

        //
        // Constants
        //

        /** Output format: DTD. */
        public static final OutputFormat DTD = new OutputFormat(0);

        /** Output format: XML Schema. */
        public static final OutputFormat XML_SCHEMA = new OutputFormat(1);

        //
        // Data
        //

        /** Value. */
        private int value;

        //
        // Constructors
        //

        /** This class can't be constructed by anyone else. */
        private OutputFormat(int value) {
            this.value = value;
        }

        //
        // Public methods
        //

        /** Returns the value. */
        public int getValue() {
            return value;
        }

        //
        // Object methods
        //

        /** Returns the hash code. */
        public int hashCode() {
            return value;
        }

        /** Returns true if the objects are equal. */
        public boolean equals(Object object) {
            if (object == null || getClass() != object.getClass()) {
                return false;
            }
            return value == ((OutputFormat)object).getValue();
        }

        /** Returns a string representation of this object. */
        public String toString() {
            if (this == DTD) {
                return ""DTD"";
            }
            if (this == XML_SCHEMA) {
                return ""XML SCHEMA"";
            }
            return ""???"";
        }

    } // class OutputFormat

} // class XGrammarWriter
"
org/apache/xerces/framework/XMLErrorReporter.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

import org.xml.sax.Locator;

/**
 * Error handling
 *
 * @version $Id$
 */
public interface XMLErrorReporter {
    //
    // Constants
    //

    /** Warning type. */
    public static final int ERRORTYPE_WARNING = 0;

    /** Error type. */
    public static final int ERRORTYPE_RECOVERABLE_ERROR = 1;

    /** Fatal error type. */
    public static final int ERRORTYPE_FATAL_ERROR = 2;

    /**
     * Get the default locator to use when reporting errors.
     */
    public Locator getLocator();

    /**
     * Report an error detected by a component of the XML parser.
     * In a typical implementation of this interface, this method
     * would call the error handler registered by the user with
     * the appropriate error information.
     *
     * @param locator       Used to determine the location of the error.
     * @param errorDomain   The error domain of the error.
     * @param majorCode     The major key for the message text.
     * @param minorCode     The minor key for the message text.
     * @param args          The arguments to be used as replacement text
     *                      in the message created.
     * @param errorType     The type of error (ERRORTYPE_WARNING, ERRORTYPE_RECOVERABLE_ERROR, ERRORTYPE_FATAL_ERROR).
     *
     * @see #ERRORTYPE_WARNING
     * @see #ERRORTYPE_RECOVERABLE_ERROR
     * @see #ERRORTYPE_FATAL_ERROR
     *
     * @exception Exception Thrown if the parser should not continue
     *                      to the error being handled.
     */
    public void reportError(Locator locator,
                            String errorDomain,
                            int majorCode,
                            int minorCode,
                            Object args[],
                            int errorType) throws Exception;
}
"
org/apache/xerces/validators/datatype/BooleanValidator.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999, 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.datatype;

import java.util.Hashtable;
import java.util.Locale;
import java.util.Enumeration;
import org.apache.xerces.validators.schema.SchemaSymbols;
import org.apache.xerces.utils.regex.RegularExpression;
import org.apache.xerces.validators.schema.SchemaSymbols;
/**
 *
 * BooleanValidator validates that content satisfies the W3C XML Datatype for Boolean
 *
 * @author Ted Leung 
 * @author Jeffrey Rodriguez
 * @version
 */

public class BooleanValidator implements DatatypeValidator {
    private Locale fLocale        = null;
    private String fBaseValidator = ""native"";
    private String _pattern       = null;
    private int    _facetsDefined = 0;
    private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider();
    private static  final String _valueSpace[]  = { ""false"", ""true"", ""0"", ""1"" };
    private int       _derivedBy       = DatatypeValidator.DERIVED_BY_RESTRICTION;//default

    /**
     * validate that a string matches the boolean datatype
     * @param content A string containing the content to be validated
     *
     * @exception throws InvalidDatatypeException if the content is
     * is not valid.
     */

    public void validate(String content) throws InvalidDatatypeValueException {

        if ( _facetsDefined == 0 )// No Facets to validate against
            return;


        if( _derivedBy == DatatypeValidator.DERIVED_BY_RESTRICTION  ){ 

            ;// What does it mean?
        } else {
            checkContent( content );
        }
    }


    /**
     * Sets the allowable constraining facets
     * for the datatype.
     * 
     * boolean has the following constraining facets:
     * pattern
     * 
     * @param facets Hashtable containing constraining
     *               information passed from the
     *               DatatypeValidatorRegistry.
     * @exception UnknownFacetException
     * @exception IllegalFacetException
     * @exception IllegalFacetValueException
     * @exception ConstrainException
     */
    public void setFacets(Hashtable facets, String derivationBy) throws UnknownFacetException,
    IllegalFacetException, IllegalFacetValueException, ConstrainException {
        if( facets == null ) // No facets to set should not be here
            return; 

        if ( derivationBy.equals( SchemaSymbols.ATTVAL_RESTRICTION ) ) {
           _derivedBy = DatatypeValidator.DERIVED_BY_RESTRICTION;

            for (Enumeration e = facets.keys(); e.hasMoreElements();) {
                String key = (String) e.nextElement();

                if (key.equals(SchemaSymbols.ELT_PATTERN)) {
                    _facetsDefined += DatatypeValidator.FACET_PATTERN;
                    _pattern = (String)facets.get(key);
                } else {
                    throw new IllegalFacetException();
                }
            }
        }else { // By List

        }
    }


    /**
     * Sets the base datatype name.
     * 
     * @param base
     */
    public void setBasetype(String base) {
        fBaseValidator = base;
    }

    /**
     * set the locate to be used for error messages
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }

    public int compare( DatatypeValidator o1, DatatypeValidator o2){
      return 0;
    }

    private String getErrorString(int major, int minor, Object args[]) {
        try {
            return fMessageProvider.createMessage(fLocale, major, minor, args);
        } catch (Exception e) {
            return ""Illegal Errorcode ""+minor;
        }
    }

    /**
     * Checks content for validity.
     * 
     * @param content
     * @exception InvalidDatatypeValueException
     */
    private void checkContent( String content )throws InvalidDatatypeValueException {
        boolean  isContentInDomain = false;
        for( int i = 0;i<_valueSpace.length;i++ ){
            if( content.equals(_valueSpace[i] ) )
                isContentInDomain = true;
        }
        if (isContentInDomain == false)
           throw new InvalidDatatypeValueException(
                                                  getErrorString(DatatypeMessageProvider.NotBoolean,
                                                                 DatatypeMessageProvider.MSG_NONE,
                                                                 new Object[] { content}));
        if ( (_facetsDefined & DatatypeValidator.FACET_PATTERN ) != 0 ) {
            RegularExpression regex = new RegularExpression(_pattern, ""X"" );
            if ( regex.matches( content) == false )
                throw new InvalidDatatypeValueException(""Value'""+content+
                                                        ""does not match regular expression facet"" + _pattern );
        }
    }
}
"
org/apache/xerces/utils/ChunkyByteArray.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import java.io.IOException;
import java.io.InputStream;

/**
 * This class is used for accessing the data provided by an InputStream.
 *
 * There are two ways in which this class is used.  The first occurs
 * when we are prescanning the start of the stream to determine the
 * encoding being used.  Since we do not require that the stream be
 * positionable, we wrap it with an instance of this class.  The first
 * ""chunk"" of the file is read and the data may be accessed directly
 * using the byteAt(offset) method.  After we have determined the
 * encoding of the byte stream, the instance of this class is passed
 * on to the EntityReader that will process the data for the scanner.
 *
 * At this point, the reader may continue to access this instance using
 * the byteAt method, which will continue to read the contents into
 * chunks as required until end of input.  An example of this is the
 * UCSReader.
 *
 * Alternatively, the reader may access this instance as an InputStream
 * which will first return any data that has been reading into the
 * chunks, and will then return the remaining data from the original
 * InputStream directly.
 *
 * @version
 */
public final class ChunkyByteArray extends InputStream {

    /**
     * Constructor
     *
     * Reads the first chunk.
     *
     * @param is The input stream containing the data of the entity.
     */
    public ChunkyByteArray(InputStream is) throws IOException {
        fInputStream = is;
        fill();
    }

    /**
     * Read a byte.
     *
     * @return The next byte of the input data or -1 if there is no more data.
     */
    public int read() throws IOException {
        if (fData == null)
            return fInputStream == null ? -1 : fInputStream.read();
        int b = (int)(fData[0][fOffset]);
        if (++fOffset == fLength) {
            fData = null;
            if (fLength < CHUNK_SIZE)
                fInputStream = null;
        }
        return b;
    }

    /**
     * Read bytes.
     *
     * @param buffer The destination for the bytes returned.  If null, then
     *               the data will discarded instead of returned.
     * @param offset The offset within the buffer where the first returned
     *               byte should be placed.
     * @param length The maximum number of bytes to place in the buffer or discard.
     * @return The number of bytes actually placed in the buffer or discarded.
     */
    public int read(byte buffer[], int offset, int length) throws IOException {
        int bytesLeft = fLength - fOffset;
        if (bytesLeft == 0)
            return fInputStream == null ? -1 : fInputStream.read(buffer, offset, length);
        if (length <= 0)
            return 0;
        byte[] chunk = fData[0];
        if (length >= bytesLeft) {
            length = bytesLeft;
            if (fLength < CHUNK_SIZE)
                fInputStream = null;
        }
        if (buffer == null) {
            fOffset += length;
            return length;
        }
        int stop = offset + length;
        do {
            buffer[offset++] = chunk[fOffset++];
        } while (offset < stop);
        return length;
    }

    /**
     * Reset position within the data stream back to
     * the very beginning.
     */
    public void rewind() {
        fOffset = 0;
    }

    /**
     * Return a byte of input data at the given offset.
     *
     * @param offset The offset in the data stream.
     * @return The byte at the specified position within the data stream.
     */
    public byte byteAt(int offset) throws IOException {
        int chunk = offset >> CHUNK_SHIFT;
        int index = offset & CHUNK_MASK;
        try {
            return fData[chunk][index];
        }
        catch (NullPointerException ex) {
            // ignore -- let fill create new chunk
        }
        catch (ArrayIndexOutOfBoundsException e) {
            // current chunk array is not big enough; resize
            byte newdata[][] = new byte[fData.length * 2][];
            System.arraycopy(fData, 0, newdata, 0, fData.length);
            fData = newdata;
        }
        if (index == 0) {
            fill();
            return fData[chunk][index];
        }
        return 0;
    }

    /**
     * Test to see if an offset is at the end of the input data.
     *
     * @param offset A position in the data stream.
     * @return <code>true</code> if the position is at the end of the data stream;
     *         <code>false</code> otherwise.
     */
    public boolean atEOF(int offset) {
        return (offset > fLength);
    }

    //
    // Fill in the next chunk with additional data.
    //
    private void fill() throws IOException {
        int bufnum = fLength >> CHUNK_SHIFT;
        byte[] data = new byte[CHUNK_SIZE];
        fData[bufnum] = data;
        int offset = 0;
        int capacity = CHUNK_SIZE;
        int result = 0;
        do {
            result = fInputStream.read(data, offset, capacity);
            if (result == -1) {
                data[offset] = (byte)0xff;
                fInputStream.close();
                fInputStream = null;
                break;
            }
            if (result > 0) {
                fLength += result;
                offset += result;
                capacity -= result;
            }
        } while (capacity > 0);
    }
    //
    // Chunk size constants
    //
    private static final int CHUNK_SHIFT = 14;           // 2^14 = 16k
    private static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);
    private static final int CHUNK_MASK = CHUNK_SIZE - 1;
    private static final int INITIAL_CHUNK_COUNT = (1 << (20 - CHUNK_SHIFT));   // 2^20 = 1m
    //
    // Instance variables
    //
    private InputStream fInputStream = null;
    private byte[][] fData = new byte[INITIAL_CHUNK_COUNT][];
    private int fLength = 0;
    private int fOffset = 0; // for read methods
}
"
org/apache/xerces/readers/XMLEntityHandler.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import java.io.InputStream;

/**
 * This is the interface used for entity management.  This interface
 * is typically implemented by the ""parser"" class to provide entity
 * management services for the scanner classes.
 *
 * @version $Id$
 */
public interface XMLEntityHandler extends Locator {

    /**
     * Special return values for scanCharRef method.  The normal return
     * value is a unicode character.  These error conditions are defined
     * using invalid XML unicode code points.
     */
    public static final int
        CHARREF_RESULT_SEMICOLON_REQUIRED  = -1,
        CHARREF_RESULT_INVALID_CHAR        = -2,
        CHARREF_RESULT_OUT_OF_RANGE        = -3;

    /**
     * Special return values for scanStringLiteral method.  The normal
     * return value is a StringPool handle.  These error conditions are
     * defined using invalid indices.
     */
    public static final int
        STRINGLIT_RESULT_QUOTE_REQUIRED = -1,
        STRINGLIT_RESULT_INVALID_CHAR   = -2;

    /**
     * Special return values for scanAttValue method.  The normal return
     * value is a StringPool handle for a simple AttValue that was already
     * correctly normalized for CDATA in the original document.  These
     * other return values either indicate an error or that the AttValue
     * needs further processing.
     */
    public static final int
        ATTVALUE_RESULT_COMPLEX         = -1,
        ATTVALUE_RESULT_LESSTHAN        = -2,
        ATTVALUE_RESULT_INVALID_CHAR    = -3;

    /**
     * Special return values for scanEntityValue method.  The normal return
     * value is a StringPool handle for a simple EntityValue that was entirely
     * contained within the original document.  These other return values can
     * either indicate an error or that the EntityValue needs further processing.
     */
    public static final int
        ENTITYVALUE_RESULT_FINISHED     = -1,
        ENTITYVALUE_RESULT_REFERENCE    = -2,
        ENTITYVALUE_RESULT_PEREF        = -3,
        ENTITYVALUE_RESULT_INVALID_CHAR = -4,
        ENTITYVALUE_RESULT_END_OF_INPUT = -5;

    /**
     * Return values for the scanContent method.
     */
    public static final int
        CONTENT_RESULT_START_OF_PI              =  0,
        CONTENT_RESULT_START_OF_COMMENT         =  1,
        CONTENT_RESULT_START_OF_CDSECT          =  2,
        CONTENT_RESULT_END_OF_CDSECT            =  3,
        CONTENT_RESULT_START_OF_ETAG            =  4,
        CONTENT_RESULT_MATCHING_ETAG            =  5,
        CONTENT_RESULT_START_OF_ELEMENT         =  6,
        CONTENT_RESULT_START_OF_CHARREF         =  7,
        CONTENT_RESULT_START_OF_ENTITYREF       =  8,
        CONTENT_RESULT_INVALID_CHAR             =  9,
        CONTENT_RESULT_MARKUP_NOT_RECOGNIZED    = 10,
        CONTENT_RESULT_MARKUP_END_OF_INPUT      = 11,
        CONTENT_RESULT_REFERENCE_END_OF_INPUT   = 12;

    /**
     * This is an enumeration of all the defined entity types.
     * These are provided to communicate state information to
     * the clients of the parser.
     */
    public static final int
        ENTITYTYPE_INTERNAL_PE      = 0,
        ENTITYTYPE_EXTERNAL_PE      = 1,
        ENTITYTYPE_INTERNAL         = 2,
        ENTITYTYPE_EXTERNAL         = 3,
        ENTITYTYPE_UNPARSED         = 4,
        ENTITYTYPE_DOCUMENT         = 5,
        ENTITYTYPE_EXTERNAL_SUBSET  = 6;

    /**
     * This is an enumeration of all the defined contexts in which
     * an entity reference may appear.  The order is important, as
     * all explicit general entity references must appear first and
     * the last of these must be ENTITYREF_IN_CONTENT.  This permits
     * the test ""(context <= ENTITYREF_IN_CONTENT)"" to be used as a
     * quick check for a general entity reference.
     *
     * @see #startReadingFromEntity
     */
    public static final int
        ENTITYREF_IN_ATTVALUE = 0,
        ENTITYREF_IN_DEFAULTATTVALUE = 1,
        ENTITYREF_IN_CONTENT = 2,
        ENTITYREF_IN_DTD_AS_MARKUP = 3,
        ENTITYREF_IN_ENTITYVALUE = 4,
        ENTITYREF_IN_DTD_WITHIN_MARKUP = 5,
        ENTITYREF_DOCUMENT = 6,
        ENTITYREF_EXTERNAL_SUBSET = 7;

    /**
     * Start reading document from an InputSource.
     *
     * @param source The input source for the document to process.
     * @return <code>true</code> if we were able to open the document source;
     *         <code>false</code> otherwise.
     * @exception java.lang.Exception
     */
    public boolean startReadingFromDocument(InputSource source) throws Exception;

    /**
     * Start reading from this entity.
     *
     * Note that the reader depth is not used by the reader, but is made
     * available so that it may be retrieved at end of input to test that
     * gramatical structures are properly nested within entities.
     *
     * @param entityName The entity name handle in the string pool.
     * @param readerDepth The depth to associate with the reader for this entity.
     * @param context The context of the entity reference; see ENTITYREF_IN_*.
     * @return <code>true</code> if the entity might start with a TextDecl;
     *         <code>false</code> otherwise.
     * @exception java.lang.Exception
     */
    public boolean startReadingFromEntity(int entityName, int readerDepth, int entityContext) throws Exception;

    /**
     * Expand the system identifier relative to the entity that we are processing.
     *
     * @return The expanded system identifier.
     */
    public String expandSystemId(String systemId);

    /**
     * DTD specific entity handler
     */
    public interface DTDHandler {
        /**
         * Start reading from the external subset of the DTD.
         *
         * @param publicId The public identifier for the external subset.
         * @param systemId The system identifier for the external subset.
         * @param readerDepth The depth to associate with the reader for the external subset.
         * @exception java.lang.Exception
         */
        public void startReadingFromExternalSubset(String publicId, String systemId, int readerDepth) throws Exception;

        /**
         * Finished reading from the external subset of the DTD.
         * @exception java.lang.Exception
         */
        public void stopReadingFromExternalSubset() throws Exception;

        /**
         * Start the scope of an entity declaration.
         *
         * @return <code>true</code> on success; otherwise
         *         <code>false</code> if the entity declaration is recursive.
         * @exception java.lang.Exception
         */
        public boolean startEntityDecl(boolean isPE, int entityName) throws Exception;

        /**
         * End the scope of an entity declaration.
         * @exception java.lang.Exception
         */
        public void endEntityDecl() throws Exception;

        /**
         * Declare entities and notations.
         */
        public int addInternalPEDecl(int entityName, int value, boolean isExternal) throws Exception;
        public int addExternalPEDecl(int entityName, int publicId, int systemId, boolean isExternal) throws Exception;
        public int addInternalEntityDecl(int entityName, int value, boolean isExternal) throws Exception;
        public int addExternalEntityDecl(int entityName, int publicId, int systemId, boolean isExternal) throws Exception;
        public int addUnparsedEntityDecl(int entityName, int publicId, int systemId, int notationName, boolean isExternal) throws Exception;
        public int addNotationDecl(int notationName, int publicId, int systemId, boolean isExternal) throws Exception;

        /**
         * Check for unparsed entity.
         *
         * @param entityName The string handle for the entity name.
         * @return <code>true</code> if entityName is an unparsed entity; otherwise
         *         <code>false</code> if entityName is not declared or not an unparsed entity.
         */
        public boolean isUnparsedEntity(int entityName);

        /**
         * Check for declared notation.
         *
         * @param notationName The string handle for the notation name.
         * @return <code>true</code> if notationName is a declared notation; otherwise
         *         <code>false</code> if notationName is not declared.
         */
        public boolean isNotationDeclared(int entityName);

        /**
         * Remember a required but undeclared notation.
         */
        public void addRequiredNotation(int notationName, Locator locator, int majorCode, int minorCode, Object[] args);

        /**
         * Check required but undeclared notations.
         */
        public void checkRequiredNotations() throws Exception;
    }

    /**
     * Return a unique identifier for the current reader.
     */
    public int getReaderId();

    /**
     * Set the depth for the current reader.
     */
    public void setReaderDepth(int depth);

    /**
     * Return the depth set for the current reader.
     */
    public int getReaderDepth();

    /**
     * Return the current reader.
     */
    public EntityReader getEntityReader();

    /**
     * This method is called by the reader subclasses at the
     * end of input.
     *
     * @return The reader to use next.
     * @exception java.lang.Exception
     */
    public EntityReader changeReaders() throws Exception;

    /**
     * This interface is used to store and retrieve character
     * sequences.  The primary use is for a literal data buffer
     * where we can construct the values for literal entity
     * replacement text.  When all of the characters for the
     * replacement text have been added to the buffer, the
     * contents are added to the string pool for later use
     * in constructing a StringReader if the entity is referenced.
     */
    public interface CharBuffer {
        /**
         * Append a character to this buffer.
         *
         * @param ch The character.
         */
        public void append(char ch);

        /**
         * Append characters to this buffer.
         *
         * @param chars The char array containing the characters.
         * @param offset The offset within the char array of the first character to append.
         * @param length The number of characters to append.
         */
        public void append(char[] chars, int offset, int length);

        /**
         * Get the current length of the buffer.  This is also the
         * offset of the next character that is added to the buffer.
         *
         * @return The length of the buffer.
         */
        public int length();

        /**
         * Add a region of this buffer to the string pool.
         *
         * @param offset The offset within this buffer of the first character of the string.
         * @param length The number of characters in the string.
         * @return The <code>StringPool</code> handle of the string.
         */
        public int addString(int offset, int length);
    }

    /**
     * Set the character data handler.
     */
    public void setCharDataHandler(XMLEntityHandler.CharDataHandler charDataHandler);

    /**
     * Get the character data handler.
     */
    public XMLEntityHandler.CharDataHandler getCharDataHandler();

    /**
     * Interface for passing character data.
     */
    public interface CharDataHandler {
        /**
         * Process character data, character array version
         * 
         * @param chars character buffer to be processed
         * @param offset offset in buffer where the data starts
         * @param length length of characters to be processed
         * @exception java.lang.Exception
         */
        public void processCharacters(char[] chars, int offset, int length) throws Exception;

        /**
         * Process character data, <code>StringPool</code> handle version
         *
         * @param stringHandle <code>StringPool</code> handle to the character data
         * @exception java.lang.Exception
         */
        public void processCharacters(int stringHandle) throws Exception;

        /**
         * Process white space data, character array version
         *
         * @param chars character buffer to be processed
         * @param offset offset in buffer where the data starts
         * @param length length of whitespace to be processed
         * @exception java.lang.Exception
         */
        public void processWhitespace(char[] chars, int offset, int length) throws Exception;

        /**
         * Process white space data, <code>StringPool</code> handle version
         *
         * @param stringHandle <code>StringPool</code> handle to the whitespace
         * @exception java.lang.Exception
         */
        public void processWhitespace(int stringHandle) throws Exception;
    }

    /**
     * This is the interface for scanners to process input data
     * from entities without needing to know the details of the
     * underlying storage of those entities, or their encodings.
     *
     * The methods in this interface have been refined over time
     * to a rough balance between keeping the XML grammar dependent
     * code within the scanner classes, and allowing high performance
     * processing of XML documents.
     */
    public interface EntityReader {
        /**
         * Return the current offset within this reader.
         *
         * @return The offset.
         */
        public int currentOffset();

        /**
         * Return the line number of the current position within the document that we are processing.
         *
         * @return The current line number.
         */
        public int getLineNumber();

        /**
         * Return the column number of the current position within the document that we are processing.
         *
         * @return The current column number.
         */
        public int getColumnNumber();

        /**
         * This method is provided for scanner implementations.
         */
        public void setInCDSect(boolean inCDSect);

        /**
         * This method is provided for scanner implementations.
         */
        public boolean getInCDSect();

        /**
         * Append the characters processed by this reader associated with <code>offset</code> and
         * <code>length</code> to the <code>CharBuffer</code>.
         *
         * @param charBuffer The <code>CharBuffer</code> to append the characters to.
         * @param offset The offset within this reader where the copy should start.
         * @param length The length within this reader where the copy should stop.
         */
        public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length);

        /**
         * Add a string to the <code>StringPool</code> from the characters scanned using this
         * reader as described by <code>offset</code> and <code>length</code>.
         *
         * @param offset The offset within this reader where the characters start.
         * @param length The length within this reader where the characters end.
         * @return The <code>StringPool</code> handle for the string.
         */
        public int addString(int offset, int length);

        /**
         * Add a symbol to the <code>StringPool</code> from the characters scanned using this
         * reader as described by <code>offset</code> and <code>length</code>.
         *
         * @param offset The offset within this reader where the characters start.
         * @param length The length within this reader where the characters end.
         * @return The <code>StringPool</code> handle for the symbol.
         */
        public int addSymbol(int offset, int length);

        /**
         * Test that the current character is a <code>ch</code> character.
         *
         * @param ch The character to match against.
         * @param skipPastChar If <code>true</code>, we advance past the matched character.
         * @return <code>true</code> if the current character is a <code>ch</code> character;
         *         <code>false</code> otherwise.
         * @exception java.lang.Exception
         */
        public boolean lookingAtChar(char ch, boolean skipPastChar) throws Exception;

        /**
         * Test that the current character is valid.
         *
         * @param skipPastChar If <code>true</code>, we advance past the valid character.
         * @return <code>true</code> if the current character is valid;
         *         <code>false</code> otherwise.
         * @exception java.lang.Exception
         */
        public boolean lookingAtValidChar(boolean skipPastChar) throws Exception;

        /**
         * Test that the current character is a whitespace character.
         *
         * @param skipPastChar If <code>true</code>, we advance past the whitespace character.
         * @return <code>true</code> if the current character is whitespace;
         *         <code>false</code> otherwise.
         * @exception java.lang.Exception
         */
        public boolean lookingAtSpace(boolean skipPastChar) throws Exception;

        /**
         * Advance through the input data up to the next <code>ch</code> character.
         *
         * @param ch The character to search for.
         * @exception java.lang.Exception
         */
        public void skipToChar(char ch) throws Exception;

        /**
         * Skip past whitespace characters starting at the current position.
         * @exception java.lang.Exception
         */
        public void skipPastSpaces() throws Exception;

        /**
         * Skip past a sequence of characters that match the XML definition of a Name.
         * @exception java.lang.Exception
         */
        public void skipPastName(char fastcheck) throws Exception;

        /**
         * Skip past a sequence of characters that match the XML definition of an Nmtoken.
         * @exception java.lang.Exception
         */
        public void skipPastNmtoken(char fastcheck) throws Exception;

        /**
         * Skip past a sequence of characters that matches the specified character array.
         *
         * @param s The characters to match.
         * @return <code>true</code> if the current character is valid;
         *         <code>false</code> otherwise.
         * @exception java.lang.Exception
         */
        public boolean skippedString(char[] s) throws Exception;

        /**
         * Scan an invalid character.
         *
         * @return The invalid character as an integer, or -1 if there was a bad encoding.
         * @exception java.lang.Exception
         */
        public int scanInvalidChar() throws Exception;

        /**
         * Scan a character reference.
         *
         * @return The value of the character, or one of the following error codes:
         *
         *   CHARREF_RESULT_SEMICOLON_REQUIRED
         *   CHARREF_RESULT_INVALID_CHAR
         *   CHARREF_RESULT_OUT_OF_RANGE
         * @exception java.lang.Exception
         */
        public int scanCharRef(boolean isHexadecimal) throws Exception;

        /**
         * Scan a string literal.
         *
         * @return The <code>StringPool</code> handle for the string that
         *         was scanned, or one of the following error codes:
         *
         *   STRINGLIT_RESULT_QUOTE_REQUIRED
         *   STRINGLIT_RESULT_INVALID_CHAR
         * @exception java.lang.Exception
         */
        public int scanStringLiteral() throws Exception;

        /**
         * Scan an attribute value.
         *
         * @param qchar The initial quote character, either a single or double quote.
         * @return The <code>StringPool</code> handle for the string that
         *         was scanned, or one of the following error codes:
         *
         *   ATTVALUE_RESULT_COMPLEX
         *   ATTVALUE_RESULT_LESSTHAN
         *   ATTVALUE_RESULT_INVALID_CHAR
         * @exception java.lang.Exception
         */
        public int scanAttValue(char qchar, boolean asSymbol) throws Exception;

        /**
         * Scan an entity value.
         *
         * @param qchar The initial quote character, either a single or double quote.
         * @return The <code>StringPool</code> handle for the string that
         *         was scanned, or one of the following error codes:
         *
         *   ENTITYVALUE_RESULT_FINISHED
         *   ENTITYVALUE_RESULT_REFERENCE
         *   ENTITYVALUE_RESULT_PEREF
         *   ENTITYVALUE_RESULT_INVALID_CHAR
         *   ENTITYVALUE_RESULT_END_OF_INPUT
         * @exception java.lang.Exception
         */
        public int scanEntityValue(int qchar, boolean createString) throws Exception;

        /**
         * Add a sequence of characters that match the XML definition of a Name to the <code>StringPool</code>.
         *
         * If we find a name at the current position we will add it to the <code>StringPool</code>
         * as a symbol and will return the string pool handle for that symbol to the caller.
         *
         * @param fastcheck A character that is not a legal name character that is provided as a
         *                  hint to the reader of a character likely to terminate the Name.
         * @return The <code>StringPool</code> handle for the name that was scanned,
         *         or -1 if a name was not found at the current position within the input data.
         * @exception java.lang.Exception
         */
        public int scanName(char fastcheck) throws Exception;

        /**
         * Scan the name that is expected at the current position in the document.
         *
         * This method is invoked when we are scanning the element type in an end tag
         * that must match the element type in the corresponding start tag.
         *
         * @param fastcheck A character that is not a legal name character that is provided as a
         *                  hint to the reader of a character likely to terminate the Name.
         * @param expectedName The characters of the name we expect.
         * @return <code>true</code> if we scanned the name we expected to find; otherwise
         *         <code>false</code> if we did not.
         * @exception java.lang.Exception
         */
        public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws Exception;

        /**
         * Add a sequence of characters that match the XML Namespaces definition of a QName
         * to the <code>StringPool</code>.
         *
         * If we find a QName at the current position we will add it to the <code>StringPool</code>
         * and will return the string pool handle of that QName to the caller.
         *
         * @param fastcheck A character that is not a legal name character that is provided as a
         *                  hint to the reader of a character likely to terminate the Name.
         * <!--
         * @return The <code>StringPool</code> handle for the QName that was scanned,
         *         or -1 if a name was not found at the current position within the input data.
         * -->
         * @exception java.lang.Exception
         */
        public void scanQName(char fastcheck, QName qname) throws Exception;

        /**
         * Skip through the input while we are looking at character data.
         *
         * @param elementType The element type handle in the StringPool.
         * @return One of the following result codes:
         *
         *   CONTENT_RESULT_START_OF_PI
         *   CONTENT_RESULT_START_OF_COMMENT
         *   CONTENT_RESULT_START_OF_CDSECT
         *   CONTENT_RESULT_END_OF_CDSECT
         *   CONTENT_RESULT_START_OF_ETAG
         *   CONTENT_RESULT_MATCHING_ETAG
         *   CONTENT_RESULT_START_OF_ELEMENT
         *   CONTENT_RESULT_START_OF_CHARREF
         *   CONTENT_RESULT_START_OF_ENTITYREF
         *   CONTENT_RESULT_INVALID_CHAR
         *   CONTENT_RESULT_MARKUP_NOT_RECOGNIZED
         *   CONTENT_RESULT_MARKUP_END_OF_INPUT
         *   CONTENT_RESULT_REFERENCE_END_OF_INPUT
         * @exception java.lang.Exception
         */
        public int scanContent(QName element) throws Exception;
    }
}
"
org/apache/xerces/validators/schema/SchemaMessageProvider.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.schema;

import org.apache.xerces.utils.XMLMessageProvider;
import java.util.ResourceBundle;
import java.util.ListResourceBundle;
import java.util.Locale;

/**
 * SchemaMessageProvider implements an XMLMessageProvider that
 * provides localizable error messages for the W3C XML Schema Language
 *
 */
public class SchemaMessageProvider implements XMLMessageProvider {
    /**
     * The domain of messages concerning the XML Schema: Structures specification.
     */
    public static final String SCHEMA_DOMAIN = ""http://www.w3.org/TR/xml-schema-1"";

    /**
     *
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }
    /**
     *
     */
    public Locale getLocale() {
        return fLocale;
    }

    /**
     * Creates a message from the specified key and replacement
     * arguments, localized to the given locale.
     *
     * @param locale    The requested locale of the message to be
     *                  created.
     * @param key       The key for the message text.
     * @param args      The arguments to be used as replacement text
     *                  in the message created.
     */
    public String createMessage(Locale locale, int majorCode, int minorCode, Object args[]) {
        boolean throwex = false;
        if (fResourceBundle == null || locale != fLocale) {
            if (locale != null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.SchemaMessages"", locale);
            if (fResourceBundle == null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.SchemaMessages"");
        }
        if (majorCode < 0 || majorCode >= fgMessageKeys.length) {
            majorCode = MSG_BAD_MAJORCODE;
            throwex = true;
        }
        String msgKey = fgMessageKeys[majorCode];
        String msg = fResourceBundle.getString(msgKey);
        if (args != null) {
            try {
                msg = java.text.MessageFormat.format(msg, args);
            } catch (Exception e) {
                msg = fResourceBundle.getString(fgMessageKeys[MSG_FORMAT_FAILURE]);
                msg += "" "" + fResourceBundle.getString(msgKey);
            }
        }

        if (throwex) {
            throw new RuntimeException(msg);
        }
        return msg;
    }
    //
    //
    //
    private Locale fLocale = null;
    private ResourceBundle fResourceBundle = null;
    //
    // Major codes
    //
    public static final int 
        MSG_BAD_MAJORCODE = 0,              //  majorCode parameter to createMessage was out of bounds
        MSG_FORMAT_FAILURE = 1,             //  exception thrown during messageFormat call
        NoValidatorFor = 2,
        IncorrectDatatype = 3,
        AttMissingType = 4,
        NotADatatype = 5,
        TextOnlyContentWithType = 6,
        FeatureUnsupported = 7,
        NestedOnlyInElemOnly = 8,
        EltRefOnlyInMixedElemOnly = 9,
        OnlyInEltContent = 10,
        OrderIsAll = 11,
        DatatypeWithType = 12,
        DatatypeQualUnsupported = 13,
        GroupContentRestricted = 14,
        UnknownBaseDatatype = 15,
        OneOfTypeRefArchRef = 16,
        NoContentForRef = 17,
        IncorrectDefaultType = 18,
        IllegalAttContent = 19,
        ValueNotInteger = 20,
        DatatypeError = 21,
		TypeAlreadySet = 22,
		GenericError = 23,
		UnclassifiedError = 24,
        // ...
        MSG_MAX_CODE = 31;
    //
    // Minor Codes
    //
    public static final int
        MSG_NONE = 0;

    public static final String[] fgMessageKeys = {
        ""BadMajorCode"",                 //   0, ""The majorCode parameter to createMessage was out of bounds.""
        ""FormatFailed"",                 //   1, ""An internal error occurred while formatting the following message:""
        ""NoValidatorFor"",               //   2, ""No validator for datatype {0}""
        ""IncorrectDatatype"",            //   3, ""Incorrect datatype: {0}"" 
        ""AttMissingType"",               //   4, ""The {0} attribute must appear with a type attribute.""
        ""NotADatatype"",                 //   5, ""{0} is not a datatype.""
        ""TextOnlyContentWithType"",      //   6, ""The content attribute must be 'textOnly' if you specify a type attribute."" 
        ""FeatureUnsupported"",           //   7, ""{0} is unsupported""
        ""NestedOnlyInElemOnly"",         //   8, ""Nested Element decls only allowed in elemOnly content""
        ""EltRefOnlyInMixedElemOnly"",    //   9, ""Element references only allowed in mixed or elemOnly content""
        ""OnlyInEltContent"",             //  10, ""{0} only allowed in elemOnly content.""
        ""OrderIsAll"",                   //  11, ""{0} not allowed if the order is all.""
        ""DatatypeWithType"",             //  12, ""Datatype qualifiers can only be used if you specify a type attribute.""},
        ""DatatypeQualUnsupported"",      //  13, ""The datatype qualifier {0} is not supported.""
        ""GroupContentRestricted"",       //  14, ""Error: {0} content must be one of element, group, modelGroupRef.  Saw {1}""
        ""UnknownBaseDatatype"",          //  15, ""Unknown base type {0} for type {1}."" },
        ""OneOfTypeRefArchRef"",          //  16, ""Can only have one of type, ref, and archRef attributes.""},
        ""NoContentForRef"",              //  17, ""Cannot have child content for an element declaration that has a ref attribute""
        ""IncorrectDefaultType"",         //  18, ""Incorrect type for {0}'s default value: {1}""
        ""IllegalAttContent"",            //  19, ""Illegal content {0} in attribute group""
        ""ValueNotInteger"",              //  20, ""Value of {0} is not an integer""
        ""DatatypeError"",                //  21, ""Datatype error {0}."" 
		""TypeAlreadySet"",				//	22,	""The type of the element has already been declared.""
		""GenericError"",					//	23, ""Schema error: {0}.""
		""UnclassifiedError"",			//	24,	""Unclassified error.""
    };
}
"
org/w3c/dom/NodeList.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>NodeList</code> interface provides the abstraction of an ordered 
 * collection of nodes, without defining or constraining how this collection 
 * is implemented.
 * <p> The items in the <code>NodeList</code> are accessible via an integral 
 * index, starting from 0. 
 */
public interface NodeList {
    /**
     *  Returns the <code>index</code> th item in the collection. If 
     * <code>index</code> is greater than or equal to the number of nodes in 
     * the list, this returns <code>null</code> .
     * @param index  Index into the collection.
     * @return  The node at the <code>index</code> th position in the 
     *   <code>NodeList</code> , or <code>null</code> if that is not a valid 
     *   index.
     */
    public Node item(int index);

    /**
     *  The number of nodes in the list. The range of valid child node indices 
     * is 0 to <code>length-1</code> inclusive. 
     */
    public int getLength();

}

"
org/apache/xerces/msg/DatatypeMessages.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.msg;

import java.util.ListResourceBundle;

/**
 * This file contains error and warning messages for the schema datatype validator
 * The messages are arranged in key and value tuples in a ListResourceBundle.
 *
 *
 * @version
 */
public class DatatypeMessages extends ListResourceBundle {
    /** The list resource bundle contents. */
    public static final Object CONTENTS[][] = {
// Internal message formatter messages
        { ""BadMajorCode"", ""The majorCode parameter to createMessage was out of bounds."" },
        { ""FormatFailed"", ""An internal error occurred while formatting the following message:\n  "" },
        { ""NotBoolean"", ""{0} is not a boolean."" },
        { ""NotDecimal"", ""{0} is not a decimal."" },
        { ""FacetsInconsistent"", ""Facets are inconsistent with base type."" },
        { ""IllegalFacetValue"", ""Illegal value {0} for facet {1}."" },
        { ""IllegalDecimalFacet"", ""Illegal Facet for decimal type."" },
        { ""UnknownFacet"", ""Unknown Facet: {0}."" },
        { ""InvalidEnumValue"", ""Invalid value for Enum constant: {0}."" },
        { ""OutOfBounds"", ""{0} is out of bounds."" },
        { ""NotAnEnumValue"", ""{0} is not one of the specified enum values."" },
        { ""NotInteger"", ""{0} is not an integer."" },
        { ""IllegalIntegerFacet"", ""Illegal Facet for Integer type."" },
        { ""NotReal"", ""{0} is not a double."" },
        { ""IllegalRealFacet"", ""Illegal Facet for Real type."" },
        { ""ScaleLargerThanPrecision"", ""Scale Facet must be less than or equal to Precision Facet"" },
        { ""PrecisionExceeded"", ""{0} has exceeded the precision Facet {1}""},
        { ""ScaleExceeded"", ""{0} has execeed the scale Facet {1}""},
    };

    /** Returns the list resource bundle contents. */
    public Object[][] getContents() {
        return CONTENTS;
    }
}
"
org/apache/xerces/readers/MIME2Java.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import java.util.*;

/**
 * MIME2Java is a convenience class which handles conversions between MIME charset names
 * and Java encoding names.
 * <p>The supported XML encodings are the intersection of XML-supported code sets and those 
 * supported in JDK 1.1.
 * <p>MIME charset names are used on <var>xmlEncoding</var> parameters to methods such
 * as <code>TXDocument#setEncoding</code> and <code>DTD#setEncoding</code>.
 * <p>Java encoding names are used on <var>encoding</var> parameters to
 * methods such as <code>TXDocument#printWithFormat</code> and <code>DTD#printExternal</code>. 
 * <P>
 * <TABLE BORDER=""0"" WIDTH=""100%"">
 *  <TR>
 *      <TD WIDTH=""33%"">
 *          <P ALIGN=""CENTER""><B>Common Name</B>
 *      </TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER""><B>Use this name in XML files</B>
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER""><B>Name Type</B>
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER""><B>Xerces converts to this Java Encoder Name</B>
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">8 bit Unicode</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">UTF-8
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">UTF8
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin 1</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-1
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-1
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin 2</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-2
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-2
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin 3</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-3
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-3
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin 4</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-4
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-4
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin Cyrillic</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-5
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-5
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin Arabic</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-6
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-6
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin Greek</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-7
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-7
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin Hebrew</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-8
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-8
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">ISO Latin 5</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ISO-8859-9
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">ISO-8859-9
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: US</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-us
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp037
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Canada</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-ca
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp037
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Netherlands</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-nl
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp037
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Denmark</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-dk
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp277
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Norway</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-no
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp277
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Finland</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-fi
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp278
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Sweden</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-se
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp278
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Italy</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-it
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp280
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Spain, Latin America</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-es
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp284
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Great Britain</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-gb
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp285
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: France</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-fr
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp297
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Arabic</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-ar1
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp420
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Hebrew</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-he
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp424
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Switzerland</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-ch
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp500
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Roece</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-roece
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp870
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Yogoslavia</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-yu
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp870
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Iceland</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-is
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp871
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">EBCDIC: Urdu</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">ebcdic-cp-ar2
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">IANA
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">cp918
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Chinese for PRC, mixed 1/2 byte</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">gb2312
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">GB2312
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Extended Unix Code, packed for Japanese</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">euc-jp
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">eucjis
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Japanese: iso-2022-jp</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">iso-2020-jp
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">JIS
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Japanese: Shift JIS</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">Shift_JIS
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">SJIS
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Chinese: Big5</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">Big5
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">Big5
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Extended Unix Code, packed for Korean</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">euc-kr
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">iso2022kr
 *      </TD>
 *  </TR>
 *  <TR>
 *      <TD WIDTH=""33%"">Cyrillic</TD>
 *      <TD WIDTH=""15%"">
 *          <P ALIGN=""CENTER"">koi8-r
 *      </TD>
 *      <TD WIDTH=""12%"">
 *          <P ALIGN=""CENTER"">MIME
 *      </TD>
 *      <TD WIDTH=""31%"">
 *          <P ALIGN=""CENTER"">koi8-r
 *      </TD>
 *  </TR>
 * </TABLE>
 * 
 * @version
 * @author TAMURA Kent &lt;kent@trl.ibm.co.jp&gt;
 */
public class MIME2Java {
    
    static private Hashtable s_enchash;
    static private Hashtable s_revhash;
    
    static {
        s_enchash = new Hashtable();
        //    <preferred MIME name>, <Java encoding name>
        s_enchash.put(""UTF-8"", ""UTF8"");
        s_enchash.put(""US-ASCII"",        ""8859_1"");    // ?
        s_enchash.put(""ISO-8859-1"",      ""8859_1"");
        s_enchash.put(""ISO-8859-2"",      ""8859_2"");
        s_enchash.put(""ISO-8859-3"",      ""8859_3"");
        s_enchash.put(""ISO-8859-4"",      ""8859_4"");
        s_enchash.put(""ISO-8859-5"",      ""8859_5"");
        s_enchash.put(""ISO-8859-6"",      ""8859_6"");
        s_enchash.put(""ISO-8859-7"",      ""8859_7"");
        s_enchash.put(""ISO-8859-8"",      ""8859_8"");
        s_enchash.put(""ISO-8859-9"",      ""8859_9"");
        s_enchash.put(""ISO-2022-JP"",     ""JIS"");
        s_enchash.put(""SHIFT_JIS"",       ""SJIS"");
        s_enchash.put(""EUC-JP"",          ""EUCJIS"");
        s_enchash.put(""GB2312"",          ""GB2312"");
        s_enchash.put(""BIG5"",            ""Big5"");
        s_enchash.put(""EUC-KR"",          ""KSC5601"");
        s_enchash.put(""ISO-2022-KR"",     ""ISO2022KR"");
        s_enchash.put(""KOI8-R"",          ""KOI8_R"");

        s_enchash.put(""EBCDIC-CP-US"",    ""CP037"");
        s_enchash.put(""EBCDIC-CP-CA"",    ""CP037"");
        s_enchash.put(""EBCDIC-CP-NL"",    ""CP037"");
        s_enchash.put(""EBCDIC-CP-DK"",    ""CP277"");
        s_enchash.put(""EBCDIC-CP-NO"",    ""CP277"");
        s_enchash.put(""EBCDIC-CP-FI"",    ""CP278"");
        s_enchash.put(""EBCDIC-CP-SE"",    ""CP278"");
        s_enchash.put(""EBCDIC-CP-IT"",    ""CP280"");
        s_enchash.put(""EBCDIC-CP-ES"",    ""CP284"");
        s_enchash.put(""EBCDIC-CP-GB"",    ""CP285"");
        s_enchash.put(""EBCDIC-CP-FR"",    ""CP297"");
        s_enchash.put(""EBCDIC-CP-AR1"",   ""CP420"");
        s_enchash.put(""EBCDIC-CP-HE"",    ""CP424"");
        s_enchash.put(""EBCDIC-CP-CH"",    ""CP500"");
        s_enchash.put(""EBCDIC-CP-ROECE"", ""CP870"");
        s_enchash.put(""EBCDIC-CP-YU"",    ""CP870"");
        s_enchash.put(""EBCDIC-CP-IS"",    ""CP871"");
        s_enchash.put(""EBCDIC-CP-AR2"",   ""CP918"");

                                                // j:CNS11643 -> EUC-TW?
                                                // ISO-2022-CN? ISO-2022-CN-EXT?
                                                
        s_revhash = new Hashtable();
        //    <Java encoding name>, <preferred MIME name>
        s_revhash.put(""UTF8"", ""UTF-8"");
        //s_revhash.put(""8859_1"", ""US-ASCII"");    // ?
        s_revhash.put(""8859_1"", ""ISO-8859-1"");
        s_revhash.put(""8859_2"", ""ISO-8859-2"");
        s_revhash.put(""8859_3"", ""ISO-8859-3"");
        s_revhash.put(""8859_4"", ""ISO-8859-4"");
        s_revhash.put(""8859_5"", ""ISO-8859-5"");
        s_revhash.put(""8859_6"", ""ISO-8859-6"");
        s_revhash.put(""8859_7"", ""ISO-8859-7"");
        s_revhash.put(""8859_8"", ""ISO-8859-8"");
        s_revhash.put(""8859_9"", ""ISO-8859-9"");
        s_revhash.put(""JIS"", ""ISO-2022-JP"");
        s_revhash.put(""SJIS"", ""Shift_JIS"");
        s_revhash.put(""EUCJIS"", ""EUC-JP"");
        s_revhash.put(""GB2312"", ""GB2312"");
        s_revhash.put(""BIG5"", ""Big5"");
        s_revhash.put(""KSC5601"", ""EUC-KR"");
        s_revhash.put(""ISO2022KR"", ""ISO-2022-KR"");
        s_revhash.put(""KOI8_R"", ""KOI8-R"");

        s_revhash.put(""CP037"", ""EBCDIC-CP-US"");
        s_revhash.put(""CP037"", ""EBCDIC-CP-CA"");
        s_revhash.put(""CP037"", ""EBCDIC-CP-NL"");
        s_revhash.put(""CP277"", ""EBCDIC-CP-DK"");
        s_revhash.put(""CP277"", ""EBCDIC-CP-NO"");
        s_revhash.put(""CP278"", ""EBCDIC-CP-FI"");
        s_revhash.put(""CP278"", ""EBCDIC-CP-SE"");
        s_revhash.put(""CP280"", ""EBCDIC-CP-IT"");
        s_revhash.put(""CP284"", ""EBCDIC-CP-ES"");
        s_revhash.put(""CP285"", ""EBCDIC-CP-GB"");
        s_revhash.put(""CP297"", ""EBCDIC-CP-FR"");
        s_revhash.put(""CP420"", ""EBCDIC-CP-AR1"");
        s_revhash.put(""CP424"", ""EBCDIC-CP-HE"");
        s_revhash.put(""CP500"", ""EBCDIC-CP-CH"");
        s_revhash.put(""CP870"", ""EBCDIC-CP-ROECE"");
        s_revhash.put(""CP870"", ""EBCDIC-CP-YU"");
        s_revhash.put(""CP871"", ""EBCDIC-CP-IS"");
        s_revhash.put(""CP918"", ""EBCDIC-CP-AR2"");
    }

    private MIME2Java() {
    }

    /**
     * Convert a MIME charset name, also known as an XML encoding name, to a Java encoding name.
     * @param   mimeCharsetName Case insensitive MIME charset name: <code>UTF-8, US-ASCII, ISO-8859-1,
     *                          ISO-8859-2, ISO-8859-3, ISO-8859-4, ISO-8859-5, ISO-8859-6,
     *                          ISO-8859-7, ISO-8859-8, ISO-8859-9, ISO-2022-JP, Shift_JIS, 
     *                          EUC-JP, GB2312, Big5, EUC-KR, ISO-2022-KR, KOI8-R,
     *                          EBCDIC-CP-US, EBCDIC-CP-CA, EBCDIC-CP-NL, EBCDIC-CP-DK,
     *                          EBCDIC-CP-NO, EBCDIC-CP-FI, EBCDIC-CP-SE, EBCDIC-CP-IT,
     *                          EBCDIC-CP-ES, EBCDIC-CP-GB, EBCDIC-CP-FR, EBCDIC-CP-AR1,
     *                          EBCDIC-CP-HE, EBCDIC-CP-CH, EBCDIC-CP-ROECE, EBCDIC-CP-YU,
     *                          EBCDIC-CP-IS and EBCDIC-CP-AR2</code>.
     * @return                  Java encoding name, or <var>null</var> if <var>mimeCharsetName</var>
     *                          is unknown.
     * @see #reverse
     */
    public static String convert(String mimeCharsetName) {
        return (String)s_enchash.get(mimeCharsetName.toUpperCase());
    }

    /**
     * Convert a Java encoding name to MIME charset name.
     * Available values of <i>encoding</i> are ""UTF8"", ""8859_1"", ""8859_2"", ""8859_3"", ""8859_4"",
     * ""8859_5"", ""8859_6"", ""8859_7"", ""8859_8"", ""8859_9"", ""JIS"", ""SJIS"", ""EUCJIS"",
     * ""GB2312"", ""BIG5"", ""KSC5601"", ""ISO2022KR"",  ""KOI8_R"", ""CP037"", ""CP277"", ""CP278"",
     * ""CP280"", ""CP284"", ""CP285"", ""CP297"", ""CP420"", ""CP424"", ""CP500"", ""CP870"", ""CP871"" and ""CP918"".
     * @param   encoding    Case insensitive Java encoding name: <code>UTF8, 8859_1, 8859_2, 8859_3,
     *                      8859_4, 8859_5, 8859_6, 8859_7, 8859_8, 8859_9, JIS, SJIS, EUCJIS,
     *                      GB2312, BIG5, KSC5601, ISO2022KR, KOI8_R, CP037, CP277, CP278,
     *                      CP280, CP284, CP285, CP297, CP420, CP424, CP500, CP870, CP871 
     *                      and CP918</code>.
     * @return              MIME charset name, or <var>null</var> if <var>encoding</var> is unknown.
     * @see #convert
     */
    public static String reverse(String encoding) {
        return (String)s_revhash.get(encoding.toUpperCase());
    }
}
"
org/xml/sax/helpers/LocatorImpl.java,true,"// SAX default implementation for Locator.
// No warranty; no copyright -- use this as you will.
// $Id: LocatorImpl.java,v 1.4 2000/05/05 17:49:44 david Exp $

package org.xml.sax.helpers;

import org.xml.sax.Locator;


/**
 * Provide an optional convenience implementation of Locator.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This class is available mainly for application writers, who
 * can use it to make a persistent snapshot of a locator at any
 * point during a document parse:</p>
 *
 * <pre>
 * Locator locator;
 * Locator startloc;
 *
 * public void setLocator (Locator locator)
 * {
 *         // note the locator
 *   this.locator = locator;
 * }
 *
 * public void startDocument ()
 * {
 *         // save the location of the start of the document
 *         // for future use.
 *   Locator startloc = new LocatorImpl(locator);
 * }
 *</pre>
 *
 * <p>Normally, parser writers will not use this class, since it
 * is more efficient to provide location information only when
 * requested, rather than constantly updating a Locator object.</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Locator Locator
 */
public class LocatorImpl implements Locator
{
    
    
    /**
     * Zero-argument constructor.
     *
     * <p>This will not normally be useful, since the main purpose
     * of this class is to make a snapshot of an existing Locator.</p>
     */
    public LocatorImpl ()
    {
    }
    
    
    /**
     * Copy constructor.
     *
     * <p>Create a persistent copy of the current state of a locator.
     * When the original locator changes, this copy will still keep
     * the original values (and it can be used outside the scope of
     * DocumentHandler methods).</p>
     *
     * @param locator The locator to copy.
     */
    public LocatorImpl (Locator locator)
    {
	setPublicId(locator.getPublicId());
	setSystemId(locator.getSystemId());
	setLineNumber(locator.getLineNumber());
	setColumnNumber(locator.getColumnNumber());
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Implementation of org.xml.sax.Locator
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Return the saved public identifier.
     *
     * @return The public identifier as a string, or null if none
     *         is available.
     * @see org.xml.sax.Locator#getPublicId
     * @see #setPublicId
     */
    public String getPublicId ()
    {
	return publicId;
    }
    
    
    /**
     * Return the saved system identifier.
     *
     * @return The system identifier as a string, or null if none
     *         is available.
     * @see org.xml.sax.Locator#getSystemId
     * @see #setSystemId
     */
    public String getSystemId ()
    {
	return systemId;
    }
    
    
    /**
     * Return the saved line number (1-based).
     *
     * @return The line number as an integer, or -1 if none is available.
     * @see org.xml.sax.Locator#getLineNumber
     * @see #setLineNumber
     */
    public int getLineNumber ()
    {
	return lineNumber;
    }
    
    
    /**
     * Return the saved column number (1-based).
     *
     * @return The column number as an integer, or -1 if none is available.
     * @see org.xml.sax.Locator#getColumnNumber
     * @see #setColumnNumber
     */
    public int getColumnNumber ()
    {
	return columnNumber;
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Setters for the properties (not in org.xml.sax.Locator)
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Set the public identifier for this locator.
     *
     * @param publicId The new public identifier, or null 
     *        if none is available.
     * @see #getPublicId
     */
    public void setPublicId (String publicId)
    {
	this.publicId = publicId;
    }
    
    
    /**
     * Set the system identifier for this locator.
     *
     * @param systemId The new system identifier, or null 
     *        if none is available.
     * @see #getSystemId
     */
    public void setSystemId (String systemId)
    {
	this.systemId = systemId;
    }
    
    
    /**
     * Set the line number for this locator (1-based).
     *
     * @param lineNumber The line number, or -1 if none is available.
     * @see #getLineNumber
     */
    public void setLineNumber (int lineNumber)
    {
	this.lineNumber = lineNumber;
    }
    
    
    /**
     * Set the column number for this locator (1-based).
     *
     * @param columnNumber The column number, or -1 if none is available.
     * @see #getColumnNumber
     */
    public void setColumnNumber (int columnNumber)
    {
	this.columnNumber = columnNumber;
    }
    
    

    ////////////////////////////////////////////////////////////////////
    // Internal state.
    ////////////////////////////////////////////////////////////////////
    
    private String publicId;
    private String systemId;
    private int lineNumber;
    private int columnNumber;
    
}

// end of LocatorImpl.java
"
org/apache/xerces/msg/SchemaMessages.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.msg;

import java.util.ListResourceBundle;

/**
 * This file contains error and warning messages for the Schema validator
 * The messages are arranged in key and value tuples in a ListResourceBundle.
 *
 * @version $Id$
 */
public class SchemaMessages extends ListResourceBundle {
    /** The list resource bundle contents. */
    public static final Object CONTENTS[][] = {
// Internal message formatter messages
        { ""BadMajorCode"", ""The majorCode parameter to createMessage was out of bounds."" },
        { ""FormatFailed"", ""An internal error occurred while formatting the following message:\n  "" },
        { ""NoValidatorFor"", ""No validator for datatype {0}"" },
        { ""IncorrectDatatype"", ""Incorrect datatype: {0}"" },
        { ""NotADatatype"", ""{0} is not a datatype."" },
        { ""TextOnlyContentWithType"", ""The content attribute must be 'textOnly' if you specify a type attribute."" },
        { ""FeatureUnsupported"", ""{0} is unsupported"" },
        { ""NestedOnlyInElemOnly"", ""Nested Element decls only allowed in elementOnly content"" },
        { ""EltRefOnlyInMixedElemOnly"", ""Element references only allowed in mixed or elementOnly content""},
        { ""OnlyInEltContent"", ""{0} only allowed in elementOnly content.""},
        { ""OrderIsAll"", ""{0} not allowed if the order is all.""},
        { ""DatatypeWithType"", ""Datatype qualifiers can only be used if you specify a type attribute.""},
        { ""DatatypeQualUnsupported"", ""The datatype qualifier {0} is not supported.""},
        { ""GroupContentRestricted"", ""Error: {0} content must be one of element, group, modelGroupRef.  Saw {1}""},
        { ""UnknownBaseDatatype"", ""Unknown base type {0} for type {1}."" },
        { ""OneOfTypeRefArchRef"", ""Can only have one of type and ref attributes.""},
        { ""NoContentForRef"", ""Cannot have child content for an element declaration that has a ref attribute"" },
        { ""IncorrectDefaultType"", ""Incorrect type for {0}'s default value: {1}"" },
        { ""IllegalAttContent"", ""Illegal content {0} in attribute group"" },
        { ""ValueNotInteger"", ""Value of {0} is not an integer."" },
        { ""DatatypeError"", ""Datatype error: {0}."" },
		{ ""TypeAlreadySet"", ""The type of the element has already been declared."" },
		{ ""GenericError"", ""Schema error: {0}."" },
		{ ""UnexpectedError"", ""UnexpectedError"" },
   };
    
    /** Returns the list resource bundle contents. */
    public Object[][] getContents() {
        return CONTENTS;
    }

}
"
org/apache/xerces/readers/EBCDICRecognizer.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.ChunkyByteArray;
import org.apache.xerces.utils.StringPool;

import java.io.InputStreamReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

/**
 *
 * @version
 */
final class EBCDICRecognizer extends XMLDeclRecognizer {
    //
    //
    //
    public XMLEntityHandler.EntityReader recognize(XMLEntityReaderFactory readerFactory,
                                                   XMLEntityHandler entityHandler,
                                                   XMLErrorReporter errorReporter,
                                                   boolean sendCharDataAsCharArray,
                                                   StringPool stringPool,
                                                   ChunkyByteArray data,
                                                   boolean xmlDecl,
                                                   boolean allowJavaEncodingName) throws Exception
    {
        XMLEntityHandler.EntityReader reader = null;
        byte b0 = data.byteAt(0);
        byte b1 = data.byteAt(1);
        byte b2 = data.byteAt(2);
        byte b3 = data.byteAt(3);
        boolean debug = false;

        if (b0 != 0x4c || b1 != 0x6f || b2 != (byte)0xa7 || b3 != (byte)0x94)
            return reader;
        XMLEntityHandler.EntityReader declReader = readerFactory.createCharReader(entityHandler, errorReporter, sendCharDataAsCharArray, new InputStreamReader(data, ""CP037""), stringPool);
        int encoding = prescanXMLDeclOrTextDecl(declReader, xmlDecl);
        if (encoding == -1) {
            data.rewind();
            // REVISIT - The document is not well-formed.  There is no encoding, yet the file is
            //   clearly not UTF8.
            throw new UnsupportedEncodingException(null);
        }
        String enc = stringPool.orphanString(encoding).toUpperCase();
        if (""ISO-10646-UCS-2"".equals(enc)) throw new UnsupportedEncodingException(enc);
        if (""ISO-10646-UCS-4"".equals(enc)) throw new UnsupportedEncodingException(enc);
        if (""UTF-16"".equals(enc)) throw new UnsupportedEncodingException(enc);
        String javaencname = MIME2Java.convert(enc);
        if (null == javaencname) {
            if (allowJavaEncodingName) {
                javaencname = enc;
            } else {
                throw new UnsupportedEncodingException(enc);
            }
        }
        try {
            data.rewind();
            reader = readerFactory.createCharReader(entityHandler, errorReporter, sendCharDataAsCharArray, new InputStreamReader(data, javaencname), stringPool);
        } catch (UnsupportedEncodingException e) {
            throw e;
        } catch (Exception e) {
            if( debug == true )
                e.printStackTrace();            // Internal Error
        }
        return reader;
    }
}
"
org/w3c/dom/NamedNodeMap.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  Objects implementing the <code>NamedNodeMap</code> interface are used to 
 * represent collections of nodes that can be accessed by name. Note that 
 * <code>NamedNodeMap</code> does not inherit from <code>NodeList</code> ; 
 * <code>NamedNodeMaps</code> are not maintained in any particular order. 
 * Objects contained in an object implementing <code>NamedNodeMap</code> may 
 * also be accessed by an ordinal index, but this is simply to allow 
 * convenient enumeration of the contents of a <code>NamedNodeMap</code> , 
 * and does not imply that the DOM specifies an order to these Nodes. 
 */
public interface NamedNodeMap {
    /**
     *  Retrieves a node specified by name.
     * @param name  The <code>nodeName</code> of a node to retrieve.
     * @return  A <code>Node</code> (of any type) with the specified 
     *   <code>nodeName</code> , or <code>null</code> if it does not identify 
     *   any node in this map.
     */
    public Node getNamedItem(String name);

    /**
     *  Adds a node using its <code>nodeName</code> attribute. If a node with 
     * that name is already present in this map, it is replaced by the new 
     * one.
     * <br> As the <code>nodeName</code> attribute is used to derive the name 
     * which the node must be stored under, multiple nodes of certain types 
     * (those that have a ""special"" string value) cannot be stored as the 
     * names would clash. This is seen as preferable to allowing nodes to be 
     * aliased.
     * @param arg  A node to store in this map. The node will later be 
     *   accessible using the value of its <code>nodeName</code> attribute.
     * @return  If the new <code>Node</code> replaces an existing node the 
     *   replaced <code>Node</code> is returned, otherwise <code>null</code> 
     *   is returned.
     * @exception DOMException
     *    WRONG_DOCUMENT_ERR: Raised if <code>arg</code> was created from a 
     *   different document than the one that created this map.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.
     *   <br> INUSE_ATTRIBUTE_ERR: Raised if <code>arg</code> is an 
     *   <code>Attr</code> that is already an attribute of another 
     *   <code>Element</code> object. The DOM user must explicitly clone 
     *   <code>Attr</code> nodes to re-use them in other elements.
     */
    public Node setNamedItem(Node arg)
                             throws DOMException;

    /**
     *  Removes a node specified by name. A removed attribute may be known to 
     * have a default value when this map contains the attributes attached to 
     * an element, as returned by the attributes attribute of the 
     * <code>Node</code> interface. If so, an attribute immediately appears 
     * containing the default value as well as the corresponding namespace 
     * URI, local name, and prefix when applicable.
     * @param name  The <code>nodeName</code> of the node to remove.
     * @return  The node removed from this map if a node with such a name 
     *   exists.
     * @exception DOMException
     *    NOT_FOUND_ERR: Raised if there is no node named <code>name</code> 
     *   in this map.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.
     */
    public Node removeNamedItem(String name)
                                throws DOMException;

    /**
     *  Returns the <code>index</code> th item in the map. If 
     * <code>index</code> is greater than or equal to the number of nodes in 
     * this map, this returns <code>null</code> .
     * @param index  Index into this map.
     * @return  The node at the <code>index</code> th position in the map, or 
     *   <code>null</code> if that is not a valid index.
     */
    public Node item(int index);

    /**
     *  The number of nodes in this map. The range of valid child node indices 
     * is <code>0</code> to <code>length-1</code> inclusive. 
     */
    public int getLength();

    /**
     *  Retrieves a node specified by local name and namespace URI. HTML-only 
     * DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the node to retrieve.
     * @param localName  The  local name of the node to retrieve.
     * @return  A <code>Node</code> (of any type) with the specified local 
     *   name and namespace URI, or <code>null</code> if they do not identify 
     *   any node in this map.
     * @since DOM Level 2
     */
    public Node getNamedItemNS(String namespaceURI, 
                               String localName);

    /**
     *  Adds a node using its <code>namespaceURI</code> and 
     * <code>localName</code> . If a node with that namespace URI and that 
     * local name is already present in this map, it is replaced by the new 
     * one.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param arg  A node to store in this map. The node will later be 
     *   accessible using the value of its <code>namespaceURI</code> and 
     *   <code>localName</code> attributes.
     * @return  If the new <code>Node</code> replaces an existing node the 
     *   replaced <code>Node</code> is returned, otherwise <code>null</code> 
     *   is returned.
     * @exception DOMException
     *    WRONG_DOCUMENT_ERR: Raised if <code>arg</code> was created from a 
     *   different document than the one that created this map.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.
     *   <br> INUSE_ATTRIBUTE_ERR: Raised if <code>arg</code> is an 
     *   <code>Attr</code> that is already an attribute of another 
     *   <code>Element</code> object. The DOM user must explicitly clone 
     *   <code>Attr</code> nodes to re-use them in other elements.
     * @since DOM Level 2
     */
    public Node setNamedItemNS(Node arg)
                               throws DOMException;

    /**
     *  Removes a node specified by local name and namespace URI. A removed 
     * attribute may be known to have a default value when this map contains 
     * the attributes attached to an element, as returned by the attributes 
     * attribute of the <code>Node</code> interface. If so, an attribute 
     * immediately appears containing the default value as well as the 
     * corresponding namespace URI, local name, and prefix when applicable.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the node to remove.
     * @param localName  The  local name of the node to remove.
     * @return  The node removed from this map if a node with such a local 
     *   name and namespace URI exists.
     * @exception DOMException
     *    NOT_FOUND_ERR: Raised if there is no node with the specified 
     *   <code>namespaceURI</code> and <code>localName</code> in this map.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.
     * @since DOM Level 2
     */
    public Node removeNamedItemNS(String namespaceURI, 
                                  String localName)
                                  throws DOMException;

}

"
org/apache/xerces/validators/schema/XUtil.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.schema;

import org.apache.xerces.dom.AttrImpl;
import org.apache.xerces.dom.DocumentImpl;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

/**
 * Some useful utility methods.
 */
public class XUtil {

    //
    // Constructors
    //

    /** This class cannot be instantiated. */
    protected XUtil() {}

    //
    // Public static methods
    //

    /**
     * Copies the source tree into the specified place in a destination
     * tree. The source node and its children are appended as children
     * of the destination node.
     * <p>
     * <em>Note:</em> This is an iterative implementation.
     */
    public static void copyInto(Node src, Node dest) throws DOMException {

        // get node factory
        Document factory = dest.getOwnerDocument();
        boolean domimpl = factory instanceof DocumentImpl;

        // placement variables
        Node start  = src;
        Node parent = src;
        Node place  = src;

        // traverse source tree
        while (place != null) {

            // copy this node
            Node node = null;
            int  type = place.getNodeType();
            switch (type) {
                case Node.CDATA_SECTION_NODE: {
                    node = factory.createCDATASection(place.getNodeValue());
                    break;
                }
                case Node.COMMENT_NODE: {
                    node = factory.createComment(place.getNodeValue());
                    break;
                }
                case Node.ELEMENT_NODE: {
                    Element element = factory.createElement(place.getNodeName());
                    node = element;
                    NamedNodeMap attrs  = place.getAttributes();
                    int attrCount = attrs.getLength();
                    for (int i = 0; i < attrCount; i++) {
                        Attr attr = (Attr)attrs.item(i);
                        String attrName = attr.getNodeName();
                        String attrValue = attr.getNodeValue();
                        element.setAttribute(attrName, attrValue);
                        if (domimpl && !attr.getSpecified()) {
                            ((AttrImpl)element.getAttributeNode(attrName)).setSpecified(false);
                        }
                    }
                    break;
                }
                case Node.ENTITY_REFERENCE_NODE: {
                    node = factory.createEntityReference(place.getNodeName());
                    break;
                }
                case Node.PROCESSING_INSTRUCTION_NODE: {
                    node = factory.createProcessingInstruction(place.getNodeName(),
                                                               place.getNodeValue());
                    break;
                }
                case Node.TEXT_NODE: {
                    node = factory.createTextNode(place.getNodeValue());
                    break;
                }
                default: {
                    throw new IllegalArgumentException(""can't copy node type, ""+
                                                       type+"" (""+
                                                       node.getNodeName()+')');
                }
            }
            dest.appendChild(node);

            // iterate over children
            if (place.hasChildNodes()) {
                parent = place;
                place  = place.getFirstChild();
                dest   = node;
            }

            // advance
            else {
                place = place.getNextSibling();
                while (place == null && parent != start) {
                    place  = parent.getNextSibling();
                    parent = parent.getParentNode();
                    dest   = dest.getParentNode();
                }
            }

        }

    } // copyInto(Node,Node)

    /** Finds and returns the first child element node. */
    public static Element getFirstChildElement(Node parent) {

        // search for node
        Node child = parent.getFirstChild();
        while (child != null) {
            if (child.getNodeType() == Node.ELEMENT_NODE) {
                return (Element)child;
            }
            child = child.getNextSibling();
        }

        // not found
        return null;

    } // getFirstChildElement(Node):Element

    /** Finds and returns the next sibling element node. */
    public static Element getNextSiblingElement(Node node) {

        // search for node
        Node sibling = node.getNextSibling();
        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE) {
                return (Element)sibling;
            }
            sibling = sibling.getNextSibling();
        }

        // not found
        return null;

    } // getNextSiblingdElement(Node):Element

    /** Finds and returns the first child node with the given name. */
    public static Element getFirstChildElement(Node parent, String elemName) {

        // search for node
        Node child = parent.getFirstChild();
        while (child != null) {
            if (child.getNodeType() == Node.ELEMENT_NODE) {
                if (child.getNodeName().equals(elemName)) {
                    return (Element)child;
                }
            }
            child = child.getNextSibling();
        }

        // not found
        return null;

    } // getFirstChildElement(Node,String):Element

    /** Finds and returns the next sibling node with the given name. */
    public static Element getNextSiblingElement(Node node, String elemName) {

        // search for node
        Node sibling = node.getNextSibling();
        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE) {
                if (sibling.getNodeName().equals(elemName)) {
                    return (Element)sibling;
                }
            }
            sibling = sibling.getNextSibling();
        }

        // not found
        return null;

    } // getNextSiblingdElement(Node,String):Element

    /** Finds and returns the first child node with the given name. */
    public static Element getFirstChildElement(Node parent, String elemNames[]) {

        // search for node
        Node child = parent.getFirstChild();
        while (child != null) {
            if (child.getNodeType() == Node.ELEMENT_NODE) {
                for (int i = 0; i < elemNames.length; i++) {
                    if (child.getNodeName().equals(elemNames[i])) {
                        return (Element)child;
                    }
                }
            }
            child = child.getNextSibling();
        }

        // not found
        return null;

    } // getFirstChildElement(Node,String[]):Element

    /** Finds and returns the next sibling node with the given name. */
    public static Element getNextSiblingElement(Node node, String elemNames[]) {

        // search for node
        Node sibling = node.getNextSibling();
        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE) {
                for (int i = 0; i < elemNames.length; i++) {
                    if (sibling.getNodeName().equals(elemNames[i])) {
                        return (Element)sibling;
                    }
                }
            }
            sibling = sibling.getNextSibling();
        }

        // not found
        return null;

    } // getNextSiblingdElement(Node,String[]):Element

    /**
     * Finds and returns the first child node with the given name and
     * attribute name, value pair.
     */
    public static Element getFirstChildElement(Node   parent,
                                               String elemName,
                                               String attrName,
                                               String attrValue) {

        // search for node
        Node child = parent.getFirstChild();
        while (child != null) {
            if (child.getNodeType() == Node.ELEMENT_NODE) {
                Element element = (Element)child;
                if (element.getNodeName().equals(elemName) &&
                    element.getAttribute(attrName).equals(attrValue)) {
                    return element;
                }
            }
            child = child.getNextSibling();
        }

        // not found
        return null;

    } // getFirstChildElement(Node,String,String,String):Element

    /**
     * Finds and returns the next sibling node with the given name and
     * attribute name, value pair. Since only elements have attributes,
     * the node returned will be of type Node.ELEMENT_NODE.
     */
    public static Element getNextSiblingElement(Node   node,
                                                String elemName,
                                                String attrName,
                                                String attrValue) {

        // search for node
        Node sibling = node.getNextSibling();
        while (sibling != null) {
            if (sibling.getNodeType() == Node.ELEMENT_NODE) {
                Element element = (Element)sibling;
                if (element.getNodeName().equals(elemName) &&
                    element.getAttribute(attrName).equals(attrValue)) {
                    return element;
                }
            }
            sibling = sibling.getNextSibling();
        }

        // not found
        return null;

    } // getNextSiblingElement(Node,String,String,String):Element

} // class XUtil
"
org/apache/xerces/utils/ImplementationMessages.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.xerces.utils;

import java.util.Locale;
import java.util.ResourceBundle;
import java.util.ListResourceBundle;

/**
 * ImplementationMessages provides messages internal to the parser implementation
 *
 * @version
 */
public class ImplementationMessages implements XMLMessageProvider {
    /**
     * The domain of messages concerning the Xerces implementation.
     */
    public static final String XERCES_IMPLEMENTATION_DOMAIN = ""http://www.apache.org/xml/xerces.html"";

    /**
     *
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }
    /**
     *
     */
    public Locale getLocale() {
        return fLocale;
    }

    /**
     * Creates a message from the specified key and replacement
     * arguments, localized to the given locale.
     *
     * @param locale    The requested locale of the message to be
     *                  created.
     * @param key       The key for the message text.
     * @param args      The arguments to be used as replacement text
     *                  in the message created.
     */
    public String createMessage(Locale locale, int majorCode, int minorCode, Object args[]) {
        boolean throwex = false;
        if (fResourceBundle == null || locale != fLocale) {
            if (locale != null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.ImplementationMessages"", locale);
            if (fResourceBundle == null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.ImplementationMessages"");
        }
        if (majorCode < 0 || majorCode >= fgMessageKeys.length - 1) {
            majorCode = BAD_MAJORCODE;
            throwex = true;
        }
        String msgKey = fgMessageKeys[majorCode];
        String msg = fResourceBundle.getString(msgKey);
        if (args != null) {
            try {
                msg = java.text.MessageFormat.format(msg, args);
            } catch (Exception e) {
                msg = fResourceBundle.getString(fgMessageKeys[FORMAT_FAILED]);
                msg += "" "" + fResourceBundle.getString(msgKey);
            }
        }
        if (throwex) {
            throw new RuntimeException(msg);
        }
        return msg;
    }
    //
    //
    //
    private Locale fLocale = null;
    private ResourceBundle fResourceBundle = null;
    //
    //
    //
    public static final int
        BAD_MAJORCODE = 0,  //  majorCode parameter to createMessage was out of bounds
        ENC4 = 1,           // ""Invalid UTF-8 code. (byte: 0x{0})""
        ENC5 = 2,           // ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1})""
        ENC6 = 3,           // ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2})""
        ENC7 = 4,           // ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2} 0x{3})""
        IO0 = 5,            // ""File, \""{0}\"", not found.""
        VAL_BST = 6,        // ""Invalid ContentSpecNode.NODE_XXX value for binary op CMNode.""
        VAL_CMSI = 7,       // ""Invalid CMStateSet bit index.""
        VAL_CST = 8,        // ""Unknown ContentSpecNode.NODE_XXX value.""
        VAL_LST = 9,        // ""Invalid ContentSpecNode.NODE_XXX value for leaf CMNode.""
        VAL_NIICM = 10,     // ""Only * unary ops should be in the internal content model tree.""
        VAL_NPCD = 11,      // ""PCData found in non-mixed model content.""
        VAL_UST = 12,       // ""Invalid ContentSpecNode.NODE_XXX value for unary op CMNode.""
        VAL_WCGHI = 13,     // ""Input to whatCanGoHere() is inconsistent.""
        INT_DCN = 14,       // ""Internal Error: dataChunk == NULL""
        INT_PCN = 15,       // ""Internal Error: fPreviousChunk == NULL""
        FATAL_ERROR = 16,   // ""Stopping after fatal error: {0}""

        //
        // KEEP THIS AT THE END
        //
        FORMAT_FAILED = 17; // ""Internal Error while formatting error message ""

    //
    // Table of error code to error key strings.
    //
    private static final String[] fgMessageKeys = {
        ""BadMajorCode"",         //  0, ""The majorCode parameter to createMessage was out of bounds.""
        ""ENC4"",                 //  1, ""Invalid UTF-8 code. (byte: 0x{0})""
        ""ENC5"",                 //  2, ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1})""
        ""ENC6"",                 //  3, ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2})""
        ""ENC7"",                 //  4, ""Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2} 0x{3})""
        ""FileNotFound"",         //  5, ""File, \""{0}\"", not found.""
        ""VAL_BST"",              //  6, ""Invalid ContentSpecNode.NODE_XXX value for binary op CMNode.""
        ""VAL_CMSI"",             //  7, ""Invalid CMStateSet bit index.""
        ""VAL_CST"",              //  8, ""Unknown ContentSpecNode.NODE_XXX value.""
        ""VAL_LST"",              //  9, ""Invalid ContentSpecNode.NODE_XXX value for leaf CMNode.""
        ""VAL_NIICM"",            // 10, ""Only * unary ops should be in the internal content model tree.""
        ""VAL_NPCD"",             // 11, ""PCData found in non-mixed model content.""
        ""VAL_UST"",              // 12, ""Invalid ContentSpecNode.NODE_XXX value for unary op CMNode.""
        ""VAL_WCGHI"",            // 13, ""Input to whatCanGoHere() is inconsistent.""
        ""INT_DCN"",              // 14, ""Internal Error: dataChunk == NULL""
        ""INT_PCN"",              // 15, ""Internal Error: fPreviousChunk == NULL""
        ""FatalError"",           // 16, ""Stopping after fatal error: {0}""

        //
        // KEEP THIS AT THE END
        //
        ""FormatFailed"",         // 17, ""An internal error occurred while formatting the following message:""
        null
    };
}
"
org/apache/xerces/dom/events/MutationEventImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.xerces.dom.events;

import org.apache.xerces.dom.*;
import org.w3c.dom.*;
import org.w3c.dom.events.*;

public class MutationEventImpl 
extends org.apache.xerces.dom.events.EventImpl 
implements MutationEvent
{
    Node relatedNode=null;
    String prevValue=null,newValue=null,attrName=null;
    
    // NON-DOM CONSTANTS: Storage efficiency, avoid risk of typos.
    public static final String DOM_SUBTREE_MODIFIED = ""DOMSubtreeModified"";
    public static final String DOM_NODE_INSERTED = ""DOMNodeInserted"";
    public static final String DOM_NODE_REMOVED = ""DOMNodeRemoved"";
    public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = ""DOMNodeRemovedFromDocument"";
    public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = ""DOMNodeInsertedIntoDocument"";
    public static final String DOM_ATTR_MODIFIED = ""DOMAttrModified"";
    public static final String DOM_CHARACTER_DATA_MODIFIED = ""DOMCharacterDataModified"";

    /** @return the name of the Attr which
        changed, for DOMAttrModified events. 
        Undefined for others.
        */
    public String getAttrName()
    {
        return attrName;
    }

    /** @return the new string value of the Attr for DOMAttrModified events, or
        of the CharacterData node for DOMCharDataModifed events.
        Undefined for others.
        */
    public String getNewValue()
    {
        return newValue;
    }

    /** @return the previous string value of the Attr for DOMAttrModified events, or
        of the CharacterData node for DOMCharDataModifed events.
        Undefined for others.
        */
    public String getPrevValue()
    {
        return prevValue;
    }

    /** @return a Node related to this event, other than the target that the
        node was dispatched to. For DOMNodeRemoved, it is the node which
        was removed. 
        No other uses are currently defined.
        */
    public Node getRelatedNode()
    {
        return relatedNode;
    }

    /** Initialize a mutation event, or overwrite the event's current
        settings with new values of the parameters. 
        */
    public void initMutationEvent(String typeArg, boolean canBubbleArg, 
        boolean cancelableArg, Node relatedNodeArg, String prevValueArg, 
        String newValueArg, String attrNameArg)
    {
        relatedNode=relatedNodeArg;
        prevValue=prevValueArg;
        newValue=newValueArg;
        attrName=attrNameArg;
        super.initEvent(typeArg,canBubbleArg,cancelableArg);
    }

}
"
org/w3c/dom/Element.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>Element</code> interface represents an element in an HTML or XML 
 * document. Elements may have attributes associated with them; since the 
 * <code>Element</code> interface inherits from <code>Node</code> , the 
 * generic <code>Node</code> interface attribute <code>attributes</code> may 
 * be used to retrieve the set of all attributes for an element. There are 
 * methods on the <code>Element</code> interface to retrieve either an 
 * <code>Attr</code> object by name or an attribute value by name. In XML, 
 * where an attribute value may contain entity references, an 
 * <code>Attr</code> object should be retrieved to examine the possibly 
 * fairly complex sub-tree representing the attribute value. On the other 
 * hand, in HTML, where all attributes have simple string values, methods to 
 * directly access an attribute value can safely be used as a convenience. In 
 * DOM Level 2, the method <code>normalize</code> is inherited from the 
 * <code>Node</code> interface where it was moved.
 */
public interface Element extends Node {
    /**
     *  The name of the element. For example, in: 
     * <pre>
     * &lt;elementExample id=""demo""&gt; 
     *         ... 
     * &lt;/elementExample&gt; ,</pre>
     *  <code>tagName</code> has 
     * the value <code>""elementExample""</code> . Note that this is 
     * case-preserving in XML, as are all of the operations of the DOM. The 
     * HTML DOM returns the <code>tagName</code> of an HTML element in the 
     * canonical uppercase form, regardless of the case in the  source HTML 
     * document. 
     */
    public String getTagName();

    /**
     *  Retrieves an attribute value by name.
     * @param name  The name of the attribute to retrieve.
     * @return  The <code>Attr</code> value as a string, or the empty string if
     *    that attribute does not have a specified or default value.
     */
    public String getAttribute(String name);

    /**
     *  Adds a new attribute. If an attribute with that name is already 
     * present in the element, its value is changed to be that of the value 
     * parameter. This value is a simple string; it is not parsed as it is 
     * being set. So any markup (such as syntax to be recognized as an entity 
     * reference) is treated as literal text, and needs to be appropriately 
     * escaped by the implementation when it is written out. In order to 
     * assign an attribute value that contains entity references, the user 
     * must create an <code>Attr</code> node plus any <code>Text</code> and 
     * <code>EntityReference</code> nodes, build the appropriate subtree, and 
     * use <code>setAttributeNode</code> to assign it as the value of an 
     * attribute.
     * <br> To set an attribute with a qualified name and namespace URI, use 
     * the <code>setAttributeNS</code> method.
     * @param name  The name of the attribute to create or alter.
     * @param value  Value to set in string form.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void setAttribute(String name, 
                             String value)
                             throws DOMException;

    /**
     *  Removes an attribute by name. If the removed attribute is known to 
     * have a default value, an attribute immediately appears containing the 
     * default value as well as the corresponding namespace URI, local name, 
     * and prefix when applicable.
     * <br> To remove an attribute by local name and namespace URI, use the 
     * <code>removeAttributeNS</code> method.
     * @param name  The name of the attribute to remove.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void removeAttribute(String name)
                                throws DOMException;

    /**
     *  Retrieves an attribute node by name.
     * <br> To retrieve an attribute node by qualified name and namespace URI, 
     * use the <code>getAttributeNodeNS</code> method.
     * @param name  The name (<code>nodeName</code> ) of the attribute to 
     *   retrieve.
     * @return  The <code>Attr</code> node with the specified name (
     *   <code>nodeName</code> ) or <code>null</code> if there is no such 
     *   attribute.
     */
    public Attr getAttributeNode(String name);

    /**
     *  Adds a new attribute node. If an attribute with that name (
     * <code>nodeName</code> ) is already present in the element, it is 
     * replaced by the new one.
     * <br> To add a new attribute node with a qualified name and namespace 
     * URI, use the <code>setAttributeNodeNS</code> method.
     * @param newAttr  The <code>Attr</code> node to add to the attribute list.
     * @return  If the <code>newAttr</code> attribute replaces an existing 
     *   attribute, the replaced <code>Attr</code> node is returned, 
     *   otherwise <code>null</code> is returned.
     * @exception DOMException
     *    WRONG_DOCUMENT_ERR: Raised if <code>newAttr</code> was created from 
     *   a different document than the one that created the element.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> INUSE_ATTRIBUTE_ERR: Raised if <code>newAttr</code> is already 
     *   an attribute of another <code>Element</code> object. The DOM user 
     *   must explicitly clone <code>Attr</code> nodes to re-use them in 
     *   other elements.
     */
    public Attr setAttributeNode(Attr newAttr)
                                 throws DOMException;

    /**
     *  Removes the specified attribute node. If the removed <code>Attr</code> 
     * has a default value it is immediately replaced. The replacing 
     * attribute has the same namespace URI and local name, as well as the 
     * original prefix, when applicable.
     * @param oldAttr  The <code>Attr</code> node to remove from the attribute 
     *   list.
     * @return  The <code>Attr</code> node that was removed.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> NOT_FOUND_ERR: Raised if <code>oldAttr</code> is not an 
     *   attribute of the element.
     */
    public Attr removeAttributeNode(Attr oldAttr)
                                    throws DOMException;

    /**
     *  Returns a <code>NodeList</code> of all descendant elements with a 
     * given tag name, in the order in which they would be encountered in a 
     * preorder traversal of the <code>Element</code> tree.
     * @param name  The name of the tag to match on. The special value ""*"" 
     *   matches all tags.
     * @return  A list of matching <code>Element</code> nodes.
     */
    public NodeList getElementsByTagName(String name);

    /**
     *  Retrieves an attribute value by local name and namespace URI. 
     * HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to retrieve.
     * @param localName  The  local name of the attribute to retrieve.
     * @return  The <code>Attr</code> value as a string, or an 
     *   <code>null</code> if that attribute does not have a specified or 
     *   default value.  This is different from <code>getAttribute</code> 
     *   which never return <code>null</code> . 
     * @since DOM Level 2
     */
    public String getAttributeNS(String namespaceURI, 
                                 String localName);

    /**
     *  Adds a new attribute. If an attribute with the same local name and 
     * namespace URI is already present on the element, its prefix is changed 
     * to be the prefix part of the <code>qualifiedName</code> , and its 
     * value is changed to be the <code>value</code> parameter. This value is 
     * a simple string; it is not parsed as it is being set. So any markup 
     * (such as syntax to be recognized as an entity reference) is treated as 
     * literal text, and needs to be appropriately escaped by the 
     * implementation when it is written out. In order to assign an attribute 
     * value that contains entity references, the user must create an 
     * <code>Attr</code> node plus any <code>Text</code> and 
     * <code>EntityReference</code> nodes, build the appropriate subtree, and 
     * use <code>setAttributeNodeNS</code> or <code>setAttributeNode</code> to
     *  assign it as the value of an attribute.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to create or 
     *   alter.
     * @param qualifiedName  The  qualified name of the attribute to create or 
     *   alter.
     * @param value  The value to set in string form.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed, if the <code>qualifiedName</code> has a prefix and the 
     *   <code>namespaceURI</code> is <code>null</code> or an empty string, 
     *   if the <code>qualifiedName</code> has a prefix that is ""xml"" and the 
     *   <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/XML/1998/namespace"", if the 
     *   <code>qualifiedName</code> has a prefix that is ""xmlns"" and the 
     *   <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/2000/xmlns/"", or if the <code>qualifiedName</code>
     *    is ""xmlns"" and the <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/2000/xmlns/"".
     * @since DOM Level 2
     */
    public void setAttributeNS(String namespaceURI, 
                               String qualifiedName, 
                               String value)
                               throws DOMException;

    /**
     *  Removes an attribute by local name and namespace URI. If the removed 
     * attribute has a default value it is immediately replaced. The 
     * replacing attribute has the same namespace URI and local name, as well 
     * as the original prefix.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to remove.
     * @param localName  The  local name of the attribute to remove.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     * @since DOM Level 2
     */
    public void removeAttributeNS(String namespaceURI, 
                                  String localName)
                                  throws DOMException;

    /**
     *  Retrieves an <code>Attr</code> node by local name and namespace URI. 
     * HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to retrieve.
     * @param localName  The  local name of the attribute to retrieve.
     * @return  The <code>Attr</code> node with the specified attribute local 
     *   name and namespace URI or <code>null</code> if there is no such 
     *   attribute.
     * @since DOM Level 2
     */
    public Attr getAttributeNodeNS(String namespaceURI, 
                                   String localName);

    /**
     *  Adds a new attribute. If an attribute with that local name and that 
     * namespace URI is already present in the element, it is replaced by the 
     * new one.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param newAttr  The <code>Attr</code> node to add to the attribute list.
     * @return  If the <code>newAttr</code> attribute replaces an existing 
     *   attribute with the same  local name and  namespace URI , the 
     *   replaced <code>Attr</code> node is returned, otherwise 
     *   <code>null</code> is returned.
     * @exception DOMException
     *    WRONG_DOCUMENT_ERR: Raised if <code>newAttr</code> was created from 
     *   a different document than the one that created the element.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br> INUSE_ATTRIBUTE_ERR: Raised if <code>newAttr</code> is already 
     *   an attribute of another <code>Element</code> object. The DOM user 
     *   must explicitly clone <code>Attr</code> nodes to re-use them in 
     *   other elements.
     * @since DOM Level 2
     */
    public Attr setAttributeNodeNS(Attr newAttr)
                                   throws DOMException;

    /**
     *  Returns a <code>NodeList</code> of all the <code>Elements</code> with 
     * a given local name and namespace URI in the order in which they would 
     * be encountered in a preorder traversal of the <code>Document</code> 
     * tree, starting from this node.
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the elements to match on. 
     *   The special value ""*"" matches all namespaces.
     * @param localName  The  local name of the elements to match on. The 
     *   special value ""*"" matches all local names.
     * @return  A new <code>NodeList</code> object containing all the matched 
     *   <code>Elements</code> .
     * @since DOM Level 2
     */
    public NodeList getElementsByTagNameNS(String namespaceURI, 
                                           String localName);

    /**
     *  Returns <code>true</code> when an attribute with a given name is 
     * specified on this element or has a default value, <code>false</code> 
     * otherwise.
     * @param name  The name of the attribute to look for.
     * @return <code>true</code> if an attribute with the given name is 
     *   specified on this element or has a default value, <code>false</code> 
     *   otherwise.
     * @since DOM Level 2
     */
    public boolean hasAttribute(String name);

    /**
     *  Returns <code>true</code> when an attribute with a given local name 
     * and namespace URI is specified on this element or has a default value, 
     * <code>false</code> otherwise. HTML-only DOM implementations do not 
     * need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to look for.
     * @param localName  The  local name of the attribute to look for.
     * @return <code>true</code> if an attribute with the given local name and 
     *   namespace URI is specified or has a default value on this element, 
     *   <code>false</code> otherwise.
     * @since DOM Level 2
     */
    public boolean hasAttributeNS(String namespaceURI, 
                                  String localName);

}

"
org/xml/sax/SAXNotSupportedException.java,true,"// SAXNotSupportedException.java - unsupported feature or value.
// Written by David Megginson, sax@megginson.com
// NO WARRANTY!  This class is in the Public Domain.

// $Id: SAXNotSupportedException.java,v 1.5 2000/05/05 17:47:39 david Exp $


package org.xml.sax;

/**
 * Exception class for an unsupported operation.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>An XMLReader will throw this exception when it recognizes a
 * feature or property identifier, but cannot perform the requested
 * operation (setting a state or value).  Other SAX2 applications and
 * extensions may use this class for similar purposes.</p>
 *
 * @since SAX 2.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.SAXNotRecognizedException 
 */
public class SAXNotSupportedException extends SAXException
{

    /**
     * Construct a new exception with the given message.
     *
     * @param message The text message of the exception.
     */
    public SAXNotSupportedException (String message)
    {
	super(message);
    }

}

// end of SAXNotSupportedException.java
"
org/xml/sax/Parser.java,true,"// SAX parser interface.
// No warranty; no copyright -- use this as you will.
// $Id: Parser.java,v 1.5 2000/05/05 17:47:07 david Exp $

package org.xml.sax;

import java.io.IOException;
import java.util.Locale;


/**
 * Basic interface for SAX (Simple API for XML) parsers.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This was the main event supplier interface for SAX1; it has
 * been replaced in SAX2 by {@link org.xml.sax.XMLReader XMLReader},
 * which includes Namespace support and sophisticated configurability
 * and extensibility.</p>
 *
 * <p>All SAX1 parsers must implement this basic interface: it allows
 * applications to register handlers for different types of events
 * and to initiate a parse from a URI, or a character stream.</p>
 *
 * <p>All SAX1 parsers must also implement a zero-argument constructor
 * (though other constructors are also allowed).</p>
 *
 * <p>SAX1 parsers are reusable but not re-entrant: the application
 * may reuse a parser object (possibly with a different input source)
 * once the first parse has completed successfully, but it may not
 * invoke the parse() methods recursively within a parse.</p>
 *
 * @deprecated This interface has been replaced by the SAX2
 *             {@link org.xml.sax.XMLReader XMLReader}
 *             interface, which includes Namespace support.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.EntityResolver
 * @see org.xml.sax.DTDHandler
 * @see org.xml.sax.DocumentHandler
 * @see org.xml.sax.ErrorHandler
 * @see org.xml.sax.HandlerBase
 * @see org.xml.sax.InputSource
 */
public interface Parser 
{
    
    /**
     * Allow an application to request a locale for errors and warnings.
     *
     * <p>SAX parsers are not required to provide localisation for errors
     * and warnings; if they cannot support the requested locale,
     * however, they must throw a SAX exception.  Applications may
     * not request a locale change in the middle of a parse.</p>
     *
     * @param locale A Java Locale object.
     * @exception org.xml.sax.SAXException Throws an exception
     *            (using the previous or default locale) if the 
     *            requested locale is not supported.
     * @see org.xml.sax.SAXException
     * @see org.xml.sax.SAXParseException
     */
    public abstract void setLocale (Locale locale)
	throws SAXException;
    
    
    /**
     * Allow an application to register a custom entity resolver.
     *
     * <p>If the application does not register an entity resolver, the
     * SAX parser will resolve system identifiers and open connections
     * to entities itself (this is the default behaviour implemented in
     * HandlerBase).</p>
     *
     * <p>Applications may register a new or different entity resolver
     * in the middle of a parse, and the SAX parser must begin using
     * the new resolver immediately.</p>
     *
     * @param resolver The object for resolving entities.
     * @see EntityResolver
     * @see HandlerBase
     */
    public abstract void setEntityResolver (EntityResolver resolver);
    
    
    /**
     * Allow an application to register a DTD event handler.
     *
     * <p>If the application does not register a DTD handler, all DTD
     * events reported by the SAX parser will be silently
     * ignored (this is the default behaviour implemented by
     * HandlerBase).</p>
     *
     * <p>Applications may register a new or different
     * handler in the middle of a parse, and the SAX parser must
     * begin using the new handler immediately.</p>
     *
     * @param handler The DTD handler.
     * @see DTDHandler
     * @see HandlerBase
     */
    public abstract void setDTDHandler (DTDHandler handler);
    
    
    /**
     * Allow an application to register a document event handler.
     *
     * <p>If the application does not register a document handler, all
     * document events reported by the SAX parser will be silently
     * ignored (this is the default behaviour implemented by
     * HandlerBase).</p>
     *
     * <p>Applications may register a new or different handler in the
     * middle of a parse, and the SAX parser must begin using the new
     * handler immediately.</p>
     *
     * @param handler The document handler.
     * @see DocumentHandler
     * @see HandlerBase
     */
    public abstract void setDocumentHandler (DocumentHandler handler);
    
    
    /**
     * Allow an application to register an error event handler.
     *
     * <p>If the application does not register an error event handler,
     * all error events reported by the SAX parser will be silently
     * ignored, except for fatalError, which will throw a SAXException
     * (this is the default behaviour implemented by HandlerBase).</p>
     *
     * <p>Applications may register a new or different handler in the
     * middle of a parse, and the SAX parser must begin using the new
     * handler immediately.</p>
     *
     * @param handler The error handler.
     * @see ErrorHandler
     * @see SAXException
     * @see HandlerBase
     */
    public abstract void setErrorHandler (ErrorHandler handler);
    
    
    /**
     * Parse an XML document.
     *
     * <p>The application can use this method to instruct the SAX parser
     * to begin parsing an XML document from any valid input
     * source (a character stream, a byte stream, or a URI).</p>
     *
     * <p>Applications may not invoke this method while a parse is in
     * progress (they should create a new Parser instead for each
     * additional XML document).  Once a parse is complete, an
     * application may reuse the same Parser object, possibly with a
     * different input source.</p>
     *
     * @param source The input source for the top-level of the
     *        XML document.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException An IO exception from the parser,
     *            possibly from a byte stream or character stream
     *            supplied by the application.
     * @see org.xml.sax.InputSource
     * @see #parse(java.lang.String)
     * @see #setEntityResolver
     * @see #setDTDHandler
     * @see #setDocumentHandler
     * @see #setErrorHandler
     */
    public abstract void parse (InputSource source)
	throws SAXException, IOException;
    
    
    /**
     * Parse an XML document from a system identifier (URI).
     *
     * <p>This method is a shortcut for the common case of reading a
     * document from a system identifier.  It is the exact
     * equivalent of the following:</p>
     *
     * <pre>
     * parse(new InputSource(systemId));
     * </pre>
     *
     * <p>If the system identifier is a URL, it must be fully resolved
     * by the application before it is passed to the parser.</p>
     *
     * @param systemId The system identifier (URI).
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException An IO exception from the parser,
     *            possibly from a byte stream or character stream
     *            supplied by the application.
     * @see #parse(org.xml.sax.InputSource)
     */
    public abstract void parse (String systemId)
	throws SAXException, IOException;
    
}

// end of Parser.java
"
org/w3c/dom/Document.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>Document</code> interface represents the entire HTML or XML 
 * document. Conceptually, it is the root of the document tree, and provides 
 * the  primary access to the document's data.
 * <p> Since elements, text nodes, comments, processing instructions, etc. 
 * cannot exist outside the context of a <code>Document</code> , the 
 * <code>Document</code> interface also contains the factory methods needed 
 * to create these objects. The <code>Node</code> objects created have a 
 * <code>ownerDocument</code> attribute which associates them with the 
 * <code>Document</code> within whose context they were created.
 */
public interface Document extends Node {
    /**
     *  The Document Type Declaration (see <code>DocumentType</code> ) 
     * associated with this document. For HTML documents as well as XML 
     * documents without a document type declaration this returns 
     * <code>null</code> . The DOM Level 2 does not support editing the 
     * Document Type Declaration, therefore <code>docType</code> cannot be 
     * altered in any way, including through the use of methods, such as 
     * <code>insertNode</code> or <code>removeNode</code> , inherited from 
     * <code>Node</code> .
     */
    public DocumentType getDoctype();

    /**
     *  The <code>DOMImplementation</code> object that handles this document. 
     * A DOM application may use objects from multiple  implementations.
     */
    public DOMImplementation getImplementation();

    /**
     *  This is a convenience attribute that allows direct access to the child 
     * node that is the root element of  the document. For HTML documents, 
     * this is the element with the tagName ""HTML"".
     */
    public Element getDocumentElement();

    /**
     *  Creates an element of the type specified. Note that the instance 
     * returned implements the <code>Element</code> interface, so attributes 
     * can be specified directly  on the returned object.
     * <br> In addition, if there are known attributes with default values, 
     * <code>Attr</code> nodes representing them are automatically created and
     *  attached to the element.
     * <br> To create an element with a qualified name and namespace URI, use 
     * the <code>createElementNS</code> method.
     * @param tagName  The name of the element type to instantiate. For XML, 
     *   this is case-sensitive. For HTML, the  <code>tagName</code> 
     *   parameter may be provided in any case,  but it must be mapped to the 
     *   canonical uppercase form by  the DOM implementation. 
     * @return  A new <code>Element</code> object with the 
     *   <code>nodeName</code> attribute set to <code>tagName</code> , and 
     *   <code>localName</code> , <code>prefix</code> , and 
     *   <code>namespaceURI</code> set to <code>null</code> .
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     */
    public Element createElement(String tagName)
                                 throws DOMException;

    /**
     *  Creates an empty <code>DocumentFragment</code> object. 
     * @return  A new <code>DocumentFragment</code> .
     */
    public DocumentFragment createDocumentFragment();

    /**
     *  Creates a <code>Text</code> node given the specified string.
     * @param data  The data for the node.
     * @return  The new <code>Text</code> object.
     */
    public Text createTextNode(String data);

    /**
     *  Creates a <code>Comment</code> node given the specified string.
     * @param data  The data for the node.
     * @return  The new <code>Comment</code> object.
     */
    public Comment createComment(String data);

    /**
     *  Creates a <code>CDATASection</code> node whose value  is the specified 
     * string.
     * @param data  The data for the <code>CDATASection</code> contents.
     * @return  The new <code>CDATASection</code> object.
     * @exception DOMException
     *    NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     */
    public CDATASection createCDATASection(String data)
                                           throws DOMException;

    /**
     *  Creates a <code>ProcessingInstruction</code> node given the specified 
     * name and data strings.
     * @param target  The target part of the processing instruction.
     * @param data  The data for the node.
     * @return  The new <code>ProcessingInstruction</code> object.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified target contains an 
     *   illegal character.
     *   <br> NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     */
    public ProcessingInstruction createProcessingInstruction(String target, 
                                                             String data)
                                                             throws DOMException;

    /**
     *  Creates an <code>Attr</code> of the given name. Note that the 
     * <code>Attr</code> instance can then be set on an <code>Element</code> 
     * using the <code>setAttribute</code> method. 
     * <br> To create an attribute with a qualified name and namespace URI, use
     *  the <code>createAttributeNS</code> method.
     * @param name  The name of the attribute.
     * @return  A new <code>Attr</code> object with the <code>nodeName</code> 
     *   attribute set to <code>name</code> , and <code>localName</code> , 
     *   <code>prefix</code> , and <code>namespaceURI</code> set to 
     *   <code>null</code> .
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     */
    public Attr createAttribute(String name)
                                throws DOMException;

    /**
     *  Creates an <code>EntityReference</code> object. In addition, if the 
     * referenced entity is known, the child list of the 
     * <code>EntityReference</code> node is made the same as that of the 
     * corresponding <code>Entity</code> node. If any descendant of the 
     * <code>Entity</code> node has an unbound  namespace prefix , the 
     * corresponding descendant of the created <code>EntityReference</code> 
     * node is also unbound; (its <code>namespaceURI</code> is 
     * <code>null</code> ). The DOM Level 2 does not support any mechanism to 
     * resolve namespace prefixes.
     * @param name  The name of the entity to reference. 
     * @return  The new <code>EntityReference</code> object.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     *   <br> NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     */
    public EntityReference createEntityReference(String name)
                                                 throws DOMException;

    /**
     *  Returns a <code>NodeList</code> of all the <code>Elements</code> with 
     * a given tag name in the order in which they would be encountered in a 
     * preorder traversal of the <code>Document</code> tree. 
     * @param tagname  The name of the tag to match on. The special value ""*"" 
     *   matches all tags.
     * @return  A new <code>NodeList</code> object containing all the matched 
     *   <code>Elements</code> .
     */
    public NodeList getElementsByTagName(String tagname);

    /**
     *  Imports a node from another document to this document. The returned 
     * node has no parent; (<code>parentNode</code> is <code>null</code> ). 
     * The source node is not altered or removed from the original document; 
     * this method creates a new copy of the source node.
     * <br> For all nodes, importing a node creates a node object owned by the 
     * importing document, with attribute values identical to the source 
     * node's <code>nodeName</code> and <code>nodeType</code> , plus the 
     * attributes related to namespaces (<code>prefix</code> , 
     * <code>localName</code> , and <code>namespaceURI</code> ). As in the 
     * <code>cloneNode</code> operation on a <code>Node</code> , the source 
     * node is not altered.
     * <br> Additional information is copied as appropriate to the 
     * <code>nodeType</code> , attempting to mirror the behavior expected if a
     *  fragment of XML or HTML source was copied from one document to 
     * another, recognizing that the two documents may have different DTDs in 
     * the XML case. The following list describes the specifics for every 
     * type of node. 
     * <dl>
     * <dt> ELEMENT_NODE</dt>
     * <dd> Specified attribute nodes of the source 
     * element are imported, and the generated <code>Attr</code> nodes are 
     * attached to the generated <code>Element</code> . Default attributes 
     * are  not copied, though if the document being imported into defines 
     * default attributes for this element name, those are assigned. If the 
     * <code>importNode</code> <code>deep</code> parameter was set to 
     * <code>true</code> , the descendants of the source element will be 
     * recursively imported and the resulting nodes reassembled to form the 
     * corresponding subtree.</dd>
     * <dt> ATTRIBUTE_NODE</dt>
     * <dd> The <code>specified</code> flag 
     * is set to <code>true</code> on the generated <code>Attr</code> . The 
     * descendants of the source <code>Attr</code> are recursively imported 
     * and the resulting nodes reassembled to form the corresponding subtree. 
     * Note that the <code>deep</code> parameter does not apply to 
     * <code>Attr</code> nodes; they always carry their children with them 
     * when imported.</dd>
     * <dt> TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</dt>
     * <dd> These three 
     * types of nodes inheriting from <code>CharacterData</code> copy their 
     * <code>data</code> and <code>length</code> attributes from those of the 
     * source node.</dd>
     * <dt> ENTITY_REFERENCE_NODE</dt>
     * <dd> Only the 
     * <code>EntityReference</code> itself is copied, even if a 
     * <code>deep</code> import is requested, since the source and 
     * destination documents might have defined the entity differently. If 
     * the document being imported into provides a definition for this entity 
     * name, its value is assigned.</dd>
     * <dt> ENTITY_NODE</dt>
     * <dd><code>Entity</code> nodes can 
     * be imported, however in the current release of the DOM the 
     * <code>DocumentType</code> is readonly. Ability to add these imported 
     * nodes to a <code>DocumentType</code> will be considered for addition 
     * to a future release of the DOM. On import, the <code>publicId</code> , 
     * <code>systemId</code> , and <code>notationName</code> attributes are 
     * copied. If a <code>deep</code> import is requested, the descendants of 
     * the the source <code>Entity</code> is recursively imported and the 
     * resulting nodes reassembled to form the corresponding subtree.</dd>
     * <dt> 
     * PROCESSING_INSTRUCTION_NODE</dt>
     * <dd> The imported node copies its 
     * <code>target</code> and <code>data</code> values from those of the 
     * source node.</dd>
     * <dt> DOCUMENT_NODE</dt>
     * <dd><code>Document</code> nodes cannot be 
     * imported.</dd>
     * <dt> DOCUMENT_TYPE_NODE</dt>
     * <dd><code>DocumentType</code> nodes cannot be 
     * imported.</dd>
     * <dt> DOCUMENT_FRAGMENT_NODE</dt>
     * <dd> If the <code>deep</code> option was 
     * set <code>true</code> , the descendants of the source element will be 
     * recursively imported and the resulting nodes reassembled to form the 
     * corresponding subtree. Otherwise, this simply generates an empty 
     * <code>DocumentFragment</code> .</dd>
     * <dt> NOTATION_NODE</dt>
     * <dd><code>Notation</code> 
     * nodes can be imported, however in the current release of the DOM the 
     * <code>DocumentType</code> is readonly. Ability to add these imported 
     * nodes to a <code>DocumentType</code> will be considered for addition 
     * to a future release of the DOM. On import, the <code>publicId</code> 
     * and <code>systemId</code> attributes are copied. Note that the 
     * <code>deep</code> parameter does not apply to <code>Notation</code> 
     * nodes since they never have any children.</dd>
     * </dl> 
     * @param importedNode  The node to import.
     * @param deep  If <code>true</code> , recursively import the subtree 
     *   under the specified node; if <code>false</code> , import only the 
     *   node itself, as explained above. This does not apply to 
     *   <code>Attr</code> , <code>EntityReference</code> , and 
     *   <code>Notation</code> nodes.
     * @return  The imported node that belongs to this <code>Document</code> .
     * @exception DOMException
     *    NOT_SUPPORTED_ERR: Raised if the type of node being imported is not 
     *   supported.
     * @since DOM Level 2
     */
    public Node importNode(Node importedNode, 
                           boolean deep)
                           throws DOMException;

    /**
     *  Creates an element of the given qualified name and namespace URI. 
     * HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the element to create.
     * @param qualifiedName  The  qualified name of the element type to 
     *   instantiate.
     * @return  A new <code>Element</code> object with the following 
     *   attributes: Attribute Value<code>Node.nodeName</code>
     *   <code>qualifiedName</code><code>Node.namespaceURI</code>
     *   <code>namespaceURI</code><code>Node.prefix</code> prefix, extracted 
     *   from <code>qualifiedName</code> , or <code>null</code> if there is no
     *    prefix<code>Node.localName</code> local name , extracted from 
     *   <code>qualifiedName</code><code>Element.tagName</code>
     *   <code>qualifiedName</code>
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character.
     *   <br> NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed, if the <code>qualifiedName</code> has a prefix and the 
     *   <code>namespaceURI</code> is <code>null</code> or an empty string, 
     *   or if the <code>qualifiedName</code> has a prefix that is ""xml"" and 
     *   the <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/XML/1998/namespace""  .
     * @since DOM Level 2
     */
    public Element createElementNS(String namespaceURI, 
                                   String qualifiedName)
                                   throws DOMException;

    /**
     *  Creates an attribute of the given qualified name and namespace URI. 
     * HTML-only DOM implementations do not need to implement this method.
     * @param namespaceURI  The  namespace URI of the attribute to create.
     * @param qualifiedName  The  qualified name of the attribute to 
     *   instantiate.
     * @return  A new <code>Attr</code> object with the following attributes: 
     *   Attribute Value<code>Node.nodeName</code> qualifiedName
     *   <code>Node.namespaceURI</code><code>namespaceURI</code>
     *   <code>Node.prefix</code> prefix, extracted from 
     *   <code>qualifiedName</code> , or <code>null</code> if there is no 
     *   prefix<code>Node.localName</code> local name , extracted from 
     *   <code>qualifiedName</code><code>Attr.name</code>
     *   <code>qualifiedName</code>
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character.
     *   <br> NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed, if the <code>qualifiedName</code> has a prefix and the 
     *   <code>namespaceURI</code> is <code>null</code> or an empty string, 
     *   if the <code>qualifiedName</code> has a prefix that is ""xml"" and the 
     *   <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/XML/1998/namespace"", if the 
     *   <code>qualifiedName</code> has a prefix that is ""xmlns"" and the 
     *   <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/2000/xmlns/"", or if the <code>qualifiedName</code>
     *    is ""xmlns"" and the <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/2000/xmlns/"".
     * @since DOM Level 2
     */
    public Attr createAttributeNS(String namespaceURI, 
                                  String qualifiedName)
                                  throws DOMException;

    /**
     *  Returns a <code>NodeList</code> of all the <code>Elements</code> with 
     * a given  local name and namespace URI in the order in which they would 
     * be encountered in a preorder traversal of the <code>Document</code> 
     * tree.
     * @param namespaceURI  The  namespace URI of the elements to match on. 
     *   The special value ""*"" matches all namespaces.
     * @param localName  The  local name of the elements to match on. The 
     *   special value ""*"" matches all local names.
     * @return  A new <code>NodeList</code> object containing all the matched 
     *   <code>Elements</code> .
     * @since DOM Level 2
     */
    public NodeList getElementsByTagNameNS(String namespaceURI, 
                                           String localName);

    /**
     *  Returns the <code>Element</code> whose <code>ID</code> is given by 
     * <code>elementId</code> . If no such element exists, returns 
     * <code>null</code> . Behavior is not defined if more than one element 
     * has this <code>ID</code> .  The DOM implementation must have 
     * information that says which attributes are of type ID. Attributes with 
     * the name ""ID"" are not of type ID unless so defined. Implementations 
     * that do not know whether attributes are of type ID or not are expected 
     * to return <code>null</code> .
     * @param elementId  The unique <code>id</code> value for an element.
     * @return  The matching element.
     * @since DOM Level 2
     */
    public Element getElementById(String elementId);

}

"
org/apache/xerces/readers/UTF8Reader.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.SymbolCache;
import org.apache.xerces.utils.UTF8DataChunk;
import org.apache.xerces.utils.XMLCharacterProperties;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.LocatorImpl;
import java.io.InputStream;
import java.util.Vector;

/**
 * This is the primary reader used for UTF-8 encoded byte streams.
 * <p>
 * This reader processes requests from the scanners against the
 * underlying UTF-8 byte stream, avoiding when possible any up-front
 * transcoding.  When the StringPool handle interfaces are used,
 * the information in the data stream will be added to the string
 * pool and lazy-evaluated until asked for.
 * <p>
 * We use the SymbolCache to match expected names (element types in
 * end tags) and walk the data structures of that class directly.
 * <p>
 * There is a significant amount of hand-inlining and some blatant
 * voilation of good object oriented programming rules, ignoring
 * boundaries of modularity, etc., in the name of good performance.
 * <p>
 * There are also some places where the code here frequently crashes
 * the SUN java runtime compiler (JIT) and the code here has been
 * carefully ""crafted"" to avoid those problems.
 * 
 * @version $Id$
 */
final class UTF8Reader extends XMLEntityReader {
    //
    //
    //
    private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false;
    private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true;
    //
    //
    //
    public UTF8Reader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, InputStream dataStream, StringPool stringPool) throws Exception {
        super(entityHandler, errorReporter, sendCharDataAsCharArray);
        fInputStream = dataStream;
        fStringPool = stringPool;
        fCharArrayRange = fStringPool.createCharArrayRange();
        fCurrentChunk = UTF8DataChunk.createChunk(fStringPool, null);
        fillCurrentChunk();
    }
    /**
     *
     */
    public int addString(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addString(offset, length);
    }
    /**
     *
     */
    public int addSymbol(int offset, int length) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addSymbol(offset, length, 0);
    }
    /**
     *
     */
    private int addSymbol(int offset, int length, int hashcode) {
        if (length == 0)
            return 0;
        return fCurrentChunk.addSymbol(offset, length, hashcode);
    }
    /**
     *
     */
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        fCurrentChunk.append(charBuffer, offset, length);
    }
    //
    //
    //
    private int slowLoadNextByte()  throws Exception {
        fCallClearPreviousChunk = true;
        if (fCurrentChunk.nextChunk() != null) {
            fCurrentChunk = fCurrentChunk.nextChunk();
            fCurrentIndex = 0;
            fMostRecentData = fCurrentChunk.toByteArray();
            return (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
        } else {
            fCurrentChunk = UTF8DataChunk.createChunk(fStringPool, fCurrentChunk);
            return fillCurrentChunk();
        }
    }
    private int loadNextByte() throws Exception {
        fCurrentOffset++;
        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
            fCurrentIndex++;
            try {
                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                return fMostRecentByte;
            } catch (ArrayIndexOutOfBoundsException ex) {
                return slowLoadNextByte();
            }
        } else {
            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                return slowLoadNextByte();
            else
                return (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
        }
    }
    //
    //
    //
    private boolean atEOF(int offset) {
        return (offset > fLength);
    }
    //
    //
    //
    public XMLEntityHandler.EntityReader changeReaders() throws Exception {
        XMLEntityHandler.EntityReader nextReader = super.changeReaders();
        fCurrentChunk.releaseChunk();
        fCurrentChunk = null;
        fMostRecentData = null;
        fMostRecentByte = 0;
        return nextReader;
    }
    //
    //
    //
    public boolean lookingAtChar(char ch, boolean skipPastChar) throws Exception {
        int b0 = fMostRecentByte;
        if (b0 != ch) {
            if (b0 == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtChar(ch, skipPastChar);
                }
            }
            if (ch == 0x0A && b0 == 0x0D) {
                if (skipPastChar) {
                    fCarriageReturnCounter++;
                    fCharacterCounter = 1;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                b0 = fMostRecentByte;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    if (b0 == 0x0A) {
                        fLinefeedCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    slowLoadNextByte();
                                else
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            }
                        }
                    }
                }
                return true;
            }
            return false;
        }
        if (ch == 0x0D)
            return false;
        if (skipPastChar) {
            fCharacterCounter++;
            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                loadNextByte();
            } else {
                fCurrentOffset++;
                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                    fCurrentIndex++;
                    try {
                        fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        slowLoadNextByte();
                    }
                } else {
                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                        slowLoadNextByte();
                    else
                        fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                }
            }
        }
        return true;
    }
    //
    //
    //
    public boolean lookingAtValidChar(boolean skipPastChar) throws Exception {
        int b0 = fMostRecentByte;
        if (b0 < 0x80) {  // 0xxxxxxx
            if (b0 >= 0x20 || b0 == 0x09) {
                if (skipPastChar) {
                    fCharacterCounter++;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                slowLoadNextByte();
                            else
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                        }
                    }
                }
                return true;
            }
            if (b0 == 0x0A) {
                if (skipPastChar) {
                    fLinefeedCounter++;
                    fCharacterCounter = 1;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                slowLoadNextByte();
                            else
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                        }
                    }
                }
                return true;
            }
            if (b0 == 0x0D) {
                if (skipPastChar) {
                    fCarriageReturnCounter++;
                    fCharacterCounter = 1;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                b0 = fMostRecentByte;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    if (b0 == 0x0A) {
                        fLinefeedCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    slowLoadNextByte();
                                else
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            }
                        }
                    }
                }
                return true;
            }
            if (b0 == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtValidChar(skipPastChar);
                }
            }
            return false;
        }
        //
        // REVISIT - optimize this with in-buffer lookahead.
        //
        UTF8DataChunk saveChunk = fCurrentChunk;
        int saveIndex = fCurrentIndex;
        int saveOffset = fCurrentOffset;
        int b1 = loadNextByte();
        if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx (0x80 to 0x7ff)
            if (skipPastChar) {
                fCharacterCounter++;
                loadNextByte();
            } else {
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
            }
            return true; // [#x20-#xD7FF]
        }
        int b2 = loadNextByte();
        if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
            // ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
            // if (!((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE))
            // if ((ch <= 0xD7FF) || (ch >= 0xE000 && ch <= 0xFFFD))
            boolean result = false;
            if (!((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE))) { // [#x20-#xD7FF] | [#xE000-#xFFFD]
                if (skipPastChar) {
                    fCharacterCounter++;
                    loadNextByte();
                    return true;
                }
                result = true;
            }
            fCurrentChunk = saveChunk;
            fCurrentIndex = saveIndex;
            fCurrentOffset = saveOffset;
            fMostRecentData = saveChunk.toByteArray();
            fMostRecentByte = b0;
            return result;
        }
        int b3 = loadNextByte();  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
        // ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3); // u uuuu zzzz yyyy yyxx xxxx (0x10000 to 0x1ffff)
        // if (ch >= 0x110000)
        boolean result = false;
        if (!(b0 > 0xF4 || (b0 == 0xF4 && b1 >= 0x90))) { // [#x10000-#x10FFFF]
            if (skipPastChar) {
                fCharacterCounter++;
                loadNextByte();
                return true;
            }
            result = true;
        }
        fCurrentChunk = saveChunk;
        fCurrentIndex = saveIndex;
        fCurrentOffset = saveOffset;
        fMostRecentData = saveChunk.toByteArray();
        fMostRecentByte = b0;
        return result;
    }
    //
    //
    //
    public boolean lookingAtSpace(boolean skipPastChar) throws Exception {
        int ch = fMostRecentByte;
        if (ch > 0x20)
            return false;
        if (ch == 0x20 || ch == 0x09) {
            if (!skipPastChar)
                return true;
            fCharacterCounter++;
        } else if (ch == 0x0A) {
            if (!skipPastChar)
                return true;
            fLinefeedCounter++;
            fCharacterCounter = 1;
        } else if (ch == 0x0D) {
            if (!skipPastChar)
                return true;
            fCarriageReturnCounter++;
            fCharacterCounter = 1;
            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                ch = loadNextByte();
            } else {
                fCurrentOffset++;
                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                    fCurrentIndex++;
                    try {
                        fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                        ch = fMostRecentByte;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        ch = slowLoadNextByte();
                    }
                } else {
                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                        ch = slowLoadNextByte();
                    else
                        ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                }
            }
            if (ch != 0x0A)
                return true;
            fLinefeedCounter++;
        } else {
            if (ch == 0) { // REVISIT - should we be checking this here ?
                if (atEOF(fCurrentOffset + 1)) {
                    return changeReaders().lookingAtSpace(skipPastChar);
                }
            }
            return false;
        }
        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
            loadNextByte();
        } else {
            fCurrentOffset++;
            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                fCurrentIndex++;
                try {
                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                } catch (ArrayIndexOutOfBoundsException ex) {
                    slowLoadNextByte();
                }
            } else {
                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                    slowLoadNextByte();
                else
                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
            }
        }
        return true;
    }
    //
    //
    //
    public void skipToChar(char ch) throws Exception {
        //
        // REVISIT - this will skip invalid characters without reporting them.
        //
        int b0 = fMostRecentByte;
        while (true) {
            if (b0 == ch) // ch will always be an ascii character
                return;
            if (b0 == 0) {
                if (atEOF(fCurrentOffset + 1)) {
                    changeReaders().skipToChar(ch);
                    return;
                }
                fCharacterCounter++;
            } else if (b0 == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (b0 == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
                b0 = loadNextByte();
                if (b0 != 0x0A)
                    continue;
                fLinefeedCounter++;
            } else if (b0 < 0x80) { // 0xxxxxxx
                fCharacterCounter++;
            } else {
                fCharacterCounter++;
                if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                    loadNextByte();
                } else if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                    loadNextByte();
                    loadNextByte();
                } else { // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
                    loadNextByte();
                    loadNextByte();
                    loadNextByte();
                }
            }
            b0 = loadNextByte();
        }
    }
    //
    //
    //
    public void skipPastSpaces() throws Exception {
        int ch = fMostRecentByte;
        while (true) {
            if (ch == 0x20 || ch == 0x09) {
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    ch = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            ch = fMostRecentByte;
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            ch = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            ch = slowLoadNextByte();
                        else
                            ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                if (ch != 0x0A)
                    continue;
                fLinefeedCounter++;
            } else {
                if (ch == 0 && atEOF(fCurrentOffset + 1))
                    changeReaders().skipPastSpaces();
                return;
            }
            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                ch = loadNextByte();
            } else {
                fCurrentOffset++;
                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                    fCurrentIndex++;
                    try {
                        fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                        ch = fMostRecentByte;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        ch = slowLoadNextByte();
                    }
                } else {
                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                        ch = slowLoadNextByte();
                    else
                        ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                }
            }
        }
    }
    //
    //
    //
    protected boolean skippedMultiByteCharWithFlag(int b0, int flag) throws Exception {
        UTF8DataChunk saveChunk = fCurrentChunk;
        int saveOffset = fCurrentOffset;
        int saveIndex = fCurrentIndex;
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        int b1 = loadNextByte();
        if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
            if ((XMLCharacterProperties.fgCharFlags[((0x1f & b0)<<6) + (0x3f & b1)] & flag) == 0) { // yyy yyxx xxxx (0x80 to 0x7ff)
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return false;
            }
            return true;
        }
        int b2 = loadNextByte();
        if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
            // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
            if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return false;
            }
            if ((XMLCharacterProperties.fgCharFlags[((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2)] & flag) == 0) { // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return false;
            }
            return true;
        } else { // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
            fCurrentChunk = saveChunk;
            fCurrentIndex = saveIndex;
            fCurrentOffset = saveOffset;
            fMostRecentData = saveChunk.toByteArray();
            fMostRecentByte = b0;
            return false;
        }
    }
    public void skipPastName(char fastcheck) throws Exception {
        int b0 = fMostRecentByte;
        if (b0 < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[b0] == 0)
                return;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if (!skippedMultiByteCharWithFlag(b0, XMLCharacterProperties.E_InitialNameCharFlag))
                return;
        }
        while (true) {
            fCharacterCounter++;
            b0 = loadNextByte();
            if (fastcheck == b0)
                return;
            if (b0 < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[b0] == 0)
                    return;
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if (!skippedMultiByteCharWithFlag(b0, XMLCharacterProperties.E_NameCharFlag))
                    return;
            }
        }
    }
    //
    //
    //
    public void skipPastNmtoken(char fastcheck) throws Exception {
        int b0 = fMostRecentByte;
        while (true) {
            if (fastcheck == b0)
                return;
            if (b0 < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[b0] == 0)
                    return;
            } else {
                if (!skippedMultiByteCharWithFlag(b0, XMLCharacterProperties.E_NameCharFlag))
                    return;
            }
            fCharacterCounter++;
            b0 = loadNextByte();
        }
    }
    //
    //
    //
    public boolean skippedString(char[] s) throws Exception {
        int length = s.length;
        byte[] data = fMostRecentData;
        int index = fCurrentIndex + length;
        int sindex = length;
        try {
            while (sindex-- > 0) {
                if (data[--index] != s[sindex])
                    return false;
            }
            fCurrentIndex += length;
        } catch (ArrayIndexOutOfBoundsException ex) {
            int i = 0;
            index = fCurrentIndex;
            while (index < UTF8DataChunk.CHUNK_SIZE) {
                if (data[index++] != s[i++])
                    return false;
            }
            UTF8DataChunk dataChunk = fCurrentChunk;
            int savedOffset = fCurrentOffset;
            int savedIndex = fCurrentIndex;
            slowLoadNextByte();
            data = fMostRecentData;
            index = 0;
            while (i < length) {
                if (data[index++] != s[i++]) {
                    fCurrentChunk = dataChunk;
                    fCurrentIndex = savedIndex;
                    fCurrentOffset = savedOffset;
                    fMostRecentData = fCurrentChunk.toByteArray();
                    fMostRecentByte = fMostRecentData[savedIndex] & 0xFF;
                    return false;
                }
            }
            fCurrentIndex = index;
        }
        fCharacterCounter += length;
        fCurrentOffset += length;
        try {
            fMostRecentByte = data[fCurrentIndex] & 0xFF;
        } catch (ArrayIndexOutOfBoundsException ex) {
            slowLoadNextByte();
        }
        return true;
    }
    //
    //
    //
    public int scanInvalidChar() throws Exception {
        int b0 = fMostRecentByte;
        int ch = b0;
        if (ch == 0x0A) {
            fLinefeedCounter++;
            fCharacterCounter = 1;
        } else if (ch == 0x0D) {
            fCarriageReturnCounter++;
            fCharacterCounter = 1;
            ch = loadNextByte();
            if (ch != 0x0A)
                return 0x0A;
            fLinefeedCounter++;
        } else if (ch == 0) {
            if (atEOF(fCurrentOffset + 1)) {
                return changeReaders().scanInvalidChar();
            }
            fCharacterCounter++;
        } else if (b0 >= 0x80) {
            fCharacterCounter++;
            int b1 = loadNextByte();
            if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                ch = ((0x1f & b0)<<6) + (0x3f & b1);
            } else {
                int b2 = loadNextByte();
                if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                    // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
                    ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                } else {
                    int b3 = loadNextByte(); // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
                    ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12)
                           + ((0x3f & b2)<<6) + (0x3f & b3);
                }
            }
        }
        loadNextByte();
        return ch;
    }
    //
    //
    //
    public int scanCharRef(boolean hex) throws Exception {
        int ch = fMostRecentByte;
        if (ch == 0) {
            if (atEOF(fCurrentOffset + 1)) {
                return changeReaders().scanCharRef(hex);
            }
            return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
        }
        int num = 0;
        if (hex) {
            if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
        } else {
            if (ch < '0' || ch > '9')
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - '0';
        }
        fCharacterCounter++;
        loadNextByte();
        boolean toobig = false;
        while (true) {
            ch = fMostRecentByte;
            if (ch == 0)
                break;
            if (hex) {
                if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                    break;
            } else {
                if (ch < '0' || ch > '9')
                    break;
            }
            fCharacterCounter++;
            loadNextByte();
            if (hex) {
                int dig = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
                num = (num << 4) + dig;
            } else {
                int dig = ch - '0';
                num = (num * 10) + dig;
            }
            if (num > 0x10FFFF) {
                toobig = true;
                num = 0;
            }
        }
        if (ch != ';')
            return XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED;
        fCharacterCounter++;
        loadNextByte();
        if (toobig)
            return XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE;
        return num;
    }
    //
    //
    //
    public int scanStringLiteral() throws Exception {
        boolean single;
        if (!(single = lookingAtChar('\'', true)) && !lookingAtChar('\""', true)) {
            return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
        }
        int offset = fCurrentOffset;
        char qchar = single ? '\'' : '\""';
        while (!lookingAtChar(qchar, false)) {
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR;
            }
        }
        int stringIndex = fCurrentChunk.addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true); // move past qchar
        return stringIndex;
    }
    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    //                   | ""'"" ([^<&'] | Reference)* ""'""
    //
    // The values in the following table are defined as:
    //
    //      0 - not special
    //      1 - quote character
    //      2 - complex
    //      3 - less than
    //      4 - invalid
    //
    public static final byte fgAsciiAttValueChar[] = {
        4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 2, 4, 4, // tab is 0x09,  LF is 0x0A,  CR is 0x0D
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        0, 0, 1, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, // '\""' is 0x22, '&' is 0x26, '\'' is 0x27
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, // '<' is 0x3C
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public int scanAttValue(char qchar, boolean asSymbol) throws Exception
    {
        int offset = fCurrentOffset;
        int b0 = fMostRecentByte;
        while (true) {
            if (b0 < 0x80) {
                switch (fgAsciiAttValueChar[b0]) {
                case 1: // quote char
                    if (b0 == qchar) {
                        int length = fCurrentOffset - offset;
                        int result = length == 0 ? StringPool.EMPTY_STRING : (asSymbol ? fCurrentChunk.addSymbol(offset, length, 0) : fCurrentChunk.addString(offset, length));
                        fCharacterCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    slowLoadNextByte();
                                else
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            }
                        }
                        return result;
                    }
                    // the other quote character is not special
                    // fall through
                case 0: // non-special char
                    fCharacterCounter++;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    continue;
                case 2: // complex
                    return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
                case 3: // less than
                    return XMLEntityHandler.ATTVALUE_RESULT_LESSTHAN;
                case 4: // invalid
                    return XMLEntityHandler.ATTVALUE_RESULT_INVALID_CHAR;
                }
            } else {
                if (!skipMultiByteCharData(b0))
                    return XMLEntityHandler.ATTVALUE_RESULT_INVALID_CHAR;
                b0 = fMostRecentByte;
            }
        }
    }
    //
    // [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                     | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    // The values in the following table are defined as:
    //
    //      0 - not special
    //      1 - quote character
    //      2 - reference
    //      3 - peref
    //      4 - invalid
    //      5 - linefeed
    //      6 - carriage-return
    //      7 - end of input
    //
    public static final byte fgAsciiEntityValueChar[] = {
        7, 4, 4, 4, 4, 4, 4, 4, 4, 0, 5, 4, 4, 6, 4, 4, // tab is 0x09,  LF is 0x0A,  CR is 0x0D
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        0, 0, 1, 0, 0, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, // '\""', '%', '&', '\''
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public int scanEntityValue(int qchar, boolean createString) throws Exception
    {
        int offset = fCurrentOffset;
        int b0 = fMostRecentByte;
        while (true) {
            if (b0 < 0x80) {
                switch (fgAsciiEntityValueChar[b0]) {
                case 1: // quote char
                    if (b0 == qchar) {
                        if (!createString)
                            return XMLEntityHandler.ENTITYVALUE_RESULT_FINISHED;
                        int length = fCurrentOffset - offset;
                        int result = length == 0 ? StringPool.EMPTY_STRING : fCurrentChunk.addString(offset, length);
                        fCharacterCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    slowLoadNextByte();
                                else
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            }
                        }
                        return result;
                    }
                    // the other quote character is not special
                    // fall through
                case 0: // non-special char
                    fCharacterCounter++;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    continue;
                case 5: // linefeed
                    fLinefeedCounter++;
                    fCharacterCounter = 1;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    continue;
                case 6: // carriage-return
                    fCarriageReturnCounter++;
                    fCharacterCounter = 1;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    if (b0 != 0x0A) {
                        continue;
                    }
                    fLinefeedCounter++;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    continue;
                case 2: // reference
                    return XMLEntityHandler.ENTITYVALUE_RESULT_REFERENCE;
                case 3: // peref
                    return XMLEntityHandler.ENTITYVALUE_RESULT_PEREF;
                case 7:
                    if (atEOF(fCurrentOffset + 1)) {
                        changeReaders(); // do not call next reader, our caller may need to change the parameters
                        return XMLEntityHandler.ENTITYVALUE_RESULT_END_OF_INPUT;
                    }
                    // fall into...
                case 4: // invalid
                    return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
                }
            } else {
                if (!skipMultiByteCharData(b0))
                    return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
                b0 = fMostRecentByte;
            }
        }
    }
    //
    //
    //
    public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws Exception {
        char[] expected = expectedName.chars;
        int offset = expectedName.offset;
        int len = expectedName.length;
        int b0 = fMostRecentByte;
        int ch = 0;
        int i = 0;
        while (true) {
            if (b0 < 0x80) {
                ch = b0;
                if (i == len)
                    break;
                if (ch != expected[offset]) {
                    skipPastNmtoken(fastcheck);
                    return false;
                }
            } else {
                //
                // REVISIT - optimize this with in-buffer lookahead.
                //
                UTF8DataChunk saveChunk = fCurrentChunk;
                int saveIndex = fCurrentIndex;
                int saveOffset = fCurrentOffset;
                int b1;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    b1 = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            b1 = fMostRecentData[fCurrentIndex] & 0xFF;
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            b1 = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            b1 = slowLoadNextByte();
                        else
                            b1 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                    ch = ((0x1f & b0)<<6) + (0x3f & b1);
                    if (i == len)
                        break;
                    if (ch != expected[offset]) {
                        fCurrentChunk = saveChunk;
                        fCurrentIndex = saveIndex;
                        fCurrentOffset = saveOffset;
                        fMostRecentData = saveChunk.toByteArray();
                        fMostRecentByte = b0;
                        skipPastNmtoken(fastcheck);
                        return false;
                    }
                } else {
                    int b2;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b2 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b2 = fMostRecentData[fCurrentIndex] & 0xFF;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b2 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b2 = slowLoadNextByte();
                            else
                                b2 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                        // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
                        if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                            fCurrentChunk = saveChunk;
                            fCurrentIndex = saveIndex;
                            fCurrentOffset = saveOffset;
                            fMostRecentData = saveChunk.toByteArray();
                            fMostRecentByte = b0;
                            return false;
                        }
                        ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                        if (i == len)
                            break;
                        if (ch != expected[offset]) {
                            fCurrentChunk = saveChunk;
                            fCurrentIndex = saveIndex;
                            fCurrentOffset = saveOffset;
                            fMostRecentData = saveChunk.toByteArray();
                            fMostRecentByte = b0;
                            skipPastNmtoken(fastcheck);
                            return false;
                        }
                    } else { // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
                        fCurrentChunk = saveChunk;
                        fCurrentIndex = saveIndex;
                        fCurrentOffset = saveOffset;
                        fMostRecentData = saveChunk.toByteArray();
                        fMostRecentByte = b0;
                        return false;
                    }
                }
            }
            i++;
            offset++;
            fCharacterCounter++;
            fCurrentOffset++;
            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                fCurrentIndex++;
                try {
                    b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                } catch (ArrayIndexOutOfBoundsException ex) {
                    b0 = slowLoadNextByte();
                }
            } else {
                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                    b0 = slowLoadNextByte();
                else
                    b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
            }
        }
        if (ch == fastcheck)
            return true;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                return true;
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                return true;
        }
        skipPastNmtoken(fastcheck);
        return false;
    }

    public void scanQName(char fastcheck, QName qname) throws Exception {

        int ch = fMostRecentByte;
        if (ch < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0) {
                qname.clear();
                return;
            }
            if (ch == ':') {
                qname.clear();
                return;
            }
        } else {
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0) {
                qname.clear();
                return;
            }
        }
        int offset = fCurrentOffset;
        int index = fCurrentIndex;
        byte[] data = fMostRecentData;
        int prefixend = -1;
        while (true) {
            fCharacterCounter++;
            fCurrentOffset++;
            index++;
            try {
                ch = data[index] & 0xFF;
            } catch (ArrayIndexOutOfBoundsException ex) {
                ch = slowLoadNextByte();
                index = 0;
                data = fMostRecentData;
            }
            if (fastcheck == ch)
                break;
            if (ch < 0x80) {
                if (XMLCharacterProperties.fgAsciiNameChar[ch] == 0)
                    break;
                if (ch == ':') {
                    if (prefixend != -1)
                        break;
                    prefixend = fCurrentOffset;
                    //
                    // We need to peek ahead one character.  If the next character is not a
                    // valid initial name character, or is another colon, then we cannot meet
                    // both the Prefix and LocalPart productions for the QName production,
                    // which means that there is no Prefix and we need to terminate the QName
                    // at the first colon.
                    //
                    try {
                        ch = data[index + 1] & 0xFF;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        UTF8DataChunk savedChunk = fCurrentChunk;
                        int savedOffset = fCurrentOffset;
                        ch = slowLoadNextByte();
                        fCurrentChunk = savedChunk;
                        fCurrentOffset = savedOffset;
                        fMostRecentData = fCurrentChunk.toByteArray();
                    }
                    boolean lpok = true;
                    if (ch < 0x80) {
                        if (XMLCharacterProperties.fgAsciiInitialNameChar[ch] == 0 || ch == ':')
                            lpok = false;
                    } else {
                        if (!fCalledCharPropInit) {
                            XMLCharacterProperties.initCharFlags();
                            fCalledCharPropInit = true;
                        }
                        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
                            lpok = false;
                    }
                    ch = ':';
                    if (!lpok) {
                        prefixend = -1;
                        break;
                    }
                }
            } else {
                if (!fCalledCharPropInit) {
                    XMLCharacterProperties.initCharFlags();
                    fCalledCharPropInit = true;
                }
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                    break;
            }
        }
        fCurrentIndex = index;
        fMostRecentByte = ch;
        int length = fCurrentOffset - offset;
        qname.rawname = addSymbol(offset, length);
        qname.prefix = prefixend == -1 ? -1 : addSymbol(offset, prefixend - offset);
        qname.localpart = prefixend == -1 ? qname.rawname : addSymbol(prefixend + 1, fCurrentOffset - (prefixend + 1));
        qname.uri = -1;

    } // scanQName(char,QName)

    private int getMultiByteSymbolChar(int b0) throws Exception {
        //
        // REVISIT - optimize this with in-buffer lookahead.
        //
        UTF8DataChunk saveChunk = fCurrentChunk;
        int saveIndex = fCurrentIndex;
        int saveOffset = fCurrentOffset;
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        int b1;
        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
            b1 = loadNextByte();
        } else {
            fCurrentOffset++;
            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                fCurrentIndex++;
                try {
                    b1 = fMostRecentData[fCurrentIndex] & 0xFF;
                } catch (ArrayIndexOutOfBoundsException ex) {
                    b1 = slowLoadNextByte();
                }
            } else {
                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                    b1 = slowLoadNextByte();
                else
                    b1 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
            }
        }
        if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
            int ch = ((0x1f & b0)<<6) + (0x3f & b1);
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0) { // yyy yyxx xxxx (0x80 to 0x7ff)
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return -1;
            }
            loadNextByte();
            return ch;
        }
        int b2;
        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
            b2 = loadNextByte();
        } else {
            fCurrentOffset++;
            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                fCurrentIndex++;
                try {
                    b2 = fMostRecentData[fCurrentIndex] & 0xFF;
                } catch (ArrayIndexOutOfBoundsException ex) {
                    b2 = slowLoadNextByte();
                }
            } else {
                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                    b2 = slowLoadNextByte();
                else
                    b2 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
            }
        }
        if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
            // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
            if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return -1;
            }
            int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0) { // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return -1;
            }
            loadNextByte();
            return ch;
        }
        // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
        fCurrentChunk = saveChunk;
        fCurrentIndex = saveIndex;
        fCurrentOffset = saveOffset;
        fMostRecentData = saveChunk.toByteArray();
        fMostRecentByte = b0;
        return -1;
    }
    public int scanName(char fastcheck) throws Exception {
        int b0 = fMostRecentByte;
        int ch;
        if (b0 < 0x80) {
            if (XMLCharacterProperties.fgAsciiInitialNameChar[b0] == 0) {
                if (b0 == 0 && atEOF(fCurrentOffset + 1)) {
                    return changeReaders().scanName(fastcheck);
                }
                return -1;
            }
            ch = b0;
        } else {
            //
            // REVISIT - optimize this with in-buffer lookahead.
            //
            UTF8DataChunk saveChunk = fCurrentChunk;
            int saveIndex = fCurrentIndex;
            int saveOffset = fCurrentOffset;
            if (!fCalledCharPropInit) {
                XMLCharacterProperties.initCharFlags();
                fCalledCharPropInit = true;
            }
            int b1;
            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                b1 = loadNextByte();
            } else {
                fCurrentOffset++;
                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                    fCurrentIndex++;
                    try {
                        b1 = fMostRecentData[fCurrentIndex] & 0xFF;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        b1 = slowLoadNextByte();
                    }
                } else {
                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                        b1 = slowLoadNextByte();
                    else
                        b1 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                }
            }
            if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx
                ch = ((0x1f & b0)<<6) + (0x3f & b1);
                if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0) { // yyy yyxx xxxx (0x80 to 0x7ff)
                    fCurrentChunk = saveChunk;
                    fCurrentIndex = saveIndex;
                    fCurrentOffset = saveOffset;
                    fMostRecentData = saveChunk.toByteArray();
                    fMostRecentByte = b0;
                    return -1;
                }
            } else {
                int b2;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    b2 = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            b2 = fMostRecentData[fCurrentIndex] & 0xFF;
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            b2 = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            b2 = slowLoadNextByte();
                        else
                            b2 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
                    // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
                    if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                        fCurrentChunk = saveChunk;
                        fCurrentIndex = saveIndex;
                        fCurrentOffset = saveOffset;
                        fMostRecentData = saveChunk.toByteArray();
                        fMostRecentByte = b0;
                        return -1;
                    }
                    ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
                    if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0) { // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
                        fCurrentChunk = saveChunk;
                        fCurrentIndex = saveIndex;
                        fCurrentOffset = saveOffset;
                        fMostRecentData = saveChunk.toByteArray();
                        fMostRecentByte = b0;
                        return -1;
                    }
                } else { // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
                    fCurrentChunk = saveChunk;
                    fCurrentIndex = saveIndex;
                    fCurrentOffset = saveOffset;
                    fMostRecentData = saveChunk.toByteArray();
                    fMostRecentByte = b0;
                    return -1;
                }
            }
        }
        fCharacterCounter++;
        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
            b0 = loadNextByte();
        } else {
            fCurrentOffset++;
            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                fCurrentIndex++;
                try {
                    b0 = fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                } catch (ArrayIndexOutOfBoundsException ex) {
                    b0 = slowLoadNextByte();
                }
            } else {
                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                    b0 = slowLoadNextByte();
                else
                    b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
            }
        }
        return scanMatchingName(ch, b0, fastcheck);
    }
    private int scanMatchingName(int ch, int b0, int fastcheck) throws Exception {
        SymbolCache cache = fStringPool.getSymbolCache();
        int[][] cacheLines = cache.fCacheLines;
        char[] symbolChars = cache.fSymbolChars;
        boolean lengthOfOne = fastcheck == fMostRecentByte;
        int startOffset = cache.fSymbolCharsOffset;
        int entry = 0;
        int[] entries = cacheLines[entry];
        int offset = 1 + ((entries[0] - 1) * SymbolCache.CACHE_RECORD_SIZE);
        int totalMisses = 0;
        if (lengthOfOne) {
            while (offset > 0) {
                if (entries[offset + SymbolCache.CHAR_OFFSET] == ch) {
                    if (entries[offset + SymbolCache.INDEX_OFFSET] != -1) {
                        int symbolIndex = entries[offset + SymbolCache.INDEX_OFFSET];
                        if (totalMisses > 3)
                            fStringPool.updateCacheLine(symbolIndex, totalMisses, 1);
                        return symbolIndex;
                    }
                    break;
                }
                offset -= SymbolCache.CACHE_RECORD_SIZE;
                totalMisses++;
            }
            try {
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                symbolChars = new char[cache.fSymbolCharsOffset * 2];
                System.arraycopy(cache.fSymbolChars, 0, symbolChars, 0, cache.fSymbolCharsOffset);
                cache.fSymbolChars = symbolChars;
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            }
            cache.fSymbolCharsOffset++;
            if (offset < 0) {
                offset = 1 + (entries[0] * SymbolCache.CACHE_RECORD_SIZE);
                entries[0]++;
                try {
                    entries[offset + SymbolCache.CHAR_OFFSET] = ch;
                } catch (ArrayIndexOutOfBoundsException ex) {
                    int newSize = 1 + ((offset - 1) * 2);
                    entries = new int[newSize];
                    System.arraycopy(cacheLines[entry], 0, entries, 0, offset);
                    cacheLines[entry] = entries;
                    entries[offset + SymbolCache.CHAR_OFFSET] = ch;
                }
                entries[offset + SymbolCache.NEXT_OFFSET] = -1;
            }
            int result = fStringPool.createNonMatchingSymbol(startOffset, entry, entries, offset);
            return result;
        }
        try {
            symbolChars[cache.fSymbolCharsOffset] = (char)ch;
        } catch (ArrayIndexOutOfBoundsException ex) {
            symbolChars = new char[cache.fSymbolCharsOffset * 2];
            System.arraycopy(cache.fSymbolChars, 0, symbolChars, 0, cache.fSymbolCharsOffset);
            cache.fSymbolChars = symbolChars;
            symbolChars[cache.fSymbolCharsOffset] = (char)ch;
        }
        cache.fSymbolCharsOffset++;
        int depth = 1;
        while (true) {
            if (offset < 0)
                break;
            if (entries[offset + SymbolCache.CHAR_OFFSET] != ch) {
                offset -= SymbolCache.CACHE_RECORD_SIZE;
                totalMisses++;
                continue;
            }
            if (b0 >= 0x80) {
                ch = getMultiByteSymbolChar(b0);
                b0 = fMostRecentByte;
            } else if (b0 == fastcheck || XMLCharacterProperties.fgAsciiNameChar[b0] == 0) {
                ch = -1;
            } else {
                ch = b0;
                fCharacterCounter++;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    b0 = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            b0 = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            b0 = slowLoadNextByte();
                        else
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
            }
            if (ch == -1) {
                if (entries[offset + SymbolCache.INDEX_OFFSET] == -1) {
                    return fStringPool.createNonMatchingSymbol(startOffset, entry, entries, offset);
                }
                cache.fSymbolCharsOffset = startOffset;
                int symbolIndex = entries[offset + SymbolCache.INDEX_OFFSET];
                if (totalMisses > (depth * 3))
                    fStringPool.updateCacheLine(symbolIndex, totalMisses, depth);
                return symbolIndex;
            }
            try {
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                symbolChars = new char[cache.fSymbolCharsOffset * 2];
                System.arraycopy(cache.fSymbolChars, 0, symbolChars, 0, cache.fSymbolCharsOffset);
                cache.fSymbolChars = symbolChars;
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            }
            cache.fSymbolCharsOffset++;
            entry = entries[offset + SymbolCache.NEXT_OFFSET];
            try {
                entries = cacheLines[entry];
            } catch (ArrayIndexOutOfBoundsException ex) {
                if (entry == -1) {
                    entry = cache.fCacheLineCount++;
                    entries[offset + SymbolCache.NEXT_OFFSET] = entry;
                    entries = new int[1+(SymbolCache.INITIAL_CACHE_RECORD_COUNT*SymbolCache.CACHE_RECORD_SIZE)];
                    try {
                        cacheLines[entry] = entries;
                    } catch (ArrayIndexOutOfBoundsException ex2) {
                        cacheLines = new int[entry * 2][];
                        System.arraycopy(cache.fCacheLines, 0, cacheLines, 0, entry);
                        cache.fCacheLines = cacheLines;
                        cacheLines[entry] = entries;
                    }
                } else {
                    entries = cacheLines[entry];
                    throw new RuntimeException(""RDR001 untested""); // REVISIT
                }
            }
            offset = 1 + ((entries[0] - 1) * SymbolCache.CACHE_RECORD_SIZE);
            depth++;
        }
        if (offset < 0)
            offset = 1 + (entries[0] * SymbolCache.CACHE_RECORD_SIZE);
        while (true) {
            entries[0]++;
            try {
                entries[offset + SymbolCache.CHAR_OFFSET] = ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                int newSize = 1 + ((offset - 1) * 2);
                entries = new int[newSize];
                System.arraycopy(cacheLines[entry], 0, entries, 0, offset);
                cacheLines[entry] = entries;
                entries[offset + SymbolCache.CHAR_OFFSET] = ch;
            }
            if (b0 >= 0x80) {
                ch = getMultiByteSymbolChar(b0);
                b0 = fMostRecentByte;
            } else if (b0 == fastcheck || XMLCharacterProperties.fgAsciiNameChar[b0] == 0) {
                ch = -1;
            } else {
                ch = b0;
                fCharacterCounter++;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    b0 = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            b0 = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            b0 = slowLoadNextByte();
                        else
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
            }
            if (ch == -1) {
                entries[offset + SymbolCache.NEXT_OFFSET] = -1;
                break;
            }
            entry = cache.fCacheLineCount++;
            entries[offset + SymbolCache.INDEX_OFFSET] = -1;
            entries[offset + SymbolCache.NEXT_OFFSET] = entry;
            entries = new int[1+(SymbolCache.INITIAL_CACHE_RECORD_COUNT*SymbolCache.CACHE_RECORD_SIZE)];
            try {
                cacheLines[entry] = entries;
            } catch (ArrayIndexOutOfBoundsException ex) {
                cacheLines = new int[entry * 2][];
                System.arraycopy(cache.fCacheLines, 0, cacheLines, 0, entry);
                cache.fCacheLines = cacheLines;
                cacheLines[entry] = entries;
            }
            offset = 1;
            try {
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                symbolChars = new char[cache.fSymbolCharsOffset * 2];
                System.arraycopy(cache.fSymbolChars, 0, symbolChars, 0, cache.fSymbolCharsOffset);
                cache.fSymbolChars = symbolChars;
                symbolChars[cache.fSymbolCharsOffset] = (char)ch;
            }
            cache.fSymbolCharsOffset++;
        }

        int result = fStringPool.createNonMatchingSymbol(startOffset, entry, entries, offset);
        return result;
    }
    //
    // [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
    //
    private int recognizeMarkup(int b0, QName element) throws Exception {
        switch (b0) {
        case 0:
            return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
        case '?':
            fCharacterCounter++;
            loadNextByte();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_PI;
        case '!':
            fCharacterCounter++;
            b0 = loadNextByte();
            if (b0 == 0) {
                fCharacterCounter--;
                fCurrentOffset--;
                return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
            }
            if (b0 == '-') {
                fCharacterCounter++;
                b0 = loadNextByte();
                if (b0 == 0) {
                    fCharacterCounter -= 2;
                    fCurrentOffset -= 2;
                    return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                }
                if (b0 == '-') {
                    fCharacterCounter++;
                    b0 = loadNextByte();
                    return XMLEntityHandler.CONTENT_RESULT_START_OF_COMMENT;
                }
                break;
            }
            if (b0 == '[') {
                for (int i = 0; i < 6; i++) {
                    fCharacterCounter++;
                    b0 = loadNextByte();
                    if (b0 == 0) {
                        fCharacterCounter -= (2 + i);
                        fCurrentOffset -= (2 + i);
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                    }
                    if (b0 != cdata_string[i]) {
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
                    }
                }
                fCharacterCounter++;
                loadNextByte();
                return XMLEntityHandler.CONTENT_RESULT_START_OF_CDSECT;
            }
            break;
        case '/':
            fCharacterCounter++;
            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                b0 = loadNextByte();
            } else {
                fCurrentOffset++;
                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                    fCurrentIndex++;
                    try {
                        b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        b0 = slowLoadNextByte();
                    }
                } else {
                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                        b0 = slowLoadNextByte();
                    else
                        b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                }
            }
            int expectedName = element.rawname;
            fStringPool.getCharArrayRange(expectedName, fCharArrayRange);
            char[] expected = fCharArrayRange.chars;
            int offset = fCharArrayRange.offset;
            int len = fCharArrayRange.length;
            //
            // DEFECT !! - needs UTF8 multibyte support...
            //
            if (b0 == expected[offset++]) {
                UTF8DataChunk savedChunk = fCurrentChunk;
                int savedIndex = fCurrentIndex;
                int savedOffset = fCurrentOffset;
                for (int i = 1; i < len; i++) {
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        b0 = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                b0 = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                b0 = slowLoadNextByte();
                            else
                                b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                    //
                    // DEFECT !! - needs UTF8 multibyte support...
                    //
                    if (b0 != expected[offset++]) {
                        fCurrentChunk = savedChunk;
                        fCurrentIndex = savedIndex;
                        fCurrentOffset = savedOffset;
                        fMostRecentData = fCurrentChunk.toByteArray();
                        fMostRecentByte = fMostRecentData[savedIndex] & 0xFF;
                        return XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG;
                    }
                }
                fCharacterCounter += len; // REVISIT - double check this...
                fCharacterCounter++;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    b0 = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            b0 = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            b0 = slowLoadNextByte();
                        else
                            b0 = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                if (b0 == '>') {
                    fCharacterCounter++;
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                slowLoadNextByte();
                            else
                                fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                        }
                    }
                    return XMLEntityHandler.CONTENT_RESULT_MATCHING_ETAG;
                }
                while (b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D) {
                    if (b0 == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                        b0 = loadNextByte();
                    } else if (b0 == 0x0D) {
                        fCarriageReturnCounter++;
                        fCharacterCounter = 1;
                        b0 = loadNextByte();
                        if (b0 == 0x0A) {
                            fLinefeedCounter++;
                            b0 = loadNextByte();
                        }
                    } else {
                        fCharacterCounter++;
                        b0 = loadNextByte();
                    }
                    if (b0 == '>') {
                        fCharacterCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    slowLoadNextByte();
                                else
                                    fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF;
                            }
                        }
                        return XMLEntityHandler.CONTENT_RESULT_MATCHING_ETAG;
                    }
                }
                fCurrentChunk = savedChunk;
                fCurrentIndex = savedIndex;
                fCurrentOffset = savedOffset;
                fMostRecentData = fCurrentChunk.toByteArray();
                fMostRecentByte = fMostRecentData[savedIndex] & 0xFF;
            }
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG;
        default:
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ELEMENT;
        }
        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
    }
    private int recognizeReference(int ch) throws Exception {
        if (ch == 0) {
            return XMLEntityHandler.CONTENT_RESULT_REFERENCE_END_OF_INPUT;
        }
        //
        // [67] Reference ::= EntityRef | CharRef
        // [68] EntityRef ::= '&' Name ';'
        // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
        //
        if (ch == '#') {
            fCharacterCounter++;
            loadNextByte();
            return XMLEntityHandler.CONTENT_RESULT_START_OF_CHARREF;
        } else {
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ENTITYREF;
        }
    }
    public int scanContent(QName element) throws Exception {
        if (fCallClearPreviousChunk && fCurrentChunk.clearPreviousChunk())
            fCallClearPreviousChunk = false;
        fCharDataLength = 0;
        int charDataOffset = fCurrentOffset;
        int ch = fMostRecentByte;
        if (ch < 0x80) {
            switch (XMLCharacterProperties.fgAsciiWSCharData[ch]) {
            case 0:
                if (fSendCharDataAsCharArray) {
                    try {
                        fCharacters[fCharDataLength] = (char)ch;
                        fCharDataLength++;
                    } catch (ArrayIndexOutOfBoundsException ex) {
                        slowAppendCharData(ch);
                    }
                }
                fCharacterCounter++;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    ch = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            ch = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            ch = slowLoadNextByte();
                        else
                            ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                break;
            case 1: // '<'
                fCharacterCounter++;
                if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                    ch = loadNextByte();
                } else {
                    fCurrentOffset++;
                    if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                        fCurrentIndex++;
                        try {
                            ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            ch = slowLoadNextByte();
                        }
                    } else {
                        if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                            ch = slowLoadNextByte();
                        else
                            ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                    }
                }
                if (!fInCDSect) {
                    return recognizeMarkup(ch, element);
                }
                if (fSendCharDataAsCharArray)
                    appendCharData('<');
                break;
            case 2: // '&'
                fCharacterCounter++;
                ch = loadNextByte();
                if (!fInCDSect) {
                    return recognizeReference(ch);
                }
                if (fSendCharDataAsCharArray)
                    appendCharData('&');
                break;
            case 3: // ']'
                fCharacterCounter++;
                ch = loadNextByte();
                if (ch != ']') {
                    if (fSendCharDataAsCharArray)
                        appendCharData(']');
                    break;
                }
                if (fCurrentIndex + 1 == UTF8DataChunk.CHUNK_SIZE) {
                    UTF8DataChunk saveChunk = fCurrentChunk;
                    int saveIndex = fCurrentIndex;
                    int saveOffset = fCurrentOffset;
                    if (loadNextByte() != '>') {
                        fCurrentChunk = saveChunk;
                        fCurrentIndex = saveIndex;
                        fCurrentOffset = saveOffset;
                        fMostRecentData = fCurrentChunk.toByteArray();
                        fMostRecentByte = ']';
                        if (fSendCharDataAsCharArray)
                            appendCharData(']');
                        break;
                    }
                } else {
                    if (fMostRecentData[fCurrentIndex + 1] != '>') {
                        if (fSendCharDataAsCharArray)
                            appendCharData(']');
                        break;
                    }
                    fCurrentIndex++;
                    fCurrentOffset++;
                }
                loadNextByte();
                fCharacterCounter += 2;
                return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
            case 4: // invalid char
                if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                    changeReaders();
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                }
                return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
            case 5:
                do {
                    if (ch == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                    } else if (ch == 0x0D) {
                        fCarriageReturnCounter++;
                        fCharacterCounter = 1;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            ch = loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    ch = slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    ch = slowLoadNextByte();
                                else
                                    ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            }
                        }
                        if (ch != 0x0A) {
                            if (fSendCharDataAsCharArray)
                                appendCharData(0x0A);
                            if (ch == 0x20 || ch == 0x09 || ch == 0x0D)
                                continue;
                            break;
                        }
                        fLinefeedCounter++;
                    } else {
                        fCharacterCounter++;
                    }
                    if (fSendCharDataAsCharArray) {
                        try {
                            fCharacters[fCharDataLength] = (char)ch;
                            fCharDataLength++;
                        } catch (ArrayIndexOutOfBoundsException ex) {
                            slowAppendCharData(ch);
                        }
                    }
                    if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                        ch = loadNextByte();
                    } else {
                        fCurrentOffset++;
                        if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                            fCurrentIndex++;
                            try {
                                ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            } catch (ArrayIndexOutOfBoundsException ex) {
                                ch = slowLoadNextByte();
                            }
                        } else {
                            if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                ch = slowLoadNextByte();
                            else
                                ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                        }
                    }
                } while (ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D);
                if (ch < 0x80) {
                    switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                    case 0:
                        if (fSendCharDataAsCharArray)
                            appendCharData(ch);
                        fCharacterCounter++;
                        ch = loadNextByte();
                        break;
                    case 1: // '<'
                        if (!fInCDSect) {
                            if (fSendCharDataAsCharArray) {
                                fCharDataHandler.processWhitespace(fCharacters, 0, fCharDataLength);
                            } else {
                                int stringIndex = addString(charDataOffset, fCurrentOffset - charDataOffset);
                                fCharDataHandler.processWhitespace(stringIndex);
                            }
                            fCharacterCounter++;
                            if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                                ch = loadNextByte();
                            } else {
                                fCurrentOffset++;
                                if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                    fCurrentIndex++;
                                    try {
                                        ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                                    } catch (ArrayIndexOutOfBoundsException ex) {
                                        ch = slowLoadNextByte();
                                    }
                                } else {
                                    if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                        ch = slowLoadNextByte();
                                    else
                                        ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                                }
                            }
                            return recognizeMarkup(ch, element);
                        }
                        if (fSendCharDataAsCharArray)
                            appendCharData('<');
                        fCharacterCounter++;
                        ch = loadNextByte();
                        break;
                    case 2: // '&'
                        if (!fInCDSect) {
                            whitespace(charDataOffset, fCurrentOffset);
                            fCharacterCounter++;
                            ch = loadNextByte();
                            return recognizeReference(ch);
                        }
                        if (fSendCharDataAsCharArray)
                            appendCharData('&');
                        fCharacterCounter++;
                        ch = loadNextByte();
                        break;
                    case 3: // ']'
                        int endOffset = fCurrentOffset;
                        ch = loadNextByte();
                        if (ch != ']') {
                            fCharacterCounter++;
                            if (fSendCharDataAsCharArray)
                                appendCharData(']');
                            break;
                        }
                        if (fCurrentIndex + 1 == UTF8DataChunk.CHUNK_SIZE) {
                            UTF8DataChunk saveChunk = fCurrentChunk;
                            int saveIndex = fCurrentIndex;
                            int saveOffset = fCurrentOffset;
                            if (loadNextByte() != '>') {
                                fCurrentChunk = saveChunk;
                                fCurrentIndex = saveIndex;
                                fCurrentOffset = saveOffset;
                                fMostRecentData = fCurrentChunk.toByteArray();
                                fMostRecentByte = ']';
                                fCharacterCounter++;
                                if (fSendCharDataAsCharArray)
                                    appendCharData(']');
                                break;
                            }
                        } else {
                            if (fMostRecentData[fCurrentIndex + 1] != '>') {
                                fCharacterCounter++;
                                if (fSendCharDataAsCharArray)
                                    appendCharData(']');
                                break;
                            }
                            fCurrentIndex++;
                            fCurrentOffset++;
                        }
                        loadNextByte();
                        whitespace(charDataOffset, endOffset);
                        fCharacterCounter += 3;
                        return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                    case 4: // invalid char
                        whitespace(charDataOffset, fCurrentOffset);
                        if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                            changeReaders();
                            return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                        }
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                } else {
                    if (fSendCharDataAsCharArray) {
                        if (!copyMultiByteCharData(ch)) {
                            whitespace(charDataOffset, fCurrentOffset);
                            return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                        }
                    } else if (!skipMultiByteCharData(ch)) {
                        whitespace(charDataOffset, fCurrentOffset);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                }
                break;
            }
        } else {
            if (fSendCharDataAsCharArray) {
                if (!copyMultiByteCharData(ch)) {
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            } else {
                if (!skipMultiByteCharData(ch)) {
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            }
        }
        if (fSendCharDataAsCharArray)
            ch = copyAsciiCharData();
        else
            ch = skipAsciiCharData();
        while (true) {
            if (ch < 0x80) {
                switch (XMLCharacterProperties.fgAsciiCharData[ch]) {
                case 0:
                    if (fSendCharDataAsCharArray)
                        appendCharData(ch);
                    fCharacterCounter++;
                    ch = loadNextByte();
                    break;
                case 1: // '<'
                    if (!fInCDSect) {
                        if (fSendCharDataAsCharArray) {
                            fCharDataHandler.processCharacters(fCharacters, 0, fCharDataLength);
                        } else {
                            int stringIndex = addString(charDataOffset, fCurrentOffset - charDataOffset);
                            fCharDataHandler.processCharacters(stringIndex);
                        }
                        fCharacterCounter++;
                        if (USE_OUT_OF_LINE_LOAD_NEXT_BYTE) {
                            ch = loadNextByte();
                        } else {
                            fCurrentOffset++;
                            if (USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE) {
                                fCurrentIndex++;
                                try {
                                    ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                                } catch (ArrayIndexOutOfBoundsException ex) {
                                    ch = slowLoadNextByte();
                                }
                            } else {
                                if (++fCurrentIndex == UTF8DataChunk.CHUNK_SIZE)
                                    ch = slowLoadNextByte();
                                else
                                    ch = (fMostRecentByte = fMostRecentData[fCurrentIndex] & 0xFF);
                            }
                        }
                        return recognizeMarkup(ch, element);
                    }
                    if (fSendCharDataAsCharArray)
                        appendCharData('<');
                    fCharacterCounter++;
                    ch = loadNextByte();
                    break;
                case 2: // '&'
                    if (!fInCDSect) {
                        characters(charDataOffset, fCurrentOffset);
                        fCharacterCounter++;
                        ch = loadNextByte();
                        return recognizeReference(ch);
                    }
                    if (fSendCharDataAsCharArray)
                        appendCharData('&');
                    fCharacterCounter++;
                    ch = loadNextByte();
                    break;
                case 3: // ']'
                    int endOffset = fCurrentOffset;
                    ch = loadNextByte();
                    if (ch != ']') {
                        fCharacterCounter++;
                        if (fSendCharDataAsCharArray)
                            appendCharData(']');
                        break;
                    }
                    if (fCurrentIndex + 1 == UTF8DataChunk.CHUNK_SIZE) {
                        UTF8DataChunk saveChunk = fCurrentChunk;
                        int saveIndex = fCurrentIndex;
                        int saveOffset = fCurrentOffset;
                        if (loadNextByte() != '>') {
                            fCurrentChunk = saveChunk;
                            fCurrentIndex = saveIndex;
                            fCurrentOffset = saveOffset;
                            fMostRecentData = fCurrentChunk.toByteArray();
                            fMostRecentByte = ']';
                            fCharacterCounter++;
                            if (fSendCharDataAsCharArray)
                                appendCharData(']');
                            break;
                        }
                    } else {
                        if (fMostRecentData[fCurrentIndex + 1] != '>') {
                            fCharacterCounter++;
                            if (fSendCharDataAsCharArray)
                                appendCharData(']');
                            break;
                        }
                        fCurrentIndex++;
                        fCurrentOffset++;
                    }
                    loadNextByte();
                    characters(charDataOffset, endOffset);
                    fCharacterCounter += 3;
                    return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                case 4: // invalid char
                    if (ch == 0x0A) {
                        if (fSendCharDataAsCharArray)
                            appendCharData(ch);
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                        ch = loadNextByte();
                        break;
                    }
                    if (ch == 0x0D) {
                        if (fSendCharDataAsCharArray)
                            appendCharData(0x0A);
                        fCarriageReturnCounter++;
                        fCharacterCounter = 1;
                        ch = loadNextByte();
                        if (ch == 0x0A) {
                            fLinefeedCounter++;
                            ch = loadNextByte();
                        }
                        break;
                    }
                    characters(charDataOffset, fCurrentOffset);
                    if (ch == 0 && atEOF(fCurrentOffset + 1)) {
                        changeReaders();
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR; // REVISIT - not quite...
                    }
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            } else {
                if (fSendCharDataAsCharArray) {
                    if (!copyMultiByteCharData(ch)) {
                        characters(charDataOffset, fCurrentOffset);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                } else if (!skipMultiByteCharData(ch)) {
                    characters(charDataOffset, fCurrentOffset);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
                ch = fMostRecentByte;
            }
        }
    }
    private boolean copyMultiByteCharData(int b0) throws Exception {
        UTF8DataChunk saveChunk = fCurrentChunk;
        int saveOffset = fCurrentOffset;
        int saveIndex = fCurrentIndex;
        int b1 = loadNextByte();
        if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx (0x80 to 0x7ff)
            int ch = ((0x1f & b0)<<6) + (0x3f & b1);
            appendCharData(ch); // yyy yyxx xxxx (0x80 to 0x7ff)
            loadNextByte();
            return true;
        }
        int b2 = loadNextByte();
        if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
            // ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
            // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
            if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return false;
            }
            int ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2);
            appendCharData(ch); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
            loadNextByte();
            return true;
        }
        int b3 = loadNextByte();  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
        // ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3); // u uuuu zzzz yyyy yyxx xxxx (0x10000 to 0x1ffff)
        // if (ch >= 0x110000)
        if (b0 > 0xF4 || (b0 == 0xF4 && b1 >= 0x90)) {
            fCurrentChunk = saveChunk;
            fCurrentIndex = saveIndex;
            fCurrentOffset = saveOffset;
            fMostRecentData = saveChunk.toByteArray();
            fMostRecentByte = b0;
            return false;
        }
        int ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3);
        if (ch < 0x10000) {
            appendCharData(ch);
        } else {
            appendCharData(((ch-0x00010000)>>10)+0xd800);
            appendCharData(((ch-0x00010000)&0x3ff)+0xdc00);
        }
        loadNextByte();
        return true;
    }
    private boolean skipMultiByteCharData(int b0) throws Exception {
        UTF8DataChunk saveChunk = fCurrentChunk;
        int saveOffset = fCurrentOffset;
        int saveIndex = fCurrentIndex;
        int b1 = loadNextByte();
        if ((0xe0 & b0) == 0xc0) { // 110yyyyy 10xxxxxx (0x80 to 0x7ff)
            loadNextByte();
            return true;
        }
        int b2 = loadNextByte();
        if ((0xf0 & b0) == 0xe0) { // 1110zzzz 10yyyyyy 10xxxxxx
            // ch = ((0x0f & b0)<<12) + ((0x3f & b1)<<6) + (0x3f & b2); // zzzz yyyy yyxx xxxx (0x800 to 0xffff)
            // if ((ch >= 0xD800 && ch <= 0xDFFF) || ch >= 0xFFFE)
            if ((b0 == 0xED && b1 >= 0xA0) || (b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE)) {
                fCurrentChunk = saveChunk;
                fCurrentIndex = saveIndex;
                fCurrentOffset = saveOffset;
                fMostRecentData = saveChunk.toByteArray();
                fMostRecentByte = b0;
                return false;
            }
            loadNextByte();
            return true;
        }
        int b3 = loadNextByte();  // 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
        // ch = ((0x0f & b0)<<18) + ((0x3f & b1)<<12) + ((0x3f & b2)<<6) + (0x3f & b3); // u uuuu zzzz yyyy yyxx xxxx (0x10000 to 0x1ffff)
        // if (ch >= 0x110000)
        if (b0 > 0xF4 || (b0 == 0xF4 && b1 >= 0x90)) {
            fCurrentChunk = saveChunk;
            fCurrentIndex = saveIndex;
            fCurrentOffset = saveOffset;
            fMostRecentData = saveChunk.toByteArray();
            fMostRecentByte = b0;
            return false;
        }
        loadNextByte();
        return true;
    }
    private int copyAsciiCharData() throws Exception {
        int srcIndex = fCurrentIndex;
        int offset = fCurrentOffset - srcIndex;
        byte[] data = fMostRecentData;
        int dstIndex = fCharDataLength;
        boolean skiplf = false;
        while (true) {
            int ch;
            try {
                ch = data[srcIndex] & 0xFF;
            } catch (ArrayIndexOutOfBoundsException ex) {
                offset += srcIndex;
                slowLoadNextByte();
                srcIndex = 0;
                data = fMostRecentData;
                ch = data[srcIndex] & 0xFF;
            }
            if (ch >= 0x80) {
                fCurrentOffset = offset + srcIndex;
                fCurrentIndex = srcIndex;
                fMostRecentByte = ch;
                return ch;
            }
            if (XMLCharacterProperties.fgAsciiCharData[ch] == 0) {
                fCharacterCounter++;
                skiplf = false;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                if (skiplf) {
                    skiplf = false;
                    srcIndex++;
                    continue;
                }
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
                skiplf = true;
                ch = 0x0A;
            } else {
                fCurrentOffset = offset + srcIndex;
                fCurrentIndex = srcIndex;
                fMostRecentByte = ch;
                return ch;
            }
            srcIndex++;
            try {
                fCharacters[fCharDataLength] = (char)ch;
                fCharDataLength++;
            } catch (ArrayIndexOutOfBoundsException ex) {
                slowAppendCharData(ch);
            }
        }
    }
    private int skipAsciiCharData() throws Exception {
        int srcIndex = fCurrentIndex;
        int offset = fCurrentOffset - srcIndex;
        byte[] data = fMostRecentData;
        while (true) {
            int ch;
            try {
                ch = data[srcIndex] & 0xFF;
            } catch (ArrayIndexOutOfBoundsException ex) {
                offset += srcIndex;
                slowLoadNextByte();
                srcIndex = 0;
                data = fMostRecentData;
                ch = data[srcIndex] & 0xFF;
            }
            if (ch >= 0x80) {
                fCurrentOffset = offset + srcIndex;
                fCurrentIndex = srcIndex;
                fMostRecentByte = ch;
                return ch;
            }
            if (XMLCharacterProperties.fgAsciiCharData[ch] == 0) {
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
            } else {
                fCurrentOffset = offset + srcIndex;
                fCurrentIndex = srcIndex;
                fMostRecentByte = ch;
                return ch;
            }
            srcIndex++;
        }
    }
    private char[] fCharacters = new char[UTF8DataChunk.CHUNK_SIZE];
    private int fCharDataLength = 0;
    private void appendCharData(int ch) throws Exception {
        try {
            fCharacters[fCharDataLength] = (char)ch;
            fCharDataLength++;
        } catch (ArrayIndexOutOfBoundsException ex) {
            slowAppendCharData(ch);
        }
    }
    private void slowAppendCharData(int ch) throws Exception {
        // flush the buffer...
        characters(0, fCharDataLength); /* DEFECT !! whitespace this long is unlikely, but possible */
        fCharDataLength = 0;
        fCharacters[fCharDataLength++] = (char)ch;
    }
    private void characters(int offset, int endOffset) throws Exception {
        //
        // REVISIT - need more up front bounds checking code of params...
        //
        if (!fSendCharDataAsCharArray) {
            int stringIndex = addString(offset, endOffset - offset);
            fCharDataHandler.processCharacters(stringIndex);
            return;
        }
        fCharDataHandler.processCharacters(fCharacters, 0, fCharDataLength);
    }
    private void whitespace(int offset, int endOffset) throws Exception {
        //
        // REVISIT - need more up front bounds checking code of params...
        //
        if (!fSendCharDataAsCharArray) {
            int stringIndex = addString(offset, endOffset - offset);
            fCharDataHandler.processWhitespace(stringIndex);
            return;
        }
        fCharDataHandler.processWhitespace(fCharacters, 0, fCharDataLength);
    }
    //
    //
    //
    private static final char[] cdata_string = { 'C','D','A','T','A','[' };
    private StringPool.CharArrayRange fCharArrayRange = null;
    private InputStream fInputStream = null;
    private StringPool fStringPool = null;
    private UTF8DataChunk fCurrentChunk = null;
    private int fCurrentIndex = 0;
    private byte[] fMostRecentData = null;
    private int fMostRecentByte = 0;
    private int fLength = 0;
    private boolean fCalledCharPropInit = false;
    private boolean fCallClearPreviousChunk = true;
    //
    //
    //
    private int fillCurrentChunk() throws Exception {
        byte[] buf = fCurrentChunk.toByteArray();
        if (fInputStream == null) {
            if (buf == null)
                buf = new byte[1];
            buf[0] = 0;
            fMostRecentData = buf;
            fCurrentIndex = 0;
            fCurrentChunk.setByteArray(fMostRecentData);
            return (fMostRecentByte = fMostRecentData[0] & 0xFF);
        }
        if (buf == null)
            buf = new byte[UTF8DataChunk.CHUNK_SIZE];
        int offset = 0;
        int capacity = UTF8DataChunk.CHUNK_SIZE;
        int result = 0;
        do {
            try {
                result = fInputStream.read(buf, offset, capacity);
            } catch (java.io.IOException ex) {
                result = -1;
            }
            if (result == -1) {
                //
                // We have reached the end of the stream.
                //
                fInputStream.close();
                fInputStream = null;
                try {
                    buf[offset] = 0;
                } catch (ArrayIndexOutOfBoundsException ex) {
                }
                break;
            }
            if (result > 0) {
                offset += result;
                capacity -= result;
            }
        } while (capacity > 0);
        fMostRecentData = buf;
        fLength += offset;
        fCurrentIndex = 0;
        fCurrentChunk.setByteArray(fMostRecentData);
        return (fMostRecentByte = fMostRecentData[0] & 0xFF);
    }
}
"
org/apache/xerces/utils/SymbolCache.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

/**
 *
 * @version
 */
public final class SymbolCache {
    //
    // Symbol Cache
    //
    public static final int CHAR_OFFSET = 0;
    public static final int INDEX_OFFSET = 1;
    public static final int NEXT_OFFSET = 2;
    public static final int CACHE_RECORD_SIZE = 3;
    //
    public static final int INITIAL_CACHE_RECORD_COUNT = 4; // start with 4 entries per level
    //
    public char[] fSymbolChars = new char[8192];
    public int fSymbolCharsOffset = 0;
    public int[][] fCacheLines = new int[8][];
    public int fCacheLineCount = 0;
    //
    //
    //
    public SymbolCache() {
        fCacheLines[fCacheLineCount++] = new int[1+(INITIAL_CACHE_RECORD_COUNT*CACHE_RECORD_SIZE)];
    }
    public void reset() {
        fSymbolCharsOffset = 0;
        fCacheLineCount = 0;
        fCacheLines[fCacheLineCount++] = new int[1+(INITIAL_CACHE_RECORD_COUNT*CACHE_RECORD_SIZE)];
    }
    //
    //
    //
    public char[] getSymbolChars() {
        return fSymbolChars;
    }
    //
    // Symbol interfaces
    //
    public String createSymbol(int symbolHandle, int startOffset, int entry, int[] entries, int offset) {
        int slen = fSymbolCharsOffset - startOffset;
        String str = new String(fSymbolChars, startOffset, slen);
        try {
            entries[offset + SymbolCache.INDEX_OFFSET] = symbolHandle;
        } catch (ArrayIndexOutOfBoundsException ex) {
            throw new RuntimeException(""UTL001 untested"");
        }
        return str;
    }
    public int addSymbolToCache(String str, int slen, int symbolHandle) {
        int charsOffset = fSymbolCharsOffset;
        if (slen == 0) // EMPTY_STRING cannot be a legal ""symbol""
            return charsOffset;
        int strIndex = 0;
        char ch = str.charAt(strIndex++);
        try {
            fSymbolChars[fSymbolCharsOffset] = ch;
        } catch (ArrayIndexOutOfBoundsException ex) {
            char[] newChars = new char[fSymbolChars.length * 2];
            System.arraycopy(fSymbolChars, 0, newChars, 0, fSymbolChars.length);
            fSymbolChars = newChars;
            fSymbolChars[fSymbolCharsOffset] = ch;
        }
        fSymbolCharsOffset++;
        int entry = 0;
        int[] entries = fCacheLines[entry];
        int count = entries[0];
        int i = 0;
        int offset = 1;
        while (true) {
            if (i == count)
                break;
            if (entries[offset + CHAR_OFFSET] != ch) {
                i++;
                offset += CACHE_RECORD_SIZE;
                continue;
            }
            if (strIndex == slen) {
                if (entries[offset + INDEX_OFFSET] != -1) {
                    // How did we miss this during lookup ?
                    throw new RuntimeException(""addSymbolToCache"");
                }
                entries[offset + INDEX_OFFSET] = symbolHandle;
                return charsOffset;
            }
            ch = str.charAt(strIndex++);
            try {
                fSymbolChars[fSymbolCharsOffset] = ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                char[] newChars = new char[fSymbolChars.length * 2];
                System.arraycopy(fSymbolChars, 0, newChars, 0, fSymbolChars.length);
                fSymbolChars = newChars;
                fSymbolChars[fSymbolCharsOffset] = ch;
            }
            fSymbolCharsOffset++;
            entry = entries[offset + NEXT_OFFSET];
            try {
                entries = fCacheLines[entry];
            } catch (ArrayIndexOutOfBoundsException ex) {
                if (entry == -1) {
                    entry = fCacheLineCount++;
                    entries[offset + NEXT_OFFSET] = entry;
                    entries = new int[1+(INITIAL_CACHE_RECORD_COUNT*CACHE_RECORD_SIZE)];
                    try {
                        fCacheLines[entry] = entries;
                    } catch (ArrayIndexOutOfBoundsException ex2) {
                        int[][] newCache = new int[entry * 2][];
                        System.arraycopy(fCacheLines, 0, newCache, 0, entry);
                        fCacheLines = newCache;
                        fCacheLines[entry] = entries;
                    }
                } else {
                    entries = fCacheLines[entry];
                    throw new RuntimeException(""UTL001 untested"");
                }
            }
            count = entries[0];
            i = 0;
            offset = 1;
        }
        while (true) {
            entries[0]++;
            try {
                entries[offset + CHAR_OFFSET] = ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                int newSize = 1 + ((offset - 1) * 2);
                int[] newEntries = new int[newSize];
                System.arraycopy(entries, 0, newEntries, 0, offset);
                fCacheLines[entry] = entries = newEntries;
                entries[offset + CHAR_OFFSET] = ch;
            }
            if (strIndex == slen) {
                entries[offset + INDEX_OFFSET] = symbolHandle;
                entries[offset + NEXT_OFFSET] = -1;
                break;
            }
            entry = fCacheLineCount++;
            entries[offset + INDEX_OFFSET] = -1;
            entries[offset + NEXT_OFFSET] = entry;
            entries = new int[1+(INITIAL_CACHE_RECORD_COUNT*CACHE_RECORD_SIZE)];
            try {
                fCacheLines[entry] = entries;
            } catch (ArrayIndexOutOfBoundsException ex) {
                int[][] newCache = new int[entry * 2][];
                System.arraycopy(fCacheLines, 0, newCache, 0, entry);
                fCacheLines = newCache;
                fCacheLines[entry] = entries;
            }
            offset = 1;
            ch = str.charAt(strIndex++);
            try {
                fSymbolChars[fSymbolCharsOffset] = ch;
            } catch (ArrayIndexOutOfBoundsException ex) {
                char[] newChars = new char[fSymbolChars.length * 2];
                System.arraycopy(fSymbolChars, 0, newChars, 0, fSymbolChars.length);
                fSymbolChars = newChars;
                fSymbolChars[fSymbolCharsOffset] = ch;
            }
            fSymbolCharsOffset++;
        }
        return charsOffset;
    }
    public void updateCacheLine(int charsOffset, int totalMisses, int length) {
//System.err.println(""found symbol "" + toString(symbolIndex) + "" after "" + totalMisses + "" total misses ("" + (totalMisses/length) + "" misses per character)."");
        int entry = 0;
        int[] entries = fCacheLines[0];
        int ch = fSymbolChars[charsOffset++];
        int count = entries[0];
        int offset = 1 + ((count - 1) * CACHE_RECORD_SIZE);
        int misses = 0;
        while (true) {
            if (ch != entries[offset + CHAR_OFFSET]) {
                offset -= CACHE_RECORD_SIZE;
                misses++;
                continue;
            }
            if (misses > 4) {
                int symIndex = entries[offset + INDEX_OFFSET];
                int nextIndex = entries[offset + NEXT_OFFSET];
                System.arraycopy(entries, offset + CACHE_RECORD_SIZE, entries, offset, misses * CACHE_RECORD_SIZE);
                offset = 1 + ((count - 1) * CACHE_RECORD_SIZE);
                entries[offset + CHAR_OFFSET] = ch;
                entries[offset + INDEX_OFFSET] = symIndex;
                entries[offset + NEXT_OFFSET] = nextIndex;
            }
            if (--length == 0)
                break;
            entry = entries[offset + NEXT_OFFSET];
            entries = fCacheLines[entry];
            ch = fSymbolChars[charsOffset++];
            count = entries[0];
            offset = 1 + ((count - 1) * CACHE_RECORD_SIZE);
            misses = 0;
        }
    }
}
"
org/xml/sax/AttributeList.java,true,"// SAX Attribute List Interface.
// No warranty; no copyright -- use this as you will.
// $Id: AttributeList.java,v 1.4 2000/05/05 17:44:56 david Exp $

package org.xml.sax;

/**
 * Interface for an element's attribute specifications.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This is the original SAX1 interface for reporting an element's
 * attributes.  Unlike the new {@link org.xml.sax.Attributes Attributes}
 * interface, it does not support Namespace-related information.</p>
 *
 * <p>When an attribute list is supplied as part of a
 * {@link org.xml.sax.DocumentHandler#startElement startElement}
 * event, the list will return valid results only during the
 * scope of the event; once the event handler returns control
 * to the parser, the attribute list is invalid.  To save a
 * persistent copy of the attribute list, use the SAX1
 * {@link org.xml.sax.helpers.AttributeListImpl AttributeListImpl}
 * helper class.</p>
 *
 * <p>An attribute list includes only attributes that have been
 * specified or defaulted: #IMPLIED attributes will not be included.</p>
 *
 * <p>There are two ways for the SAX application to obtain information
 * from the AttributeList.  First, it can iterate through the entire
 * list:</p>
 *
 * <pre>
 * public void startElement (String name, AttributeList atts) {
 *   for (int i = 0; i < atts.getLength(); i++) {
 *     String name = atts.getName(i);
 *     String type = atts.getType(i);
 *     String value = atts.getValue(i);
 *     [...]
 *   }
 * }
 * </pre>
 *
 * <p>(Note that the result of getLength() will be zero if there
 * are no attributes.)
 *
 * <p>As an alternative, the application can request the value or
 * type of specific attributes:</p>
 *
 * <pre>
 * public void startElement (String name, AttributeList atts) {
 *   String identifier = atts.getValue(""id"");
 *   String label = atts.getValue(""label"");
 *   [...]
 * }
 * </pre>
 *
 * @deprecated This interface has been replaced by the SAX2
 *             {@link org.xml.sax.Attributes Attributes}
 *             interface, which includes Namespace support.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.DocumentHandler#startElement startElement
 * @see org.xml.sax.helpers.AttributeListImpl AttributeListImpl
 */
public interface AttributeList {


    ////////////////////////////////////////////////////////////////////
    // Iteration methods.
    ////////////////////////////////////////////////////////////////////
    

    /**
     * Return the number of attributes in this list.
     *
     * <p>The SAX parser may provide attributes in any
     * arbitrary order, regardless of the order in which they were
     * declared or specified.  The number of attributes may be
     * zero.</p>
     *
     * @return The number of attributes in the list.  
     */
    public abstract int getLength ();
    
    
    /**
     * Return the name of an attribute in this list (by position).
     *
     * <p>The names must be unique: the SAX parser shall not include the
     * same attribute twice.  Attributes without values (those declared
     * #IMPLIED without a value specified in the start tag) will be
     * omitted from the list.</p>
     *
     * <p>If the attribute name has a namespace prefix, the prefix
     * will still be attached.</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The name of the indexed attribute, or null
     *         if the index is out of range.
     * @see #getLength 
     */
    public abstract String getName (int i);
    
    
    /**
     * Return the type of an attribute in the list (by position).
     *
     * <p>The attribute type is one of the strings ""CDATA"", ""ID"",
     * ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"", ""ENTITY"", ""ENTITIES"",
     * or ""NOTATION"" (always in upper case).</p>
     *
     * <p>If the parser has not read a declaration for the attribute,
     * or if the parser does not report attribute types, then it must
     * return the value ""CDATA"" as stated in the XML 1.0 Recommentation
     * (clause 3.3.3, ""Attribute-Value Normalization"").</p>
     *
     * <p>For an enumerated attribute that is not a notation, the
     * parser will report the type as ""NMTOKEN"".</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The attribute type as a string, or
     *         null if the index is out of range.
     * @see #getLength 
     * @see #getType(java.lang.String)
     */
    public abstract String getType (int i);
    
    
    /**
     * Return the value of an attribute in the list (by position).
     *
     * <p>If the attribute value is a list of tokens (IDREFS,
     * ENTITIES, or NMTOKENS), the tokens will be concatenated
     * into a single string separated by whitespace.</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The attribute value as a string, or
     *         null if the index is out of range.
     * @see #getLength
     * @see #getValue(java.lang.String)
     */
    public abstract String getValue (int i);



    ////////////////////////////////////////////////////////////////////
    // Lookup methods.
    ////////////////////////////////////////////////////////////////////
    
    
    /**
     * Return the type of an attribute in the list (by name).
     *
     * <p>The return value is the same as the return value for
     * getType(int).</p>
     *
     * <p>If the attribute name has a namespace prefix in the document,
     * the application must include the prefix here.</p>
     *
     * @param name The name of the attribute.
     * @return The attribute type as a string, or null if no
     *         such attribute exists.
     * @see #getType(int)
     */
    public abstract String getType (String name);
    
    
    /**
     * Return the value of an attribute in the list (by name).
     *
     * <p>The return value is the same as the return value for
     * getValue(int).</p>
     *
     * <p>If the attribute name has a namespace prefix in the document,
     * the application must include the prefix here.</p>
     *
     * @param i The index of the attribute in the list.
     * @return The attribute value as a string, or null if
     *         no such attribute exists.
     * @see #getValue(int)
     */
    public abstract String getValue (String name);
    
}

// end of AttributeList.java
"
org/apache/xerces/dom/DOMImplementationImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * The DOMImplementation class is description of a particular
 * implementation of the Document Object Model. As such its data is
 * static, shared by all instances of this implementation.
 * <P>
 * The DOM API requires that it be a real object rather than static
 * methods. However, there's nothing that says it can't be a singleton,
 * so that's how I've implemented it.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DOMImplementationImpl  
    implements DOMImplementation {

    //
    // Data
    //

    // static

    /** Dom implementation singleton. */
    static DOMImplementationImpl singleton = new DOMImplementationImpl();

    //
    // DOMImplementation methods
    //

    /** 
     * Test if the DOM implementation supports a specific ""feature"" --
     * currently meaning language and level thereof.
     * 
     * @param feature      The package name of the feature to test.
     * In Level 1, supported values are ""HTML"" and ""XML"" (case-insensitive).
     * At this writing, org.apache.xerces.dom supports only XML.
     *
     * @param version      The version number of the feature being tested.
     * This is interpreted as ""Version of the DOM API supported for the
     * specified Feature"", and in Level 1 should be ""1.0""
     *
     * @returns    true iff this implementation is compatable with the
     * specified feature and version.
     */
    public boolean hasFeature(String feature, String version) {

        // Currently, we support only XML Level 1 version 1.0
        return 
            (feature.equalsIgnoreCase(""XML"") 
            && (version == null
		|| version.equals(""1.0"")
		|| version.equals(""2.0"")))
         || (feature.equalsIgnoreCase(""Events"") 
	     && (version == null
		 || version.equals(""2.0"")))
         || (feature.equalsIgnoreCase(""MutationEvents"") 
	     && (version == null
		 || version.equals(""2.0"")))
         || (feature.equalsIgnoreCase(""Traversal"") 
	     && (version == null
		 || version.equals(""2.0"")))
            ;

    } // hasFeature(String,String):boolean

    //
    // Public methods
    //

    /** NON-DOM: Obtain and return the single shared object */
    public static DOMImplementation getDOMImplementation() {
        return singleton;
    }  
    
    /**
     * Introduced in DOM Level 2. <p>
     * 
     * Creates an empty DocumentType node.
     *
     * @param qualifiedName The qualified name of the document type to be created. 
     * @param publicID The document type public identifier.
     * @param systemID The document type system identifier.
     * @since WD-DOM-Level-2-19990923
     */
    public DocumentType       createDocumentType(String qualifiedName, 
                                                 String publicID, 
                                                 String systemID)
    {
    	if (!DocumentImpl.isXMLName(qualifiedName)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }
        int index = qualifiedName.indexOf(':');
        if (index == 0 || index == qualifiedName.length() - 1) {
	    throw new DOMExceptionImpl(DOMException.NAMESPACE_ERR, 
				       ""DOM003 Namespace error"");
	}
    	return new DocumentTypeImpl(null, qualifiedName, publicID, systemID);
    }
    /**
     * Introduced in DOM Level 2. <p>
     * 
     * Creates an XML Document object of the specified type with its document
     * element.
     *
     * @param namespaceURI     The namespace URI of the document
     *                         element to create, or null. 
     * @param qualifiedName    The qualified name of the document
     *                         element to create, or null. 
     * @param doctype          The type of document to be created or null.<p>
     *
     *                         When doctype is not null, its
     *                         Node.ownerDocument attribute is set to
     *                         the document being created.
     * @return Document        A new Document object.
     * @throws DOMException    WRONG_DOCUMENT_ERR: Raised if doctype has
     *                         already been used with a different document.
     * @since WD-DOM-Level-2-19990923
     */
    public Document           createDocument(String namespaceURI, 
                                             String qualifiedName, 
                                             DocumentType doctype)
                                             throws DOMException
    {
    	if (doctype != null && doctype.getOwnerDocument() != null) {
    		throw new DOMExceptionImpl(DOMException.WRONG_DOCUMENT_ERR, 
    		                           ""DOM005 Wrong document"");
        }
        DocumentImpl doc = new DocumentImpl(doctype);
        //((DocumentTypeImpl)doctype).ownerDocument = doc;
        Element e = doc.createElementNS( namespaceURI, qualifiedName);
        doc.appendChild(e);
        return doc;
    }

} // class DOMImplementationImpl
"
org/apache/xerces/dom/DocumentImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.w3c.dom.*;

import org.w3c.dom.traversal.*;
import org.w3c.dom.range.*;
import org.w3c.dom.events.*;
import org.apache.xerces.dom.events.*;

/**
 * The Document interface represents the entire HTML or XML document.
 * Conceptually, it is the root of the document tree, and provides the
 * primary access to the document's data.
 * <P>
 * Since elements, text nodes, comments, processing instructions,
 * etc. cannot exist outside the context of a Document, the Document
 * interface also contains the factory methods needed to create these
 * objects. The Node objects created have a ownerDocument attribute
 * which associates them with the Document within whose context they
 * were created.
 * <p>
 * The DocumentImpl class also implements the DOM Level 2 DocumentTraversal
 * interface. This interface is comprised of factory methods needed to
 * create NodeIterators and TreeWalkers. The process of creating these
 * traversal objects also adds these references to this document.
 * After finishing with the It is important to remove the traversal objects
 * using the remove methods in this implementation. This allows the release of
 * all the references from the traversal objects to the DOM Nodes.
 * <p>
 * <b>Note:</b> When any node in the document is serialized, the
 * entire document is serialized along with it.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DocumentImpl
    extends ParentNode
    implements Document, DocumentTraversal, DocumentEvent {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 515687835542616694L;

    //
    // Data
    //

    // document information

    /** Document type. */
    protected DocumentTypeImpl docType;

    /** Document element. */
    protected ElementImpl docElement;

    /** Identifiers. */
    protected Hashtable identifiers;

    /** Iterators */
    // REVISIT: Should this be transient? -Ac
    protected Vector iterators;

    /** Tree walkers */
    // REVISIT: Should this be transient? -Ac
    protected Vector treeWalkers;
	
     /** Ranges */
    // REVISIT: Should this be transient? -Ac
    protected Vector ranges;
    
    /** Table for quick check of child insertion. */
    protected static int[] kidOK;

    /** Table for quick check of child insertion. */
    protected Hashtable userData;

    // experimental

    /** Allow grammar access. */
    protected boolean allowGrammarAccess;

    /** Bypass error checking. */
    protected boolean errorChecking = true;

    //
    // Static initialization
    //

    static {

        kidOK = new int[13];

        kidOK[DOCUMENT_NODE] =
            1 << ELEMENT_NODE | 1 << PROCESSING_INSTRUCTION_NODE |
            1 << COMMENT_NODE | 1 << DOCUMENT_TYPE_NODE;
			
        kidOK[DOCUMENT_FRAGMENT_NODE] =
        kidOK[ENTITY_NODE] =
        kidOK[ENTITY_REFERENCE_NODE] =
        kidOK[ELEMENT_NODE] =
            1 << ELEMENT_NODE | 1 << PROCESSING_INSTRUCTION_NODE |
            1 << COMMENT_NODE | 1 << TEXT_NODE |
            1 << CDATA_SECTION_NODE | 1 << ENTITY_REFERENCE_NODE ;
			
			
        kidOK[ATTRIBUTE_NODE] =
            1 << TEXT_NODE | 1 << ENTITY_REFERENCE_NODE;
			
        kidOK[DOCUMENT_TYPE_NODE] =
        kidOK[PROCESSING_INSTRUCTION_NODE] =
        kidOK[COMMENT_NODE] =
        kidOK[TEXT_NODE] =
        kidOK[CDATA_SECTION_NODE] =
        kidOK[NOTATION_NODE] =
            0;

    } // static

    //
    // Constructors
    //

    /**
     * NON-DOM: Actually creating a Document is outside the DOM's spec,
     * since it has to operate in terms of a particular implementation.
     */
    public DocumentImpl() {
        this(false);
    }

    /** Experimental constructor. */
    public DocumentImpl(boolean grammarAccess) {
        super(null);
        ownerDocument = this;
        allowGrammarAccess = grammarAccess;
    }

    // For DOM2: support.
    // The createDocument factory method is in DOMImplementation.
    public DocumentImpl(DocumentType doctype)
    {
        this(doctype, false);
    }
    
    /** Experimental constructor. */
    public DocumentImpl(DocumentType doctype, boolean grammarAccess) {
        this(grammarAccess);
        this.docType = (DocumentTypeImpl)doctype;
        if (this.docType != null) {
            docType.ownerDocument = this;
        }
    }

    //
    // Node methods
    //

    // even though ownerDocument refers to this in this implementation
    // the DOM Level 2 spec says it must be null, so make it appear so
    final public Document getOwnerDocument() {
        return null;
    }

    /** Returns the node type. */
    public short getNodeType() {
        return Node.DOCUMENT_NODE;
    }

    /** Returns the node name. */
    public String getNodeName() {
        return ""#document"";
    }

    /**
     * Deep-clone a document, including fixing ownerDoc for the cloned
     * children. Note that this requires bypassing the WRONG_DOCUMENT_ERR
     * protection. I've chosen to implement it by calling importNode
     * which is DOM Level 2.
     *
     * @return org.w3c.dom.Node
     * @param deep boolean, iff true replicate children
     */
    public Node cloneNode(boolean deep) {

        // clone the node itself
        DocumentImpl newdoc = new DocumentImpl();

        // then the children by importing them
        if (deep) {
            for (ChildNode n = firstChild; n != null; n = n.nextSibling) {
                newdoc.appendChild(newdoc.importNode(n, true));
            }
        }

        // REVISIT: What to do about identifiers that are cloned? -Ac
        //newdoc.identifiers = (Hashtable)identifiers.clone(); // WRONG!
        newdoc.identifiers = null;
        newdoc.iterators = null;
        newdoc.treeWalkers = null;
        newdoc.ranges = null;
        newdoc.userData = null;

        // experimental
        newdoc.allowGrammarAccess = allowGrammarAccess;
        newdoc.errorChecking = errorChecking;

        // return new document
    	return newdoc;

    } // cloneNode(boolean):Node

    /**
     * Since a Document may contain at most one top-level Element child,
  	 * and at most one DocumentType declaraction, we need to subclass our
  	 * add-children methods to implement this constraint.
	 * Since appendChild() is implemented as insertBefore(,null),
	 * altering the latter fixes both.
  	 * <p>
  	 * While I'm doing so, I've taken advantage of the opportunity to
  	 * cache documentElement and docType so we don't have to
  	 * search for them.
	 */
    public Node insertBefore(Node newChild, Node refChild)
        throws DOMException {

    	// Only one such child permitted
        int type = newChild.getNodeType();
        if (errorChecking) {
            if((type == Node.ELEMENT_NODE && docElement != null) ||
               (type == Node.DOCUMENT_TYPE_NODE && docType != null)) {
                throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR,
                                           ""DOM006 Hierarchy request error"");
            }
        }

    	super.insertBefore(newChild,refChild);

    	// If insert succeeded, cache the kid appropriately
        if (type == Node.ELEMENT_NODE) {
    	    docElement = (ElementImpl)newChild;
        }
        else if (type == Node.DOCUMENT_TYPE_NODE) {
    	    docType=(DocumentTypeImpl)newChild;
        }

    	return newChild;

    } // insertBefore(Node,Node):Node

    /**
     * Since insertBefore caches the docElement (and, currently, docType),
	 * removeChild has to know how to undo the cache
     */
    public Node removeChild(Node oldChild)
        throws DOMException {
	    super.removeChild(oldChild);
	
    	// If remove succeeded, un-cache the kid appropriately
        int type = oldChild.getNodeType();
        if(type == Node.ELEMENT_NODE) {
    	    docElement = null;
        }
        else if (type == Node.DOCUMENT_TYPE_NODE) {
    	    docType=null;
        }

    	return oldChild;

    }   // removeChild(Node):Node

    //
    // Document methods
    //

    // factory methods

    /**
     * Factory method; creates an Attribute having this Document as its
	 * OwnerDoc.
     *
	 * @param name The name of the attribute. Note that the attribute's value
	 * is _not_ established at the factory; remember to set it!
     *
	 * @throws DOMException(INVALID_NAME_ERR) if the attribute name is not
	 * acceptable.
     */
    public Attr createAttribute(String name)
        throws DOMException {

    	if(errorChecking && !isXMLName(name)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR,
    		                           ""DOM002 Illegal character"");
        }

    	return new AttrImpl(this, name);

    } // createAttribute(String):Attr

    /**
     * Factory method; creates a CDATASection having this Document as
	 * its OwnerDoc.
     *
	 * @param data The initial contents of the CDATA
     *
	 * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents. (HTML
	 * not yet implemented.)
	 */
    public CDATASection createCDATASection(String data)
	    throws DOMException {
	    return new CDATASectionImpl(this, data);
    }

    /**
     * Factory method; creates a Comment having this Document as its
     * OwnerDoc.
     *
     * @param data The initial contents of the Comment. */
    public Comment createComment(String data) {
	    return new CommentImpl(this, data);
    }

    /**
     * Factory method; creates a DocumentFragment having this Document
	 * as its OwnerDoc.
     */
    public DocumentFragment createDocumentFragment() {
	    return new DocumentFragmentImpl(this);
    }

    /**
     * Factory method; creates an Element having this Document
	 * as its OwnerDoc.
     *
	 * @param tagName The name of the element type to instantiate. For
	 * XML, this is case-sensitive. For HTML, the tagName parameter may
	 * be provided in any case, but it must be mapped to the canonical
	 * uppercase form by the DOM implementation.
     *
	 * @throws DOMException(INVALID_NAME_ERR) if the tag name is not
	 * acceptable.
	 */
    public Element createElement(String tagName)
        throws DOMException {

    	if (errorChecking && !isXMLName(tagName)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }

    	return new ElementImpl(this, tagName);

    } // createElement(String):Element

    /**
     * Factory method; creates an EntityReference having this Document
     * as its OwnerDoc.
     *
     * @param name The name of the Entity we wish to refer to
     *
     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
     * nonstandard entities are not permitted. (HTML not yet
     * implemented.)
     */
    public EntityReference createEntityReference(String name)
        throws DOMException {

    	if (errorChecking && !isXMLName(name)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }

    	return new EntityReferenceImpl(this, name);

    } // createEntityReference(String):EntityReference

    /**
     * Factory method; creates a ProcessingInstruction having this Document
	 * as its OwnerDoc.
     *
	 * @param target The target ""processor channel""
	 * @param data Parameter string to be passed to the target.
     *
	 * @throws DOMException(INVALID_NAME_ERR) if the target name is not
	 * acceptable.
     *
	 * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents. (HTML
	 * not yet implemented.)
	 */
    public ProcessingInstruction createProcessingInstruction(String target, String data)
        throws DOMException {

    	if(errorChecking && !isXMLName(target)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR,
    		                           ""DOM002 Illegal character"");
        }

    	return new ProcessingInstructionImpl(this, target, data);

    } // createProcessingInstruction(String,String):ProcessingInstruction

    /**
     * Factory method; creates a Text node having this Document as its
	 * OwnerDoc.
     *
	 * @param data The initial contents of the Text.
     */
    public Text createTextNode(String data) {
        return new TextImpl(this, data);
    }

    // other document methods

    /**
     * For XML, this provides access to the Document Type Definition.
	 * For HTML documents, and XML documents which don't specify a DTD,
	 * it will be null.
	 */
    public DocumentType getDoctype() {
        if (syncChildren()) {
            synchronizeChildren();
        }
	    return docType;
    }

    /**
     * Convenience method, allowing direct access to the child node
	 * which is considered the root of the actual document content. For
	 * HTML, where it is legal to have more than one Element at the top
	 * level of the document, we pick the one with the tagName
	 * ""HTML"". For XML there should be only one top-level
     *
	 * (HTML not yet supported.)
     */
    public Element getDocumentElement() {
        if (syncChildren()) {
            synchronizeChildren();
        }
	    return docElement;
    }

    /**
     * Return a <em>live</em> collection of all descendent Elements (not just
	 * immediate children) having the specified tag name.
     *
	 * @param tagname The type of Element we want to gather. ""*"" will be
	 * taken as a wildcard, meaning ""all elements in the document.""
     *
	 * @see DeepNodeListImpl
	 */
    public NodeList getElementsByTagName(String tagname) {
	    return new DeepNodeListImpl(this,tagname);
    }

    /**
     * Retrieve information describing the abilities of this particular
	 * DOM implementation. Intended to support applications that may be
	 * using DOMs retrieved from several different sources, potentially
	 * with different underlying representations.
	 */
    public DOMImplementation getImplementation() {
        // Currently implemented as a singleton, since it's hardcoded
        // information anyway.
        return DOMImplementationImpl.getDOMImplementation();
    }

    //
    // Public methods
    //

    // properties

    /** 
     * Sets whether the DOM implementation performs error checking
     * upon operations. Turning off error checking only affects
     * the following DOM checks:
     * <ul>
     * <li>Checking strings to make sure that all characters are
     *     legal XML characters
     * <li>Hierarchy checking such as allowed children, checks for
     *     cycles, etc.
     * </ul>
     * <p>
     * Turning off error checking does <em>not</em> turn off the
     * following checks:
     * <ul>
     * <li>Read only checks
     * <li>Checks related to DOM events
     * </ul>
     */
    public void setErrorChecking(boolean check) {
        errorChecking = check;
    }

    /**
     * Returns true if the DOM implementation performs error checking.
     */
    public boolean getErrorChecking() {
        return errorChecking;
    }

    // non-DOM factory methods
    
    /**
     * NON-DOM
     * Factory method; creates a DocumentType having this Document
     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
     * DTD information unspecified.)
     *
     * @param name The name of the Entity we wish to provide a value for.
     *
     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
     * DTDs are not permitted. (HTML not yet implemented.)
     */
    public DocumentType createDocumentType(String qualifiedName,
                                           String publicID,
                                           String systemID)
        throws DOMException {

    	if (errorChecking && !isXMLName(qualifiedName)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }
    	return new DocumentTypeImpl(this, qualifiedName, publicID, systemID);

    } // createDocumentType(String):DocumentType

    /**
     * NON-DOM
     * Factory method; creates an Entity having this Document
     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
     * DTD information unspecified.)
     *
     * @param name The name of the Entity we wish to provide a value for.
     *
     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
     * nonstandard entities are not permitted. (HTML not yet
     * implemented.)
     */
    public Entity createEntity(String name)
        throws DOMException {

        // REVISIT: Should we be checking XML name chars?
        /***
    	if (errorChecking && !isXMLName(name)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }
        /***/

    	return new EntityImpl(this, name);

    } // createEntity(String):Entity

    /**
     * NON-DOM
     * Factory method; creates a Notation having this Document
     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
     * DTD information unspecified.)
     *
     * @param name The name of the Notation we wish to describe
     *
     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
     * notations are not permitted. (HTML not yet
     * implemented.)
     */
    public Notation createNotation(String name)
        throws DOMException {

        // REVISIT: Should we be checking XML name chars?
        /***
    	if (errorChecking && !isXMLName(name)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }
        /***/

    	return new NotationImpl(this, name);

    } // createNotation(String):Notation

    /**
     * NON-DOM Factory method: creates an element definition. Element
     * definitions hold default attribute values.
     */
    public ElementDefinitionImpl createElementDefinition(String name)
        throws DOMException {

        // REVISIT: Should we be checking XML name chars?
        /***
    	if (errorChecking && !isXMLName(name)) {
    		throw new DOMExceptionImpl(DOMException.INVALID_CHARACTER_ERR, 
    		                           ""DOM002 Illegal character"");
        }
        /***/

        return new ElementDefinitionImpl(this, name);

    } // createElementDefinition(String):ElementDefinitionImpl

    // other non-DOM methods

    /**
     * Copies data from the source node. Unlike cloneNode, this
     * _can_ copy data from another document. If the source document is also
     * based on org.apache.xerces.dom, we will attempt to preserve the domimpl-
     * internal data by doing a clone-and-reparent. If not, we will use
     * the source's public methods, and this document's Factory methods,
     * to copy data defined by the DOM interfaces.
     *
     * Its behavior is otherwise similar to that of cloneNode.
     *
     * Attempting to import a Document into another Document is meaningless --
     * a new Document would not improve matters much, and a DocumentFragment
     * couldn't carry the DocumentType child (if any). Best thing we can do
     * is throw a HIERARCHY_REQUEST_ERR.
     *
     * ????? Should we push some of this down to copy-ctors, so
     * subclassed DOMs have the option of special-casing each other
     * (as we do for ourself)?
     */
    public Node importNode(Node source, boolean deep)
        throws DOMException {

    	Node newnode=null;

    	// Sigh. This doesn't work; too many nodes have private data that
    	// would have to be manually tweaked. May be able to add local
    	// shortcuts to each nodetype. Consider ?????
    	// if(source instanceof NodeImpl &&
    	//	!(source instanceof DocumentImpl))
    	// {
    	//  // Can't clone DocumentImpl since it invokes us...
    	//	newnode=(NodeImpl)source.cloneNode(false);
    	//	newnode.ownerDocument=this;
    	//}
    	//else
        int type = source.getNodeType();
    	switch (type) {
    		
            case ELEMENT_NODE: {
		Element newelement;
		if (source.getLocalName() == null) {
		    newelement = createElement(source.getNodeName());
		} else {
		    newelement = createElementNS(source.getNamespaceURI(),
						 source.getNodeName());
		}
		NamedNodeMap srcattr = source.getAttributes();
		if (srcattr != null) {
                    for(int i = 0; i < srcattr.getLength(); i++) {
                        Attr attr = (Attr) srcattr.item(i);
                        if (attr.getSpecified()) { // not a default attribute
                            Attr nattr = (Attr) importNode(attr, true);
                            if (attr.getLocalName() == null)
                                newelement.setAttributeNode(nattr);
                            else
                                newelement.setAttributeNodeNS(nattr);
                        }
                    }
                }
		newnode = newelement;
		break;
            }

            case ATTRIBUTE_NODE: {
		if (source.getLocalName() == null) {
		    newnode = createAttribute(source.getNodeName());
		} else {
		    newnode = createAttributeNS(source.getNamespaceURI(),
						source.getNodeName());
		}
                deep = true;
		// Kids carry value
		break;
            }

	    case TEXT_NODE: {
		newnode = createTextNode(source.getNodeValue());
		break;
            }

	    case CDATA_SECTION_NODE: {
		newnode = createCDATASection(source.getNodeValue());
		break;
            }

    	    case ENTITY_REFERENCE_NODE: {
		newnode = createEntityReference(source.getNodeName());
                // allow deep import temporarily
                ((EntityReferenceImpl)newnode).readOnly(false);
		break;
            }

    	    case ENTITY_NODE: {
		Entity srcentity = (Entity)source;
		EntityImpl newentity =
		    (EntityImpl)createEntity(source.getNodeName());
		newentity.setPublicId(srcentity.getPublicId());
		newentity.setSystemId(srcentity.getSystemId());
		newentity.setNotationName(srcentity.getNotationName());
		// Kids carry additional value
                newentity.readOnly(false); // allow deep import temporarily
		newnode = newentity;
		break;
            }

    	    case PROCESSING_INSTRUCTION_NODE: {
		newnode = createProcessingInstruction(source.getNodeName(),
						      source.getNodeValue());
		break;
            }

    	    case COMMENT_NODE: {
		newnode = createComment(source.getNodeValue());
		break;
            }

    	    case DOCUMENT_TYPE_NODE: {
		DocumentType srcdoctype = (DocumentType)source;
		DocumentTypeImpl newdoctype = (DocumentTypeImpl)
		    createDocumentType(srcdoctype.getNodeName(),
				       srcdoctype.getPublicId(),
				       srcdoctype.getSystemId());
		// Values are on NamedNodeMaps
		NamedNodeMap smap = srcdoctype.getEntities();
		NamedNodeMap tmap = newdoctype.getEntities();
		if(smap != null) {
		    for(int i = 0; i < smap.getLength(); i++) {
			tmap.setNamedItem(importNode(smap.item(i), true));
                    }
                }
		smap = srcdoctype.getNotations();
		tmap = newdoctype.getNotations();
		if (smap != null) {
		    for(int i = 0; i < smap.getLength(); i++) {
			tmap.setNamedItem(importNode(smap.item(i), true));
                    }
                }
		// NOTE: At this time, the DOM definition of DocumentType
		// doesn't cover Elements and their Attributes. domimpl's
		// extentions in that area will not be preserved, even if
		// copying from domimpl to domimpl. We could special-case
		// that here. Arguably we should. Consider. ?????
		newnode = newdoctype;
		break;
            }

    	    case DOCUMENT_FRAGMENT_NODE: {
		newnode = createDocumentFragment();
		// No name, kids carry value
		break;
            }

    	    case NOTATION_NODE: {
		Notation srcnotation = (Notation)source;
		NotationImpl newnotation =
		    (NotationImpl)createNotation(source.getNodeName());
		newnotation.setPublicId(srcnotation.getPublicId());
		newnotation.setSystemId(srcnotation.getSystemId());
		// Kids carry additional value
		newnode = newnotation;
		// No name, no value
		break;
            }

    	    case DOCUMENT_NODE : // Document can't be child of Document
    	    default: {		// Unknown node type
		throw new DOMExceptionImpl(DOMException.HIERARCHY_REQUEST_ERR,
					   ""DOM006 Hierarchy request error"");
            }
        }

    	// If deep, replicate and attach the kids.
    	if (deep) {
	    for (Node srckid = source.getFirstChild();
                 srckid != null;
                 srckid = srckid.getNextSibling()) {
		newnode.appendChild(importNode(srckid, true));
	    }
        }
        if (newnode.getNodeType() == Node.ENTITY_REFERENCE_NODE
            || newnode.getNodeType() == Node.ENTITY_NODE) {
          ((NodeImpl)newnode).setReadOnly(true, true);
        }
    	return newnode;

    } // importNode(Node,boolean):Node

    /**
     * NON-DOM:
     * Change the node's ownerDocument, and its subtree, to this Document
     *
     * @param source The node to move in to this document.
     * @exception NOT_SUPPORTED_ERR DOMException, raised if the implementation
     * cannot handle the request, such as when the source node comes from a
     * different DOMImplementation
     * @see DocumentImpl.importNode
     **/
    public void adoptNode(Node source) {
	if (!(source instanceof NodeImpl)) {
	    throw new DOMExceptionImpl(DOMException.NOT_SUPPORTED_ERR,
		      ""cannot move a node in from another DOM implementation"");
	}
	Node parent = source.getParentNode();
	if (parent != null) {
	    parent.removeChild(source);
	}
	((NodeImpl)source).setOwnerDocument(this);
    }

    // identifier maintenence
    /**
     *  Introduced in DOM Level 2 
     *  Returns the Element whose ID is given by elementId. If no such element
     *  exists, returns null. Behavior is not defined if more than one element has this ID.
     *  <p>
     *  Note: The DOM implementation must have information that says which
     *  attributes are of type ID. Attributes with the name ""ID"" are not of type ID unless
     *  so defined. Implementations that do not know whether attributes are of type ID
     *  or not are expected to return null.
     * @see #getIdentifier
     */
    public Element getElementById(String elementId) {
        return getIdentifier(elementId);
    }

    /**
     * Registers an identifier name with a specified element node.
     * If the identifier is already registered, the new element
     * node replaces the previous node. If the specified element
     * node is null, removeIdentifier() is called.
     *
     * @see #getIdentifier
     * @see #removeIdentifier
     */
    public void putIdentifier(String idName, Element element) {

        if (element == null) {
            removeIdentifier(idName);
            return;
        }

        if (syncData()) {
            synchronizeData();
        }

        if (identifiers == null) {
            identifiers = new Hashtable();
        }

        identifiers.put(idName, element);

    } // putIdentifier(String,Element)

    /**
     * Returns a previously registered element with the specified
     * identifier name, or null if no element is registered.
     *
     * @see #putIdentifier
     * @see #removeIdentifier
     */
    public Element getIdentifier(String idName) {

        if (syncData()) {
            synchronizeData();
        }

        if (identifiers == null) {
            return null;
        }

        return (Element)identifiers.get(idName);

    } // getIdentifier(String):Element

    /**
     * Removes a previously registered element with the specified
     * identifier name.
     *
     * @see #putIdentifier
     * @see #getIdentifier
     */
    public void removeIdentifier(String idName) {

        if (syncData()) {
            synchronizeData();
        }

        if (identifiers == null) {
            return;
        }

        identifiers.remove(idName);

    } // removeIdentifier(String)

    /** Returns an enumeration registered of identifier names. */
    public Enumeration getIdentifiers() {

        if (syncData()) {
            synchronizeData();
        }

        if (identifiers == null) {
            identifiers = new Hashtable();
        }

        return identifiers.keys();

    } // getIdentifiers():Enumeration

    //
    // DOM2: Namespace methods
    //

    /**
     * Introduced in DOM Level 2. <p>
     * Creates an element of the given qualified name and namespace URI. 
     * If the given namespaceURI is null or an empty string and the 
     * qualifiedName has a prefix that is ""xml"", the created element 
     * is bound to the predefined namespace
     * ""http://www.w3.org/XML/1998/namespace"" [Namespaces]. 
     * @param namespaceURI The namespace URI of the element to
     *                     create.
     * @param qualifiedName The qualified name of the element type to
     *                      instantiate.
     * @return Element A new Element object with the following attributes:
     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified
                            name contains an invalid character.
     * @throws DOMException NAMESPACE_ERR: Raised if the qualifiedName has a
     *                      prefix that is ""xml"" and the namespaceURI is 
     *                      neither null nor an empty string nor 
     *                      ""http://www.w3.org/XML/1998/namespace"", or
     *                      if the qualifiedName has a prefix different 
     *                      from ""xml"" and the namespaceURI is null or an empty string.
     * @since WD-DOM-Level-2-19990923
     */
    public Element createElementNS(String namespaceURI, String qualifiedName)
        throws DOMException
    {
        return new ElementNSImpl( this, namespaceURI, qualifiedName);
    }

    /**
     * Introduced in DOM Level 2. <p>
     * Creates an attribute of the given qualified name and namespace URI. 
     * If the given namespaceURI is null or an empty string and the 
     * qualifiedName has a prefix that is ""xml"", the created element 
     * is bound to the predefined namespace
     * ""http://www.w3.org/XML/1998/namespace"" [Namespaces]. 
     *
     * @param namespaceURI  The namespace URI of the attribute to
     *                      create. When it is null or an empty string,
     *                      this method behaves like createAttribute.
     * @param qualifiedName The qualified name of the attribute to
     *                      instantiate.
     * @return Attr         A new Attr object.
     * @throws DOMException INVALID_CHARACTER_ERR: Raised if the specified
                            name contains an invalid character.
     * @since WD-DOM-Level-2-19990923
     */
    public Attr createAttributeNS(String namespaceURI, String qualifiedName)
        throws DOMException
    {
        return new AttrNSImpl( this, namespaceURI, qualifiedName);
    }

    /**
     * Introduced in DOM Level 2. <p>
     * Returns a NodeList of all the Elements with a given local name and
     * namespace URI in the order in which they would be encountered in a preorder
     * traversal of the Document tree.
     * @param namespaceURI  The namespace URI of the elements to match
     *                      on. The special value ""*"" matches all
     *                      namespaces. When it is null or an empty
     *                      string, this method behaves like
     *                      getElementsByTagName.
     * @param localName     The local name of the elements to match on.
     *                      The special value ""*"" matches all local names.
     * @return NodeList     A new NodeList object containing all the matched Elements.
     * @since WD-DOM-Level-2-19990923
     */
    public NodeList getElementsByTagNameNS(String namespaceURI, String localName)
    {
	    return new DeepNodeListImpl(this, namespaceURI, localName);
    }

    //
    // DocumentTraversal methods
    //

    /**
     * NON-DOM extension:
     * Create and return a NodeIterator. The NodeIterator is
     * added to a list of NodeIterators so that it can be
     * removed to free up the DOM Nodes it references.
     * @see #removeNodeIterator
     * @see #removeNodeIterators
     * @see #getNodeIterators
     *
     * @param root The root of the iterator.
     * @param whatToShow The whatToShow mask.
     * @param filter The NodeFilter installed. Null means no filter.
     */
    public NodeIterator createNodeIterator(Node root,
                                           short whatToShow,
                                           NodeFilter filter)
    {                                           
        return createNodeIterator(root,whatToShow,filter,true);
    }    
     
    /**
     * Create and return a NodeIterator. The NodeIterator is
     * added to a list of NodeIterators so that it can be
     * removed to free up the DOM Nodes it references.
     * @see #removeNodeIterator
     * @see #removeNodeIterators
     * @see #getNodeIterators
     *
     * @param root The root of the iterator.
     * @param whatToShow The whatToShow mask.
     * @param filter The NodeFilter installed. Null means no filter.
     * @param entityReferenceExpansion true to expand the contents of EntityReference nodes
     * @since WD-DOM-Level-2-19990923
     */
    public NodeIterator createNodeIterator(Node root,
                                           int whatToShow,
                                           NodeFilter filter,
                                           boolean entityReferenceExpansion)
    {
        NodeIterator iterator = new NodeIteratorImpl(
                                        this,
                                        root,
                                        whatToShow,
                                        filter,
                                        entityReferenceExpansion);
        if (iterators == null) {
            iterators = new Vector();
        }

        iterators.addElement(iterator);

        return iterator;
    }

    /**
     * NON-DOM extension:
     * Create and return a TreeWalker. The TreeWalker is
     * added to a list of TreeWalkers so that it can be
     * removed to free up the DOM Nodes it references.
     * @see #removeTreeWalker
     * @see #removeTreeWalkers
     * @see #getTreeWalkers
     *
     * @param root The root of the iterator.
     * @param whatToShow The whatToShow mask.
     * @param filter The NodeFilter installed. Null means no filter.
     */
    public TreeWalker createTreeWalker(Node root,
                                       short whatToShow,
                                       NodeFilter filter)
    {
        return createTreeWalker(root,whatToShow,filter,true);
    }
    /**
     * Create and return a TreeWalker. The TreeWalker is
     * added to a list of TreeWalkers so that it can be
     * removed to free up the DOM Nodes it references.
     * @see #removeTreeWalker
     * @see #removeTreeWalkers
     * @see #getTreeWalkers
     *
     * @param root The root of the iterator.
     * @param whatToShow The whatToShow mask.
     * @param filter The NodeFilter installed. Null means no filter.
     * @param entityReferenceExpansion true to expand the contents of EntityReference nodes
     * @since WD-DOM-Level-2-19990923
     */
    public TreeWalker createTreeWalker(Node root,
                                       int whatToShow,
                                       NodeFilter filter,
                                       boolean entityReferenceExpansion)
    {
    	if( root==null) {
    		throw new DOMExceptionImpl(
    			DOMException.NOT_SUPPORTED_ERR, 
			""DOM007 Not supported"");
        }
        
        TreeWalker treeWalker = new TreeWalkerImpl(root,
                                                   whatToShow,
                                                   filter,
                                                   entityReferenceExpansion);
        if (treeWalkers == null) {
            treeWalkers = new Vector();
        }

        treeWalkers.addElement(treeWalker);

        return treeWalker;
    }

    //
    // Not DOM Level 2. Support DocumentTraversal methods.
    //

    /** This is not called by the developer client. The 
     *  developer client uses the detach() function on the 
     *  NodeIterator itself. <p>
     *  
     *  This function is called from the NodeIterator#detach().
     */
     void removeNodeIterator(NodeIterator nodeIterator) {

        if (nodeIterator == null) return;
        if (iterators == null) return;

        iterators.removeElement(nodeIterator);
    }

    /** Remove a TreeWalker from the list of TreeWalkers. */
    public void removeTreeWalker(TreeWalker treeWalker) {

        if (treeWalker == null) return;
        if (treeWalkers == null) return;

        treeWalkers.removeElement(treeWalker);
    }

    /** Return an Enumeration of all NodeIterators. */
    public Enumeration getNodeIterators() {
        if (iterators == null) return null;

        return iterators.elements();
    }

    /** Return an Enumeration of all TreeWalkers. */
    public Enumeration getTreeWalkers() {
        if (treeWalkers == null) return null;

        return treeWalkers.elements();
    }
    
    //
    // DocumentRange methods
    //
    /**
     */
    public Range createRange() {
        
        if (ranges == null) {
            ranges = new Vector();
        }

        Range range = new RangeImpl(this);
        
        ranges.addElement(range);

        return range;
        
    }
    
    /** Return an Enumeration of all Ranges. */
    public Enumeration getRanges() {
        if (ranges == null) return null;

        return ranges.elements();
    }
    
    /** Not a client function. Called by Range.detach(),
     *  so a Range can remove itself from the list of
     *  Ranges.
     */
    void removeRange(Range range) {

        if (range == null) return;
        if (ranges == null) return;

        ranges.removeElement(range);
    }
    
    
    //
    // DocumentEvent methods
    //

    /**
     * Introduced in DOM Level 2. Optional. <p>
     * Create and return Event objects. 
	 * <p>
	 * @param type The event set name, defined as the interface name 
	 * minus package qualifiers. For example, to create a DOMNodeInserted
	 * event you'd call <code>createEvent(""MutationEvent"")</code>, 
	 * then use its initMutationEvent() method to configure it properly
	 * as DOMNodeInserted. This parameter is case-sensitive.
	 * @return an uninitialized Event object. Call the appropriate
	 * <code>init...Event()</code> method before dispatching it.
	 * @exception DOMException UNSUPPORTED_EVENT_TYPE if the requested
	 * event set is not supported in this DOM.
     * @since WD-DOM-Level-2-19990923
     */
    public Event createEvent(String type) 
	throws DOMException {
	    if(""Event"".equals(type))
	        return new EventImpl();
	    if(""MutationEvent"".equals(type))
	        return new MutationEventImpl();
	    else
	        throw new DOMExceptionImpl(DOMExceptionImpl.UNSUPPORTED_EVENT_TYPE,
					   ""DOM007 Not supported"");
	}
     
    //
    // Object methods
    //

    /** Clone. */
    public Object clone() throws CloneNotSupportedException {
        DocumentImpl newdoc = (DocumentImpl)super.clone();
        newdoc.docType = null;
        newdoc.docElement = null;
        return newdoc;
    }

    //
    // Public static methods
    //

    /**
     * Check the string against XML's definition of acceptable names for
     * elements and attributes and so on. From the XML spec:
     * <p>
     * [Definition:] A Name is a token beginning with a letter or one of a
     * few punctuation characters, and continuing with letters, digits,
     * hyphens,underscores, colons, or full stops, together known as name
     * characters.
     * <p>
     * Unfortunately, that spec goes on to say that after the first character,
     * names may use ""combining characters"" and ""extender characters"",
     * which are explicitly listed rather than defined in terms of Java's
     * Unicode character types... and which in fact can't be expressed solely
     * in terms of those types.
     * <p>
     * I've empirically derived some tests which are partly based on the
     * Java Unicode space (which simplifies them considerably), but they
     * still wind up having to be further qualified. This may not remain
     * valid if future extensions of Java and/or Unicode introduce other
     * characters having these type numbers.
     * <p>
     * Suggestions for alternative implementations would be welcome.
     */
    public static boolean isXMLName(String s) {

        // REVISIT: Use the parser's character checking code. -Ac

        if (s == null) {
            return false;
        }

    	char [] ca=new char[s.length()];
    	s.getChars(0,s.length(),ca,0);

    	// First character must be letter, underscore, or colon.
    	if (!Character.isLetter(ca[0]) && ""_:"".indexOf((int)ca[0]) == -1) {
    		return false;
            }

    	// Remaining characters must be letter, digit, underscore,
    	// colon, period, dash, an XML ""Combining Character"", or an
    	// XML ""Extender Character"".
    	for (int i = 1; i < s.length(); ++i) {

    		char c = ca[i];
    		int ctype = Character.getType(c);

    		if (!Character.isLetterOrDigit(c) &&
                ("".-_:"".indexOf(c) == -1) &&
    		
                // Right type
    		    (!(ctype >= 6 && ctype <= 8 &&	
                      // Bad ranges, combined from the three types:
    				  !((c >= 0x06dd && c <= 0x06de) ||
      				  	(c >= 0x20dd && c <= 0x20e0) ||
      				   	 c >= 0x309b
    				   	)
    				  )
    			    ) &&
    		
    			  // XML Extender chars are all type 4 (uppercase) except
    			  // for two which are type 24. (titlecase modifier)

                  // Right type
    		      (!(ctype == 4 &&
                        // Bad ranges
    					!((c >= 0x02d0 && c <= 0x0559) ||
    				      (c >= 0x06e5 && c <= 0x06e6) ||
    					  (c >= 0x309b && c <= 0x309c)
    					 )
    				|| c == 0x00b7 // Type 24
    				|| c == 0x0387 // Type 24
    				))
                  ) {
    		
    		    return false;
            }
    		
    	}

    	// All characters passed the tests.
    	return true;
    	
    } // isXMLName(String):boolean

    /**
     * Store user data related to a given node
     */
    protected void setUserData(NodeImpl n, Object data) {
        if (userData == null) {
            userData = new Hashtable();
        }
        if (data == null) {
            userData.remove(n);
        } else {
            userData.put(n, data);
        }
    }

    /**
     * Retreive user data related to a given node
     */
    protected Object getUserData(NodeImpl n) {
        if (userData == null) {
            return null;
        }
        return userData.get(n);
    }

    //
    // Protected methods
    //

    /**
     * Uses the kidOK lookup table to check whether the proposed
     * tree structure is legal.
     */
    protected boolean isKidOK(Node parent, Node child) {
        if (allowGrammarAccess && parent.getNodeType() == Node.DOCUMENT_TYPE_NODE) {
            return child.getNodeType() == Node.ELEMENT_NODE;
        }
    	return 0 != (kidOK[parent.getNodeType()] & 1 << child.getNodeType());
    }

} // class DocumentImpl
"
org/w3c/dom/DOMImplementation.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>DOMImplementation</code> interface provides a number of methods 
 * for performing operations that are independent of any particular instance 
 * of the document object model.
 */
public interface DOMImplementation {
    /**
     *  Test if the DOM implementation implements a specific feature.
     * @param feature  The name of the feature to test (case-insensitive). The 
     *   legal values are defined throughout this specification and listed in 
     *   the  section. The name must be an  XML name . To avoid possible 
     *   conflicts, as a convention, names referring to features defined 
     *   outside the DOM spec should be made unique by reversing the name of 
     *   the Internet domain name of the person (or the organization that 
     *   person belongs to) who defines the feature, component by component, 
     *   and use this as a prefix. For instance, the W3C SYMM Working Group 
     *   defines the feature ""org.w3c.dom.smil"".
     * @param version  This is the version number of the feature to test. In 
     *   Level 2, this is the string ""2.0"". If the version is not specified, 
     *   supporting any version of the feature causes the method to return 
     *   <code>true</code> .
     * @return <code>true</code> if the feature is implemented in the 
     *   specified version, <code>false</code> otherwise.
     */
    public boolean hasFeature(String feature, 
                              String version);

    /**
     *  Creates an empty <code>DocumentType</code> node. Entity declarations 
     * and notations are not made available. Entity reference expansions and 
     * default attribute additions do not occur. It is expected that a future 
     * version of the DOM will provide a way for populating a 
     * <code>DocumentType</code> .
     * <br> HTML-only DOM implementations do not need to implement this method.
     * @param qualifiedName  The  qualified name of the document type to be 
     *   created. 
     * @param publicId  The external subset public identifier.
     * @param systemId  The external subset system identifier.
     * @return  A new <code>DocumentType</code> node with 
     *   <code>Node.ownerDocument</code> set to <code>null</code> .
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character.
     *   <br> NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed.
     * @since DOM Level 2
     */
    public DocumentType createDocumentType(String qualifiedName, 
                                           String publicId, 
                                           String systemId)
                                           throws DOMException;

    /**
     *  Creates an XML <code>Document</code> object of the specified type with 
     * its document element. HTML-only DOM implementations do not need to 
     * implement this method.
     * @param namespaceURI  The  namespace URI of the document element to 
     *   create, or <code>null</code> .
     * @param qualifiedName  The  qualified name of the document element to be 
     *   created.
     * @param doctype  The type of document to be created or <code>null</code> 
     *   . When <code>doctype</code> is not <code>null</code> , its 
     *   <code>Node.ownerDocument</code> attribute is set to the document 
     *   being created.
     * @return  A new <code>Document</code> object.
     * @exception DOMException
     *    INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character.
     *   <br> NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed, or if the <code>qualifiedName</code> has a prefix that is 
     *   ""xml"" and the <code>namespaceURI</code> is different from 
     *   ""http://www.w3.org/XML/1998/namespace"".
     *   <br> WRONG_DOCUMENT_ERR: Raised if <code>doctype</code> has already 
     *   been used with a different document.
     * @since DOM Level 2
     */
    public Document createDocument(String namespaceURI, 
                                   String qualifiedName, 
                                   DocumentType doctype)
                                   throws DOMException;

}

"
org/apache/xerces/utils/XMLCharacterProperties.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

/** 
 * A class representing properties of characters according to various
 * W3C recommendations
 *
 * XMLCharacterProperties provides convenience methods for commonly used
 * character tests.
 *
 * For performance reasons, the tables used by the convenience methods are
 * also public, and are directly accessed by performance critical routines.
 *
 */

public final class XMLCharacterProperties {
    /*
     * [26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+
     *
     * Note: This is the same as the ascii portion of the
     *       NameChar definition.
     */
    /** 
     * Check to see if a string is a valid version string according to
     * [26] in the XML 1.0 Recommendation
     *
     * @param version string to check
     * @return true if version is a valid version string
     */
    public static boolean validVersionNum(String version) {
        if (version.length() == 0)
            return false;
        for (int i = 0; i < version.length(); i++) {
            char ch = version.charAt(i);
            if (ch > 'z' || fgAsciiNameChar[ch] == 0)
                return false;
        }
        return true;
    }
    /*
     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
     */
    /**
     * Check to see if a string is a valid encoding name according to [81]
     * in the XML 1.0 Recommendation
     * 
     * @param encoding string to check
     * @return true if encoding is a valid encoding name
     */
    public static boolean validEncName(String encoding) {
        if (encoding.length() == 0)
            return false;
        char ch = encoding.charAt(0);
        if (ch > 'z' || fgAsciiAlphaChar[ch] == 0)
            return false;
        for (int i = 1; i < encoding.length(); i++) {
            ch = encoding.charAt(i);
            if (ch > 'z' || fgAsciiEncNameChar[ch] == 0)
                return false;
        }
        return true;
    }
    /*
     * [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
     */
    /** 
     * Check to see if a string is a valid public identifier according to [13]
     * in the XML 1.0 Recommendation
     *
     * @param publicId string to check
     * @return true if publicId is a valid public identifier
     */
    public static int validPublicId(String publicId) {
        if (publicId.length() == 0)
            return -1;
        for (int i = 0; i < publicId.length(); i++) {
            char ch = publicId.charAt(i);
            if (ch > 'z' || fgAsciiPubidChar[ch] == 0)
                return i;
        }
        return -1;
    }
    /*
     * [5] Name ::= (Letter | '_' | ':') (NameChar)*
     */
    /**
     * Check to see if a string is a valid Name according to [5]
     * in the XML 1.0 Recommendation
     *
     * @param name string to check
     * @return true if name is a valid Name
     */
    public static boolean validName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if (ch > 'z') {
            if ((fgCharFlags[ch] & E_InitialNameCharFlag) == 0)
                return false;
        } else if (fgAsciiInitialNameChar[ch] == 0)
            return false;
        for (int i = 1; i < name.length(); i++) {
            ch = name.charAt(i);
            if (ch > 'z') {
                if ((fgCharFlags[ch] & E_NameCharFlag) == 0)
                    return false;
            } else if (fgAsciiNameChar[ch] == 0)
                return false;
        }
        return true;
    }
    
    /*
     * from the namespace rec
     * [5] NCName ::= (Letter | '_' | ':') (NameNCChar)*
     */
    /**
     * Check to see if a string is a valid NCName according to [5]
     * from the XML Namespaces 1.0 Recommendation
     *
     * @param name string to check
     * @return true if name is a valid NCName
     */
    public static boolean validNCName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if (ch > 'z') {
            if ((fgCharFlags[ch] & E_InitialNameCharFlag) == 0)
                return false;
        } else if (fgAsciiInitialNCNameChar[ch] == 0)
            return false;
        for (int i = 1; i < name.length(); i++) {
            ch = name.charAt(i);
            if (ch > 'z') {
                if ((fgCharFlags[ch] & E_NameCharFlag) == 0)
                    return false;
            } else if (fgAsciiNCNameChar[ch] == 0)
                return false;
        }
        return true;
    }
    
    
    /*
     * [7] Nmtoken ::= (NameChar)+
     */
    /** 
     * Check to see if a string is a valid Nmtoken according to [7]
     * in the XML 1.0 Recommendation
     *
     * @param nmtoken string to checj
     * @return true if nmtoken is a valid Nmtoken
     */
    public static boolean validNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++) {
            char ch = nmtoken.charAt(i);
            if (ch > 'z') {
                if ((fgCharFlags[ch] & E_NameCharFlag) == 0)
                    return false;
            } else if (fgAsciiNameChar[ch] == 0) {
                return false;
            }
        }
        return true;
    }
    /*
     * Here are tables used to build character properties.
     */
    public static final byte fgAsciiXDigitChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // '0' - '9'
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 'A' - 'F'
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 'a' - 'f'
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public static final byte fgAsciiAlphaChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, // 'P' - 'Z'
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiEncNameChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, // '-' is 0x2D and '.' is 0x2E
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // '0' - '9'
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiPubidChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, // ' ', '!', '#', '$', '%',
                                                        // '\'', '(', ')', '*', '+', ',', '-', '.', '/'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, // '0' - '9', ':', ';', '=', '?'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // '@', 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiInitialNameChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, // ':' is 0x3A
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiNameChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, // '-' is 0x2D and '.' is 0x2E
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, // '0' - '9' and ':' is 0x3A
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiInitialNCNameChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // ':' is 0x3A
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiNCNameChar[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, // '-' is 0x2D and '.' is 0x2E
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // '0' - '9' and ':' is 0x3A
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'A' - 'O'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 'P' - 'Z' and '_' is 0x5F
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 'a' - 'o'
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 'p' - 'z'
    };
    public static final byte fgAsciiCharData[] = {
        4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, // tab is 0x09
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, // '&' is 0x26
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, // '<' is 0x3C
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, // ']' is 0x5D
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public static final byte fgAsciiWSCharData[] = {
        4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 5, 4, 4, // tab is 0x09,  LF is 0x0A,  CR is 0x0D
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, // ' ' is 0x20, '&' is 0x26
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, // '<' is 0x3C
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, // ']' is 0x5D
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    public static final byte E_CharDataFlag = 1<<0;
    public static final byte E_InitialNameCharFlag = 1<<1;
    public static final byte E_NameCharFlag = 1<<2;
    public static byte[] fgCharFlags = null;
    public static synchronized void initCharFlags() {
        if (fgCharFlags == null) {
            fgCharFlags = new byte[0x10000];
            setFlagForRange(fgCharDataRanges, E_CharDataFlag);
            setFlagForRange(fgInitialNameCharRanges, (byte)(E_InitialNameCharFlag | E_NameCharFlag));
            setFlagForRange(fgNameCharRanges, E_NameCharFlag);
        }
    }
    private static void setFlagForRange(char[] ranges, byte flag)
    {
        int i;
        int ch;
        for (i = 0; (ch = ranges[i]) != 0; i += 2) {
            int endch = ranges[i+1];
            while (ch <= endch)
                fgCharFlags[ch++] |= flag;
        }
        for (i++; (ch = ranges[i]) != 0; i++)
            fgCharFlags[ch] |= flag;
    }
    /*
     *  [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF]        // any Unicode character, excluding the
     *               | [#xE000-#xFFFD] | [#x10000-#x10FFFF] // surrogate blocks, FFFE, and FFFF.
     * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
     *
     * We will use Char - ( [^<&] | ']' | #xA | #xD ) and handle the special cases inline.
     */
    private static final char fgCharDataRanges[] = {
        0x0020, 0x0025, // '&' is 0x0026
        0x0027, 0x003B, // '<' is 0x003C
        0x003D, 0x005C, // ']' is 0x005D
        0x005E, 0xD7FF,
        0xE000, 0xFFFD,
            0x0000,
        0x0009,         // tab
            0x0000
    };
    /*
     *  [5] Name ::= (Letter | '_' | ':') (NameChar)*
     *  [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender
     * [84] Letter ::= BaseChar | Ideographic
     * [85] BaseChar ::= <see standard>
     * [86] Ideographic ::= <see standard>
     * [87] CombiningChar ::= <see standard>
     * [88] Digit ::= <see standard>
     * [89] Extender ::= <see standard>
     */
    private static final char fgInitialNameCharRanges[] = {
        //
        // Ranges:
        //
        //  BaseChar ranges
        //
        0x0041, 0x005A, 0x0061, 0x007A, 0x00C0, 0x00D6, 0x00D8, 0x00F6,
        0x00F8, 0x0131, 0x0134, 0x013E, 0x0141, 0x0148, 0x014A, 0x017E,
        0x0180, 0x01C3, 0x01CD, 0x01F0, 0x01F4, 0x01F5, 0x01FA, 0x0217,
        0x0250, 0x02A8, 0x02BB, 0x02C1, 0x0388, 0x038A, 0x038E, 0x03A1,
        0x03A3, 0x03CE, 0x03D0, 0x03D6, 0x03E2, 0x03F3, 0x0401, 0x040C,
        0x040E, 0x044F, 0x0451, 0x045C, 0x045E, 0x0481, 0x0490, 0x04C4,
        0x04C7, 0x04C8, 0x04CB, 0x04CC, 0x04D0, 0x04EB, 0x04EE, 0x04F5,
        0x04F8, 0x04F9, 0x0531, 0x0556, 0x0561, 0x0586, 0x05D0, 0x05EA,
        0x05F0, 0x05F2, 0x0621, 0x063A, 0x0641, 0x064A, 0x0671, 0x06B7,
        0x06BA, 0x06BE, 0x06C0, 0x06CE, 0x06D0, 0x06D3, 0x06E5, 0x06E6,
        0x0905, 0x0939, 0x0958, 0x0961, 0x0985, 0x098C, 0x098F, 0x0990,
        0x0993, 0x09A8, 0x09AA, 0x09B0, 0x09B6, 0x09B9, 0x09DC, 0x09DD,
        0x09DF, 0x09E1, 0x09F0, 0x09F1, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10,
        0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36,
        0x0A38, 0x0A39, 0x0A59, 0x0A5C, 0x0A72, 0x0A74, 0x0A85, 0x0A8B,
        0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3,
        0x0AB5, 0x0AB9, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28,
        0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B36, 0x0B39, 0x0B5C, 0x0B5D,
        0x0B5F, 0x0B61, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
        0x0B99, 0x0B9A, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA,
        0x0BAE, 0x0BB5, 0x0BB7, 0x0BB9, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10,
        0x0C12, 0x0C28, 0x0C2A, 0x0C33, 0x0C35, 0x0C39, 0x0C60, 0x0C61,
        0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3,
        0x0CB5, 0x0CB9, 0x0CE0, 0x0CE1, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
        0x0D12, 0x0D28, 0x0D2A, 0x0D39, 0x0D60, 0x0D61, 0x0E01, 0x0E2E,
        0x0E32, 0x0E33, 0x0E40, 0x0E45, 0x0E81, 0x0E82, 0x0E87, 0x0E88,
        0x0E94, 0x0E97, 0x0E99, 0x0E9F, 0x0EA1, 0x0EA3, 0x0EAA, 0x0EAB,
        0x0EAD, 0x0EAE, 0x0EB2, 0x0EB3, 0x0EC0, 0x0EC4, 0x0F40, 0x0F47,
        0x0F49, 0x0F69, 0x10A0, 0x10C5, 0x10D0, 0x10F6, 0x1102, 0x1103,
        0x1105, 0x1107, 0x110B, 0x110C, 0x110E, 0x1112, 0x1154, 0x1155,
        0x115F, 0x1161, 0x116D, 0x116E, 0x1172, 0x1173, 0x11AE, 0x11AF,
        0x11B7, 0x11B8, 0x11BC, 0x11C2, 0x1E00, 0x1E9B, 0x1EA0, 0x1EF9,
        0x1F00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D,
        0x1F50, 0x1F57, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FBC,
        0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB,
        0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x212A, 0x212B,
        0x2180, 0x2182, 0x3041, 0x3094, 0x30A1, 0x30FA, 0x3105, 0x312C,
        0xAC00, 0xD7A3,
        //
        //  Ideographic ranges
        //
        0x3021, 0x3029, 0x4E00, 0x9FA5,
        //
        // Ranges end marker
        //
        0x0000,
        //
        // Single char values
        //
        0x003A, // ':'
        0x005F, // '_'
        //
        //  BaseChar singles
        //
        0x0386, 0x038C, 0x03DA, 0x03DC, 0x03DE, 0x03E0, 0x0559, 0x06D5,
        0x093D, 0x09B2, 0x0A5E, 0x0A8D, 0x0ABD, 0x0AE0, 0x0B3D, 0x0B9C,
        0x0CDE, 0x0E30, 0x0E84, 0x0E8A, 0x0E8D, 0x0EA5, 0x0EA7, 0x0EB0,
        0x0EBD, 0x1100, 0x1109, 0x113C, 0x113E, 0x1140, 0x114C, 0x114E,
        0x1150, 0x1159, 0x1163, 0x1165, 0x1167, 0x1169, 0x1175, 0x119E,
        0x11A8, 0x11AB, 0x11BA, 0x11EB, 0x11F0, 0x11F9, 0x1F59, 0x1F5B,
        0x1F5D, 0x1FBE, 0x2126, 0x212E,
        //
        //  Ideographic singles
        //
        0x3007,
        //
        // Singles end marker
        //
        0x0000
    };
    private static final char fgNameCharRanges[] = {
        //
        // Ranges:
        //
        0x002D, 0x002E, // '-' and '.'
        //
        //  CombiningChar ranges
        //
        0x0300, 0x0345, 0x0360, 0x0361, 0x0483, 0x0486, 0x0591, 0x05A1,
        0x05A3, 0x05B9, 0x05BB, 0x05BD, 0x05C1, 0x05C2, 0x064B, 0x0652,
        0x06D6, 0x06DC, 0x06DD, 0x06DF, 0x06E0, 0x06E4, 0x06E7, 0x06E8,
        0x06EA, 0x06ED, 0x0901, 0x0903, 0x093E, 0x094C, 0x0951, 0x0954,
        0x0962, 0x0963, 0x0981, 0x0983, 0x09C0, 0x09C4, 0x09C7, 0x09C8,
        0x09CB, 0x09CD, 0x09E2, 0x09E3, 0x0A40, 0x0A42, 0x0A47, 0x0A48,
        0x0A4B, 0x0A4D, 0x0A70, 0x0A71, 0x0A81, 0x0A83, 0x0ABE, 0x0AC5,
        0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0B01, 0x0B03, 0x0B3E, 0x0B43,
        0x0B47, 0x0B48, 0x0B4B, 0x0B4D, 0x0B56, 0x0B57, 0x0B82, 0x0B83,
        0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0C01, 0x0C03,
        0x0C3E, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D, 0x0C55, 0x0C56,
        0x0C82, 0x0C83, 0x0CBE, 0x0CC4, 0x0CC6, 0x0CC8, 0x0CCA, 0x0CCD,
        0x0CD5, 0x0CD6, 0x0D02, 0x0D03, 0x0D3E, 0x0D43, 0x0D46, 0x0D48,
        0x0D4A, 0x0D4D, 0x0E34, 0x0E3A, 0x0E47, 0x0E4E, 0x0EB4, 0x0EB9,
        0x0EBB, 0x0EBC, 0x0EC8, 0x0ECD, 0x0F18, 0x0F19, 0x0F71, 0x0F84,
        0x0F86, 0x0F8B, 0x0F90, 0x0F95, 0x0F99, 0x0FAD, 0x0FB1, 0x0FB7,
        0x20D0, 0x20DC, 0x302A, 0x302F,
        //
        //  Digit ranges
        //
        0x0030, 0x0039, 0x0660, 0x0669, 0x06F0, 0x06F9, 0x0966, 0x096F,
        0x09E6, 0x09EF, 0x0A66, 0x0A6F, 0x0AE6, 0x0AEF, 0x0B66, 0x0B6F,
        0x0BE7, 0x0BEF, 0x0C66, 0x0C6F, 0x0CE6, 0x0CEF, 0x0D66, 0x0D6F,
        0x0E50, 0x0E59, 0x0ED0, 0x0ED9, 0x0F20, 0x0F29,
        //
        //  Extender ranges
        //
        0x3031, 0x3035, 0x309D, 0x309E, 0x30FC, 0x30FE,
        //
        // Ranges end marker
        //
        0x0000,
        //
        // Single char values
        //
        //  CombiningChar singles
        //
        0x05BF, 0x05C4, 0x0670, 0x093C, 0x094D, 0x09BC, 0x09BE, 0x09BF,
        0x09D7, 0x0A02, 0x0A3C, 0x0A3E, 0x0A3F, 0x0ABC, 0x0B3C, 0x0BD7,
        0x0D57, 0x0E31, 0x0EB1, 0x0F35, 0x0F37, 0x0F39, 0x0F3E, 0x0F3F,
        0x0F97, 0x0FB9, 0x20E1, 0x3099, 0x309A,
        //
        //  Extender singles
        //
        0x00B7, 0x02D0, 0x02D1, 0x0387, 0x0640, 0x0E46, 0x0EC6, 0x3005,
        //
        // Singles end marker
        //
        0x0000
    };
}
"
org/apache/xerces/readers/UCSReader.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.ChunkyByteArray;
import org.apache.xerces.utils.ChunkyCharArray;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringHasher;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLCharacterProperties;
import java.io.IOException;

/**
 * Reader for UCS-2 and UCS-4 encodings.
 * <p>
 * This reader is created by the UCSRecognizer class when it decides that the
 * byte stream is encoded in a format supported by this class.  This class
 * was intended to be another example of an encoding sensitive reader that
 * could take advantage of the system design to improve performance and reduce
 * resource consumption, but the actual performance tuning remains to be done.
 *
 * @version $Id$
 */
final class UCSReader extends XMLEntityReader implements StringPool.StringProducer {

    //
    // Constants
    //

    // debugging
    
    /** Set to true to debug UTF-16, big-endian. */
    private static final boolean DEBUG_UTF16_BIG = false;

    //
    // Scanner encoding enumeration
    //
    static final int
        E_UCS4B = 0,            // UCS-4 big endian
        E_UCS4L = 1,            // UCS-4 little endian
        E_UCS2B = 2,            // UCS-2 big endian with byte order mark
        E_UCS2L = 3,            // UCS-2 little endian with byte order mark
        E_UCS2B_NOBOM = 4,      // UCS-2 big endian without byte order mark
        E_UCS2L_NOBOM = 5;      // UCS-2 little endian without byte order mark
    //
    //
    //
    private ChunkyByteArray fData = null;
    private int fEncoding = -1;
    private StringPool fStringPool = null;
    private int fBytesPerChar = -1;
    private boolean fBigEndian = true;
    private ChunkyCharArray fStringCharArray = null;
    private boolean fCalledCharPropInit = false;
    //
    //
    //
    UCSReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, ChunkyByteArray data, int encoding, StringPool stringPool) throws Exception {
        super(entityHandler, errorReporter, sendCharDataAsCharArray);
        fCurrentOffset = (encoding == E_UCS2B || encoding == E_UCS2L) ? 2 : 0;
        fData = data;
        fEncoding = encoding;
        fStringPool = stringPool;
        fBytesPerChar = (fEncoding == E_UCS4B || fEncoding == E_UCS4L) ? 4 : 2;
        fBigEndian = fEncoding == E_UCS4B || fEncoding == E_UCS2B || fEncoding == E_UCS2B_NOBOM;
    }
    //
    //
    //
    private int getChar(int offset) throws IOException {
        int b0 = fData.byteAt(offset++) & 0xff;
        if (b0 == 0xff && fData.atEOF(offset))
            return -1;
        int b1 = fData.byteAt(offset++) & 0xff;
        if (fBytesPerChar == 4) {
            int b2 = fData.byteAt(offset++) & 0xff;
            int b3 = fData.byteAt(offset++) & 0xff;
            if (fBigEndian)
                return (b0<<24)+(b1<<16)+(b2<<8)+b3;
            else
                return (b3<<24)+(b2<<16)+(b1<<8)+b0;
        } else {
            if (fBigEndian)
                return (b0<<8)+b1;
            else
                return (b1<<8)+b0;
        }
    }
    /**
     *
     */
    public int addString(int offset, int length) {
        if (length == 0)
            return 0;
        return fStringPool.addString(this, offset, length);
    }
    /**
     *
     */
    public int addSymbol(int offset, int length) {
        if (length == 0)
            return 0;
        return fStringPool.addSymbol(this, offset, length, getHashcode(offset, length));
    }
    //
    //
    //
    public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
        int endOffset = offset + length;
        while (offset < endOffset) {
            int ch;
            try {
                ch = getChar(offset);
            }
            catch (IOException ex) {
                ch = 0; // REVISIT
            }
            charBuffer.append((char)ch);
            offset += fBytesPerChar;
        }
    }
    //
    //
    //
    public void releaseString(int offset, int length) {
        // nothing to do...
    }
    //
    //
    //
    public String toString(int offset, int length) {
        //
        // REVISIT - we need to cache this operation !!
        //
        if (fStringCharArray == null)
            fStringCharArray = new ChunkyCharArray(fStringPool);
        int newOffset = fStringCharArray.length();
        append(fStringCharArray, offset, length);
        int newLength = fStringCharArray.length() - newOffset;
        int stringIndex = fStringCharArray.addString(newOffset, newLength);
        return fStringPool.toString(stringIndex);
    }
    //
    //
    //
    private int getHashcode(int offset, int length) {
        int endOffset = offset + length;
        int hashcode = 0;
        while (offset < endOffset) {
            int ch;
            try {
                ch = getChar(offset);
            }
            catch (IOException ex) {
                ch = 0; // REVISIT
            }
            hashcode = StringHasher.hashChar(hashcode, ch);
            offset += fBytesPerChar;
        }
        return StringHasher.finishHash(hashcode);
    }
    //
    public boolean equalsString(int offset, int length, char[] strChars, int strOffset, int strLength) {
        int endOffset = offset + length;
        int slen = strLength;
        while (offset < endOffset) {
            if (slen-- == 0)
                return false;
            int ch;
            try {
                ch = getChar(offset);
            }
            catch (IOException ex) {
                ch = 0; // REVISIT
            }
            if (ch != strChars[strOffset++])
                return false;
            offset += fBytesPerChar;
        }
        return slen == 0;
    }
    //
    //
    //
    private static char[] fCharacters = new char[256];
    private int fCharDataLength = 0;
    private void appendCharData(int ch) {
        if (fCharacters.length == fCharDataLength) {
            char[] newchars = new char[fCharacters.length * 2];
            System.arraycopy(fCharacters, 0, newchars, 0, fCharacters.length);
            fCharacters = newchars;
        }
        fCharacters[fCharDataLength++] = (char)ch;
    }
    public void callCharDataHandler(int offset, int length, boolean isWhitespace) throws Exception {
        int endOffset = offset + length;
        boolean skiplf = false;
        while (offset < endOffset) {
            int ch = getChar(offset);
            // fix for Bug23: Element Data not normalized...
            if (skiplf) {
                skiplf = false;
                if (ch == 0x0A) {
                    offset += fBytesPerChar;
                    continue;
                }
            }
            if (ch == 0x0D) {
                skiplf = true;
                ch = 0x0A;
            }
            appendCharData(ch);
            offset += fBytesPerChar;
        }
        if (fSendCharDataAsCharArray) {
            if (isWhitespace)
                fCharDataHandler.processWhitespace(fCharacters, 0, fCharDataLength);
            else
                fCharDataHandler.processCharacters(fCharacters, 0, fCharDataLength);
        } else {
            int stringIndex = fStringPool.addString(new String(fCharacters, 0, fCharDataLength));
            if (isWhitespace)
                fCharDataHandler.processWhitespace(stringIndex);
            else
                fCharDataHandler.processCharacters(stringIndex);
        }
        fCharDataLength = 0;
    }
    //
    //
    //
    public boolean lookingAtChar(char ch, boolean skipPastChar) throws Exception {
        int ch2 = getChar(fCurrentOffset);
        if (ch2 == ch) {
            if (skipPastChar) {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
            }
            return true;
        }
        return false;
    }
    //
    //
    //
    public boolean lookingAtValidChar(boolean skipPastChar) throws Exception {
        int ch = getChar(fCurrentOffset);
        if (ch < 0x20) {
            if (ch == 0x09) {
                if (!skipPastChar)
                    return true;
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                if (!skipPastChar)
                    return true;
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                if (!skipPastChar)
                    return true;
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
            } else {
                if (ch == -1) {
                    return changeReaders().lookingAtValidChar(skipPastChar);
                }
                return false;
            }
            fCurrentOffset += fBytesPerChar;
            return true;
        }
        if (ch <= 0xD7FF) {
            if (skipPastChar) {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
            }
            return true;
        }
        if (ch <= 0xDFFF) {
            // REVISIT - check that the surrogate pair is valid
            if (skipPastChar) {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
            }
            return true;
        }
        if (ch <= 0xFFFD) {
            if (skipPastChar) {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
            }
            return true;
        }
        return false;
    }
    //
    //
    //
    public boolean lookingAtSpace(boolean skipPastChar) throws Exception {
        int ch = getChar(fCurrentOffset);
        if (ch > 0x20)
            return false;
        if (ch == 0x20 || ch == 0x09) {
            if (!skipPastChar)
                return true;
            fCharacterCounter++;
        } else if (ch == 0x0A) {
            if (!skipPastChar)
                return true;
            fLinefeedCounter++;
            fCharacterCounter = 1;
        } else if (ch == 0x0D) {
            if (!skipPastChar)
                return true;
            fCarriageReturnCounter++;
            fCharacterCounter = 1;
        } else {
            if (ch == -1) { // REVISIT - should we be checking this here ?
                return changeReaders().lookingAtSpace(skipPastChar);
            }
            return false;
        }
        fCurrentOffset += fBytesPerChar;
        return true;
    }
    //
    //
    //
    public void skipToChar(char chr) throws Exception {
        while (true) {
            int ch = getChar(fCurrentOffset);
            if (ch == chr)
                return;
            if (ch == -1) {
                changeReaders().skipToChar(chr);
                return;
            }
            if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
            } else if (ch >= 0xD800 && ch < 0xDC00) {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
                ch = getChar(fCurrentOffset);
                if (ch < 0xDC00 || ch >= 0xE000)
                    continue;
            } else
                fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
        }
    }
    //
    //
    //
    public void skipPastSpaces() throws Exception {
        while (true) {
            int ch = getChar(fCurrentOffset);
            if (ch > 0x20)
                return;
            if (ch == 0x20 || ch == 0x09) {
                fCharacterCounter++;
            } else if (ch == 0x0A) {
                fLinefeedCounter++;
                fCharacterCounter = 1;
            } else if (ch == 0x0D) {
                fCarriageReturnCounter++;
                fCharacterCounter = 1;
            } else {
                if (ch == -1)
                    changeReaders().skipPastSpaces();
                return;
            }
            fCurrentOffset += fBytesPerChar;
        }
    }
    //
    //
    //
    public void skipPastName(char fastcheck) throws Exception {
        int ch = getChar(fCurrentOffset);
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag) == 0)
            return;
        while (true) {
            fCurrentOffset += fBytesPerChar;
            fCharacterCounter++;
            ch = getChar(fCurrentOffset);
            if (fastcheck == ch)
                return;
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                return;
        }
    }
    //
    //
    //
    public void skipPastNmtoken(char fastcheck) throws Exception {
        int ch = getChar(fCurrentOffset);
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        while (true) {
            if (fastcheck == ch)
                return;
            if ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)
                return;
            fCurrentOffset += fBytesPerChar;
            fCharacterCounter++;
            ch = getChar(fCurrentOffset);
        }
    }
    //
    //
    //
    public boolean skippedString(char[] s) throws Exception {
        int offset = fCurrentOffset;
        for (int i = 0; i < s.length; i++) {
            if (getChar(offset) != s[i])
                return false;
            offset += fBytesPerChar;
        }
        fCurrentOffset = offset;
        fCharacterCounter += s.length;
        return true;
    }
    //
    //
    //
    public int scanInvalidChar() throws Exception {
        int ch = getChar(fCurrentOffset);
        if (ch == -1) {
            return changeReaders().scanInvalidChar();
        }
        fCurrentOffset += fBytesPerChar;
        if (ch == 0x0A) {
            fLinefeedCounter++;
            fCharacterCounter = 1;
        } else if (ch == 0x0D) {
            fCarriageReturnCounter++;
            fCharacterCounter = 1;
        } else {
            fCharacterCounter++;
            if (ch >= 0xD800 && ch < 0xDC00) {
                int ch2 = getChar(fCurrentOffset);
                if (ch2 >= 0xDC00 && ch2 < 0xE000) {
                    ch = ((ch-0xD800)<<10)+(ch2-0xDC00)+0x10000;
                    fCurrentOffset += fBytesPerChar;
                }
            }
        }
        return ch;
    }
    //
    //
    //
    public int scanCharRef(boolean hex) throws Exception {
        int ch = getChar(fCurrentOffset);
        if (ch == -1) {
            return changeReaders().scanCharRef(hex);
        }
        int num = 0;
        if (hex) {
            if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
        } else {
            if (ch < '0' || ch > '9')
                return XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR;
            num = ch - '0';
        }
        fCharacterCounter++;
        fCurrentOffset += fBytesPerChar;
        boolean toobig = false;
        while (true) {
            ch = getChar(fCurrentOffset);
            if (ch == -1)
                break;
            if (hex) {
                if (ch > 'f' || XMLCharacterProperties.fgAsciiXDigitChar[ch] == 0)
                    break;
            } else {
                if (ch < '0' || ch > '9')
                    break;
            }
            fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
            if (hex) {
                int dig = ch - (ch < 'A' ? '0' : (ch < 'a' ? 'A' : 'a') - 10);
                num = (num << 4) + dig;
            } else {
                int dig = ch - '0';
                num = (num * 10) + dig;
            }
            if (num > 0x10FFFF) {
                toobig = true;
                num = 0;
            }
        }
        if (ch != ';')
            return XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED;
        fCharacterCounter++;
        fCurrentOffset += fBytesPerChar;
        if (toobig)
            return XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE;
        return num;
    }
    //
    //
    //
    public int scanStringLiteral() throws Exception {
        boolean single;
        if (!(single = lookingAtChar('\'', true)) && !lookingAtChar('\""', true)) {
            return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
        }
        int offset = fCurrentOffset;
        char qchar = single ? '\'' : '\""';
        while (!lookingAtChar(qchar, false)) {
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR;
            }
        }
        int stringIndex = addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true); // move past qchar
        return stringIndex;
    }
    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    //                   | ""'"" ([^<&'] | Reference)* ""'""
    //
    public int scanAttValue(char qchar, boolean asSymbol) throws Exception
    {
        int offset = fCurrentOffset;
        while (true) {
            if (lookingAtChar(qchar, false)) {
                break;
            }
            if (lookingAtChar(' ', true)) {
                continue;
            }
            if (lookingAtSpace(false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('&', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_COMPLEX;
            }
            if (lookingAtChar('<', false)) {
                return XMLEntityHandler.ATTVALUE_RESULT_LESSTHAN;
            }
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.ATTVALUE_RESULT_INVALID_CHAR;
            }
        }
        int result = asSymbol ? addSymbol(offset, fCurrentOffset - offset) : addString(offset, fCurrentOffset - offset);
        lookingAtChar(qchar, true);
        return result;
    }
    //
    //  [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                      | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    public int scanEntityValue(int qchar, boolean createString) throws Exception
    {
        int offset = fCurrentOffset;
        while (true) {
            if (qchar != -1 && lookingAtChar((char)qchar, false)) {
                if (!createString)
                    return XMLEntityHandler.ENTITYVALUE_RESULT_FINISHED;
                break;
            }
            if (lookingAtChar('&', false)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_REFERENCE;
            }
            if (lookingAtChar('%', false)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_PEREF;
            }
            if (!lookingAtValidChar(true)) {
                return XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR;
            }
        }
        int result = addString(offset, fCurrentOffset - offset);
        lookingAtChar((char)qchar, true);
        return result;
    }
    //
    //
    //
    public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws Exception {
        int nameOffset = fCurrentOffset;
        skipPastName(fastcheck);
        int nameLength = fCurrentOffset - nameOffset;
        if (nameLength == 0)
            return false;
        int nameIndex = addSymbol(nameOffset, nameLength);
        // DEFECT !! check name against expected name
        return true;
    }

    public void scanQName(char fastcheck, QName qname) throws Exception {

        // DEFECT !! no code // Defect #126
        int nameOffset = fCurrentOffset;
        skipPastName(fastcheck);
        int nameLength = fCurrentOffset - nameOffset;
        if (nameLength == 0) {
            qname.clear();
            return;
        }
        qname.prefix = -1;
        qname.localpart = -1;
        qname.rawname = addSymbol(nameOffset, nameLength);
        qname.uri = -1;

    } // scanQName(char,QName)

    public int scanName(char fastcheck) throws Exception {
        int nameOffset = fCurrentOffset;
        skipPastName(fastcheck);
        int nameLength = fCurrentOffset - nameOffset;
        if (nameLength == 0)
            return -1;
        int nameIndex = addSymbol(nameOffset, nameLength);
        return nameIndex;
    }
    //
    //
    //
    private static final char[] cdata_string = { 'C','D','A','T','A','[' };
    private int recognizeMarkup() throws Exception {
        int ch = getChar(fCurrentOffset);
        switch (ch) {
        case -1:
            return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
        case '?':
            fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
            return XMLEntityHandler.CONTENT_RESULT_START_OF_PI;
        case '!':
            fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
            ch = getChar(fCurrentOffset);
            if (ch == -1) {
                fCharacterCounter--;
                fCurrentOffset -= fBytesPerChar;;
                return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
            }
            if (ch == '-') {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
                ch = getChar(fCurrentOffset);
                if (ch == -1) {
                    fCharacterCounter -= 2;
                    fCurrentOffset -= 2;
                    return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                }
                if (ch == '-') {
                    fCharacterCounter++;
                    fCurrentOffset += fBytesPerChar;
                    return XMLEntityHandler.CONTENT_RESULT_START_OF_COMMENT;
                }
                break;
            }
            if (ch == '[') {
                fCharacterCounter++;
                fCurrentOffset += fBytesPerChar;
                for (int i = 0; i < 6; i++) {
                    ch = getChar(fCurrentOffset);
                    if (ch == -1) {
                        fCharacterCounter -= (2 + i);
                        fCurrentOffset -= ((2 + i) * fBytesPerChar);
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT;
                    }
                    if (ch != cdata_string[i]) {
                        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
                    }
                    fCharacterCounter++;
                    fCurrentOffset += fBytesPerChar;
                }
                return XMLEntityHandler.CONTENT_RESULT_START_OF_CDSECT;
            }
            break;
        case '/':
            fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG;
        default:
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ELEMENT;
        }
        return XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED;
    }
    private int recognizeReference() throws Exception {
        int ch = getChar(fCurrentOffset);
        if (ch == -1) {
            return XMLEntityHandler.CONTENT_RESULT_REFERENCE_END_OF_INPUT;
        }
        //
        // [67] Reference ::= EntityRef | CharRef
        // [68] EntityRef ::= '&' Name ';'
        // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
        //
        if (ch == '#') {
            fCharacterCounter++;
            fCurrentOffset += fBytesPerChar;
            return XMLEntityHandler.CONTENT_RESULT_START_OF_CHARREF;
        } else {
            return XMLEntityHandler.CONTENT_RESULT_START_OF_ENTITYREF;
        }
    }
    public int scanContent(QName element) throws Exception {
        int offset = fCurrentOffset;
        int ch = getChar(fCurrentOffset);
        fCurrentOffset += fBytesPerChar;
        byte prop;
        if (!fCalledCharPropInit) {
            XMLCharacterProperties.initCharFlags();
            fCalledCharPropInit = true;
        }
        if (ch < 0x80) {
            if (ch == -1) {
                fCurrentOffset -= fBytesPerChar;
                return changeReaders().scanContent(element); // REVISIT - not quite...
            }
            prop = XMLCharacterProperties.fgCharFlags[ch];
            if ((prop & XMLCharacterProperties.E_CharDataFlag) == 0 && ch != 0x0A && ch != 0x0D) {
                if (ch == '<') {
                    fCharacterCounter++;
                    if (!fInCDSect) {
                        return recognizeMarkup();
                    }
                } else if (ch == '&') {
                    fCharacterCounter++;
                    if (!fInCDSect) {
                        return recognizeReference();
                    }
                } else if (ch == ']') {
                    if (getChar(fCurrentOffset) == ']' && getChar(fCurrentOffset + fBytesPerChar) == '>') {
                        fCharacterCounter += 3;
                        fCurrentOffset += (2 * fBytesPerChar);
                        return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                    }
                } else {
                    fCurrentOffset -= fBytesPerChar;
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
            } else if (ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D) {
                do {
                    if (ch == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                    } else if (ch == 0x0D) {
                        fCarriageReturnCounter++;
                        fCharacterCounter = 1;
                    } else {
                        fCharacterCounter++;
                    }
                    ch = getChar(fCurrentOffset);
                    fCurrentOffset += fBytesPerChar;
                } while (ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D);
                if (ch < 0x80) {
                    if (ch == -1) {
                        fCurrentOffset -= fBytesPerChar;
                        callCharDataHandler(offset, fCurrentOffset - offset, true);
                        return changeReaders().scanContent(element); // REVISIT - not quite...
                    }
                    prop = XMLCharacterProperties.fgCharFlags[ch];
                    if ((prop & XMLCharacterProperties.E_CharDataFlag) == 0) {
                        if (ch == '<') {
                            if (!fInCDSect) {
                                callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, true);
                                fCharacterCounter++;
                                return recognizeMarkup();
                            }
                            fCharacterCounter++;
                        } else if (ch == '&') {
                            if (!fInCDSect) {
                                callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, true);
                                fCharacterCounter++;
                                return recognizeReference();
                            }
                            fCharacterCounter++;
                        } else if (ch == ']') {
                            if (getChar(fCurrentOffset) == ']' && getChar(fCurrentOffset + fBytesPerChar) == '>') {
                                callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, true);
                                fCharacterCounter += 3;
                                fCurrentOffset += (2 * fBytesPerChar);
                                return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                            }
                        } else {
                            fCurrentOffset -= fBytesPerChar;
                            callCharDataHandler(offset, fCurrentOffset - offset, true);
                            return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                        }
                    }
                } else {
                    if (ch >= 0xD800 && ch <= 0xDFFF) {
                        fCurrentOffset += fBytesPerChar;
                    } else if (ch == 0xFFFE || ch == 0xFFFF) {
                        fCurrentOffset -= fBytesPerChar;
                        callCharDataHandler(offset, fCurrentOffset - offset, true);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                }
            }
        } else {
            if (ch >= 0xD800 && ch <= 0xDFFF) {
                fCurrentOffset += fBytesPerChar;
            } else if (ch == 0xFFFE || ch == 0xFFFF) {
                fCurrentOffset -= fBytesPerChar;
                return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
            }
        }
        fCharacterCounter++;
        while (true) {
            ch = getChar(fCurrentOffset);
            fCurrentOffset += fBytesPerChar;
            if (ch >= 0x80 || ch < 0)
                break;
            prop = XMLCharacterProperties.fgCharFlags[ch];
            if ((prop & XMLCharacterProperties.E_CharDataFlag) == 0) {
                if (ch == 0x0A) {
                    fLinefeedCounter++;
                    fCharacterCounter = 1;
                } else if (ch == 0x0D) {
                    fCarriageReturnCounter++;
                    fCharacterCounter = 1;
                } else
                    break;
            } else
                fCharacterCounter++;
        }
        while (true) { // REVISIT - EOF check ?
            if (ch < 0x80) {
                if (ch == -1) {
                    fCurrentOffset -= fBytesPerChar;
                    callCharDataHandler(offset, fCurrentOffset - offset, false);
                    return changeReaders().scanContent(element); // REVISIT - not quite...
                }
                prop = XMLCharacterProperties.fgCharFlags[ch];
                if ((prop & XMLCharacterProperties.E_CharDataFlag) == 0) {
                    if (ch == '<') {
                        if (!fInCDSect) {
                            callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, false);
                            fCharacterCounter++;
                            return recognizeMarkup();
                        }
                        fCharacterCounter++;
                    } else if (ch == '&') {
                        if (!fInCDSect) {
                            callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, false);
                            fCharacterCounter++;
                            return recognizeReference();
                        }
                        fCharacterCounter++;
                    } else if (ch == 0x0A) {
                        fLinefeedCounter++;
                        fCharacterCounter = 1;
                    } else if (ch == 0x0D) {
                        fCarriageReturnCounter++;
                        fCharacterCounter = 1;
                    } else if (ch == ']') {
                        if (getChar(fCurrentOffset) == ']' && getChar(fCurrentOffset + fBytesPerChar) == '>') {
                            callCharDataHandler(offset, (fCurrentOffset - fBytesPerChar) - offset, false);
                            fCharacterCounter += 3;
                            fCurrentOffset += (2 * fBytesPerChar);
                            return XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT;
                        }
                        fCharacterCounter++;
                    } else {
                        fCurrentOffset -= fBytesPerChar;
                        callCharDataHandler(offset, fCurrentOffset - offset, false);
                        return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                    }
                } else {
                    fCharacterCounter++;
                }
            } else {
                if (ch >= 0xD800 && ch <= 0xDFFF) {
                    fCharacterCounter++;
                    fCurrentOffset += fBytesPerChar;
                } else if (ch == 0xFFFE || ch == 0xFFFF) {
                    fCurrentOffset -= fBytesPerChar;
                    callCharDataHandler(offset, fCurrentOffset - offset, false);
                    return XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR;
                }
                fCharacterCounter++;
            }
            ch = getChar(fCurrentOffset);
            fCurrentOffset += fBytesPerChar;
        }
    }
}
"
org/apache/xerces/dom/DeepNodeListImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;
import java.util.Vector;

/**
 * This class implements the DOM's NodeList behavior for
 * Element.getElementsByTagName()
 * <P>
 * The DOM describes NodeList as follows:
 * <P>
 * 1) It may represent EITHER nodes scattered through a subtree (when
 * returned by Element.getElementsByTagName), or just the immediate
 * children (when returned by Node.getChildNodes). The latter is easy,
 * but the former (which this class addresses) is more challenging.
 * <P>
 * 2) Its behavior is ""live"" -- that is, it always reflects the
 * current state of the document tree. To put it another way, the
 * NodeLists obtained before and after a series of insertions and
 * deletions are effectively identical (as far as the user is
 * concerned, the former has been dynamically updated as the changes
 * have been made).
 * <P>
 * 3) Its API accesses individual nodes via an integer index, with the
 * listed nodes numbered sequentially in the order that they were
 * found during a preorder depth-first left-to-right search of the tree.
 * (Of course in the case of getChildNodes, depth is not involved.) As
 * nodes are inserted or deleted in the tree, and hence the NodeList,
 * the numbering of nodes that follow them in the NodeList will
 * change.
 * <P>
 * It is rather painful to support the latter two in the
 * getElementsByTagName case. The current solution is for Nodes to
 * maintain a change count (eventually that may be a Digest instead),
 * which the NodeList tracks and uses to invalidate itself.
 * <P>
 * Unfortunately, this does _not_ respond efficiently in the case that
 * the dynamic behavior was supposed to address: scanning a tree while
 * it is being extended. That requires knowing which subtrees have
 * changed, which can become an arbitrarily complex problem.
 * <P>
 * We save some work by filling the vector only as we access the
 * item()s... but I suspect the same users who demanded index-based
 * access will also start by doing a getLength() to control their loop,
 * blowing this optimization out of the water.
 * <P>
 * NOTE: Level 2 of the DOM will probably _not_ use NodeList for its
 * extended search mechanisms, partly for the reasons just discussed.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeepNodeListImpl 
    implements NodeList {

    //
    // Data
    //

    protected NodeImpl rootNode; // Where the search started
    protected String tagName;   // Or ""*"" to mean all-tags-acceptable
    protected int changes=0;
    protected Vector nodes;
    
    protected String nsName;
    protected boolean enableNS = false;

    //
    // Constructors
    //

    /** Constructor. */
    public DeepNodeListImpl(NodeImpl rootNode, String tagName) {
        this.rootNode = rootNode;
        this.tagName  = tagName;
        nodes = new Vector();
    }  

    /** Constructor for Namespace support. */
    public DeepNodeListImpl(NodeImpl rootNode,
                            String nsName, String tagName) {
        this(rootNode, tagName);
        this.nsName = (nsName != null && !nsName.equals("""")) ? nsName : null;
        enableNS = true;
    }
    
    //
    // NodeList methods
    //

    /** Returns the length of the node list. */
    public int getLength() {
        // Preload all matching elements. (Stops when we run out of subtree!)
        item(java.lang.Integer.MAX_VALUE);
        return nodes.size();
    }  

    /** Returns the node at the specified index. */
    public Node item(int index) {
    	Node thisNode;

        // Tree changed. Do it all from scratch!
    	if(rootNode.changes() != changes) {
            nodes   = new Vector();     
            changes = rootNode.changes();
    	}
    
        // In the cache
    	if (index < nodes.size())      
    	    return (Node)nodes.elementAt(index);
    
        // Not yet seen
    	else {
    
            // Pick up where we left off (Which may be the beginning)
    		if (nodes.size() == 0)     
    		    thisNode = rootNode;
    		else
    		    thisNode=(NodeImpl)(nodes.lastElement());
    
    		// Add nodes up to the one we're looking for
    		while(thisNode != null && index >= nodes.size()) {
    			thisNode=nextMatchingElementAfter(thisNode);
    			if (thisNode != null)
    			    nodes.addElement(thisNode);
    		    }

            // Either what we want, or null (not avail.)
		    return thisNode;           
	    }

    } // item(int):Node

    //
    // Protected methods (might be overridden by an extending DOM)
    //

    /** 
     * Iterative tree-walker. When you have a Parent link, there's often no
     * need to resort to recursion. NOTE THAT only Element nodes are matched
     * since we're specifically supporting getElementsByTagName().
     */
    protected Node nextMatchingElementAfter(Node current) {

	    Node next;
	    while (current != null) {
		    // Look down to first child.
		    if (current.hasChildNodes()) {
			    current = (current.getFirstChild());
		    }

		    // Look right to sibling (but not from root!)
		    else if (current != rootNode && null != (next = current.getNextSibling())) {
				current = next;
			}

			// Look up and right (but not past root!)
			else {
				next = null;
				for (; current != rootNode; // Stop when we return to starting point
					current = current.getParentNode()) {

					next = current.getNextSibling();
					if (next != null)
						break;
				}
				current = next;
			}

			// Have we found an Element with the right tagName?
			// (""*"" matches anything.)
		    if (current != rootNode 
		        && current != null
		        && current.getNodeType() ==  Node.ELEMENT_NODE) {
			if (!enableNS) {
			    if (tagName.equals(""*"") ||
				((ElementImpl) current).getTagName().equals(tagName))
			    {
				return current;
			    }
			} else {
			    // DOM2: Namespace logic. 
			    if (tagName.equals(""*"")) {
				if (nsName != null && nsName.equals(""*"")) {
				    return current;
				} else {
				    ElementImpl el = (ElementImpl) current;
				    if ((nsName == null
					 && el.getNamespaceURI() == null)
					|| (nsName != null
					    && nsName.equals(el.getNamespaceURI())))
				    {
					return current;
				    }
				}
			    } else {
				ElementImpl el = (ElementImpl) current;
				if (el.getLocalName() != null
				    && el.getLocalName().equals(tagName)) {
				    if (nsName != null && nsName.equals(""*"")) {
					return current;
				    } else {
					if ((nsName == null
					     && el.getNamespaceURI() == null)
					    || (nsName != null &&
						nsName.equals(el.getNamespaceURI())))
					{
					    return current;
					}
				    }
				}
			    }
			}
		    }

		// Otherwise continue walking the tree
	    }

	    // Fell out of tree-walk; no more instances found
	    return null;

    } // nextMatchingElementAfter(int):Node

} // class DeepNodeListImpl
"
org/apache/xerces/dom/EntityImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Entity nodes hold the reference data for an XML Entity -- either
 * parsed or unparsed. The nodeName (inherited from Node) will contain
 * the name (if any) of the Entity. Its data will be contained in the
 * Entity's children, in exactly the structure which an
 * EntityReference to this name will present within the document's
 * body.
 * <P>
 * Note that this object models the actual entity, _not_ the entity
 * declaration or the entity reference.
 * <P>
 * An XML processor may choose to completely expand entities before
 * the structure model is passed to the DOM; in this case, there will
 * be no EntityReferences in the DOM tree.
 * <P>
 * Quoting the 10/01 DOM Proposal,
 * <BLOCKQUOTE>
 * ""The DOM Level 1 does not support editing Entity nodes; if a user
 * wants to make changes to the contents of an Entity, every related
 * EntityReference node has to be replaced in the structure model by
 * a clone of the Entity's contents, and then the desired changes 
 * must be made to each of those clones instead. All the
 * descendants of an Entity node are readonly.""
 * </BLOCKQUOTE>
 * I'm interpreting this as: It is the parser's responsibilty to call
 * the non-DOM operation setReadOnly(true,true) after it constructs
 * the Entity. Since the DOM explicitly decided not to deal with this,
 * _any_ answer will involve a non-DOM operation, and this is the
 * simplest solution.
 *
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class EntityImpl 
    extends ParentNode
    implements Entity {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -3575760943444303423L;
    
    //
    // Data
    //

    /** Entity name. */
    protected String name;

    /** Public identifier. */
    protected String publicId;

    /** System identifier. */
    protected String systemId;

    /** Notation name. */
    protected String notationName;

    //
    // Constructors
    //

    /** Factory constructor. */
    public EntityImpl(DocumentImpl ownerDoc, String name) {
    	super(ownerDoc);
        this.name = name;
        readOnly(true);
    }
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.ENTITY_NODE;
    }

    /**
     * Returns the entity name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    /** Clone node. */
    public Node cloneNode(boolean deep) {
        EntityImpl newentity = (EntityImpl)super.cloneNode(deep);
        return newentity;
    }

    //
    // Entity methods
    //

    /** 
     * The public identifier associated with the entity. If not specified,
     * this will be null. 
     */
    public String getPublicId() {
        
        if (syncData()) {
            synchronizeData();
        }
        return publicId;

    } // getPublicId():String

    /** 
     * The system identifier associated with the entity. If not specified,
     * this will be null. 
     */
    public String getSystemId() {

        if (syncData()) {
            synchronizeData();
        }
        return systemId;

    } // getSystemId():String

    /** 
     * Unparsed entities -- which contain non-XML data -- have a
     * ""notation name"" which tells applications how to deal with them.
     * Parsed entities, which <em>are</em> in XML format, don't need this and
     * set it to null.  
     */
    public String getNotationName() {

        if (syncData()) {
            synchronizeData();
        }
        return notationName;

    } // getNotationName():String

    //
    // Public methods
    //

    /**
     * NON-DOM The public identifier associated with the entity. If not specified,
     * this will be null. */
    public void setPublicId(String id) {
        
        if (syncData()) {
            synchronizeData();
        }
    	publicId = id;

    } // getPublicId(String)

    /**
     * NON-DOM The system identifier associated with the entity. If not
     * specified, this will be null. 
     */
    public void setSystemId(String id) {

        if (syncData()) {
            synchronizeData();
        }
    	systemId = id;

    } // setSystemId(String)

    /** 
     * NON-DOM Unparsed entities -- which contain non-XML data -- have a
     * ""notation name"" which tells applications how to deal with them.
     * Parsed entities, which <em>are</em> in XML format, don't need this and
     * set it to null.  
     */
    public void setNotationName(String name) {
        
        if (syncData()) {
            synchronizeData();
        }
    	notationName = name;

    } // setNotationName(String)

} // class EntityImpl
"
org/apache/xerces/dom/DeferredEntityReferenceImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * EntityReference models the XML &entityname; syntax, when used for
 * entities defined by the DOM. Entities hardcoded into XML, such as
 * character entities, should instead have been translated into text
 * by the code which generated the DOM tree.
 * <P>
 * An XML processor has the alternative of fully expanding Entities
 * into the normal document tree. If it does so, no EntityReference nodes
 * will appear.
 * <P>
 * Similarly, non-validating XML processors are not required to read
 * or process entity declarations made in the external subset or
 * declared in external parameter entities. Hence, some applications
 * may not make the replacement value available for Parsed Entities 
 * of these types.
 * <P>
 * EntityReference behaves as a read-only node, and the children of 
 * the EntityReference (which reflect those of the Entity, and should
 * also be read-only) give its replacement value, if any. They are 
 * supposed to automagically stay in synch if the DocumentType is 
 * updated with new values for the Entity.
 * <P>
 * The defined behavior makes efficient storage difficult for the DOM
 * implementor. We can't just look aside to the Entity's definition
 * in the DocumentType since those nodes have the wrong parent (unless
 * we can come up with a clever ""imaginary parent"" mechanism). We
 * must at least appear to clone those children... which raises the
 * issue of keeping the reference synchronized with its parent.
 * This leads me back to the ""cached image of centrally defined data""
 * solution, much as I dislike it.
 * <P>
 * For now I have decided, since REC-DOM-Level-1-19980818 doesn't
 * cover this in much detail, that synchronization doesn't have to be
 * considered while the user is deep in the tree. That is, if you're
 * looking within one of the EntityReferennce's children and the Entity
 * changes, you won't be informed; instead, you will continue to access
 * the same object -- which may or may not still be part of the tree.
 * This is the same behavior that obtains elsewhere in the DOM if the
 * subtree you're looking at is deleted from its parent, so it's
 * acceptable here. (If it really bothers folks, we could set things
 * up so deleted subtrees are walked and marked invalid, but that's
 * not part of the DOM's defined behavior.)
 * <P>
 * As a result, only the EntityReference itself has to be aware of
 * changes in the Entity. And it can take advantage of the same
 * structure-change-monitoring code I implemented to support
 * DeepNodeList.
 * 
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredEntityReferenceImpl 
    extends EntityReferenceImpl 
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 390319091370032223L;
    
    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here. 
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredEntityReferenceImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);
        syncChildren(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** 
     * Synchronize the entity data. This is special because of the way
     * that the ""fast"" version stores the information.
     */
    protected void synchronizeData() {

        // no need to sychronize again
        syncData(false);

        // get the node data
        DeferredDocumentImpl ownerDocument = (DeferredDocumentImpl)this.ownerDocument;
        name = ownerDocument.getNodeNameString(fNodeIndex);
        
    } // synchronizeData()

    /** Synchronize the children. */
    protected void synchronizeChildren() {

        // no need to synchronize again
        syncChildren(false);

        // get children
        DocumentType doctype = ownerDocument.getDoctype();
        boolean found = false;
        if (doctype != null) {
            NamedNodeMap entities = doctype.getEntities();
            if (entities != null) {
                Entity entity = (Entity)entities.getNamedItem(getNodeName());
                if (entity != null) {

                    // we found the entity
                    found = true;

                    // clone entity at this reference
                    readOnly(false);
                    Node child = entity.getFirstChild();
                    while (child != null) {
                        appendChild(child.cloneNode(true));
                        child = child.getNextSibling();
                    }
                    setReadOnly(true, true);
                }
            }
        }

        // if not found, create entity at this reference
        if (!found) {
            readOnly(false);
            synchronizeChildren(fNodeIndex);
            setReadOnly(true, true);
        }

    } // synchronizeChildren()

    // inhibit the synchronize inherited from EntityReferenceImpl
    protected void synchronize() {
    }

} // class DeferredEntityReferenceImpl
"
org/xml/sax/Locator.java,true,"// SAX locator interface for document events.
// No warranty; no copyright -- use this as you will.
// $Id: Locator.java,v 1.4 2000/05/05 17:46:57 david Exp $

package org.xml.sax;


/**
 * Interface for associating a SAX event with a document location.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>If a SAX parser provides location information to the SAX
 * application, it does so by implementing this interface and then
 * passing an instance to the application using the content
 * handler's {@link org.xml.sax.ContentHandler#setDocumentLocator
 * setDocumentLocator} method.  The application can use the
 * object to obtain the location of any other content handler event
 * in the XML source document.</p>
 *
 * <p>Note that the results returned by the object will be valid only
 * during the scope of each content handler method: the application
 * will receive unpredictable results if it attempts to use the
 * locator at any other time.</p>
 *
 * <p>SAX parsers are not required to supply a locator, but they are
 * very strongly encouraged to do so.  If the parser supplies a
 * locator, it must do so before reporting any other document events.
 * If no locator has been set by the time the application receives
 * the {@link org.xml.sax.ContentHandler#startDocument startDocument}
 * event, the application should assume that a locator is not 
 * available.</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.ContentHandler#setDocumentLocator 
 */
public interface Locator {
    
    
    /**
     * Return the public identifier for the current document event.
     *
     * <p>The return value is the public identifier of the document
     * entity or of the external parsed entity in which the markup
     * triggering the event appears.</p>
     *
     * @return A string containing the public identifier, or
     *         null if none is available.
     * @see #getSystemId
     */
    public abstract String getPublicId ();
    
    
    /**
     * Return the system identifier for the current document event.
     *
     * <p>The return value is the system identifier of the document
     * entity or of the external parsed entity in which the markup
     * triggering the event appears.</p>
     *
     * <p>If the system identifier is a URL, the parser must resolve it
     * fully before passing it to the application.</p>
     *
     * @return A string containing the system identifier, or null
     *         if none is available.
     * @see #getPublicId
     */
    public abstract String getSystemId ();
    
    
    /**
     * Return the line number where the current document event ends.
     *
     * <p><strong>Warning:</strong> The return value from the method
     * is intended only as an approximation for the sake of error
     * reporting; it is not intended to provide sufficient information
     * to edit the character content of the original XML document.</p>
     *
     * <p>The return value is an approximation of the line number
     * in the document entity or external parsed entity where the
     * markup triggering the event appears.</p>
     *
     * <p>If possible, the SAX driver should provide the line position 
     * of the first character after the text associated with the document 
     * event.  The first line in the document is line 1.</p>
     *
     * @return The line number, or -1 if none is available.
     * @see #getColumnNumber
     */
    public abstract int getLineNumber ();
    
    
    /**
     * Return the column number where the current document event ends.
     *
     * <p><strong>Warning:</strong> The return value from the method
     * is intended only as an approximation for the sake of error
     * reporting; it is not intended to provide sufficient information
     * to edit the character content of the original XML document.</p>
     *
     * <p>The return value is an approximation of the column number
     * in the document entity or external parsed entity where the
     * markup triggering the event appears.</p>
     *
     * <p>If possible, the SAX driver should provide the line position 
     * of the first character after the text associated with the document 
     * event.</p>
     *
     * <p>If possible, the SAX driver should provide the line position 
     * of the first character after the text associated with the document 
     * event.  The first column in each line is column 1.</p>
     *
     * @return The column number, or -1 if none is available.
     * @see #getLineNumber
     */
    public abstract int getColumnNumber ();
    
}

// end of Locator.java
"
org/apache/xerces/readers/XCatalog.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLParser;
import org.apache.xerces.parsers.SAXParser;
import org.apache.xerces.utils.StringPool;

import org.xml.sax.AttributeList;
import org.xml.sax.DocumentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

/**
 * This catalog supports the XCatalog proposal draft 0.2 posted
 * to the xml-dev mailing list by 
 * <a href=""mailto:cowan@locke.ccil.org"">John Cowan</a>. XCatalog
 * is an XML representation of the SGML Open TR9401:1997 catalog
 * format. The current proposal supports public identifier maps,
 * system identifier aliases, and public identifier prefix 
 * delegates. Refer to the XCatalog DTD for the full specification 
 * of this catalog format at 
 * <a href=""http://www.ccil.org/~cowan/XML/XCatalog.html"">http://www.ccil.org/~cowan/XML/XCatalog.html</a>.
 * <p>
 * In order to use XCatalogs, you must write the catalog files
 * with the following restrictions:
 * <ul>
 * <li>You must follow the XCatalog grammar.
 * <li>You must specify the <tt>&lt;!DOCTYPE&gt;</tt> line with
 *   the <tt>PUBLIC</tt> specified as ""-//DTD XCatalog//EN"" or
 *   make sure that the system identifier is able to locate the
 *   XCatalog 0.2 DTD (which is included in the Jar file containing
 *   the org.apache.xerces.readers.XCatalog class).
 *   For example:
 *   <pre>
 *   &lt;!DOCTYPE XCatalog PUBLIC ""-//DTD XCatalog//EN"" ""org/apache/xerces/readers/xcatalog.dtd""&gt;
 *   </pre>
 * <li>The enclosing <tt>&lt;XCatalog&gt;</tt> document root 
 *   element is <b>not</b> optional -- it <b>must</b> be specified.
 * <li>The <tt>Version</tt> attribute of the <tt>&lt;XCatalog&gt;</tt>
 *   has been modified from '<tt><i>#FIXED ""1.0""</i></tt>' to 
 *   '<tt><i>(0.1|0.2) ""0.2""</i></tt>'.
 * </ul>
 * <p>
 * To use this catalog in a parser, set an XCatalog instance as the
 * parser's <tt>EntityResolver</tt>. For example:
 * <pre>
 *   XMLParser parser  = new AnyParser();
 *   Catalog   catalog = <font color=""blue"">new XCatalog()</font>;
 *   <font color=""blue"">parser.getEntityHandler().setEntityResolver(catalog);</font>
 * </pre>
 * <p>
 * Once installed, catalog files that conform to the XCatalog grammar
 * can be appended to the catalog by calling the <tt>loadCatalog</tt>
 * method on the parser or the catalog instance. The following example
 * loads the contents of two catalog files:
 * <pre>
 *   parser.loadCatalog(new InputSource(""catalogs/cat1.xml""));
 *   parser.loadCatalog(new InputSource(""http://host/catalogs/cat2.xml""));
 * </pre>
 * <p>
 * <b>Limitations:</b> The following are the current limitations
 * of this XCatalog implementation:
 * <ul>
 * <li>No error checking is done to avoid circular <tt>Delegate</tt>
 *   or <tt>Extend</tt> references. Do not specify a combination of
 *   catalog files that reference each other.
 * </ul>
 *
 * @author  Andy Clark, IBM
 * @version $Id$
 */
public class XCatalog
    extends XMLCatalogHandler
    {

    //
    // Constants
    //

    // public

    /** XCatalog public identifier string (""-//DTD XCatalog//EN""). */
    public static final String XCATALOG_DTD_PUBLICID = ""-//DTD XCatalog//EN"";

    // ""default""

    /** XCatalog DTD resource name (""xcatalog.dtd""). */
    static final String DTD = ""xcatalog.dtd"";

    /** XCatalog element name (""XCatalog""). */
    static final String XCATALOG = ""XCatalog"";

    /** Map element name (""Map""). */
    static final String MAP = ""Map"";

    /** PublicID attribute name (""PublicID""). */
    static final String PUBLICID = ""PublicID"";

    /** HRef attribute name (""HRef""). */
    static final String HREF = ""HRef"";

    /** Delegate element name (""Delegate""). */
    static final String DELEGATE = ""Delegate"";

    /** Extend element name (""Extend""). */
    static final String EXTEND = ""Extend"";

    /** Base element name (""Base""). */
    static final String BASE = ""Base"";

    /** Remap element name (""Remap""). */
    static final String REMAP = ""Remap"";

    /** SystemID attribute name (""SystemID""). */
    static final String SYSTEMID = ""SystemID"";

    // private

    /** Set to true and recompile to include debugging code in class. */
    private static final boolean DEBUG = false;

    //
    // Data
    //

    /** Delegates. */
    private Hashtable delegate = new Hashtable();

    /** Delegates ordering. */
    private Vector delegateOrder = new Vector();

    //
    // Constructors
    //

    /** 
     * Constructs an XCatalog instance.
     */
    public XCatalog() {
    }

    //
    // Catalog methods
    //

    /**
     * Loads the catalog stream specified by the given input source and
     * appends the contents to the catalog.
     *
     * @param source The catalog source.
     *
     * @exception org.xml.sax.SAXException Throws exception on SAX error.
     * @exception java.io.IOException Throws exception on i/o error.
     */
    public void loadCatalog(InputSource source)
        throws SAXException, IOException
        {
        
        new Parser(source);

        /***
        if (DEBUG) {
            print("""");
            }
        /***/

        } // loadCatalog(InputSource)

    /***
    void print(String indent) {
        System.out.println(indent+""# ""+this);
        Enumeration maps = getMapKeys();
        while (maps.hasMoreElements()) {
            String key   = (String)maps.nextElement();
            String value = getMapValue(key);
            System.out.println(indent+""MAP \""""+key+""\"" -> \""""+value+""\"""");
            }
        Enumeration delegates = getDelegateKeys();
        while (delegates.hasMoreElements()) {
            String   key   = (String)delegates.nextElement();
            XCatalog value = getDelegateValue(key);
            System.out.println(indent+""DELEGATE \""""+key+""\"" -> ""+value);
            value.print(indent+""  "");
            }
        Enumeration remaps = getRemapKeys();
        while (remaps.hasMoreElements()) {
            String key   = (String)remaps.nextElement();
            String value = getRemapValue(key);
            System.out.println(indent+""REMAP \""""+key+""\"" -> \""""+value+""\"""");
            }
        }
    /***/

    //
    // EntityResolver methods
    //

    /**
     * Resolves external entities.
     *
     * @param publicId The public identifier used for entity resolution.
     * @param systemId If the publicId is not null, this systemId is
     *                 to be considered the default system identifier;
     *                 else a system identifier alias mapping is
     *                 requested.
     *
     * @return Returns the input source of the resolved entity or null
     *         if no resolution is possible.
     *
     * @exception org.xml.sax.SAXException Exception thrown on SAX error.
     * @exception java.io.IOException Exception thrown on i/o error. 
     */
    public InputSource resolveEntity(String publicId, String systemId) 
        throws SAXException, IOException
        {

        if (DEBUG) {
            System.out.println(""resolveEntity(\""""+publicId+""\"", \""""+systemId+""\"")"");
            }

        // public identifier resolution
        if (publicId != null) {
            // direct public id mappings
            String value = getPublicMapping(publicId);
            if (DEBUG) {
                System.out.println(""  map: \""""+publicId+""\"" -> \""""+value+""\"""");
                }
            if (value != null) {
                InputSource source = resolveEntity(null, value);
                if (source == null) {
                    source = new InputSource(value);
                    }
                source.setPublicId(publicId);
                return source;
                }

            // delegates
            Enumeration delegates = getDelegateCatalogKeys();
            while (delegates.hasMoreElements()) {
                String key = (String)delegates.nextElement();
                if (DEBUG) {
                    System.out.println(""  delegate: \""""+key+""\"""");
                    }
                if (publicId.startsWith(key)) {
                    XMLCatalogHandler catalog = getDelegateCatalog(key);
                    InputSource source = catalog.resolveEntity(publicId, systemId);
                    if (source != null) {
                        return source;
                        }
                    }
                }
            }

        // system identifier resolution
        String value = getSystemMapping(systemId);
        if (value != null) {
            if (DEBUG) {
                System.out.println(""  remap: \""""+systemId+""\"" -> \""""+value+""\"""");
                }
            InputSource source = new InputSource(value);
            source.setPublicId(publicId);
            return source;
            }

        // use default behavior
        if (DEBUG) {
            System.out.println(""  returning null!"");
            }
        return null;

        } // resolveEntity(String,String):InputSource

    //
    // Public methods
    //

    /** 
     * Adds a delegate mapping. If the prefix of a public identifier
     * matches a delegate prefix, then the delegate catalog is
     * searched in order to resolve the identifier.
     * <p>
     * This method makes sure that prefixes that match each other
     * are inserted into the delegate list in order of longest prefix
     * length first.
     *
     * @param prefix  The delegate prefix.
     * @param catalog The delegate catalog.
     */
    public void addDelegateCatalog(String prefix, XCatalog catalog) {

        synchronized (delegate) {
            // insert prefix in proper order
            if (!delegate.containsKey(prefix)) {
                int size = delegateOrder.size();
                boolean found = false;
                for (int i = 0; i < size; i++) {
                    String element = (String)delegateOrder.elementAt(i);
                    if (prefix.startsWith(element) || prefix.compareTo(element) < 0) {
                        delegateOrder.insertElementAt(prefix, i);
                        found = true;
                        break;
                        }
                    }
                if (!found) {
                    delegateOrder.addElement(prefix);
                    }
                }

            // replace (or add new) prefix mapping
            delegate.put(prefix, catalog);
            }

        } // addDelegateCatalog(String,XCatalog)

    /** 
     * Removes a delegate. 
     *
     * @param prefix The delegate prefix to remove.
     */
    public void removeDelegateCatalog(String prefix) {

        synchronized (delegate) {
            delegate.remove(prefix);
            delegateOrder.removeElement(prefix);
            }

        } // removeDelegateCatalog(String)

    /** Returns an enumeration of delegate prefixes. */
    public Enumeration getDelegateCatalogKeys() {
        return delegateOrder.elements();
        }

    /** Returns the catalog for the given delegate prefix. */
    public XCatalog getDelegateCatalog(String prefix) {
        return (XCatalog)delegate.get(prefix);
        }

    //
    // ""default"" methods
    //

    /** Returns true if the string is a valid URL. */
    boolean isURL(String str) {
        try {
            new java.net.URL(str);
            return true;
            }
        catch (java.net.MalformedURLException e) {
            // assume the worst
            }
        return false;
        }

    //
    // Classes
    //

    /** Parser for XCatalog document instances. */
    class Parser
        extends SAXParser
        implements DocumentHandler
        {

        //
        // Data
        //

        /** The base. */
        private String base;

        //
        // Constructors
        //

        /** Parses the specified input source. */
        public Parser(InputSource source) 
            throws SAXException, IOException
            {

            // setup parser
            setEntityResolver(new Resolver());
            setDocumentHandler((DocumentHandler)this);

            // set base and parse
            setBase(source.getSystemId());
            parse(source);

            } // <init>(InputSource)

        //
        // Protected methods
        //

        /** 
         * Sets the base from the given system identifier. The base is
         * the same as the system identifier with the least significant
         * part (the filename) removed.
         */
        protected void setBase(String systemId) throws SAXException {

            // normalize system id
            if (systemId == null) { 
                systemId = """"; 
                }

            // expand system id
            systemId = fEntityHandler.expandSystemId(systemId);

            // cut off the least significant part
            int index = systemId.lastIndexOf('/');
            if (index != -1) {
                systemId = systemId.substring(0, index + 1);
                }

            // save base
            base = systemId;

            } // setBase(String)

        //
        // DocumentHandler methods
        //

        /** Not implemented. */
        public void processingInstruction(String target, String data) {}

        /** Not implemented. */
        public void setDocumentLocator(org.xml.sax.Locator locator) {}

        /** Not implemented. */
        public void startDocument() {}

        /** Not implemented. */
        public void endElement(String elementName) {}

        /** Not implemented. */
        public void endDocument() {}

        /** Not implemented. */
        public void characters(char ch[], int start, int length) {}

        /** Not implemented. */
        public void ignorableWhitespace(char ch[], int start, int length) {}

        /** The start of an element. */
        public void startElement(String elementName, AttributeList attrList) 
            throws SAXException
            {

            try {
                // <XCatalog Version=""..."">
                if (elementName.equals(XCATALOG)) {
                    return;
                    }
    
                // <Map PublicID=""..."" HRef=""...""/>
                if (elementName.equals(MAP)) {
                    // get attributes
                    String publicId = attrList.getValue(PUBLICID);
                    String href     = attrList.getValue(HREF);
                    if (DEBUG) {
                        System.out.println(""MAP \""""+publicId+""\"" \""""+href+""\"""");
                        }
    
                    // create mapping
                    if (!isURL(href)) {
                        href = base + href;
                        }
                    addPublicMapping(publicId, href);
                    }
    
                // <Delegate PublicId=""..."" HRef=""...""/>
                else if (elementName.equals(DELEGATE)) {
                    // get attributes
                    String publicId = attrList.getValue(PUBLICID);
                    String href     = attrList.getValue(HREF);
                    if (DEBUG) {
                        System.out.println(""DELEGATE \""""+publicId+""\"" \""""+href+""\"""");
                        }
    
                    // expand system id
                    if (!isURL(href)) {
                        href = base + href;
                        }
                    String systemId = fEntityHandler.expandSystemId(href);
    
                    // create delegate
                    XCatalog catalog = new XCatalog();
                    catalog.loadCatalog(new InputSource(systemId));
                    addDelegateCatalog(publicId, catalog);
                    }
    
                // <Extend HRef=""...""/>
                else if (elementName.equals(EXTEND)) {
                    // get attributes
                    String href = attrList.getValue(HREF);
                    if (DEBUG) {
                        System.out.println(""EXTEND \""""+href+""\"""");
                        }
    
                    // expand system id
                    if (!isURL(href)) {
                        href = base + href;
                        }
                    String systemId = fEntityHandler.expandSystemId(href);
    
                    // create catalog
                    XCatalog.this.loadCatalog(new InputSource(systemId));
                    }
    
                // <Base HRef=""...""/>
                else if (elementName.equals(BASE)) {
                    // get attributes
                    String href = attrList.getValue(HREF);
    
                    // set new base
                    setBase(href);
                    if (DEBUG) {
                        System.out.println(""BASE \""""+href+""\"" -> \""""+base+""\"""");
                        }
                    }
                
                // <Remap SystemID=""..."" HRef=""...""/>
                else if (elementName.equals(REMAP)) {
                    // get attributes
                    String systemId = attrList.getValue(SYSTEMID);
                    String href     = attrList.getValue(HREF);
                    if (DEBUG) {
                        System.out.println(""REMAP \""""+systemId+""\"" \""""+href+""\"""");
                        }
    
                    // create mapping
                    if (!isURL(href)) {
                        href = base + href;
                        }
                    addSystemMapping(systemId, href);
                    }
                }
            catch (Exception e) {
                throw new SAXException(e);
                }

            } // startElement(String,AttributeList)

        //
        // Classes
        //

        /** Resolver for locating the XCatalog DTD resource. */
        class Resolver
            implements EntityResolver
            {

            /** Resolves the XCatalog DTD entity. */
            public InputSource resolveEntity(String publicId, String systemId) 
                throws SAXException, IOException
                {

                // resolve the XCatalog DTD?
                if (publicId != null && publicId.equals(XCATALOG_DTD_PUBLICID)) {
                    InputSource src = new InputSource();
                    src.setPublicId(publicId);
                    InputStream is = getClass().getResourceAsStream(DTD);
                    src.setByteStream(is);
                    src.setCharacterStream(new InputStreamReader(is));
                    return src;
                    }

                // no resolution possible
                return null;

                } // resolveEntity(String,String):InputSource

            } // class Resolver

        } // class Parser

    } // class XCatalog
"
org/apache/xerces/dom/AttrImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;
import org.apache.xerces.dom.events.MutationEventImpl;

/**
 * Attribute represents an XML-style attribute of an
 * Element. Typically, the allowable values are controlled by its
 * declaration in the Document Type Definition (DTD) governing this
 * kind of document.
 * <P>
 * If the attribute has not been explicitly assigned a value, but has
 * been declared in the DTD, it will exist and have that default. Only
 * if neither the document nor the DTD specifies a value will the
 * Attribute really be considered absent and have no value; in that
 * case, querying the attribute will return null.
 * <P>
 * Attributes may have multiple children that contain their data. (XML
 * allows attributes to contain entity references, and tokenized
 * attribute types such as NMTOKENS may have a child for each token.)
 * For convenience, the Attribute object's getValue() method returns
 * the string version of the attribute's value.
 * <P>
 * Attributes are not children of the Elements they belong to, in the
 * usual sense, and have no valid Parent reference. However, the spec
 * says they _do_ belong to a specific Element, and an INUSE exception
 * is to be thrown if the user attempts to explicitly share them
 * between elements.
 * <P>
 * Note that Elements do not permit attributes to appear to be shared
 * (see the INUSE exception), so this object's mutability is
 * officially not an issue.
 * <p>
 * Note: The ownerNode attribute is used to store the Element the Attr
 * node is associated with. Attr nodes do not have parent nodes.
 * Besides, the getOwnerElement() method can be used to get the element node
 * this attribute is associated with.
 * <P>
 * AttrImpl does not support Namespaces. AttrNSImpl, which inherits from
 * it, does.
 * @see AttrNSImpl
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class AttrImpl
    extends ParentNode
    implements Attr {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 7277707688218972102L;

    //
    // Data
    //

    /** Attribute name. */
    protected String name;

    //
    // Constructors
    //

    /**
     * Attribute has no public constructor. Please use the factory
     * method in the Document class.
     */
    protected AttrImpl(DocumentImpl ownerDocument, String name) {
    	super(ownerDocument);
        this.name = name;
        /** False for default attributes. */
        specified(true);
    }

    // for AttrNS
    protected AttrImpl() {}

    //
    // Node methods
    //
    
    /**
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.ATTRIBUTE_NODE;
    }

    /**
     * Returns the attribute name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    /**
     * Implicit in the rerouting of getNodeValue to getValue is the
     * need to redefine setNodeValue, for symmetry's sake.  Note that
     * since we're explicitly providing a value, Specified should be set
     * true.... even if that value equals the default.
     */
    public void setNodeValue(String value) throws DOMException {
    	setValue(value);
    }

    /**
     * In Attribute objects, NodeValue is considered a synonym for
     * Value.
     *
     * @see #getValue()
     */
    public String getNodeValue() {
    	return getValue();
    }

    //
    // Attr methods
    //

    /**
     * In Attributes, NodeName is considered a synonym for the
     * attribute's Name
     */
    public String getName() {

        if (syncData()) {
            synchronizeData();
        }
    	return name;

    } // getName():String

    /**
     * The DOM doesn't clearly define what setValue(null) means. I've taken it
     * as ""remove all children"", which from outside should appear
     * similar to setting it to the empty string.
     */
    public void setValue(String value) {

    	if (readOnly()) {
    		throw new DOMExceptionImpl(
    			DOMException.NO_MODIFICATION_ALLOWED_ERR, 
    			""DOM001 Modification not allowed"");
        }
    		
        LCount lc=null;
        String oldvalue="""";
        if(MUTATIONEVENTS)
        {
            // MUTATION PREPROCESSING AND PRE-EVENTS:
            // Only DOMAttrModified need be produced directly.
            // It needs the previous value. Note that this may be
            // a treewalk, so I've put it under the conditional.
            lc=LCount.lookup(MutationEventImpl.DOM_ATTR_MODIFIED);
            if(lc.captures+lc.bubbles+lc.defaults>0 && ownerNode!=null)
            {
               oldvalue=getValue();
            }
            
        } // End mutation preprocessing

        if(MUTATIONEVENTS)
        {
            // Can no longer just discard the kids; they may have
            // event listeners waiting for them to disconnect.
            if (syncChildren()) {
                synchronizeChildren();
            }
            while(firstChild!=null)
                internalRemoveChild(firstChild,MUTATION_LOCAL);
        }
        else
        {
            // simply discard children
            if (firstChild != null) {
                // remove ref from first child to last child
                firstChild.previousSibling = null;
                firstChild.firstChild(false);
                // then remove ref to first child
                firstChild   = null;
            }
            syncChildren(false);
        }

        // Create and add the new one, generating only non-aggregate events
        // (There are no listeners on the new Text, but there may be
        // capture/bubble listeners on the Attr.
        // Note that aggregate events are NOT dispatched here,
        // since we need to combine the remove and insert.
    	specified(true);
        if (value != null) {
            internalInsertBefore(ownerDocument.createTextNode(value),null,
                                 MUTATION_LOCAL);
        }
		
    	changed(); // ***** Is this redundant?

        if(MUTATIONEVENTS)
        {
            // MUTATION POST-EVENTS:
            dispatchAggregateEvents(this,oldvalue);            
        }
		
    } // setValue(String)

    /**
     * The ""string value"" of an Attribute is its text representation,
     * which in turn is a concatenation of the string values of its children.
     */
    public String getValue() {

        if (syncChildren()) {
            synchronizeChildren();
        }
        if (firstChild == null) {
            return """";
        }
        ChildNode node = firstChild.nextSibling;
        if (node == null) {
            return firstChild.getNodeValue();
        }
    	StringBuffer value = new StringBuffer(firstChild.getNodeValue());
    	while (node != null) {
            value.append(node.getNodeValue());
            node = node.nextSibling;
    	}
    	return value.toString();

    } // getValue():String

    /**
     * The ""specified"" flag is true if and only if this attribute's
     * value was explicitly specified in the original document. Note that
     * the implementation, not the user, is in charge of this
     * property. If the user asserts an Attribute value (even if it ends
     * up having the same value as the default), it is considered a
     * specified attribute. If you really want to revert to the default,
     * delete the attribute from the Element, and the Implementation will
     * re-assert the default (if any) in its place, with the appropriate
     * specified=false setting.
     */
    public boolean getSpecified() {

        if (syncData()) {
            synchronizeData();
        }
    	return specified();

    } // getSpecified():boolean

    //
    // Attr2 methods
    //

    /**
     * Returns the element node that this attribute is associated with,
     * or null if the attribute has not been added to an element.
     *
     * @see #getOwnerElement
     *
     * @deprecated Previous working draft of DOM Level 2. New method
     *             is <tt>getOwnerElement()</tt>.
     */
    public Element getElement() {
        // if we have an owner, ownerNode is our ownerElement, otherwise it's
        // our ownerDocument and we don't have an ownerElement
        return (Element) (owned() ? ownerNode : null);
    }

    /**
     * Returns the element node that this attribute is associated with,
     * or null if the attribute has not been added to an element.
     *
     * @since WD-DOM-Level-2-19990719
     */
    public Element getOwnerElement() {
        // if we have an owner, ownerNode is our ownerElement, otherwise it's
        // our ownerDocument and we don't have an ownerElement
        return (Element) (owned() ? ownerNode : null);
    }
    
    public void normalize() {

    	Node kid, next;
    	for (kid = firstChild; kid != null; kid = next) {
    		next = kid.getNextSibling();

    		// If kid and next are both Text nodes (but _not_ CDATASection,
    		// which is a subclass of Text), they can be merged.
    		if (next != null
			 && kid.getNodeType() == Node.TEXT_NODE
			 && next.getNodeType() == Node.TEXT_NODE)
    	    {
    			((Text)kid).appendData(next.getNodeValue());
    			removeChild(next);
    			next = kid; // Don't advance; there might be another.
    		}

        }

    } // normalize()

    //
    // Public methods
    //

    /** NON-DOM, for use by parser */
    public void setSpecified(boolean arg) {

        if (syncData()) {
            synchronizeData();
        }
    	specified(arg);

    } // setSpecified(boolean)

    //
    // Object methods
    //

    /** NON-DOM method for debugging convenience */
    public String toString() {
    	return getName() + ""="" + ""\"""" + getValue() + ""\"""";
    }

} // class AttrImpl
"
org/w3c/dom/CharacterData.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>CharacterData</code> interface extends Node with a set of 
 * attributes and methods for accessing character data in the DOM.  For 
 * clarity this set is defined here rather than on each object that uses 
 * these attributes and methods. No DOM objects correspond directly to 
 * <code>CharacterData</code> , though <code>Text</code> and others do 
 * inherit the interface from it. All <code>offsets</code> in this interface 
 * start from 0.
 * <p> As explained in the <code>DOMString</code> interface, text strings in 
 * the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units.  In 
 * the following, the term  16-bit units is used whenever necessary to 
 * indicate that indexing on CharacterData is done in 16-bit units.
 */
public interface CharacterData extends Node {
    /**
     *  The character data of the node that implements this interface. The DOM 
     * implementation may not put arbitrary limits on the amount of data that 
     * may be stored in a  <code>CharacterData</code> node. However, 
     * implementation limits may  mean that the entirety of a node's data may 
     * not fit into a single <code>DOMString</code> . In such cases, the user 
     * may call <code>substringData</code> to retrieve the data in 
     * appropriately sized pieces.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     * @exception DOMException
     *    DOMSTRING_SIZE_ERR: Raised when it would return more characters 
     *   than fit in a <code>DOMString</code> variable on the implementation 
     *   platform.
     */
    public String getData()
                                  throws DOMException;
    public void setData(String data)
                                  throws DOMException;

    /**
     *  The number of  16-bit units that are available through 
     * <code>data</code> and the <code>substringData</code> method below.  
     * This may have the value zero, i.e., <code>CharacterData</code> nodes 
     * may be empty.
     */
    public int getLength();

    /**
     *  Extracts a range of data from the node.
     * @param offset  Start offset of substring to extract.
     * @param count  The number of 16-bit units to extract.
     * @return  The specified substring. If the sum of <code>offset</code> and 
     *   <code>count</code> exceeds the <code>length</code> , then all 16-bit 
     *   units to the end of the data are returned.
     * @exception DOMException
     *    INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is 
     *   negative or greater than the number of 16-bit units in 
     *   <code>data</code> , or if the specified <code>count</code> is 
     *   negative.
     *   <br> DOMSTRING_SIZE_ERR: Raised if the specified range of text does 
     *   not fit into a <code>DOMString</code> .
     */
    public String substringData(int offset, 
                                int count)
                                throws DOMException;

    /**
     *  Append the string to the end of the character data of the node. Upon 
     * success, <code>data</code> provides access to the concatenation of 
     * <code>data</code> and the <code>DOMString</code> specified.
     * @param arg  The <code>DOMString</code> to append.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void appendData(String arg)
                           throws DOMException;

    /**
     *  Insert a string at the specified character offset.
     * @param offset  The character offset at which to insert.
     * @param arg  The <code>DOMString</code> to insert.
     * @exception DOMException
     *    INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is 
     *   negative or greater than the number of 16-bit units in 
     *   <code>data</code> .
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void insertData(int offset, 
                           String arg)
                           throws DOMException;

    /**
     *  Remove a range of  16-bit units from the node. Upon success, 
     * <code>data</code> and <code>length</code> reflect the change.
     * @param offset  The offset from which to start removing.
     * @param count  The number of 16-bit units to delete. If the sum of 
     *   <code>offset</code> and <code>count</code> exceeds 
     *   <code>length</code> then all 16-bit units from <code>offset</code> 
     *   to the end of the data are deleted.
     * @exception DOMException
     *    INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is 
     *   negative or greater than the number of 16-bit units in 
     *   <code>data</code> , or if the specified <code>count</code> is 
     *   negative.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void deleteData(int offset, 
                           int count)
                           throws DOMException;

    /**
     *  Replace the characters starting at the specified  16-bit unit offset 
     * with the specified string.
     * @param offset  The offset from which to start replacing.
     * @param count  The number of 16-bit units to replace. If the sum of 
     *   <code>offset</code> and <code>count</code> exceeds 
     *   <code>length</code> , then all 16-bit units to the end of the data 
     *   are replaced; (i.e., the effect is the same as a <code>remove</code> 
     *   method call with the same range, followed by an <code>append</code> 
     *   method invocation).
     * @param arg  The <code>DOMString</code> with which the range must be 
     *   replaced.
     * @exception DOMException
     *    INDEX_SIZE_ERR: Raised if the specified <code>offset</code> is 
     *   negative or greater than the number of 16-bit units in 
     *   <code>data</code> , or if the specified <code>count</code> is 
     *   negative.
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public void replaceData(int offset, 
                            int count, 
                            String arg)
                            throws DOMException;

}

"
org/apache/xerces/parsers/RevalidatingDOMParser.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.parsers;

import org.apache.xerces.dom.TextImpl;
import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.framework.XMLValidator;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLMessages;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * This class is a validating DOM parser which can also
 * ""revalidate"" a DOM subtree after the document has been parsed.
 *
 * @version
 * @see org.apache.xerces.parsers.DOMParser
 */
public class RevalidatingDOMParser 
    extends DOMParser {

    //
    // Constants
    //

    // debugging

    /** Set to true to debug validate() method. */
    private static final boolean DEBUG_VALIDATE = false;

    //
    // Public methods
    //

    /**
     * Given a node which is a DOM tree (or subtree), validate the tree 
     * against the current DTD.  If the tree is valid, return null.  If
     * the subtree is invalid return the highest (closest to the root) 
     * and left most node which causes the tree to be invalid.
     *
     * @param node  The node representing the root of the DOM subtree to be
     *              revalidated.
     *
     * @return <i>null</i> if the subtree is valid or the first (highest and 
     *         leftmost) node where the tree is invalid.
     */
    public final Node validate(Node node) {

        if (node.getNodeType() != Node.ELEMENT_NODE) {
            throw new IllegalArgumentException(""Can't revalidate a non element"");
        }

        // perform validation
        return recursiveValidate(node, fValidator, fStringPool);

    } // validate(Node):Node

    //
    // Private methods
    //

    /** 
     * Recursive validation. This method returns the first node that is
     * in error, or <i>null</i> if the content is valid.
     *
     * @param node              The node to validate.
     * @param validator         The validation handler.
     * @param stringPool        The string pool
     */
    private final Node recursiveValidate(Node node,
                                         XMLValidator validator,
                                         StringPool stringPool) {

        // debugging output
        if (DEBUG_VALIDATE) {
            print(node, """");
        }

        // build up child array to pass to validator
        int  children[] = new int[countChildren(node)];
        Node nodes[]    = new Node[children.length];
        int  count      = expandChildren(node, children, nodes, 0, stringPool);

        // validate this node
        int result = -1;
        int parentNameIndex = stringPool.addSymbol(node.getNodeName());
        int parentIndex = -1;
        try {
            parentIndex = fStringPool.getDeclaration(parentNameIndex);
            result = validator.checkContent(parentIndex, count, children);
        } 
        catch (Exception e) {
            // the default validation handler doesn't throw exceptions
            if (DEBUG_VALIDATE) {
                e.printStackTrace();
            }
        }

        // did an error occur?
        Node errorNode = null;
        if (result != -1) {
            // set node where error occured
            errorNode = nodes[result];

            // perform error handler callback
            String cs  = validator.getContentSpecAsString(parentIndex);
            int majorCode = result != count ? XMLMessages.MSG_CONTENT_INVALID : XMLMessages.MSG_CONTENT_INCOMPLETE;
            try {
                Object[] args = { node.getNodeName(), cs };
                fErrorReporter.reportError(fErrorReporter.getLocator(),
                                           XMLMessages.XML_DOMAIN,
                                           majorCode,
                                           0,
                                           args,
                                           XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
            }
            catch (Exception e) {
                // ignore
            }
        }

        // validate children
        else {
            for (int i = 0; i < count; i++) {
                if (children[i] != -1) {
                    Node child = nodes[i];
                    if (child != null) {
                        child = recursiveValidate(child, 
                                                  validator, 
                                                  stringPool);
                        if (child != null) {
                            errorNode = child;
                            break;
                        }
                    }
                }
            }
        }

        // explicitly null out references
        children = null;
        nodes    = null;

        // return success
        return errorNode;
    
    }

    /**
     * Expands the children of the specified node into the given
     * integer array (internal indices) and Node array. 
     * <p>
     * This method returns the number of children that were actually
     * expanded since text nodes may be ignorable whitespace.
     *
     * @param node      The node for which to expand the children.
     * @param children  The destination array of the internal indices
     *                  representing the children of the specified node.
     *                  A value of -1 indicates text.
     * @param nodes     The destination array of node objects representing
     *                  the children.
     * @param count     The number of children. Since this method is
     *                  called recursively in the case of entity
     *                  references, this is the offset of where to begin
     *                  adding children. The first call to this method
     *                  passes 0 as the initial count.
     * @param stringPool The string pool where element name symbols are
     *                  stored.
     */
    private final int expandChildren(Node node, 
                                     int children[], Node nodes[], int count,
                                     StringPool stringPool) {

        // fill in children array
        if (node.hasChildNodes()) {

            NodeList childList  = node.getChildNodes();
            int      childCount = childList.getLength();
            for (int i = 0; i < childCount; i++) {
                Node child = childList.item(i);
                int  type  = child.getNodeType();

                // element
                if (type == Node.ELEMENT_NODE) {
                    children[count] = stringPool.addSymbol(child.getNodeName());
                    nodes[count]    = child;
                    count++;
                } 

                // not ignorable text
                else if (type == Node.TEXT_NODE) {
                    if (!(child instanceof TextImpl) || 
                        !((TextImpl)child).isIgnorableWhitespace()) { 
                        children[count] = -1;
                        nodes[count]    = child;
                        count++;
                    }
                }

                // entity reference node
                else if (type == Node.ENTITY_REFERENCE_NODE) {
                    count = expandChildren(child, 
                                           children, nodes, count, 
                                           stringPool);
                }

            } // for children

        } // if has children

        // return
        return count;

    } // expandChildren(Node,int[],Node[],int,StringPool):int

    /**
     * Returns the <i>true</i> number of children under the specified
     * node. When entity references occur as direct children, a
     * recursive call to this method is made in order to count those
     * nodes as children of the original node specified.
     *
     * @param node  The node whose children are to be counted.
     */
    private final int countChildren(Node node) {

        // count the children
        int count = 0;
        if (node.hasChildNodes()) {

            // count initial children
            NodeList children = node.getChildNodes();
            count += children.getLength();

            // handle entity references as special case
            //
            // Note: The variable ""i"" is decremented in this loop
            //       to avoid the use of an extraneous variable to
            //       hold the original child count. Since we're
            //       just counting the number of children, this is
            //       acceptable. -Ac
            for (int i = count - 1; i >= 0; i--) {
                Node child = children.item(i);
                if (child.getNodeType() == Node.ENTITY_REFERENCE_NODE) {
                    // The -1 is to remove the entity reference node. -Ac
                    count += countChildren(child) - 1;
                }
            }
        }

        // return
        return count;

    } // countChildren(Node):int

    //
    // Debugging methods
    //

    /** Debugging print method. */
    private static void print(Node node, String indent) {

        if (DEBUG_VALIDATE) {
            if (node == null) {
                System.out.println(indent+""!!! node == null"");
                return;
            }
            System.out.println(indent+
                               ""node: type=""+type(node.getNodeType())+
                               "", name=""+node.getNodeName()+
                               "", value=\""""+normalize(node.getNodeValue())+'""');
            if (node.hasChildNodes()) {
                System.out.println(indent+'{');
                NodeList children = node.getChildNodes();
                int count = children.getLength();
                for (int i = 0; i < count; i++) {
                    print(children.item(i), indent+""  "");
                }
                System.out.println(indent+'}');
            }
        }

    } // print(Node,String)

    /** Debugging normalizing text. */
    private static String normalize(String s) {

        if (DEBUG_VALIDATE) {
            if (s == null) {
                return ""[null]"";
            }
            StringBuffer str = new StringBuffer();
            int len = s.length();
            for (int i = 0; i < len; i++) {
                if (i > 20) {
                    str.append(""..."");
                    break;
                }
                char ch = s.charAt(i);
                switch (ch) {
                    case '\r': str.append(""[\\r]""); break;
                    case '\n': str.append(""[\\n]""); break;
                    default: str.append(ch);
                }
            }
            return str.toString();
        }

        return null;

    } // normalize(String):String

    /** Debugging node type name. */
    private static String type(int type) {

        if (DEBUG_VALIDATE) {
            switch (type) {
                case Node.ATTRIBUTE_NODE: return ""ATTR"";
                case Node.ELEMENT_NODE: return ""ELEMENT"";
                case Node.TEXT_NODE: return ""TEXT"";
                case Node.ENTITY_REFERENCE_NODE: return ""ENTITY_REF"";
            }
            return ""???"";
        }

        return null;

    } // type(int):String

} // class RevalidatingDOMParser
"
org/apache/xerces/dom/DeferredProcessingInstructionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Processing Instructions (PIs) permit documents to carry
 * processor-specific information alongside their actual content. PIs
 * are most common in XML, but they are supported in HTML as well.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredProcessingInstructionImpl
    extends ProcessingInstructionImpl 
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -4643577954293565388L;
    
    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here. 
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredProcessingInstructionImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null, null);

        fNodeIndex = nodeIndex;
        syncData(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl) this.ownerDocument();
        target  = ownerDocument.getNodeNameString(fNodeIndex);
        data = ownerDocument.getNodeValueString(fNodeIndex);

    } // synchronizeData()

} // class DeferredProcessingInstructionImpl
"
org/apache/xerces/dom/DeferredEntityImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.apache.xerces.utils.StringPool;

import org.w3c.dom.*;

/**
 * Entity nodes hold the reference data for an XML Entity -- either
 * parsed or unparsed. The nodeName (inherited from Node) will contain
 * the name (if any) of the Entity. Its data will be contained in the
 * Entity's children, in exactly the structure which an
 * EntityReference to this name will present within the document's
 * body.
 * <P>
 * Note that this object models the actual entity, _not_ the entity
 * declaration or the entity reference.
 * <P>
 * An XML processor may choose to completely expand entities before
 * the structure model is passed to the DOM; in this case, there will
 * be no EntityReferences in the DOM tree.
 * <P>
 * Quoting the 10/01 DOM Proposal,
 * <BLOCKQUOTE>
 * ""The DOM Level 1 does not support editing Entity nodes; if a user
 * wants to make changes to the contents of an Entity, every related
 * EntityReference node has to be replaced in the structure model by
 * a clone of the Entity's contents, and then the desired changes
 * must be made to each of those clones instead. All the
 * descendants of an Entity node are readonly.""
 * </BLOCKQUOTE>
 * I'm interpreting this as: It is the parser's responsibilty to call
 * the non-DOM operation setReadOnly(true,true) after it constructs
 * the Entity. Since the DOM explicitly decided not to deal with this,
 * _any_ answer will involve a non-DOM operation, and this is the
 * simplest solution.
 *
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredEntityImpl
    extends EntityImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 4760180431078941638L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredEntityImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);
        syncChildren(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /**
     * Synchronize the entity data. This is special because of the way
     * that the ""fast"" version stores the information.
     */
    protected void synchronizeData() {

        // no need to sychronize again
        syncData(false);

        // get the node data
        DeferredDocumentImpl ownerDocument = (DeferredDocumentImpl)this.ownerDocument;
        name = ownerDocument.getNodeNameString(fNodeIndex);

        // get the entity data
        StringPool pool = ownerDocument.getStringPool();
        int extraDataIndex = ownerDocument.getNodeValue(fNodeIndex);
        ownerDocument.getNodeType(extraDataIndex);
        publicId     = pool.toString(ownerDocument.getNodeName(extraDataIndex));
        systemId     = pool.toString(ownerDocument.getNodeValue(extraDataIndex));
        notationName = pool.toString(ownerDocument.getLastChild(extraDataIndex));

    } // synchronizeData()

    /** Synchronize the children. */
    protected void synchronizeChildren() {

        // no need to synchronize again
        syncChildren(false);

        readOnly(false);
        synchronizeChildren(fNodeIndex);
        setReadOnly(true, true);

    } // synchronizeChildren()

} // class DeferredEntityImpl
"
org/apache/xerces/readers/UTF8Recognizer.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.ChunkyByteArray;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;

import java.io.InputStreamReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

/**
 *
 * @version
 */
final class UTF8Recognizer extends XMLDeclRecognizer {
    //
    //
    //
    public XMLEntityHandler.EntityReader recognize(XMLEntityReaderFactory readerFactory,
                                                   XMLEntityHandler entityHandler,
                                                   XMLErrorReporter errorReporter,
                                                   boolean sendCharDataAsCharArray,
                                                   StringPool stringPool,
                                                   ChunkyByteArray data,
                                                   boolean xmlDecl,
                                                   boolean allowJavaEncodingName) throws Exception {
        XMLEntityHandler.EntityReader reader = null;
        byte b0 = data.byteAt(0);
        boolean debug = false;

        if (b0 == '<') {
            int b1 = data.byteAt(1);
            if (b1 == '?') {
                if (data.byteAt(2) == 'x' && data.byteAt(3) == 'm' && data.byteAt(4) == 'l') {
                    int b5 = data.byteAt(5);
                    if (b5 == 0x20 || b5 == 0x09 || b5 == 0x0a || b5 == 0x0d) {
                        XMLEntityHandler.EntityReader declReader = new XMLDeclReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, stringPool);
                        int encoding = prescanXMLDeclOrTextDecl(declReader, xmlDecl);
                        if (encoding != -1) {
                            String encname = stringPool.orphanString(encoding);
                            String enc = encname.toUpperCase();
                            if (""ISO-10646-UCS-2"".equals(enc)) throw new UnsupportedEncodingException(encname);
                            if (""ISO-10646-UCS-4"".equals(enc)) throw new UnsupportedEncodingException(encname);
                            if (""UTF-16"".equals(enc)) throw new UnsupportedEncodingException(encname);

                            String javaencname = MIME2Java.convert(enc);
                            if (null == javaencname) {
                                // Not supported
                                if (allowJavaEncodingName) {
                                    javaencname = encname;
                                } else {
                                    throw new UnsupportedEncodingException(encname);
                                }
                            }
                            try {
                                data.rewind();
                                if (""UTF-8"".equalsIgnoreCase(javaencname) || ""UTF8"".equalsIgnoreCase(javaencname)) {
                                    reader = readerFactory.createUTF8Reader(entityHandler, errorReporter, sendCharDataAsCharArray, data, stringPool);
                                } else {
                                    reader = readerFactory.createCharReader(entityHandler, errorReporter, sendCharDataAsCharArray,
                                                                            new InputStreamReader(data, javaencname), stringPool);
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw new UnsupportedEncodingException(encname);
                            } catch (Exception e) {
                                if( debug == true )
                                   e.printStackTrace();            // Internal Error
                            }
                        } else {
                            data.rewind();
                            reader = readerFactory.createUTF8Reader(entityHandler, errorReporter, sendCharDataAsCharArray, data, stringPool);
                        }
                    }
                }
            }
        }
        return reader;
    }

    final class XMLDeclReader extends XMLEntityReader {
        //
        //
        //
        private StringPool fStringPool = null;
        private ChunkyByteArray fData = null;
        //
        //
        //
        XMLDeclReader(XMLEntityHandler entityHandler, XMLErrorReporter errorReporter, boolean sendCharDataAsCharArray, ChunkyByteArray data, StringPool stringPool) {
            super(entityHandler, errorReporter, sendCharDataAsCharArray);
            fStringPool = stringPool;
            fData = data;
        }
        //
        // These methods are used to parse XMLDecl/TextDecl.
        //
        public boolean lookingAtChar(char ch, boolean skipPastChar) throws IOException {
            if (fData.byteAt(fCurrentOffset) != ch)
                return false;
            if (skipPastChar)
                fCurrentOffset++;
            return true;
        }
        public boolean lookingAtSpace(boolean skipPastChar) throws IOException {
            int ch = fData.byteAt(fCurrentOffset) & 0xff;
            if (ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D)
                return false;
            if (skipPastChar)
                fCurrentOffset++;
            return true;
        }
        public void skipPastSpaces() throws IOException {
            while (true) {
                int ch = fData.byteAt(fCurrentOffset) & 0xff;
                if (ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D)
                    return;
                fCurrentOffset++;
            }
        }
        public boolean skippedString(char[] s) throws IOException {
            int offset = fCurrentOffset;
            for (int i = 0; i < s.length; i++) {
                if (fData.byteAt(offset) != s[i])
                    return false;
                offset++;
            }
            fCurrentOffset = offset;
            return true;
        }
        public int scanStringLiteral() throws Exception {
            boolean single;
            if (!(single = lookingAtChar('\'', true)) && !lookingAtChar('\""', true)) {
                return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
            }
            int offset = fCurrentOffset;
            char qchar = single ? '\'' : '\""';
            while (true) {
                byte b = fData.byteAt(fCurrentOffset);
                if (b == qchar)
                    break;
                if (b == -1)
                    return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;
                fCurrentOffset++;
            }
            int length = fCurrentOffset - offset;
            StringBuffer str = new StringBuffer(length);
            for (int i = 0; i < length; i++) {
                str.append((char)fData.byteAt(offset + i));
            }
            int stringIndex = fStringPool.addString(str.toString());
            fCurrentOffset++; // move past qchar
            return stringIndex;
        }
        //
        // The rest of the methods in XMLReader are not used for parsing XMLDecl/TextDecl.
        //
        public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, int length) {
            throw new RuntimeException(""RDR002 cannot happen"");
        }
        public int addString(int offset, int length) {
            throw new RuntimeException(""RDR002 cannot happen"");
        }
        public int addSymbol(int offset, int length) {
            throw new RuntimeException(""RDR002 cannot happen"");
        }
        public void skipToChar(char ch) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public void skipPastName(char fastcheck) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public void skipPastNmtoken(char fastcheck) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public boolean lookingAtValidChar(boolean skipPastChar) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanInvalidChar() throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanCharRef(boolean hex) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanAttValue(char qchar, boolean asSymbol) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanEntityValue(int qchar, boolean createString) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public boolean scanExpectedName(char fastcheck, StringPool.CharArrayRange expectedName) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public void scanQName(char fastcheck, QName qname) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanName(char fastcheck) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
        public int scanContent(QName element) throws IOException {
            throw new IOException(""RDR002 cannot happen"");
        }
    }
}
"
org/apache/xerces/framework/XMLDocumentScanner.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

import org.apache.xerces.readers.XMLEntityHandler;
import org.apache.xerces.readers.DefaultEntityHandler;
import org.apache.xerces.utils.ChunkyCharArray;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLCharacterProperties;
import org.apache.xerces.utils.XMLMessages;
import org.apache.xerces.validators.common.GrammarResolver;

import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

/**
 * This class recognizes most of the grammer for an XML processor.
 * Additional support is provided by the XMLEntityHandler, via the
 * XMLEntityReader instances it creates, which are used to process
 * simple constructs like string literals and character data between
 * markup.  The XMLDTDScanner class contains the remaining support
 * for the grammer of DTD declarations.  When a &lt;!DOCTYPE ...&gt; is
 * found in the document, the scanDoctypeDecl method will then be
 * called and the XMLDocumentScanner subclass is responsible for
 * ""connecting"" that method to the corresponding method provided
 * by the XMLDTDScanner class.
 *
 * @version $Id$
 */
public final class XMLDocumentScanner {
    //
    // Constants
    //

    //
    // These character arrays are used as parameters for calls to the
    // XMLEntityHandler.EntityReader skippedString() method.  Some have
    // package access for use by the inner dispatcher classes.
    //

    //
    // [19] CDStart ::= '<![CDATA['
    //
    static final char[] cdata_string = { '[','C','D','A','T','A','[' };
    //
    // [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    // [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
    //
    static final char[] xml_string = { 'x','m','l' };
    //
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    //
    private static final char[] version_string = { 'v','e','r','s','i','o','n' };
    //
    // [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?
    //                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
    //
    static final char[] doctype_string = { 'D','O','C','T','Y','P','E' };
    //
    // [32] SDDecl ::= S 'standalone' Eq ((""'"" ('yes' | 'no') ""'"")
    //                 | ('""' ('yes' | 'no') '""'))
    //
    private static final char[] standalone_string = { 's','t','a','n','d','a','l','o','n','e' };
    //
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    //
    private static final char[] encoding_string = { 'e','n','c','o','d','i','n','g' };

    /*
     * Return values for the EventHandler scanAttValue method.
     */
    public static final int
        RESULT_SUCCESS          =  0,
        RESULT_FAILURE          = -1,
        RESULT_DUPLICATE_ATTR   = -2;

    /** Scanner states */
    static final int
        SCANNER_STATE_XML_DECL                  =  0,
        SCANNER_STATE_START_OF_MARKUP           =  1,
        SCANNER_STATE_COMMENT                   =  2,
        SCANNER_STATE_PI                        =  3,
        SCANNER_STATE_DOCTYPE                   =  4,
        SCANNER_STATE_PROLOG                    =  5,
        SCANNER_STATE_ROOT_ELEMENT              =  6,
        SCANNER_STATE_CONTENT                   =  7,
        SCANNER_STATE_REFERENCE                 =  8,
        SCANNER_STATE_ATTRIBUTE_LIST            =  9,
        SCANNER_STATE_ATTRIBUTE_NAME            = 10,
        SCANNER_STATE_ATTRIBUTE_VALUE           = 11,
        SCANNER_STATE_TRAILING_MISC             = 12,
        SCANNER_STATE_END_OF_INPUT              = 13,
        SCANNER_STATE_TERMINATED                = 14;

    //
    // Instance Variables
    //
    /***/
    // NOTE: Used by old implementation of scanElementType method. -Ac
    private StringPool.CharArrayRange fCurrentElementCharArrayRange = null;
    /***/
    int fAttrListHandle = -1;
    XMLAttrList fAttrList = null;
    GrammarResolver fGrammarResolver = null;
    XMLDTDScanner fDTDScanner = null;
    boolean fNamespacesEnabled = false;
    boolean fValidationEnabled = false;
    QName fElementQName = new QName();
    QName fAttributeQName = new QName();
    QName fCurrentElementQName = new QName();
    ScannerDispatcher fDispatcher = null;
    EventHandler fEventHandler = null;
    StringPool fStringPool = null;
    XMLErrorReporter fErrorReporter = null;
    XMLEntityHandler fEntityHandler = null;
    XMLEntityHandler.EntityReader fEntityReader = null;
    XMLEntityHandler.CharBuffer fLiteralData = null;
    boolean fSeenRootElement = false;
    boolean fSeenDoctypeDecl = false;
    boolean fStandalone = false;
    boolean fParseTextDecl = false;
    boolean fScanningDTD = false;
    int fScannerState = SCANNER_STATE_XML_DECL;
    int fReaderId = -1;
    int fAttValueReader = -1;
    int fAttValueElementType = -1;
    int fAttValueAttrName = -1;
    int fAttValueOffset = -1;
    int fAttValueMark = -1;
    int fScannerMarkupDepth = 0;

    //
    // Interfaces
    //

    /**
     * This interface must be implemented by the users of the XMLDocumentScanner class.
     * These methods form the abstraction between the implementation semantics and the
     * more generic task of scanning the XML non-DTD grammar.
     */
    public interface EventHandler {
        /**
         * Signal standalone = ""yes""
         *
         * @exception java.lang.Exception
         */
        public void callStandaloneIsYes() throws Exception;

        /**
         * Signal the start of a document
         *
         * @exception java.lang.Exception
         */
        public void callStartDocument() throws Exception;
        /**
         * Signal the end of a document
         *
         * @exception java.lang.Exception
         */
        public void callEndDocument() throws Exception;
        /**
         * Signal the XML declaration of a document
         *
         * @param version the handle in the string pool for the version number
         * @param encoding the handle in the string pool for the encoding
         * @param standalong the handle in the string pool for the standalone value
         * @exception java.lang.Exception
         */
        public void callXMLDecl(int version, int encoding, int standalone) throws Exception;
        /**
         * Signal the Text declaration of an external entity.
         *
         * @param version the handle in the string pool for the version number
         * @param encoding the handle in the string pool for the encoding
         * @exception java.lang.Exception
         */
        public void callTextDecl(int version, int encoding) throws Exception;
        /**
         * signal the scanning of a start element tag
         * 
         * @param element Element name scanned.
         * @exception java.lang.Exception
         */
        public void callStartElement(QName element) throws Exception;
        /**
         * Signal the scanning of an element name in a start element tag.
         *
         * @param element Element name scanned.
         */
        public void element(QName element) throws Exception;
        /**
         * Signal the scanning of an attribute associated to the previous
         * start element tag.
         *
         * @param element Element name scanned.
         * @param attrName Attribute name scanned.
         * @param attrValue The string pool index of the attribute value.
         */
        public boolean attribute(QName element, QName attrName, int attrValue) throws Exception;
        /**
         * signal the scanning of an end element tag
         *
         * @param readerId the Id of the reader being used to scan the end tag.
         * @exception java.lang.Exception
         */
        public void callEndElement(int readerId) throws Exception;
        /**
         * Signal the start of a CDATA section
         * @exception java.lang.Exception
         */
        public void callStartCDATA() throws Exception;
        /**
         * Signal the end of a CDATA section
         * @exception java.lang.Exception
         */
        public void callEndCDATA() throws Exception;
        /**
         * Report the scanning of character data
         *
         * @param ch the handle in the string pool of the character data that was scanned
         * @exception java.lang.Exception
         */
        public void callCharacters(int ch) throws Exception;
        /**
         * Report the scanning of a processing instruction
         *
         * @param piTarget the handle in the string pool of the processing instruction targe
         * @param piData the handle in the string pool of the processing instruction data
         * @exception java.lang.Exception
         */
        public void callProcessingInstruction(int piTarget, int piData) throws Exception;
        /**
         * Report the scanning of a comment
         *
         * @param data the handle in the string pool of the comment text
         * @exception java.lang.Exception
         */
        public void callComment(int data) throws Exception;
    }

    /**
     * Constructor
     */
    public XMLDocumentScanner(StringPool stringPool,
                              XMLErrorReporter errorReporter,
                              XMLEntityHandler entityHandler,
                              XMLEntityHandler.CharBuffer literalData) {
        fStringPool = stringPool;
        fErrorReporter = errorReporter;
        fEntityHandler = entityHandler;
        fLiteralData = literalData;
        fDispatcher = new XMLDeclDispatcher();
        fAttrList = new XMLAttrList(fStringPool);
    }

    /**
     * Set the event handler
     *
     * @param eventHandler The place to send our callbacks.
     */
    public void setEventHandler(XMLDocumentScanner.EventHandler eventHandler) {
        fEventHandler = eventHandler;
    }

    /** Sets the grammar resolver. */
    public void setGrammarResolver(GrammarResolver resolver) {
        fGrammarResolver = resolver;
    }

    /**
     * reset the parser so that the instance can be reused
     *
     * @param stringPool the string pool instance to be used by the reset parser
     */
    public void reset(StringPool stringPool, XMLEntityHandler.CharBuffer literalData) {
        fStringPool = stringPool;
        fLiteralData = literalData;
        fParseTextDecl = false;
        fSeenRootElement = false;
        fSeenDoctypeDecl = false;
        fStandalone = false;
        fScanningDTD = false;
        fDispatcher = new XMLDeclDispatcher();
        fScannerState = SCANNER_STATE_XML_DECL;
        fScannerMarkupDepth = 0;
        fAttrList = new XMLAttrList(fStringPool);
    }

    //
    // From the standard:
    //
    // [1] document ::= prolog element Misc*
    //
    // [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
    // [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    //
    // The beginning of XMLDecl simplifies to:
    //    '<?xml' S ...
    //
    // [27] Misc ::= Comment | PI |  S
    // [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
    // [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
    // [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
    //
    // [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?
    //                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
    //
    /**
     * Entry point for parsing
     *
     * @param doItAll if true the entire document is parsed otherwise just 
     *                the next segment of the document is parsed
     */
    public boolean parseSome(boolean doItAll) throws Exception
    {
        do {
            if (!fDispatcher.dispatch(doItAll))
                return false;
        } while (doItAll);
        return true;
    }

    /**
     * Change readers
     *
     * @param nextReader the new reader that the scanner will use
     * @param nextReaderId id of the reader to change to
     * @exception throws java.lang.Exception
     */
    public void readerChange(XMLEntityHandler.EntityReader nextReader, int nextReaderId) throws Exception {
        fEntityReader = nextReader;
        fReaderId = nextReaderId;
        if (fScannerState == SCANNER_STATE_ATTRIBUTE_VALUE) {
            fAttValueOffset = fEntityReader.currentOffset();
            fAttValueMark = fAttValueOffset;
        }

        //also propagate the change to DTDScanner if there is one
        if (fDTDScanner != null && fScanningDTD)
            fDTDScanner.readerChange(nextReader, nextReaderId);
    }

    /**
     * Handle the end of input
     *
     * @param entityName the handle in the string pool of the name of the entity which has reached end of input
     * @param moreToFollow if true, there is still input left to process in other readers
     * @exception java.lang.Exception
     */
    public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
        if (fDTDScanner != null && fScanningDTD){
            fDTDScanner.endOfInput(entityName, moreToFollow);
        }
        fDispatcher.endOfInput(entityName, moreToFollow);
    }

    /** 
     * Tell if scanner has reached end of input
     * @return true if scanner has reached end of input.
     */
    public boolean atEndOfInput() {
        return fScannerState == SCANNER_STATE_END_OF_INPUT;
    }

    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""' | ""'"" ([^<&'] | Reference)* ""'""
    //
    /**
     * Scan an attribute value
     *
     * @param elementType handle to the element whose attribute value is being scanned
     * @param attrName handle in the string pool of the name of attribute being scanned
     * @param asSymbol controls whether the value is a string (duplicates allowed) or a symbol (duplicates not allowed)
     * @return handle in the string pool of the scanned value
     * @exception java.lang.Exception
     */
    public int scanAttValue(QName element, QName attribute, boolean asSymbol) throws Exception {
        boolean single;
        if (!(single = fEntityReader.lookingAtChar('\'', true)) && !fEntityReader.lookingAtChar('\""', true)) {
            reportFatalXMLError(XMLMessages.MSG_QUOTE_REQUIRED_IN_ATTVALUE,
                                XMLMessages.P10_QUOTE_REQUIRED,
                                element.rawname,
                                attribute.rawname);
            return -1;
        }
        char qchar = single ? '\'' : '\""';
        fAttValueMark = fEntityReader.currentOffset();
        int attValue = fEntityReader.scanAttValue(qchar, asSymbol);
        if (attValue >= 0)
            return attValue;
        int previousState = setScannerState(SCANNER_STATE_ATTRIBUTE_VALUE);
        fAttValueReader = fReaderId;
        // REVISIT: What should this be?
        fAttValueElementType = element.rawname;
        // REVISIT: What should this be?
        fAttValueAttrName = attribute.rawname;
        fAttValueOffset = fEntityReader.currentOffset();
        int dataOffset = fLiteralData.length();
        if (fAttValueOffset - fAttValueMark > 0)
            fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
        fAttValueMark = fAttValueOffset;
        boolean setMark = false;
        boolean skippedCR;
        while (true) {
            if (fEntityReader.lookingAtChar(qchar, true)) {
                if (fReaderId == fAttValueReader)
                    break;
            } else if (fEntityReader.lookingAtChar(' ', true)) {
                //
                // no action required
                //
            } else if ((skippedCR = fEntityReader.lookingAtChar((char)0x0D, true)) || fEntityReader.lookingAtSpace(true)) {
                if (fAttValueOffset - fAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
                setMark = true;
                fLiteralData.append(' ');
                if (skippedCR) {
                    //
                    // REVISIT - HACK !!!  code changed to pass incorrect OASIS test 'valid-sa-110'
                    //  Uncomment the next line to conform to the spec...
                    //
                    //fEntityReader.lookingAtChar((char)0x0A, true);
                }
            } else if (fEntityReader.lookingAtChar('&', true)) {
                if (fAttValueOffset - fAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
                setMark = true;
                //
                // Check for character reference first.
                //
                if (fEntityReader.lookingAtChar('#', true)) {
                    int ch = scanCharRef();
                    if (ch != -1) {
                        if (ch < 0x10000)
                            fLiteralData.append((char)ch);
                        else {
                            fLiteralData.append((char)(((ch-0x00010000)>>10)+0xd800));
                            fLiteralData.append((char)(((ch-0x00010000)&0x3ff)+0xdc00));
                        }
                    }
                } else {
                    //
                    // Entity reference
                    //
                    int nameOffset = fEntityReader.currentOffset();
                    fEntityReader.skipPastName(';');
                    int nameLength = fEntityReader.currentOffset() - nameOffset;
                    if (nameLength == 0) {
                        reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_NAME_REQUIRED);
                    } else if (!fEntityReader.lookingAtChar(';', true)) {
                        reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_SEMICOLON_REQUIRED,
                                            fEntityReader.addString(nameOffset, nameLength));
                    } else {
                        int entityName = fEntityReader.addSymbol(nameOffset, nameLength);
                        fEntityHandler.startReadingFromEntity(entityName, fScannerMarkupDepth, XMLEntityHandler.ENTITYREF_IN_ATTVALUE);
                    }
                }
            } else if (fEntityReader.lookingAtChar('<', true)) {
                if (fAttValueOffset - fAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
                setMark = true;
                reportFatalXMLError(XMLMessages.MSG_LESSTHAN_IN_ATTVALUE,
                                    XMLMessages.WFC_NO_LESSTHAN_IN_ATTVALUE,
                                    element.rawname,
                                    attribute.rawname);
            } else if (!fEntityReader.lookingAtValidChar(true)) {
                if (fAttValueOffset - fAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
                setMark = true;
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return -1;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_ATTVALUE,
                                        XMLMessages.P10_INVALID_CHARACTER,
                                        fStringPool.toString(element.rawname),
                                        fStringPool.toString(attribute.rawname),
                                        Integer.toHexString(invChar));
                }
            }
            fAttValueOffset = fEntityReader.currentOffset();
            if (setMark) {
                fAttValueMark = fAttValueOffset;
                setMark = false;
            }
        }
        restoreScannerState(previousState);
        int dataLength = fLiteralData.length() - dataOffset;
        if (dataLength == 0) {
            return fEntityReader.addString(fAttValueMark, fAttValueOffset - fAttValueMark);
        }
        if (fAttValueOffset - fAttValueMark > 0) {
            fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
            dataLength = fLiteralData.length() - dataOffset;
        }
        int value = fLiteralData.addString(dataOffset, dataLength);
        return value;
    }

    /**
     * Check the value of an XML Language attribute
     * @param langValue the handle in the string pool of the value to be checked
     * @exception java.lang.Exception
     */
    public void checkXMLLangAttributeValue(int langValue) throws Exception {
        String lang = fStringPool.toString(langValue);
        int offset = -1;
        if (lang.length() >= 2) {
            char ch0 = lang.charAt(0);
            if (lang.charAt(1) == '-') {
                if (ch0 == 'i' || ch0 == 'I' || ch0 == 'x' || ch0 == 'X') {
                    offset = 1;
                }
            } else {
                char ch1 = lang.charAt(1);
                if (((ch0 >= 'a' && ch0 <= 'z') || (ch0 >= 'A' && ch0 <= 'Z')) &&
                    ((ch1 >= 'a' && ch1 <= 'z') || (ch1 >= 'A' && ch1 <= 'Z'))) {
                        offset = 2;
                }
            }
        }
        if (offset > 0 && lang.length() > offset) {
            char ch = lang.charAt(offset++);
            if (ch != '-') {
                offset = -1;
            } else {
                while (true) {
                    if (ch == '-') {
                        if (lang.length() == offset) {
                            offset = -1;
                            break;
                        }
                        ch = lang.charAt(offset++);
                        if ((ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
                            offset = -1;
                            break;
                        }
                        if (lang.length() == offset)
                            break;
                    } else if ((ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
                        offset = -1;
                        break;
                    } else if (lang.length() == offset)
                        break;
                    ch = lang.charAt(offset++);
                }
            }
        }
        if (offset == -1) {
            reportFatalXMLError(XMLMessages.MSG_XML_LANG_INVALID,
                                XMLMessages.P33_INVALID,
                                lang);
        }
    }

    //
    //
    //
    void reportFatalXMLError(int majorCode, int minorCode) throws Exception {
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   null,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void reportFatalXMLError(int majorCode, int minorCode, int stringIndex1) throws Exception {
        Object[] args = { fStringPool.toString(stringIndex1) };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void reportFatalXMLError(int majorCode, int minorCode, String string1) throws Exception {
        Object[] args = { string1 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void reportFatalXMLError(int majorCode, int minorCode, int stringIndex1, int stringIndex2) throws Exception {
        Object[] args = { fStringPool.toString(stringIndex1),
                          fStringPool.toString(stringIndex2) };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void reportFatalXMLError(int majorCode, int minorCode, String string1, String string2) throws Exception {
        Object[] args = { string1, string2 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void reportFatalXMLError(int majorCode, int minorCode, String string1, String string2, String string3) throws Exception {
        Object[] args = { string1, string2, string3 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    void abortMarkup(int majorCode, int minorCode) throws Exception {
        reportFatalXMLError(majorCode, minorCode);
        skipPastEndOfCurrentMarkup();
    }
    void abortMarkup(int majorCode, int minorCode, int stringIndex1) throws Exception {
        reportFatalXMLError(majorCode, minorCode, stringIndex1);
        skipPastEndOfCurrentMarkup();
    }
    void abortMarkup(int majorCode, int minorCode, String string1) throws Exception {
        reportFatalXMLError(majorCode, minorCode, string1);
        skipPastEndOfCurrentMarkup();
    }
    void abortMarkup(int majorCode, int minorCode, int stringIndex1, int stringIndex2) throws Exception {
        reportFatalXMLError(majorCode, minorCode, stringIndex1, stringIndex2);
        skipPastEndOfCurrentMarkup();
    }
    void skipPastEndOfCurrentMarkup() throws Exception {
        fEntityReader.skipToChar('>');
        if (fEntityReader.lookingAtChar('>', true))
            fScannerMarkupDepth--;
    }
    //
    //
    //
    int setScannerState(int state) {
        int oldState = fScannerState;
        fScannerState = state;
        return oldState;
    }
    void restoreScannerState(int state) {
        if (fScannerState != SCANNER_STATE_END_OF_INPUT)
            fScannerState = state;
    }
    //
    //
    //
    /**
     * The main loop of the scanner is implemented by calling the dispatch method
     * of ScannerDispatcher with a flag which tells the dispatcher whether to continue
     * or return.  The scanner logic is split up into dispatchers for various syntatic
     * components of XML.  //REVISIT more rationale needed
     */
    interface ScannerDispatcher {
        /**
         * scan an XML syntactic component 
         *
         * @param keepgoing if true continue on to the next dispatcher, otherwise return
         * @return true if scanning was successful //REVISIT - does it ever return false or does it just throw?
         * @exception java.lang.Exception
         */
        boolean dispatch(boolean keepgoing) throws Exception;
        /**
         * endOfInput encapsulates the end of entity handling for each dispatcher 
         *
         * @param entityName StringPool handle of the entity that has reached the end
         * @param moreToFollow true if there is more input to be read
         * @exception
         */
        void endOfInput(int entityName, boolean moreToFollow) throws Exception;
    }
    final class XMLDeclDispatcher implements ScannerDispatcher {
        public boolean dispatch(boolean keepgoing) throws Exception {
            fEventHandler.callStartDocument();
            if (fEntityReader.lookingAtChar('<', true)) {
                fScannerMarkupDepth++;
                setScannerState(SCANNER_STATE_START_OF_MARKUP);
                if (fEntityReader.lookingAtChar('?', true)) {
                    int piTarget = fEntityReader.scanName(' ');
                    if (piTarget == -1) {
                        abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                    XMLMessages.P16_PITARGET_REQUIRED);
                    } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                        if (fEntityReader.lookingAtSpace(true)) { // an XMLDecl looks like a PI with the target 'xml'
                            scanXMLDeclOrTextDecl(false);
                        } else { // a PI target matching 'xml'
                            abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                        XMLMessages.P17_RESERVED_PITARGET);
                        }
                    } else { // PI
                      scanPI(piTarget);
                    }
                    fDispatcher = new PrologDispatcher();
                    restoreScannerState(SCANNER_STATE_PROLOG);
                    return true;
                }
                if (fEntityReader.lookingAtChar('!', true)) {
                    if (fEntityReader.lookingAtChar('-', true)) { // comment ?
                        if (fEntityReader.lookingAtChar('-', true)) {
                            scanComment(); // scan through the closing '-->'
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                        XMLMessages.P22_NOT_RECOGNIZED);
                        }
                    } else {
                        if (fEntityReader.skippedString(doctype_string)) {
                            setScannerState(SCANNER_STATE_DOCTYPE);
                            fSeenDoctypeDecl = true;
                            scanDoctypeDecl(fStandalone); // scan through the closing '>'
                            fScannerMarkupDepth--;
                            fDispatcher = new PrologDispatcher();
                            restoreScannerState(SCANNER_STATE_PROLOG);
                            return true;
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                        XMLMessages.P22_NOT_RECOGNIZED);
                        }
                    }
                } else {
                    fDispatcher = new ContentDispatcher();
                    restoreScannerState(SCANNER_STATE_ROOT_ELEMENT);
                    return true;
                }
            } else {
                if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                } else if (!fEntityReader.lookingAtValidChar(false)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            String arg = Integer.toHexString(invChar);
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_PROLOG,
                                                XMLMessages.P22_INVALID_CHARACTER,
                                                arg);
                        }
                    }
                } else {
                    reportFatalXMLError(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                        XMLMessages.P22_NOT_RECOGNIZED);
                    fEntityReader.lookingAtValidChar(true);
                }
            }
            fDispatcher = new PrologDispatcher();
            restoreScannerState(SCANNER_STATE_PROLOG);
            return true;
        }
        public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
            switch (fScannerState) {
            case SCANNER_STATE_XML_DECL:
            case SCANNER_STATE_START_OF_MARKUP:
            case SCANNER_STATE_DOCTYPE:
                break;
            case SCANNER_STATE_COMMENT:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_UNTERMINATED,
                                        XMLMessages.P15_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            case SCANNER_STATE_PI:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_PI_UNTERMINATED,
                                        XMLMessages.P16_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_PI_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            default:
                throw new RuntimeException(""FWK001 1] ScannerState=""+fScannerState+""\n"" + ""1\t""+fScannerState);
            }
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_ROOT_ELEMENT_REQUIRED,
                                    XMLMessages.P1_ELEMENT_REQUIRED);
                fDispatcher = new EndOfInputDispatcher();
                setScannerState(SCANNER_STATE_END_OF_INPUT);
            }
        }
    }
    final class PrologDispatcher implements ScannerDispatcher {
        public boolean dispatch(boolean keepgoing) throws Exception {
            do {
                if (fEntityReader.lookingAtChar('<', true)) {
                    fScannerMarkupDepth++;
                    setScannerState(SCANNER_STATE_START_OF_MARKUP);
                    if (fEntityReader.lookingAtChar('?', true)) {
                        int piTarget = fEntityReader.scanName(' ');
                        if (piTarget == -1) {
                            abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                        XMLMessages.P16_PITARGET_REQUIRED);
                        } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                            if (fEntityReader.lookingAtSpace(true)) { // an XMLDecl looks like a PI with the target 'xml'
                                abortMarkup(XMLMessages.MSG_XMLDECL_MUST_BE_FIRST,
                                            XMLMessages.P22_XMLDECL_MUST_BE_FIRST);
                            } else { // a PI target matching 'xml'
                                abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                            XMLMessages.P17_RESERVED_PITARGET);
                            }
                        } else { // PI
                            scanPI(piTarget);
                        }
                    } else if (fEntityReader.lookingAtChar('!', true)) {
                        if (fEntityReader.lookingAtChar('-', true)) { // comment ?
                            if (fEntityReader.lookingAtChar('-', true)) {
                                scanComment(); // scan through the closing '-->'
                            } else {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                            XMLMessages.P22_NOT_RECOGNIZED);
                            }
                        } else {
                            if (!fSeenDoctypeDecl && fEntityReader.skippedString(doctype_string)) {
                                setScannerState(SCANNER_STATE_DOCTYPE);
                                fSeenDoctypeDecl = true;
                                scanDoctypeDecl(fStandalone); // scan through the closing '>'
                                fScannerMarkupDepth--;
                            } else {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                            XMLMessages.P22_NOT_RECOGNIZED);
                            }
                        }
                    } else {
                        fDispatcher = new ContentDispatcher();
                        restoreScannerState(SCANNER_STATE_ROOT_ELEMENT);
                        return true;
                    }
                    restoreScannerState(SCANNER_STATE_PROLOG);
                } else if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                } else if (!fEntityReader.lookingAtValidChar(false)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            String arg = Integer.toHexString(invChar);
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_PROLOG,
                                                XMLMessages.P22_INVALID_CHARACTER,
                                                arg);
                        }
                    }
                } else {
                    reportFatalXMLError(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                        XMLMessages.P22_NOT_RECOGNIZED);
                    fEntityReader.lookingAtValidChar(true);
                }
            } while (fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing);
            return true;
        }
        public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
            switch (fScannerState) {
            case SCANNER_STATE_PROLOG:
            case SCANNER_STATE_START_OF_MARKUP:
            case SCANNER_STATE_DOCTYPE:
                break;
            case SCANNER_STATE_COMMENT:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_UNTERMINATED,
                                        XMLMessages.P15_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            case SCANNER_STATE_PI:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_PI_UNTERMINATED,
                                        XMLMessages.P16_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_PI_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            default:
                throw new RuntimeException(""FWK001 2] ScannerState=""+fScannerState+""\n"" + ""2\t""+fScannerState);
            }
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_ROOT_ELEMENT_REQUIRED,
                                    XMLMessages.P1_ELEMENT_REQUIRED);
                fDispatcher = new EndOfInputDispatcher();
                setScannerState(SCANNER_STATE_END_OF_INPUT);
            }
        }
    }
    int fCurrentElementType = -1;
    public int getCurrentElementType() {
        return fCurrentElementType;
    }
    final class ContentDispatcher implements ScannerDispatcher {
        private int fContentReader = -1;
        private int fElementDepth = 0;
        private int[] fElementTypeStack = new int[8];

        void popElementType() {
            if (fElementDepth-- == 0) {
                throw new RuntimeException(""FWK002 popElementType: fElementDepth-- == 0."");
            }
            if (fElementDepth == 0) {
                fCurrentElementType = - 1;
            } else {
                fCurrentElementType = fElementTypeStack[fElementDepth - 1];
            }
        }

        public boolean dispatch(boolean keepgoing) throws Exception {
            do {
                switch (fScannerState) {
                case SCANNER_STATE_ROOT_ELEMENT:
                {
                    scanElementType(fEntityReader, '>', fElementQName);
                    if (fElementQName.rawname != -1) {
                        //
                        // root element
                        //
                        fContentReader = fReaderId;
                        fSeenRootElement = true;
                        //
                        // scan element
                        //
                        if (fEntityReader.lookingAtChar('>', true)) {
                            //
                            // we have more content
                            //
                            fEventHandler.callStartElement(fElementQName);
                            fScannerMarkupDepth--;
                            if (fElementDepth == fElementTypeStack.length) {
                                int[] newStack = new int[fElementDepth * 2];
                                System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                fElementTypeStack = newStack;
                            }
                            fCurrentElementType = fElementQName.rawname;
                            fElementTypeStack[fElementDepth] = fElementQName.rawname;
                            fElementDepth++;
                            restoreScannerState(SCANNER_STATE_CONTENT);
                        } else if (scanElement(fElementQName)) {
                            //
                            // we have more content
                            //
                            if (fElementDepth == fElementTypeStack.length) {
                                int[] newStack = new int[fElementDepth * 2];
                                System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                fElementTypeStack = newStack;
                            }
                            fCurrentElementType = fElementQName.rawname;
                            fElementTypeStack[fElementDepth] = fElementQName.rawname;
                            fElementDepth++;
                            restoreScannerState(SCANNER_STATE_CONTENT);
                        } else {
                            fDispatcher = new TrailingMiscDispatcher();
                            restoreScannerState(SCANNER_STATE_TRAILING_MISC);
                            return true;
                        }
                    } else {
                        reportFatalXMLError(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG,
                                            XMLMessages.P22_NOT_RECOGNIZED);
                        fDispatcher = new PrologDispatcher();
                        restoreScannerState(SCANNER_STATE_PROLOG);
                        return true;
                    }
                    break;
                }
                case SCANNER_STATE_START_OF_MARKUP:
                    if (fEntityReader.lookingAtChar('?', true)) {
                        int piTarget = fEntityReader.scanName(' ');
                        if (piTarget == -1) {
                            abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                        XMLMessages.P16_PITARGET_REQUIRED);
                        } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                            if (fEntityReader.lookingAtSpace(true)) { // an XMLDecl looks like a PI with the target 'xml'
                                if (fParseTextDecl) {
                                    scanXMLDeclOrTextDecl(true);
                                    fParseTextDecl = false;
                                } else {
                                    abortMarkup(XMLMessages.MSG_TEXTDECL_MUST_BE_FIRST,
                                                XMLMessages.P30_TEXTDECL_MUST_BE_FIRST);
                                }
                            } else { // a PI target matching 'xml'
                                abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                            XMLMessages.P17_RESERVED_PITARGET);
                            }
                        } else { // PI
                            scanPI(piTarget);
                        }
                        restoreScannerState(SCANNER_STATE_CONTENT);
                    } else if (fEntityReader.lookingAtChar('!', true)) {
                        if (fEntityReader.lookingAtChar('-', true)) { // comment ?
                            if (fEntityReader.lookingAtChar('-', true)) {
                                scanComment(); // scan through the closing '-->'
                            } else {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT,
                                            XMLMessages.P43_NOT_RECOGNIZED);
                            }
                        } else {
                            if (fEntityReader.skippedString(cdata_string)) {
                                fEntityReader.setInCDSect(true);
                                fEventHandler.callStartCDATA();
                            } else {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT,
                                            XMLMessages.P43_NOT_RECOGNIZED);
                            }
                        }
                    } else {
                        if (fEntityReader.lookingAtChar('/', true)) {
                            //
                            // [42] ETag ::= '</' Name S? '>'
                            //
                            if (!scanExpectedElementType(fEntityReader, '>', fCurrentElementType)) {
                                abortMarkup(XMLMessages.MSG_ETAG_REQUIRED,
                                            XMLMessages.P39_UNTERMINATED,
                                            fCurrentElementType);
                            } else {
                                if (!fEntityReader.lookingAtChar('>', true)) {
                                    fEntityReader.skipPastSpaces();
                                    if (!fEntityReader.lookingAtChar('>', true)) {
                                        reportFatalXMLError(XMLMessages.MSG_ETAG_UNTERMINATED,
                                                            XMLMessages.P42_UNTERMINATED,
                                                            fCurrentElementType);
                                    }
                                }
                                fScannerMarkupDepth--;
                                fEventHandler.callEndElement(fReaderId);
                                if (fElementDepth-- == 0) {
                                    throw new RuntimeException(""FWK002 popElementType: fElementDepth-- == 0."");
                                }
                                if (fElementDepth == 0) {
                                    fCurrentElementType = - 1;
                                    fDispatcher = new TrailingMiscDispatcher();
                                    restoreScannerState(SCANNER_STATE_TRAILING_MISC);
                                    return true;
                                } else {
                                    fCurrentElementType = fElementTypeStack[fElementDepth - 1];
                                }
                            }
                        } else {
                            scanElementType(fEntityReader, '>', fElementQName);
                            if (fElementQName.rawname != -1) {
                                //
                                // element
                                //
                                if (fEntityReader.lookingAtChar('>', true)) {
                                    fEventHandler.callStartElement(fElementQName);
                                    fScannerMarkupDepth--;
                                    if (fElementDepth == fElementTypeStack.length) {
                                        int[] newStack = new int[fElementDepth * 2];
                                        System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                        fElementTypeStack = newStack;
                                    }
                                    fCurrentElementType = fElementQName.rawname;
                                    fElementTypeStack[fElementDepth] = fElementQName.rawname;
                                    fElementDepth++;
                                } else {
                                    if (scanElement(fElementQName)) {
                                        if (fElementDepth == fElementTypeStack.length) {
                                            int[] newStack = new int[fElementDepth * 2];
                                            System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                            fElementTypeStack = newStack;
                                        }
                                        fCurrentElementType = fElementQName.rawname;
                                        fElementTypeStack[fElementDepth] = fElementQName.rawname;
                                        fElementDepth++;
                                    }
                                }
                            } else {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT,
                                            XMLMessages.P43_NOT_RECOGNIZED);
                            }
                        }
                    }
                    restoreScannerState(SCANNER_STATE_CONTENT);
                    break;
                case SCANNER_STATE_CONTENT:
                    if (fParseTextDecl && fEntityReader.lookingAtChar('<', true)) {
                        fScannerMarkupDepth++;
                        setScannerState(SCANNER_STATE_START_OF_MARKUP);
                        continue;
                    }
                    // REVISIT: Is this the right thing to do? Do we need to
                    //          save more information on the stack?
                    fCurrentElementQName.setValues(-1, -1, fCurrentElementType);
                    switch (fEntityReader.scanContent(fCurrentElementQName)) {
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_PI:
                        fScannerMarkupDepth++;
                        int piTarget = fEntityReader.scanName(' ');
                        if (piTarget == -1) {
                            abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                        XMLMessages.P16_PITARGET_REQUIRED);
                        } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                            if (fEntityReader.lookingAtSpace(true)) { // an XMLDecl looks like a PI with the target 'xml'
                                if (fReaderId == fContentReader) {
                                    abortMarkup(XMLMessages.MSG_XMLDECL_MUST_BE_FIRST,
                                                XMLMessages.P22_XMLDECL_MUST_BE_FIRST);
                                } else {
                                    abortMarkup(XMLMessages.MSG_TEXTDECL_MUST_BE_FIRST,
                                                XMLMessages.P30_TEXTDECL_MUST_BE_FIRST);
                                }
                            } else { // a PI target matching 'xml'
                                abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                            XMLMessages.P17_RESERVED_PITARGET);
                            }
                        } else { // PI
                            scanPI(piTarget);
                        }
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_COMMENT:
                        fScannerMarkupDepth++;
                        fParseTextDecl = false;
                        scanComment(); // scan through the closing '-->'
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_CDSECT:
                        fScannerMarkupDepth++;
                        fParseTextDecl = false;
                        fEntityReader.setInCDSect(true);
                        fEventHandler.callStartCDATA();
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_ETAG:
                        fScannerMarkupDepth++;
                        fParseTextDecl = false;
                        //
                        // [42] ETag ::= '</' Name S? '>'
                        //
                        if (!scanExpectedElementType(fEntityReader, '>', fCurrentElementType)) {
                            abortMarkup(XMLMessages.MSG_ETAG_REQUIRED,
                                        XMLMessages.P39_UNTERMINATED,
                                        fCurrentElementType);
                        } else {
                            if (!fEntityReader.lookingAtChar('>', true)) {
                                fEntityReader.skipPastSpaces();
                                if (!fEntityReader.lookingAtChar('>', true)) {
                                    reportFatalXMLError(XMLMessages.MSG_ETAG_UNTERMINATED,
                                                        XMLMessages.P42_UNTERMINATED,
                                                        fCurrentElementType);
                                }
                            }
                            fScannerMarkupDepth--;
                            fEventHandler.callEndElement(fReaderId);
                            if (fElementDepth-- == 0) {
                                throw new RuntimeException(""FWK002 popElementType: fElementDepth-- == 0."");
                            }
                            if (fElementDepth == 0) {
                                fCurrentElementType = - 1;
                                fDispatcher = new TrailingMiscDispatcher();
                                restoreScannerState(SCANNER_STATE_TRAILING_MISC);
                                return true;
                            } else {
                                fCurrentElementType = fElementTypeStack[fElementDepth - 1];
                            }
                        }
                        restoreScannerState(SCANNER_STATE_CONTENT);
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_ELEMENT:
                    {
                        fScannerMarkupDepth++;
                        fParseTextDecl = false;
                        scanElementType(fEntityReader, '>', fElementQName);
                        if (fElementQName.rawname != -1) {
                            if (fEntityReader.lookingAtChar('>', true)) {
                                fEventHandler.callStartElement(fElementQName);
                                fScannerMarkupDepth--;
                                if (fElementDepth == fElementTypeStack.length) {
                                    int[] newStack = new int[fElementDepth * 2];
                                    System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                    fElementTypeStack = newStack;
                                }
                                fCurrentElementType = fElementQName.rawname;
                                fElementTypeStack[fElementDepth] = fElementQName.rawname;
                                fElementDepth++;
                            } else {
                                if (scanElement(fElementQName)) {
                                    if (fElementDepth == fElementTypeStack.length) {
                                        int[] newStack = new int[fElementDepth * 2];
                                        System.arraycopy(fElementTypeStack, 0, newStack, 0, fElementDepth);
                                        fElementTypeStack = newStack;
                                    }
                                    fCurrentElementType = fElementQName.rawname;
                                    fElementTypeStack[fElementDepth] = fElementQName.rawname;
                                    fElementDepth++;
                                }
                            }
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT,
                                        XMLMessages.P43_NOT_RECOGNIZED);
                        }
                        if (fScannerState != SCANNER_STATE_END_OF_INPUT)
                            fScannerState = SCANNER_STATE_CONTENT;
                        break;
                    }
                    case XMLEntityHandler.CONTENT_RESULT_MATCHING_ETAG:
                    {
                        fParseTextDecl = false;
                        fEventHandler.callEndElement(fReaderId);
                        if (fElementDepth-- == 0) {
                            throw new RuntimeException(""FWK002 popElementType: fElementDepth-- == 0."");
                        }
                        if (fElementDepth == 0) {
                            fCurrentElementType = - 1;
                            if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                                fDispatcher = new TrailingMiscDispatcher();
                                fScannerState = SCANNER_STATE_TRAILING_MISC;
                            }
                            return true;
                        } else {
                            fCurrentElementType = fElementTypeStack[fElementDepth - 1];
                        }
                        if (fScannerState != SCANNER_STATE_END_OF_INPUT)
                            fScannerState = SCANNER_STATE_CONTENT;
                        break;
                    }
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_CHARREF:
                        fParseTextDecl = false;
                        //
                        // [67] Reference ::= EntityRef | CharRef
                        // [68] EntityRef ::= '&' Name ';'
                        // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
                        //
                        setScannerState(SCANNER_STATE_REFERENCE);
                        int num = scanCharRef();
                        // if (num == -1) num = 0xfffd; // REVISIT - alternative is to use Unicode replacement char
                        if (num != -1)
                            fEventHandler.callCharacters(num);
                        restoreScannerState(SCANNER_STATE_CONTENT);
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_REFERENCE_END_OF_INPUT:
                        // REVISIT - This should hopefully get us the ""reference not
                        //   contained in one entity"" error when endOfInput is called.
                        //   Test that this is so...
                        //
                        // fall through...
                        //
                    case XMLEntityHandler.CONTENT_RESULT_START_OF_ENTITYREF:
                        fParseTextDecl = false;
                        //
                        // [68] EntityRef ::= '&' Name ';'
                        //
                        setScannerState(SCANNER_STATE_REFERENCE);
                        int nameOffset = fEntityReader.currentOffset();
                        fEntityReader.skipPastName(';');
                        int nameLength = fEntityReader.currentOffset() - nameOffset;
                        if (nameLength == 0) {
                            reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_REFERENCE,
                                                XMLMessages.P68_NAME_REQUIRED);
                            restoreScannerState(SCANNER_STATE_CONTENT);
                        } else if (!fEntityReader.lookingAtChar(';', true)) {
                            reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_REFERENCE,
                                                XMLMessages.P68_SEMICOLON_REQUIRED,
                                                fEntityReader.addString(nameOffset, nameLength));
                            restoreScannerState(SCANNER_STATE_CONTENT);
                        } else {
                            restoreScannerState(SCANNER_STATE_CONTENT);
                            int entityName = fEntityReader.addSymbol(nameOffset, nameLength);
                            fParseTextDecl = fEntityHandler.startReadingFromEntity(entityName, fElementDepth, XMLEntityHandler.ENTITYREF_IN_CONTENT);
                        }
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_END_OF_CDSECT:
                        fParseTextDecl = false;
                        //
                        // [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
                        // [21] CDEnd ::= ']]>'
                        //
                        if (fEntityReader.getInCDSect()) {
                            fEntityReader.setInCDSect(false);
                            fEventHandler.callEndCDATA();
                            fScannerMarkupDepth--;
                        } else {
                            reportFatalXMLError(XMLMessages.MSG_CDEND_IN_CONTENT,
                                                XMLMessages.P14_INVALID);
                        }
                        restoreScannerState(SCANNER_STATE_CONTENT);
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_INVALID_CHAR:
                        fParseTextDecl = false;
                        //
                        // The reader will also use this state if it
                        // encounters the end of input while reading
                        // content.  We need to check for this case.
                        //
                        if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                            if (!fEntityReader.lookingAtValidChar(false)) {
                                //
                                //  [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF]        // any Unicode character, excluding the
                                //               | [#xE000-#xFFFD] | [#x10000-#x10FFFF] // surrogate blocks, FFFE, and FFFF.
                                //
                                int invChar = fEntityReader.scanInvalidChar();
                                if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                                    if (invChar >= 0) {
                                        if (fEntityReader.getInCDSect()) {
                                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_CDSECT,
                                                                XMLMessages.P20_INVALID_CHARACTER,
                                                                Integer.toHexString(invChar));
                                        } else {
                                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_CONTENT,
                                                                XMLMessages.P43_INVALID_CHARACTER,
                                                                Integer.toHexString(invChar));
                                        }
                                    }
                                }
                            }
                            restoreScannerState(SCANNER_STATE_CONTENT);
                        }
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_MARKUP_NOT_RECOGNIZED:
                        fParseTextDecl = false;
                        abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT,
                                    XMLMessages.P43_NOT_RECOGNIZED);
                        break;
                    case XMLEntityHandler.CONTENT_RESULT_MARKUP_END_OF_INPUT:
                        // REVISIT - This should hopefully get us the ""markup not
                        //   contained in one entity"" error when endOfInput is called.
                        //   Test that this is so...
                        fScannerMarkupDepth++;
                        fParseTextDecl = false;
                        fScannerState = SCANNER_STATE_START_OF_MARKUP;
                        break;
                    default:
                        throw new RuntimeException(""FWK001 3] ScannerState=""+fScannerState+""\n"" + ""3\t""+fScannerState); // should not happen
                    }
                    break;
                default:
                    throw new RuntimeException(""FWK001 4] ScannerState=""+fScannerState+""\n"" + ""4\t""+fScannerState);
                }
            } while (fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing);
            return true;
        }
        public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
            switch (fScannerState) {
            case SCANNER_STATE_ROOT_ELEMENT:
            case SCANNER_STATE_START_OF_MARKUP:
                break;
            case SCANNER_STATE_CONTENT:
                if (fEntityReader.getInCDSect()) {
                    reportFatalXMLError(XMLMessages.MSG_CDSECT_UNTERMINATED,
                                        XMLMessages.P18_UNTERMINATED);
                }
                break;
            case SCANNER_STATE_ATTRIBUTE_LIST:
                if (!moreToFollow) {
// REVISIT                    reportFatalXMLError(XMLMessages.MSG_TAG1);
                } else {
// REVISIT                    reportFatalXMLError(XMLMessages.MSG_TAG1);
                }
                break;
            case SCANNER_STATE_ATTRIBUTE_NAME:
                if (!moreToFollow) {
// REVISIT                    reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
                } else {
// REVISIT                    reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
                }
                break;
            case SCANNER_STATE_ATTRIBUTE_VALUE:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_ATTRIBUTE_VALUE_UNTERMINATED,
                                        XMLMessages.P10_UNTERMINATED,
                                        fAttValueElementType,
                                        fAttValueAttrName);
                } else if (fReaderId == fAttValueReader) {
// REVISIT                        reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
                } else {
                    fEntityReader.append(fLiteralData, fAttValueMark, fAttValueOffset - fAttValueMark);
                }
                break;
            case SCANNER_STATE_COMMENT:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_UNTERMINATED,
                                        XMLMessages.P15_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_COMMENT_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            case SCANNER_STATE_PI:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_PI_UNTERMINATED,
                                        XMLMessages.P16_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_PI_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            case SCANNER_STATE_REFERENCE:
                if (!moreToFollow) {
                    reportFatalXMLError(XMLMessages.MSG_REFERENCE_UNTERMINATED,
                                        XMLMessages.P67_UNTERMINATED);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_REFERENCE_NOT_IN_ONE_ENTITY,
                                        XMLMessages.P78_NOT_WELLFORMED);
                }
                break;
            default:
                throw new RuntimeException(""FWK001 5] ScannerState=""+fScannerState+""\n"" + ""5\t""+fScannerState);
            }
            if (!moreToFollow) {
                if (fElementDepth > 0)
                    reportFatalXMLError(XMLMessages.MSG_ETAG_REQUIRED,
                                        XMLMessages.P39_UNTERMINATED,
                                        fCurrentElementType);
                fDispatcher = new EndOfInputDispatcher();
                setScannerState(SCANNER_STATE_END_OF_INPUT);
            }
        }
    }
    final class TrailingMiscDispatcher implements ScannerDispatcher {
        public boolean dispatch(boolean keepgoing) throws Exception {
            do {
                if (fEntityReader.lookingAtChar('<', true)) {
                    fScannerMarkupDepth++;
                    setScannerState(SCANNER_STATE_START_OF_MARKUP);
                    if (fEntityReader.lookingAtChar('?', true)) {
                        int piTarget = fEntityReader.scanName(' ');
                        if (piTarget == -1) {
                            abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                        XMLMessages.P16_PITARGET_REQUIRED);
                        } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                            if (fEntityReader.lookingAtSpace(true)) { // an XMLDecl looks like a PI with the target 'xml'
                                abortMarkup(XMLMessages.MSG_XMLDECL_MUST_BE_FIRST,
                                            XMLMessages.P22_XMLDECL_MUST_BE_FIRST);
                            } else { // a PI target matching 'xml'
                                abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                            XMLMessages.P17_RESERVED_PITARGET);
                            }
                        } else { // PI
                            scanPI(piTarget);
                        }
                    } else if (fEntityReader.lookingAtChar('!', true)) {
                        if (fEntityReader.lookingAtChar('-', true) &&
                            fEntityReader.lookingAtChar('-', true)) { // comment ?
                            scanComment(); // scan through the closing '-->'
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_MISC,
                                        XMLMessages.P27_NOT_RECOGNIZED);
                        }
                    } else {
                        abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_MISC,
                                    XMLMessages.P27_NOT_RECOGNIZED);
                    }
                    restoreScannerState(SCANNER_STATE_TRAILING_MISC);
                } else if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                } else if (!fEntityReader.lookingAtValidChar(false)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            String arg = Integer.toHexString(invChar);
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_MISC,
                                                XMLMessages.P27_INVALID_CHARACTER,
                                                arg);
                        }
                    }
                } else {
                    reportFatalXMLError(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_MISC,
                                        XMLMessages.P27_NOT_RECOGNIZED);
                    fEntityReader.lookingAtValidChar(true);
                }
            } while (fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing);
            return true;
        }
        public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
            if (moreToFollow)
                throw new RuntimeException(""FWK003 TrailingMiscDispatcher.endOfInput moreToFollow"");
            switch (fScannerState) {
            case SCANNER_STATE_TRAILING_MISC:
            case SCANNER_STATE_START_OF_MARKUP:
                break;
            case SCANNER_STATE_COMMENT:
                reportFatalXMLError(XMLMessages.MSG_COMMENT_UNTERMINATED,
                                    XMLMessages.P15_UNTERMINATED);
                break;
            case SCANNER_STATE_PI:
                reportFatalXMLError(XMLMessages.MSG_PI_UNTERMINATED,
                                    XMLMessages.P16_UNTERMINATED);
                break;
            default:
                throw new RuntimeException(""FWK001 6] ScannerState=""+fScannerState+""\n"" + ""6\t""+fScannerState);
            }
            fDispatcher = new EndOfInputDispatcher();
            setScannerState(SCANNER_STATE_END_OF_INPUT);
        }
    }
    final class EndOfInputDispatcher implements ScannerDispatcher {
        public boolean dispatch(boolean keepgoing) throws Exception {
            if (fScannerState != SCANNER_STATE_TERMINATED)
                fEventHandler.callEndDocument();
            setScannerState(SCANNER_STATE_TERMINATED);
            return false;
        }
        public void endOfInput(int entityName, boolean moreToFollow) throws Exception {
            throw new RuntimeException(""FWK001 7] ScannerState=""+fScannerState+""\n"" + ""7\t""+fScannerState);
        }
    }
    //
    // From the standard:
    //
    // [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    // [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
    // [32] SDDecl ::= S 'standalone' Eq ((""'"" ('yes' | 'no') ""'"")
    //                 | ('""' ('yes' | 'no') '""'))
    //
    // [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
    //
    void scanXMLDeclOrTextDecl(boolean scanningTextDecl) throws Exception
    {
        int version = -1;
        int encoding = -1;
        int standalone = -1;
        final int XMLDECL_START = 0;
        final int XMLDECL_VERSION = 1;
        final int XMLDECL_ENCODING = 2;
        final int XMLDECL_STANDALONE = 3;
        final int XMLDECL_FINISHED = 4;
        int state = XMLDECL_START;
        do {
            fEntityReader.skipPastSpaces();
            int offset = fEntityReader.currentOffset();
            if (scanningTextDecl) {
                if (state == XMLDECL_START && fEntityReader.skippedString(version_string)) {
                    state = XMLDECL_VERSION;
                } else if (fEntityReader.skippedString(encoding_string)) {
                    state = XMLDECL_ENCODING;
                } else {
                    abortMarkup(XMLMessages.MSG_ENCODINGDECL_REQUIRED,
                                XMLMessages.P77_ENCODINGDECL_REQUIRED);
                    return;
                }
            } else {
                if (state == XMLDECL_START) {
                    if (!fEntityReader.skippedString(version_string)) {
                        abortMarkup(XMLMessages.MSG_VERSIONINFO_REQUIRED,
                                    XMLMessages.P23_VERSIONINFO_REQUIRED);
                        return;
                    }
                    state = XMLDECL_VERSION;
                } else {
                    if (state == XMLDECL_VERSION) {
                        if (fEntityReader.skippedString(encoding_string))
                            state = XMLDECL_ENCODING;
                        else
                            state = XMLDECL_STANDALONE;
                    } else
                        state = XMLDECL_STANDALONE;
                    if (state == XMLDECL_STANDALONE && !fEntityReader.skippedString(standalone_string))
                        break;
                }
            }
            int length = fEntityReader.currentOffset() - offset;
            fEntityReader.skipPastSpaces();
            if (!fEntityReader.lookingAtChar('=', true)) {
                int majorCode = scanningTextDecl ?
                                XMLMessages.MSG_EQ_REQUIRED_IN_TEXTDECL :
                                XMLMessages.MSG_EQ_REQUIRED_IN_XMLDECL;
                int minorCode = state == XMLDECL_VERSION ?
                                XMLMessages.P24_EQ_REQUIRED :
                                (state == XMLDECL_ENCODING ?
                                 XMLMessages.P80_EQ_REQUIRED :
                                 XMLMessages.P32_EQ_REQUIRED);
                abortMarkup(majorCode, minorCode, fEntityReader.addString(offset, length));
                return;
            }
            fEntityReader.skipPastSpaces();
            int result = fEntityReader.scanStringLiteral();
            switch (result) {
            case XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED:
            {
                int majorCode = scanningTextDecl ?
                                XMLMessages.MSG_QUOTE_REQUIRED_IN_TEXTDECL :
                                XMLMessages.MSG_QUOTE_REQUIRED_IN_XMLDECL;
                int minorCode = state == XMLDECL_VERSION ?
                                XMLMessages.P24_QUOTE_REQUIRED :
                                (state == XMLDECL_ENCODING ?
                                 XMLMessages.P80_QUOTE_REQUIRED :
                                 XMLMessages.P32_QUOTE_REQUIRED);
                abortMarkup(majorCode, minorCode, fEntityReader.addString(offset, length));
                return;
            }
            case XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR:
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                    if (invChar >= 0) {
                        int majorCode = scanningTextDecl ?
                                        XMLMessages.MSG_INVALID_CHAR_IN_TEXTDECL :
                                        XMLMessages.MSG_INVALID_CHAR_IN_XMLDECL;
                        int minorCode = state == XMLDECL_VERSION ?
                                        XMLMessages.P26_INVALID_CHARACTER :
                                        (state == XMLDECL_ENCODING ?
                                         XMLMessages.P81_INVALID_CHARACTER :
                                         XMLMessages.P32_INVALID_CHARACTER);
                        reportFatalXMLError(majorCode, minorCode, Integer.toHexString(invChar));
                    }
                    skipPastEndOfCurrentMarkup();
                }
                return;
            default:
                break;
            }
            switch (state) {
            case XMLDECL_VERSION:
                //
                // version=""...""
                //
                version = result;
                String versionString = fStringPool.toString(version);
                if (!""1.0"".equals(versionString)) {
                    if (!validVersionNum(versionString)) {
                        abortMarkup(XMLMessages.MSG_VERSIONINFO_INVALID,
                                            XMLMessages.P26_INVALID_VALUE,
                                            versionString);
                        return;
                    }
                    // NOTE: RECOVERABLE ERROR
                    Object[] args = { versionString };
                    fErrorReporter.reportError(fErrorReporter.getLocator(),
                                               XMLMessages.XML_DOMAIN,
                                               XMLMessages.MSG_VERSION_NOT_SUPPORTED,
                                               XMLMessages.P26_NOT_SUPPORTED,
                                               args,
                                               XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
                    // REVISIT - hope it is compatible...
                    // skipPastEndOfCurrentMarkup();
                    // return;
                }
                if (!fEntityReader.lookingAtSpace(true)) {
                    if (scanningTextDecl) {
                        abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_IN_TEXTDECL,
                                    XMLMessages.P80_WHITESPACE_REQUIRED);
                        return;
                    }
                    state = XMLDECL_FINISHED;
                }
                break;
            case XMLDECL_ENCODING:
                //
                // encoding = ""...""
                //
                encoding = result;
                String encodingString = fStringPool.toString(encoding);
                if (!validEncName(encodingString)) {
                    abortMarkup(XMLMessages.MSG_ENCODINGDECL_INVALID,
                                XMLMessages.P81_INVALID_VALUE,
                                encodingString);
                    return;
                }
                if (!fEntityReader.lookingAtSpace(true)) {
                    state = XMLDECL_FINISHED;
                } else if (scanningTextDecl) {
                    fEntityReader.skipPastSpaces();
                    state = XMLDECL_FINISHED;
                }
                break;
            case XMLDECL_STANDALONE:
                //
                // standalone=""...""
                //
                standalone = result;
                String standaloneString = fStringPool.toString(standalone);
                boolean yes = ""yes"".equals(standaloneString);
                if (!yes && !""no"".equals(standaloneString)) {
                    abortMarkup(XMLMessages.MSG_SDDECL_INVALID,
                                XMLMessages.P32_INVALID_VALUE,
                                standaloneString);
                    return;
                }
                fStandalone = yes;
                fEntityReader.skipPastSpaces();
                state = XMLDECL_FINISHED;
                break;
            }
        } while (state != XMLDECL_FINISHED);
        if (!fEntityReader.lookingAtChar('?', true) || !fEntityReader.lookingAtChar('>', true)) {
            int majorCode, minorCode;
            if (scanningTextDecl) {
                majorCode = XMLMessages.MSG_TEXTDECL_UNTERMINATED;
                minorCode = XMLMessages.P77_UNTERMINATED;
            } else {
                majorCode = XMLMessages.MSG_XMLDECL_UNTERMINATED;
                minorCode = XMLMessages.P23_UNTERMINATED;
            }
            abortMarkup(majorCode, minorCode);
            return;
        }
        fScannerMarkupDepth--;
        if (scanningTextDecl) {
            fEventHandler.callTextDecl(version, encoding);
        } else {
            //
            // Now that we have hit '?>' we are done with XML decl. Call the
            // handler before returning.
            //
            fEventHandler.callXMLDecl(version, encoding, standalone);
            // if we see standalone = 'yes', call the eventHandler - XMLValidator
            if (fStandalone) {
                fEventHandler.callStandaloneIsYes();
            }
        }
    }
    //
    // From the standard:
    //
    // [39] element ::= EmptyElemTag | STag content ETag
    // [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
    // [40] STag ::= '<' Name (S Attribute)* S? '>'
    // [41] Attribute ::= Name Eq AttValue
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""' | ""'"" ([^<&'] | Reference)* ""'""
    // [67] Reference ::= EntityRef | CharRef
    // [68] EntityRef ::= '&' Name ';'
    // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
    // [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
    // [42] ETag ::= '</' Name S? '>'
    //
    // Note: We have already scanned Name.
    //
    boolean scanElement(QName element) throws Exception
    {
        //
        // Scan for attributes
        //
        boolean greater = false;
        boolean slash = false;
        if (greater = fEntityReader.lookingAtChar('>', true)) {
            // no attributes
        } else if (fEntityReader.lookingAtSpace(true)) {
            int previousState = setScannerState(SCANNER_STATE_ATTRIBUTE_LIST);
            while (true) {
                fEntityReader.skipPastSpaces();
                //
                // [41] Attribute ::= Name Eq AttValue
                //
                if ((greater = fEntityReader.lookingAtChar('>', true)) || (slash = fEntityReader.lookingAtChar('/', true)))
                    break;
                //
                // Name
                //
                setScannerState(SCANNER_STATE_ATTRIBUTE_NAME);
                scanAttributeName(fEntityReader, element, fAttributeQName);
                if (fAttributeQName.rawname == -1) {
                    break;
                }
                //
                // Eq
                //
                fEntityReader.skipPastSpaces();
                if (!fEntityReader.lookingAtChar('=', true)) {
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        abortMarkup(XMLMessages.MSG_EQ_REQUIRED_IN_ATTRIBUTE,
                                    XMLMessages.P41_EQ_REQUIRED,
                                    element.rawname, fAttributeQName.rawname);
                        restoreScannerState(previousState);
                    }
                    return false;
                }
                fEntityReader.skipPastSpaces();
                int result = scanAttValue(element, fAttributeQName, false);
                if (result == RESULT_FAILURE) {
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        skipPastEndOfCurrentMarkup();
                        restoreScannerState(previousState);
                    }
                    return false;
                } else if (result == RESULT_DUPLICATE_ATTR) {
                    reportFatalXMLError(XMLMessages.MSG_ATTRIBUTE_NOT_UNIQUE,
                                        XMLMessages.WFC_UNIQUE_ATT_SPEC,
                                        element.rawname, fAttributeQName.rawname);
                }
                //The validator will check whether we have a duplicate attr in the start tag.
                if ( fEventHandler.attribute(element, fAttributeQName, result) ) {
                    reportFatalXMLError(XMLMessages.MSG_ATTRIBUTE_NOT_UNIQUE,
                                        XMLMessages.WFC_UNIQUE_ATT_SPEC,
                                        element.rawname, fAttributeQName.rawname);
                }
                restoreScannerState(SCANNER_STATE_ATTRIBUTE_LIST);
                if (!fEntityReader.lookingAtSpace(true)) {
                    if (!(greater = fEntityReader.lookingAtChar('>', true)))
                        slash = fEntityReader.lookingAtChar('/', true);
                    break;
                }
            }
            restoreScannerState(previousState);
        } else {
            slash = fEntityReader.lookingAtChar('/', true);
        }
        if (!greater && (!slash || !fEntityReader.lookingAtChar('>', true))) { // '>' or '/>'
            if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                abortMarkup(XMLMessages.MSG_ELEMENT_UNTERMINATED,
                            XMLMessages.P40_UNTERMINATED,
                            element.rawname);
            }
            return false;
        }
        fEventHandler.callStartElement(element);
        fScannerMarkupDepth--;
        if (slash) { // '/>'
            fEventHandler.callEndElement(fReaderId);
            return false;
        } else {
            return true;
        }
    }
    //
    // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
    //
    int scanCharRef() throws Exception {
        int valueOffset = fEntityReader.currentOffset();
        boolean hex = fEntityReader.lookingAtChar('x', true);
        int num = fEntityReader.scanCharRef(hex);
        if (num < 0) {
            switch (num) {
            case XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED:
                reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_CHARREF,
                                    XMLMessages.P66_SEMICOLON_REQUIRED);
                return -1;
            case XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR:
                int majorCode = hex ? XMLMessages.MSG_HEXDIGIT_REQUIRED_IN_CHARREF :
                                      XMLMessages.MSG_DIGIT_REQUIRED_IN_CHARREF;
                int minorCode = hex ? XMLMessages.P66_HEXDIGIT_REQUIRED :
                                      XMLMessages.P66_DIGIT_REQUIRED;
                reportFatalXMLError(majorCode, minorCode);
                return -1;
            case XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE:
                num = 0x110000; // this will cause the right error to be reported below...
                break;
            }
        }
        //
        //  [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF]        // any Unicode character, excluding the
        //               | [#xE000-#xFFFD] | [#x10000-#x10FFFF] // surrogate blocks, FFFE, and FFFF.
        //
        if (num < 0x20) {
            if (num == 0x09 || num == 0x0A || num == 0x0D) {
                return num;
            }
        } else if (num <= 0xD7FF || (num >= 0xE000 && (num <= 0xFFFD || (num >= 0x10000 && num <= 0x10FFFF)))) {
            return num;
        }
        int valueLength = fEntityReader.currentOffset() - valueOffset;
        reportFatalXMLError(XMLMessages.MSG_INVALID_CHARREF,
                            XMLMessages.WFC_LEGAL_CHARACTER,
                            fEntityReader.addString(valueOffset, valueLength));
        return -1;
    }
    //
    // From the standard:
    //
    // [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
    //
    // Called after scanning past '<!--'
    //
    void scanComment() throws Exception
    {
        int commentOffset = fEntityReader.currentOffset();
        boolean sawDashDash = false;
        int previousState = setScannerState(SCANNER_STATE_COMMENT);
        while (fScannerState == SCANNER_STATE_COMMENT) {
            if (fEntityReader.lookingAtChar('-', false)) {
                int nextEndOffset = fEntityReader.currentOffset();
                int endOffset = 0;
                fEntityReader.lookingAtChar('-', true);
                int offset = fEntityReader.currentOffset();
                int count = 1;
                while (fEntityReader.lookingAtChar('-', true)) {
                    count++;
                    endOffset = nextEndOffset;
                    nextEndOffset = offset;
                    offset = fEntityReader.currentOffset();
                }
                if (count > 1) {
                    if (fEntityReader.lookingAtChar('>', true)) {
                        if (!sawDashDash && count > 2) {
                            reportFatalXMLError(XMLMessages.MSG_DASH_DASH_IN_COMMENT,
                                                XMLMessages.P15_DASH_DASH);
                            sawDashDash = true;
                        }
                        fScannerMarkupDepth--;
                        fEventHandler.callComment(fEntityReader.addString(commentOffset, endOffset - commentOffset));
                        restoreScannerState(previousState);
                        return;
                    } else if (!sawDashDash) {
                        reportFatalXMLError(XMLMessages.MSG_DASH_DASH_IN_COMMENT,
                                            XMLMessages.P15_DASH_DASH);
                        sawDashDash = true;
                    }
                }
            } else {
                if (!fEntityReader.lookingAtValidChar(true)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_COMMENT,
                                                XMLMessages.P15_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        }
                    }
                }
            }
        }
        restoreScannerState(previousState);
    }
    //
    // From the standard:
    //
    // [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
    // [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
    //
    void scanPI(int piTarget) throws Exception
    {
        String piTargetString = fStringPool.toString(piTarget);
        if (piTargetString.length() == 3 &&
            (piTargetString.charAt(0) == 'X' || piTargetString.charAt(0) == 'x') &&
            (piTargetString.charAt(1) == 'M' || piTargetString.charAt(1) == 'm') &&
            (piTargetString.charAt(2) == 'L' || piTargetString.charAt(2) == 'l')) {
            abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                        XMLMessages.P17_RESERVED_PITARGET);
            return;
        }
        int prevState = setScannerState(SCANNER_STATE_PI);
        int piDataOffset = -1;
        int piDataLength = -1;
        if (!fEntityReader.lookingAtSpace(true)) {
            if (!fEntityReader.lookingAtChar('?', true) || !fEntityReader.lookingAtChar('>', true)) {
                if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                    abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_IN_PI,
                                XMLMessages.P16_WHITESPACE_REQUIRED);
                    restoreScannerState(prevState);
                }
                return;
            }
            piDataLength = 0;
        } else {
            fEntityReader.skipPastSpaces();
            piDataOffset = fEntityReader.currentOffset();
            while (fScannerState == SCANNER_STATE_PI) {
                while (fEntityReader.lookingAtChar('?', false)) {
                    int offset = fEntityReader.currentOffset();
                    fEntityReader.lookingAtChar('?', true);
                    if (fEntityReader.lookingAtChar('>', true)) {
                        piDataLength = offset - piDataOffset;
                        break;
                    }
                }
                if (piDataLength >= 0)
                    break;
                if (!fEntityReader.lookingAtValidChar(true)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_PI,
                                                XMLMessages.P16_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        }
                        skipPastEndOfCurrentMarkup();
                        restoreScannerState(prevState);
                    }
                    return;
                }
            }
        }
        fScannerMarkupDepth--;
        restoreScannerState(prevState);
        int piData = piDataLength == 0 ?
                     StringPool.EMPTY_STRING : fEntityReader.addString(piDataOffset, piDataLength);
        fEventHandler.callProcessingInstruction(piTarget, piData);
    }

    /** Sets whether the parser preprocesses namespaces. */
    public void setNamespacesEnabled(boolean enabled) {
        fNamespacesEnabled = enabled;
    }

    /** Returns whether the parser processes namespaces. */
    public boolean getNamespacesEnabled() {
        return fNamespacesEnabled;
    }

    /** Sets whether the parser validates. */
    public void setValidationEnabled(boolean enabled) {
        fValidationEnabled = enabled;
        if (fDTDScanner != null) {
            fDTDScanner.setValidationEnabled(enabled);
        }
    }

    /** Returns true if validation is turned on. */
    public boolean getValidationEnabled() {
        return fValidationEnabled;
    }

    // old EventHandler methods pushed back into scanner

    /** Scans element type. */
    private void scanElementType(XMLEntityHandler.EntityReader entityReader, 
                                char fastchar, QName element) throws Exception {

        if (!fNamespacesEnabled) {
            element.clear();
            element.localpart = entityReader.scanName(fastchar);
            element.rawname = element.localpart;
        } 
        else {
            entityReader.scanQName(fastchar, element);
            if (entityReader.lookingAtChar(':', false)) {
                fErrorReporter.reportError(fErrorReporter.getLocator(),
                                           XMLMessages.XML_DOMAIN,
                                           XMLMessages.MSG_TWO_COLONS_IN_QNAME,
                                           XMLMessages.P5_INVALID_CHARACTER,
                                           null,
                                           XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
                 entityReader.skipPastNmtoken(' ');
            }
        }

        fEventHandler.element(element);

    } // scanElementType(XMLEntityHandler.EntityReader,char,QName)

    /** Scans expected element type. */
    private boolean scanExpectedElementType(XMLEntityHandler.EntityReader entityReader, 
                                           char fastchar, int elementType) 
        throws Exception {

        /***/
        // REVISIT: Why aren't we using the 'element' parameter? -Ac
        // REVISIT: I replaced the 'fCurrentElement' with 'element' parameter, still working, 
        //          just wondering Why are we using CharArrayRange in the first place? -ericye
        if (fCurrentElementCharArrayRange == null) {
            fCurrentElementCharArrayRange = fStringPool.createCharArrayRange();
        }
        fStringPool.getCharArrayRange(elementType, fCurrentElementCharArrayRange);
        return entityReader.scanExpectedName(fastchar, fCurrentElementCharArrayRange);
        /***
        entityReader.scanQName(fastchar, element);
        return true;
        /***/

    } // scanExpectedElementType(XMLEntityHandler.EntityReader,char,QName)

    /** Scans attribute name. */
    private void scanAttributeName(XMLEntityHandler.EntityReader entityReader, 
                                  QName element, QName attribute) 
        throws Exception {

        /***
        // REVISIT: What's this check for?
        if (!fSeenRootElement) {
            fSeenRootElement = true;
            rootElementSpecified(element);
            fStringPool.resetShuffleCount();
        }
        /***/

        if (!fNamespacesEnabled) {
            attribute.clear();
            attribute.localpart = entityReader.scanName('=');
            attribute.rawname = attribute.localpart;
        } 
        else {
            entityReader.scanQName('=', attribute);
            if (entityReader.lookingAtChar(':', false)) {
                fErrorReporter.reportError(fErrorReporter.getLocator(),
                                           XMLMessages.XML_DOMAIN,
                                           XMLMessages.MSG_TWO_COLONS_IN_QNAME,
                                           XMLMessages.P5_INVALID_CHARACTER,
                                           null,
                                           XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
                entityReader.skipPastNmtoken(' ');
            }
        }

    } // scanAttributeName(XMLEntityHandler.EntityReader,QName,QName)

    /** Scan doctype declaration. */
    private void scanDoctypeDecl(boolean standalone) throws Exception {
        
        fScanningDTD = true;

        /***
        fScanningDTD = true;
        fCheckedForSchema = true;
        /***/
        fSeenDoctypeDecl = true;
        /***
        fStandaloneReader = standalone ? fEntityHandler.getReaderId() : -1;
        fDeclsAreExternal = false;
        if (fDTDImporter == null) {
            fDTDImporter = new DTDImporter(fStringPool, fErrorReporter, fEntityHandler, this);
        } 
        else {
            fDTDImporter.reset(fStringPool);
        }
        fDTDImporter.initHandlers(fDTDHandler);
        fDTDImporter.setValidating(fValidating);
        fDTDImporter.setNamespacesEnabled(fNamespacesEnabled);
        if (fDTDImporter.scanDoctypeDecl(standalone) && fValidating) {
            // check declared elements
            if (fWarningOnUndeclaredElements) {
                // REVISIT: comment out because won't compile 
                // checkDeclaredElements();
            }

            // check required notations
            fEntityHandler.checkRequiredNotations();
        }
        fScanningDTD = false;
        /***/
        if (fDTDScanner == null) {
            fDTDScanner = new XMLDTDScanner(fStringPool, fErrorReporter, fEntityHandler, new ChunkyCharArray(fStringPool));
            fDTDScanner.setValidationEnabled(fValidationEnabled);
        }
        else {
            fDTDScanner.reset(fStringPool, new ChunkyCharArray(fStringPool));
        }
        fDTDScanner.setGrammarResolver(fGrammarResolver);
        // REVISIT: What about standalone?
        if (fDTDScanner.scanDoctypeDecl()) {
            if (fDTDScanner.getReadingExternalEntity()) {
                fDTDScanner.scanDecls(true);
            }
            // REVISIT: What about validation and checking stuff?
        }
        //VC_NOTATION_DECLARED
        if (fValidationEnabled) {
            ((DefaultEntityHandler)fEntityHandler).checkRequiredNotations();
        }
        /***/
        fScanningDTD = false;

    } // scanDoctypeDecl(boolean)

    /** Scan attribute value. */
    private int scanAttValue(QName element, QName attribute) throws Exception {

        //fAttrNameLocator = getLocatorImpl(fAttrNameLocator);
        int attValue = scanAttValue(element, attribute, fValidationEnabled);
        if (attValue == -1) {
            return XMLDocumentScanner.RESULT_FAILURE;
        }


        /***
        // REVISIT: This is validation related.
        if (!fValidating && fAttDefCount == 0) {
            int attType = fCDATASymbol;
            if (fAttrListHandle == -1)
                fAttrListHandle = fAttrList.startAttrList();
            // REVISIT: Should this be localpart or rawname?
            if (fAttrList.addAttr(attribute, attValue, attType, true, true) == -1) {
                return XMLDocumentScanner.RESULT_DUPLICATE_ATTR;
            }
            return XMLDocumentScanner.RESULT_SUCCESS;
        }
        /****/

        /****
        // REVISIT: Validation. What should these be?
        int attDefIndex = getAttDef(element, attribute);
        if (attDefIndex == -1) {

            if (fValidating) {
                // REVISIT - cache the elem/attr tuple so that we only give
                //  this error once for each unique occurrence
                Object[] args = { fStringPool.toString(element.rawname),
                                  fStringPool.toString(attribute.rawname) };
                fErrorReporter.reportError(fAttrNameLocator,
                                           XMLMessages.XML_DOMAIN,
                                           XMLMessages.MSG_ATTRIBUTE_NOT_DECLARED,
                                           XMLMessages.VC_ATTRIBUTE_VALUE_TYPE,
                                           args,
                                           XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
            }

            int attType = fCDATASymbol;
            if (fAttrListHandle == -1) {
                fAttrListHandle = fAttrList.startAttrList();
            }
            // REVISIT: Validation. What should the name be?
            if (fAttrList.addAttr(attribute, attValue, attType, true, true) == -1) {
                return XMLDocumentScanner.RESULT_DUPLICATE_ATTR;
            }
            return XMLDocumentScanner.RESULT_SUCCESS;
        }
        /****/

        /****
        int attType = getAttType(attDefIndex);
        if (attType != fCDATASymbol) {
            AttributeValidator av = getAttributeValidator(attDefIndex);
            int enumHandle = getEnumeration(attDefIndex);
            // REVISIT: Validation. What should these be?
            attValue = av.normalize(element, attribute, 
                                    attValue, attType, enumHandle);
        }

        if (fAttrListHandle == -1) {
            fAttrListHandle = fAttrList.startAttrList();
        }
        // REVISIT: Validation. What should the name be?
        if (fAttrList.addAttr(attribute, attValue, attType, true, true) == -1) {
            return XMLDocumentScanner.RESULT_DUPLICATE_ATTR;
        }
        /***/

        return XMLDocumentScanner.RESULT_SUCCESS;

    } // scanAttValue(QName,QName):int

    /** Returns true if the version number is valid. */
    private boolean validVersionNum(String version) {
        return XMLCharacterProperties.validVersionNum(version);
    }

    /** Returns true if the encoding name is valid. */
    private boolean validEncName(String encoding) {
        return XMLCharacterProperties.validEncName(encoding);
    }

} // class XMLDocumentScanner
"
org/apache/xerces/framework/XMLParser.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;
import java.util.Locale;

import org.apache.xerces.readers.DefaultEntityHandler;
import org.apache.xerces.readers.XMLDeclRecognizer;
import org.apache.xerces.readers.XMLEntityHandler;
import org.apache.xerces.readers.XMLEntityReaderFactory;
import org.apache.xerces.utils.ChunkyCharArray;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLMessageProvider;
import org.apache.xerces.utils.XMLMessages;
import org.apache.xerces.utils.ImplementationMessages;
import org.apache.xerces.validators.common.GrammarResolver;
import org.apache.xerces.validators.common.GrammarResolverImpl;
import org.apache.xerces.validators.common.XMLValidator;
import org.apache.xerces.validators.datatype.DatatypeMessageProvider;
import org.apache.xerces.validators.schema.SchemaMessageProvider;

import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;

/**
 * This is the base class of all standard parsers.
 *
 * @version $Id$
 */
public class XMLParser implements XMLErrorReporter {

    //
    // Constants
    //

    // protected

    /** SAX2 features prefix (http://xml.org/sax/features/). */
    protected static final String SAX2_FEATURES_PREFIX = ""http://xml.org/sax/features/"";

    /** SAX2 properties prefix (http://xml.org/sax/properties/). */
    protected static final String SAX2_PROPERTIES_PREFIX = ""http://xml.org/sax/properties/"";

    /** Xerces features prefix (http://apache.org/xml/features/). */
    protected static final String XERCES_FEATURES_PREFIX = ""http://apache.org/xml/features/"";

    /** Xerces properties prefix (http://apache.org/xml/properties/). */
    protected static final String XERCES_PROPERTIES_PREFIX = ""http://apache.org/xml/properties/"";

    // private

    /** Features recognized by this parser. */
    private static final String RECOGNIZED_FEATURES[] = {
        // SAX2 core
        ""http://xml.org/sax/features/validation"",
        ""http://xml.org/sax/features/external-general-entities"",
        ""http://xml.org/sax/features/external-parameter-entities"",
        ""http://xml.org/sax/features/namespaces"",
        // Xerces
        ""http://apache.org/xml/features/validation/dynamic"",
        ""http://apache.org/xml/features/validation/default-attribute-values"",
        ""http://apache.org/xml/features/validation/validate-content-models"",
        ""http://apache.org/xml/features/validation/validate-datatypes"",
        ""http://apache.org/xml/features/validation/warn-on-duplicate-attdef"",
        ""http://apache.org/xml/features/validation/warn-on-undeclared-elemdef"",
        ""http://apache.org/xml/features/allow-java-encodings"",
        ""http://apache.org/xml/features/continue-after-fatal-error"",
    };

    /** Properties recognized by this parser. */
    private static final String RECOGNIZED_PROPERTIES[] = {
        // SAX2 core
        //""http://xml.org/sax/properties/namespace-sep"",
        ""http://xml.org/sax/properties/xml-string"",
        // Xerces
    };

    // debugging

    /** Set to true and recompile to print exception stack trace. */
    private static final boolean PRINT_EXCEPTION_STACK_TRACE = false;

    //
    // Data
    //

    protected GrammarResolver fGrammarResolver = null;

    // state

    protected boolean fParseInProgress = false;
    private boolean fNeedReset = false;

    // features

    /** Continue after fatal error. */
    private boolean fContinueAfterFatalError = false;

    // properties

    /** Error handler. */
    private ErrorHandler fErrorHandler = null;

    // other

    private Locale fLocale = null;

    // error information

    private static XMLMessageProvider fgXMLMessages = new XMLMessages();
    private static XMLMessageProvider fgImplementationMessages = new ImplementationMessages();
    private static XMLMessageProvider fgSchemaMessages = new SchemaMessageProvider();
    private static XMLMessageProvider fgDatatypeMessages= new DatatypeMessageProvider();

    //
    //
    //
    protected StringPool fStringPool = null;
    protected XMLErrorReporter fErrorReporter = null;
    protected DefaultEntityHandler fEntityHandler = null;
    protected XMLDocumentScanner fScanner = null;
    protected XMLValidator fValidator = null;

    //
    // Constructors
    //

    /**
     * Constructor
     */
    protected XMLParser() {
        fStringPool = new StringPool();
        fErrorReporter = this;
        fEntityHandler = new DefaultEntityHandler(fStringPool, fErrorReporter);
        fScanner = new XMLDocumentScanner(fStringPool, fErrorReporter, fEntityHandler, new ChunkyCharArray(fStringPool));
        fValidator = new XMLValidator(fStringPool, fErrorReporter, fEntityHandler, fScanner);
        fGrammarResolver = new GrammarResolverImpl();
        fScanner.setGrammarResolver(fGrammarResolver);
        fValidator.setGrammarResolver(fGrammarResolver);
    }

    /**
     * Set char data processing preference and handlers.
     */
    protected void initHandlers(boolean sendCharDataAsCharArray,
                                XMLDocumentHandler docHandler,
                                XMLDocumentHandler.DTDHandler dtdHandler)
    {
        fValidator.initHandlers(sendCharDataAsCharArray, docHandler, dtdHandler);
    }

    //
    // Public methods
    //

    // features and properties

    /**
     * Returns a list of features that this parser recognizes.
     * This method will never return null; if no features are
     * recognized, this method will return a zero length array.
     *
     * @see #isFeatureRecognized
     * @see #setFeature
     * @see #getFeature
     */
    public String[] getFeaturesRecognized() {
        return RECOGNIZED_FEATURES;
    }

    /**
     * Returns true if the specified feature is recognized.
     *
     * @see #getFeaturesRecognized
     * @see #setFeature
     * @see #getFeature
     */
    public boolean isFeatureRecognized(String featureId) {
        String[] recognizedFeatures = getFeaturesRecognized();
        for (int i = 0; i < recognizedFeatures.length; i++) {
            if (featureId.equals(recognizedFeatures[i]))
                return true;
        }
        return false;
    }

    /**
     * Returns a list of properties that this parser recognizes.
     * This method will never return null; if no properties are
     * recognized, this method will return a zero length array.
     *
     * @see #isPropertyRecognized
     * @see #setProperty
     * @see #getProperty
     */
    public String[] getPropertiesRecognized() {
        return RECOGNIZED_PROPERTIES;
    }

    /**
     * Returns true if the specified property is recognized.
     *
     * @see #getPropertiesRecognized
     * @see #setProperty
     * @see #getProperty
     */
    public boolean isPropertyRecognized(String propertyId) {
        String[] recognizedProperties = getPropertiesRecognized();
        for (int i = 0; i < recognizedProperties.length; i++) {
            if (propertyId.equals(recognizedProperties[i]))
                return true;
        }
        return false;
    }

    // initialization

    /**
     * Setup for application-driven parsing.
     *
     * @param source the input source to be parsed.
     * @see #parseSome
     */
    public boolean parseSomeSetup(InputSource source) throws Exception {
        if (fNeedReset)
            resetOrCopy();
        fParseInProgress = true;
        fNeedReset = true;
        return fEntityHandler.startReadingFromDocument(source);
    }

    /**
     * Application-driven parsing.
     *
     * @see #parseSomeSetup
     */
    public boolean parseSome() throws Exception {
        if (!fScanner.parseSome(false)) {
            fParseInProgress = false;
            return false;
        }
        return true;
    }

    // resetting

    /** Reset parser instance so that it can be reused. */
    public void reset() throws Exception {
        fGrammarResolver.clearGrammarResolver();
        fStringPool.reset();
        fEntityHandler.reset(fStringPool);
        fScanner.reset(fStringPool, new ChunkyCharArray(fStringPool));
        fValidator.reset(fStringPool);
        fNeedReset = false;
    }

    // properties (the normal kind)

    /**
     * return the locator being used by the parser
     *
     * @return the parser's active locator
     */
    public final Locator getLocator() {
        return fEntityHandler;
    }

    /**
     * Set the reader factory.
     */
    public void setReaderFactory(XMLEntityReaderFactory readerFactory) {
        fEntityHandler.setReaderFactory(readerFactory);
    }

    /**
     * Adds a recognizer.
     *
     * @param recognizer The XML recognizer to add.
     */
    public void addRecognizer(XMLDeclRecognizer recognizer) {
        fEntityHandler.addRecognizer(recognizer);
    }

    //
    // Protected methods
    //

    // SAX2 core features

    /**
     * Sets whether the parser validates.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/validation
     * </pre>
     *
     * @param validate True to validate; false to not validate.
     *
     * @see #getValidation
     * @see #setFeature
     */
    protected void setValidation(boolean validate) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""PAR004 Cannot setFeature(http://xml.org/sax/features/validation): parse is in progress.\n""+
                                               ""http://xml.org/sax/features/validation"");
        }
        try {
            // REVISIT: [Q] Should the scanner tell the validator that
            //              validation is on? -Ac
            fScanner.setValidationEnabled(validate);
            fValidator.setValidationEnabled(validate);
        }
        catch (Exception ex) {
            throw new SAXNotSupportedException(ex.getMessage());
        }
    }

    /**
     * Returns true if validation is turned on.
     *
     * @see #setValidation
     */
    protected boolean getValidation() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fValidator.getValidationEnabled();
    }

    /**
     * <b>Note: Currently, this parser always expands external general
     * entities.</b> Setting this feature to false will throw a
     * SAXNotSupportedException.
     * <p>
     * Sets whether external general entities are expanded.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/external-general-entities
     * </pre>
     *
     * @param expand True to expand external general entities; false
     *               to not expand.
     *
     * @see #getExternalGeneralEntities
     * @see #setFeature
     */
    protected void setExternalGeneralEntities(boolean expand)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""PAR004 Cannot setFeature(http://xml.org/sax/features/external-general-entities): parse is in progress.\n""+
                                               ""http://xml.org/sax/features/external-general-entities"");
        }
        if (!expand) {
            throw new SAXNotSupportedException(""http://xml.org/sax/features/external-general-entities"");
        }
    }

    /**
     * <b>Note: This feature is always true.</b>
     * <p>
     * Returns true if external general entities are expanded.
     *
     * @see #setExternalGeneralEntities
     */
    protected boolean getExternalGeneralEntities() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return true;
    }

    /**
     * <b>Note: Currently, this parser always expands external parameter
     * entities.</b> Setting this feature to false will throw a
     * SAXNotSupportedException.
     * <p>
     * Sets whether external parameter entities are expanded.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/external-parameter-entities
     * </pre>
     *
     * @param expand True to expand external parameter entities; false
     *               to not expand.
     *
     * @see #getExternalParameterEntities
     * @see #setFeature
     */
    protected void setExternalParameterEntities(boolean expand)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""PAR004 Cannot setFeature(http://xml.org/sax/features/external-general-entities): parse is in progress.\n""+
                                               ""http://xml.org/sax/features/external-general-entities"");
        }
        if (!expand) {
            throw new SAXNotSupportedException(""http://xml.org/sax/features/external-parameter-entities"");
        }
    }

    /**
     * <b>Note: This feature is always true.</b>
     * <p>
     * Returns true if external parameter entities are expanded.
     *
     * @see #setExternalParameterEntities
     */
    protected boolean getExternalParameterEntities() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return true;
    }

    /**
     * Sets whether the parser preprocesses namespaces.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://xml.org/sax/features/namespaces
     * <pre>
     *
     * @param process True to process namespaces; false to not process.
     *
     * @see #getNamespaces
     * @see #setFeature
     */
    protected void setNamespaces(boolean process) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""PAR004 Cannot setFeature(http://xml.org/sax/features/namespaces): parse is in progress.\n""+
                                               ""http://xml.org/sax/features/namespaces"");
        }
        fScanner.setNamespacesEnabled(process);
        // REVISIT: [Q] Should the scanner tell the validator that namespace
        //              processing is on? -Ac
        fValidator.setNamespacesEnabled(process);
    }

    /**
     * Returns true if the parser preprocesses namespaces.
     *
     * @see #setNamespaces
     */
    protected boolean getNamespaces() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fValidator.getNamespacesEnabled();
    }

    // Xerces features

    /**
     * Allows the parser to validate a document only when it contains a
     * grammar. Validation is turned on/off based on each document
     * instance, automatically.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://apache.org/xml/features/validation/dynamic
     * </pre>
     *
     * @param dynamic True to dynamically validate documents; false to
     *                validate based on the validation feature.
     *
     * @see #getValidationDynamic
     * @see #setFeature
     */
    protected void setValidationDynamic(boolean dynamic) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""http://apache.org/xml/features/validation/dynamic: parse is in progress"");
        }
        try {
            fValidator.setDynamicValidationEnabled(dynamic);
        }
        catch (Exception ex) {
            throw new SAXNotSupportedException(ex.getMessage());
        }
    }

    /**
     * Returns true if validation is based on whether a document
     * contains a grammar.
     *
     * @see #setValidationDynamic
     */
    protected boolean getValidationDynamic() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fValidator.getDynamicValidationEnabled();
    }

    /**
     * Sets whether an error is emitted when an attribute is redefined
     * in the grammar.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://apache.org/xml/features/validation/warn-on-duplicate-attdef
     * </pre>
     *
     * @param warn True to warn; false to not warn.
     *
     * @see #getValidationWarnOnDuplicateAttdef
     * @see #setFeature
     */
    protected void setValidationWarnOnDuplicateAttdef(boolean warn)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fValidator.setWarningOnDuplicateAttDef(warn);
    }

    /**
     * Returns true if an error is emitted when an attribute is redefined
     * in the grammar.
     *
     * @see #setValidationWarnOnDuplicateAttdef
     */
    protected boolean getValidationWarnOnDuplicateAttdef()
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fValidator.getWarningOnDuplicateAttDef();
    }

    /**
     * Sets whether the parser emits an error when an element's content
     * model references an element by name that is not declared in the
     * grammar.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://apache.org/xml/features/validation/warn-on-undeclared-elemdef
     * </pre>
     *
     * @param warn True to warn; false to not warn.
     *
     * @see #getValidationWarnOnUndeclaredElemdef
     * @see #setFeature
     */
    protected void setValidationWarnOnUndeclaredElemdef(boolean warn)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fValidator.setWarningOnUndeclaredElements(warn);
    }

    /**
     * Returns true if the parser emits an error when an undeclared
     * element is referenced in the grammar.
     *
     * @see #setValidationWarnOnUndeclaredElemdef
     */
    protected boolean getValidationWarnOnUndeclaredElemdef()
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fValidator.getWarningOnUndeclaredElements();
    }

    /**
     * Allows the use of Java encoding names in the XMLDecl and TextDecl
     * lines in an XML document.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://apache.org/xml/features/allow-java-encodings
     * </pre>
     *
     * @param allow True to allow Java encoding names; false to disallow.
     *
     * @see #getAllowJavaEncodings
     * @see #setFeature
     */
    protected void setAllowJavaEncodings(boolean allow) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fEntityHandler.setAllowJavaEncodings(allow);
    }

    /**
     * Returns true if Java encoding names are allowed in the XML document.
     *
     * @see #setAllowJavaEncodings
     */
    protected boolean getAllowJavaEncodings() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fEntityHandler.getAllowJavaEncodings();
    }

    /**
     * Allows the parser to continue after a fatal error. Normally, a
     * fatal error would stop the parse.
     * <p>
     * This method is the equivalent to the feature:
     * <pre>
     * http://apache.org/xml/features/continue-after-fatal-error
     * </pre>
     *
     * @param continueAfterFatalError True to continue; false to stop on
     *                                fatal error.
     *
     * @see #getContinueAfterFatalError
     * @see #setFeature
     */
    protected void setContinueAfterFatalError(boolean continueAfterFatalError)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        fContinueAfterFatalError = continueAfterFatalError;
    }

    /**
     * Returns true if the parser continues after a fatal error.
     *
     * @see #setContinueAfterFatalError
     */
    protected boolean getContinueAfterFatalError() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fContinueAfterFatalError;
    }

    // SAX2 core properties

    /**
     * Set the separator to be used between the URI part of a name and the
     * local part of a name when namespace processing is being performed
     * (see the http://xml.org/sax/features/namespaces feature).  By default,
     * the separator is a single space.
     * <p>
     * This property may not be set while a parse is in progress (throws a
     * SAXNotSupportedException).
     * <p>
     * This method is the equivalent to the property:
     * <pre>
     * http://xml.org/sax/properties/namespace-sep
     * </pre>
     *
     * @param separator The new namespace separator.
     *
     * @see #getNamespaceSep
     * @see #setProperty
     */
    /***
    protected void setNamespaceSep(String separator) 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        // REVISIT: Ask someone what it could possibly hurt to allow
        //          the application to change this in mid-parse.
        if (fParseInProgress) {
            throw new SAXNotSupportedException(""http://xml.org/sax/properties/namespace-sep: parse is in progress"");
        }
        fNamespaceSep = separator;
    }
    /***/

    /**
     * Returns the namespace separator.
     *
     * @see #setNamespaceSep
     */
    /***
    protected String getNamespaceSep() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        return fNamespaceSep;
    }
    /***/

    /**
     * This method is the equivalent to the property:
     * <pre>
     * http://xml.org/sax/properties/xml-string
     * </pre>
     *
     * @see #getProperty
     */
    protected String getXMLString() 
        throws SAXNotRecognizedException, SAXNotSupportedException {
        throw new SAXNotSupportedException(""http://xml.org/sax/properties/xml-string"");
    }

    // resetting

    /**
     * Reset or copy parser
     * Allows parser instance reuse
     */
    protected void resetOrCopy() throws Exception {
        fStringPool = new StringPool();
        fEntityHandler.reset(fStringPool);
        fScanner.reset(fStringPool, new ChunkyCharArray(fStringPool));
        fValidator.resetOrCopy(fStringPool);
        fNeedReset = false;
        fGrammarResolver = new GrammarResolverImpl();
        fScanner.setGrammarResolver(fGrammarResolver);
        fValidator.setGrammarResolver(fGrammarResolver);
    }

    //
    // Parser/XMLReader methods
    //
    // NOTE: This class does *not* implement the org.xml.sax.Parser
    //       interface but it does share some common methods. -Ac

    // handlers

    /**
     * Sets the resolver used to resolve external entities. The EntityResolver
     * interface supports resolution of public and system identifiers.
     *
     * @param resolver The new entity resolver. Passing a null value will
     *                 uninstall the currently installed resolver.
     */
    public void setEntityResolver(EntityResolver resolver) {
        fEntityHandler.setEntityResolver(resolver);
    }

    /**
     * Return the current entity resolver.
     *
     * @return The current entity resolver, or null if none
     *         has been registered.
     * @see #setEntityResolver
     */
    public EntityResolver getEntityResolver() {
        return fEntityHandler.getEntityResolver();
    }

    /**
     * Sets the error handler.
     *
     * @param handler The new error handler.
     */
    public void setErrorHandler(ErrorHandler handler) {
        fErrorHandler = handler;
    }

    /**
     * Return the current error handler.
     *
     * @return The current error handler, or null if none
     *         has been registered.
     * @see #setErrorHandler
     */
    public ErrorHandler getErrorHandler() {
        return fErrorHandler;
    }

    // parsing

    /**
     * Parses the specified input source.
     *
     * @param source The input source.
     *
     * @exception org.xml.sax.SAXException Throws exception on SAX error.
     * @exception java.io.IOException Throws exception on i/o error.
     */
    public void parse(InputSource source)
        throws SAXException, IOException {

        if (fParseInProgress) {
            throw new org.xml.sax.SAXException(""FWK005 parse may not be called while parsing.""); // REVISIT - need to add new error message
        }

        try {
            if (parseSomeSetup(source)) {
                fScanner.parseSome(true);
            }
            fParseInProgress = false;
        } catch (org.xml.sax.SAXException ex) {
            fParseInProgress = false;
            if (PRINT_EXCEPTION_STACK_TRACE)
                ex.printStackTrace();
            throw ex;
        } catch (IOException ex) {
            fParseInProgress = false;
            if (PRINT_EXCEPTION_STACK_TRACE)
                ex.printStackTrace();
            throw ex;
        } catch (Exception ex) {
            fParseInProgress = false;
            if (PRINT_EXCEPTION_STACK_TRACE)
                ex.printStackTrace();
            throw new org.xml.sax.SAXException(ex);
        }

    } // parse(InputSource)

    /**
     * Parses the input source specified by the given system identifier.
     * <p>
     * This method is equivalent to the following:
     * <pre>
     *     parse(new InputSource(systemId));
     * </pre>
     *
     * @param source The input source.
     *
     * @exception org.xml.sax.SAXException Throws exception on SAX error.
     * @exception java.io.IOException Throws exception on i/o error.
     */
    public void parse(String systemId)
        throws SAXException, IOException {

        InputSource source = new InputSource(systemId);
        parse(source);
        try {
            Reader reader = source.getCharacterStream();
            if (reader != null) {
                reader.close();
            }
            else {
                InputStream is = source.getByteStream();
                if (is != null) {
                    is.close();
                }
            }
        }
        catch (IOException e) {
            // ignore
        }

    } // parse(String)

    // locale

    /**
     * Set the locale to use for messages.
     *
     * @param locale The locale object to use for localization of messages.
     *
     * @exception SAXException An exception thrown if the parser does not
     *                         support the specified locale.
     *
     * @see org.xml.sax.Parser
     */
    public void setLocale(Locale locale) throws SAXException {

        if (fParseInProgress) {
            throw new org.xml.sax.SAXException(""FWK006 setLocale may not be called while parsing""); // REVISIT - need to add new error message
        }

        fLocale = locale;
        fgXMLMessages.setLocale(locale);
        fgImplementationMessages.setLocale(locale);

    } // setLocale(Locale)

    //
    // XMLErrorReporter methods
    //

    /**
     * Report an error.
     *
     * @param locator Location of error.
     * @param errorDomain The error domain.
     * @param majorCode The major code of the error.
     * @param minorCode The minor code of the error.
     * @param args Arguments for replacement text.
     * @param errorType The type of the error.
     *
     * @exception Exception Thrown on error.
     *
     * @see XMLErrorReporter#ERRORTYPE_WARNING
     * @see XMLErrorReporter#ERRORTYPE_FATAL_ERROR
     */
    public void reportError(Locator locator, String errorDomain,
                            int majorCode, int minorCode, Object args[],
                            int errorType) throws Exception {

        // create the appropriate message
        SAXParseException spe;
        if (errorDomain.equals(XMLMessages.XML_DOMAIN)) {
            spe = new SAXParseException(fgXMLMessages.createMessage(fLocale, majorCode, minorCode, args), locator);
        }
        else if (errorDomain.equals(XMLMessages.XMLNS_DOMAIN)) {
            spe = new SAXParseException(fgXMLMessages.createMessage(fLocale, majorCode, minorCode, args), locator);
        }
        else if (errorDomain.equals(ImplementationMessages.XERCES_IMPLEMENTATION_DOMAIN)) {
            spe = new SAXParseException(fgImplementationMessages.createMessage(fLocale, majorCode, minorCode, args), locator);
        } else if (errorDomain.equals(SchemaMessageProvider.SCHEMA_DOMAIN)) {
            spe = new SAXParseException(fgSchemaMessages.createMessage(fLocale, majorCode, minorCode, args), locator);
        } else if (errorDomain.equals(DatatypeMessageProvider.DATATYPE_DOMAIN)) {
            spe = new SAXParseException(fgDatatypeMessages.createMessage(fLocale, majorCode, minorCode, args), locator);
        } else {
            throw new RuntimeException(""FWK007 Unknown error domain \"""" + errorDomain + ""\"".""+""\n""+errorDomain);
        }

        // default error handling
        if (fErrorHandler == null) {
            if (errorType == XMLErrorReporter.ERRORTYPE_FATAL_ERROR &&
                !fContinueAfterFatalError) {
                throw spe;
            }
            return;
        }

        // make appropriate callback
        if (errorType == XMLErrorReporter.ERRORTYPE_WARNING) {
            fErrorHandler.warning(spe);
        }
        else if (errorType == XMLErrorReporter.ERRORTYPE_FATAL_ERROR) {
            fErrorHandler.fatalError(spe);
            if (!fContinueAfterFatalError) {
                Object[] fatalArgs = { spe.getMessage() };
                throw new SAXException(fgImplementationMessages.createMessage(fLocale, ImplementationMessages.FATAL_ERROR, 0, fatalArgs));
            }
        }
        else {
            fErrorHandler.error(spe);
        }

    } // reportError(Locator,String,int,int,Object[],int)

    //
    // XMLReader methods
    //

    /**
     * Set the state of a feature.
     *
     * Set the state of any feature in a SAX2 parser.  The parser
     * might not recognize the feature, and if it does recognize
     * it, it might not be able to fulfill the request.
     *
     * @param featureId The unique identifier (URI) of the feature.
     * @param state The requested state of the feature (true or false).
     *
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested feature is not known.
     * @exception org.xml.sax.SAXNotSupportedException If the
     *            requested feature is known, but the requested
     *            state is not supported.
     * @exception org.xml.sax.SAXException If there is any other
     *            problem fulfilling the request.
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            String feature = featureId.substring(SAX2_FEATURES_PREFIX.length());
            //
            // http://xml.org/sax/features/validation
            //   Validate (true) or don't validate (false).
            //
            if (feature.equals(""validation"")) {
                setValidation(state);
                return;
            }
            //
            // http://xml.org/sax/features/external-general-entities
            //   Expand external general entities (true) or don't expand (false).
            //
            if (feature.equals(""external-general-entities"")) {
                setExternalGeneralEntities(state);
                return;
            }
            //
            // http://xml.org/sax/features/external-parameter-entities
            //   Expand external parameter entities (true) or don't expand (false).
            //
            if (feature.equals(""external-parameter-entities"")) {
                setExternalParameterEntities(state);
                return;
            }
            //
            // http://xml.org/sax/features/namespaces
            //   Preprocess namespaces (true) or don't preprocess (false).  See also
            //   the http://xml.org/sax/properties/namespace-sep property.
            //
            if (feature.equals(""namespaces"")) {
                setNamespaces(state);
                return;
            }
            //
            // Not recognized
            //
        }

        //
        // Xerces Features
        //

        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            String feature = featureId.substring(XERCES_FEATURES_PREFIX.length());
            //
            // http://apache.org/xml/features/validation/dynamic
            //   Allows the parser to validate a document only when it
            //   contains a grammar. Validation is turned on/off based
            //   on each document instance, automatically.
            //
            if (feature.equals(""validation/dynamic"")) {
                setValidationDynamic(state);
                return;
            }
            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (feature.equals(""validation/default-attribute-values"")) {
                // REVISIT
                throw new SAXNotSupportedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (feature.equals(""validation/validate-content-models"")) {
                // REVISIT
                throw new SAXNotSupportedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (feature.equals(""validation/validate-datatypes"")) {
                // REVISIT
                throw new SAXNotSupportedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/warn-on-duplicate-attdef
            //   Emits an error when an attribute is redefined.
            //
            if (feature.equals(""validation/warn-on-duplicate-attdef"")) {
                setValidationWarnOnDuplicateAttdef(state);
                return;
            }
            //
            // http://apache.org/xml/features/validation/warn-on-undeclared-elemdef
            //   Emits an error when an element's content model
            //   references an element, by name, that is not declared
            //   in the grammar.
            //
            if (feature.equals(""validation/warn-on-undeclared-elemdef"")) {
                setValidationWarnOnUndeclaredElemdef(state);
                return;
            }
            //
            // http://apache.org/xml/features/allow-java-encodings
            //   Allows the use of Java encoding names in the XML
            //   and TextDecl lines.
            //
            if (feature.equals(""allow-java-encodings"")) {
                setAllowJavaEncodings(state);
                return;
            }
            //
            // http://apache.org/xml/features/continue-after-fatal-error
            //   Allows the parser to continue after a fatal error.
            //   Normally, a fatal error would stop the parse.
            //
            if (feature.equals(""continue-after-fatal-error"")) {
                setContinueAfterFatalError(state);
                return;
            }
            //
            // Not recognized
            //
        }

        //
        // Not recognized
        //

        throw new SAXNotRecognizedException(featureId);

    } // setFeature(String,boolean)

    /**
     * Query the state of a feature.
     *
     * Query the current state of any feature in a SAX2 parser.  The
     * parser might not recognize the feature.
     *
     * @param featureId The unique identifier (URI) of the feature
     *                  being set.
     * @return The current state of the feature.
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested feature is not known.
     * @exception org.xml.sax.SAXException If there is any other
     *            problem fulfilling the request.
     */
    public boolean getFeature(String featureId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Features
        //

        if (featureId.startsWith(SAX2_FEATURES_PREFIX)) {
            String feature = featureId.substring(SAX2_FEATURES_PREFIX.length());
            //
            // http://xml.org/sax/features/validation
            //   Validate (true) or don't validate (false).
            //
            if (feature.equals(""validation"")) {
                return getValidation();
            }
            //
            // http://xml.org/sax/features/external-general-entities
            //   Expand external general entities (true) or don't expand (false).
            //
            if (feature.equals(""external-general-entities"")) {
                return getExternalGeneralEntities();
            }
            //
            // http://xml.org/sax/features/external-parameter-entities
            //   Expand external parameter entities (true) or don't expand (false).
            //
            if (feature.equals(""external-parameter-entities"")) {
                return getExternalParameterEntities();
            }
            //
            // http://xml.org/sax/features/namespaces
            //   Preprocess namespaces (true) or don't preprocess (false).  See also
            //   the http://xml.org/sax/properties/namespace-sep property.
            //
            if (feature.equals(""namespaces"")) {
                return getNamespaces();
            }
            //
            // Not recognized
            //
        }

        //
        // Xerces Features
        //

        else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) {
            String feature = featureId.substring(XERCES_FEATURES_PREFIX.length());
            //
            // http://apache.org/xml/features/validation/dynamic
            //   Allows the parser to validate a document only when it
            //   contains a grammar. Validation is turned on/off based
            //   on each document instance, automatically.
            //
            if (feature.equals(""validation/dynamic"")) {
                return getValidationDynamic();
            }
            //
            // http://apache.org/xml/features/validation/default-attribute-values
            //
            if (feature.equals(""validation/default-attribute-values"")) {
                // REVISIT
                throw new SAXNotRecognizedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/validate-content-models
            //
            if (feature.equals(""validation/validate-content-models"")) {
                // REVISIT
                throw new SAXNotRecognizedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/validate-datatypes
            //
            if (feature.equals(""validation/validate-datatypes"")) {
                // REVISIT
                throw new SAXNotRecognizedException(featureId);
            }
            //
            // http://apache.org/xml/features/validation/warn-on-duplicate-attdef
            //   Emits an error when an attribute is redefined.
            //
            if (feature.equals(""validation/warn-on-duplicate-attdef"")) {
                return getValidationWarnOnDuplicateAttdef();
            }
            //
            // http://apache.org/xml/features/validation/warn-on-undeclared-elemdef
            //   Emits an error when an element's content model
            //   references an element, by name, that is not declared
            //   in the grammar.
            //
            if (feature.equals(""validation/warn-on-undeclared-elemdef"")) {
                return getValidationWarnOnUndeclaredElemdef();
            }
            //
            // http://apache.org/xml/features/allow-java-encodings
            //   Allows the use of Java encoding names in the XML
            //   and TextDecl lines.
            //
            if (feature.equals(""allow-java-encodings"")) {
                return getAllowJavaEncodings();
            }
            //
            // http://apache.org/xml/features/continue-after-fatal-error
            //   Allows the parser to continue after a fatal error.
            //   Normally, a fatal error would stop the parse.
            //
            if (feature.equals(""continue-after-fatal-error"")) {
                return getContinueAfterFatalError();
            }
            //
            // Not recognized
            //
        }

        //
        // Not recognized
        //

        throw new SAXNotRecognizedException(featureId);

    } // getFeature(String):boolean

    /**
     * Set the value of a property.
     *
     * Set the value of any property in a SAX2 parser.  The parser
     * might not recognize the property, and if it does recognize
     * it, it might not support the requested value.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     * @param Object The value to which the property is being set.
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested property is not known.
     * @exception org.xml.sax.SAXNotSupportedException If the
     *            requested property is known, but the requested
     *            value is not supported.
     * @exception org.xml.sax.SAXException If there is any other
     *            problem fulfilling the request.
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Properties
        //

        if (propertyId.startsWith(SAX2_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(SAX2_PROPERTIES_PREFIX.length());
            //
            // http://xml.org/sax/properties/namespace-sep
            // Value type: String
            // Access: read/write, pre-parse only
            //   Set the separator to be used between the URI part of a name and the
            //   local part of a name when namespace processing is being performed
            //   (see the http://xml.org/sax/features/namespaces feature).  By
            //   default, the separator is a single space.  This property may not be
            //   set while a parse is in progress (throws a SAXNotSupportedException).
            //
            /***
            if (property.equals(""namespace-sep"")) {
                try {
                    setNamespaceSep((String)value);
                }
                catch (ClassCastException e) {
                    throw new SAXNotSupportedException(propertyId);
                }
                return;
            }
            /***/
            
            //
            // http://xml.org/sax/properties/xml-string
            // Value type: String
            // Access: read-only
            //   Get the literal string of characters associated with the current
            //   event.  If the parser recognises and supports this property but is
            //   not currently parsing text, it should return null (this is a good
            //   way to check for availability before the parse begins).
            //
            if (property.equals(""xml-string"")) {
                // REVISIT - we should probably ask xml-dev for a precise definition
                // of what this is actually supposed to return, and in exactly which
                // circumstances.
                throw new SAXNotSupportedException(propertyId);
            }
            //
            // Not recognized
            //
        }

        //
        // Xerces Properties
        //

        /*
        else if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            //
            // No properties defined yet that are common to all parsers.
            //
        }
        */

        //
        // Not recognized
        //

        throw new SAXNotRecognizedException(propertyId);

    } // setProperty(String,Object)

    /**
     * Query the value of a property.
     *
     * Return the current value of a property in a SAX2 parser.
     * The parser might not recognize the property.
     *
     * @param propertyId The unique identifier (URI) of the property
     *                   being set.
     * @return The current value of the property.
     * @exception org.xml.sax.SAXNotRecognizedException If the
     *            requested property is not known.
     * @exception org.xml.sax.SAXException If there is any other
     *            problem fulfilling the request.
     * @see org.xml.sax.XMLReader#getProperty
     */
    public Object getProperty(String propertyId) 
        throws SAXNotRecognizedException, SAXNotSupportedException {

        //
        // SAX2 Properties
        //

        if (propertyId.startsWith(SAX2_PROPERTIES_PREFIX)) {
            String property = propertyId.substring(SAX2_PROPERTIES_PREFIX.length());
            //
            // http://xml.org/sax/properties/namespace-sep
            // Value type: String
            // Access: read/write, pre-parse only
            //   Set the separator to be used between the URI part of a name and the
            //   local part of a name when namespace processing is being performed
            //   (see the http://xml.org/sax/features/namespaces feature).  By
            //   default, the separator is a single space.  This property may not be
            //   set while a parse is in progress (throws a SAXNotSupportedException).
            //
            /***
            if (property.equals(""namespace-sep"")) {
                return getNamespaceSep();
            }
            /***/
            //
            // http://xml.org/sax/properties/xml-string
            // Value type: String
            // Access: read-only
            //   Get the literal string of characters associated with the current
            //   event.  If the parser recognises and supports this property but is
            //   not currently parsing text, it should return null (this is a good
            //   way to check for availability before the parse begins).
            //
            if (property.equals(""xml-string"")) {
                return getXMLString();
            }
            //
            // Not recognized
            //
        }

        //
        // Xerces Properties
        //

        /*
        else if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) {
            //
            // No properties defined yet that are common to all parsers.
            //
        }
        */

        //
        // Not recognized
        //

        throw new SAXNotRecognizedException(propertyId);

    } // getProperty(String):Object

}
"
org/apache/xerces/dom/DeferredNode.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.Node;

/** 
 * An interface for deferred node object. 
 *
 * @version
 */
public interface DeferredNode extends Node {

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex();

} // interface DeferredNode
"
org/xml/sax/DocumentHandler.java,true,"// SAX document handler.
// No warranty; no copyright -- use this as you will.
// $Id: DocumentHandler.java,v 1.4 2000/05/05 17:46:11 david Exp $

package org.xml.sax;

/**
 * Receive notification of general document events.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>This was the main event-handling interface for SAX1; in
 * SAX2, it has been replaced by {@link org.xml.sax.ContentHandler
 * ContentHandler}, which provides Namespace support and reporting
 * of skipped entities.  This interface is included in SAX2 only
 * to support legacy SAX1 applications.</p>
 *
 * <p>The order of events in this interface is very important, and
 * mirrors the order of information in the document itself.  For
 * example, all of an element's content (character data, processing
 * instructions, and/or subelements) will appear, in order, between
 * the startElement event and the corresponding endElement event.</p>
 *
 * <p>Application writers who do not want to implement the entire
 * interface can derive a class from HandlerBase, which implements
 * the default functionality; parser writers can instantiate
 * HandlerBase to obtain a default handler.  The application can find
 * the location of any document event using the Locator interface
 * supplied by the Parser through the setDocumentLocator method.</p>
 *
 * @deprecated This interface has been replaced by the SAX2
 *             {@link org.xml.sax.ContentHandler ContentHandler}
 *             interface, which includes Namespace support.
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser#setDocumentHandler
 * @see org.xml.sax.Locator
 * @see org.xml.sax.HandlerBase
 */
public interface DocumentHandler {
    
    
    /**
     * Receive an object for locating the origin of SAX document events.
     *
     * <p>SAX parsers are strongly encouraged (though not absolutely
     * required) to supply a locator: if it does so, it must supply
     * the locator to the application by invoking this method before
     * invoking any of the other methods in the DocumentHandler
     * interface.</p>
     *
     * <p>The locator allows the application to determine the end
     * position of any document-related event, even if the parser is
     * not reporting an error.  Typically, the application will
     * use this information for reporting its own errors (such as
     * character content that does not match an application's
     * business rules).  The information returned by the locator
     * is probably not sufficient for use with a search engine.</p>
     *
     * <p>Note that the locator will return correct information only
     * during the invocation of the events in this interface.  The
     * application should not attempt to use it at any other time.</p>
     *
     * @param locator An object that can return the location of
     *                any SAX document event.
     * @see org.xml.sax.Locator
     */
    public abstract void setDocumentLocator (Locator locator);
    
    
    /**
     * Receive notification of the beginning of a document.
     *
     * <p>The SAX parser will invoke this method only once, before any
     * other methods in this interface or in DTDHandler (except for
     * setDocumentLocator).</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public abstract void startDocument ()
	throws SAXException;
    
    
    /**
     * Receive notification of the end of a document.
     *
     * <p>The SAX parser will invoke this method only once, and it will
     * be the last method invoked during the parse.  The parser shall
     * not invoke this method until it has either abandoned parsing
     * (because of an unrecoverable error) or reached the end of
     * input.</p>
     *
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public abstract void endDocument ()
	throws SAXException;
    
    
    /**
     * Receive notification of the beginning of an element.
     *
     * <p>The Parser will invoke this method at the beginning of every
     * element in the XML document; there will be a corresponding
     * endElement() event for every startElement() event (even when the
     * element is empty). All of the element's content will be
     * reported, in order, before the corresponding endElement()
     * event.</p>
     *
     * <p>If the element name has a namespace prefix, the prefix will
     * still be attached.  Note that the attribute list provided will
     * contain only attributes with explicit values (specified or
     * defaulted): #IMPLIED attributes will be omitted.</p>
     *
     * @param name The element type name.
     * @param atts The attributes attached to the element, if any.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement
     * @see org.xml.sax.AttributeList 
     */
    public abstract void startElement (String name, AttributeList atts)
	throws SAXException;
    
    
    /**
     * Receive notification of the end of an element.
     *
     * <p>The SAX parser will invoke this method at the end of every
     * element in the XML document; there will be a corresponding
     * startElement() event for every endElement() event (even when the
     * element is empty).</p>
     *
     * <p>If the element name has a namespace prefix, the prefix will
     * still be attached to the name.</p>
     *
     * @param name The element type name
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public abstract void endElement (String name)
	throws SAXException;
    
    
    /**
     * Receive notification of character data.
     *
     * <p>The Parser will call this method to report each chunk of
     * character data.  SAX parsers may return all contiguous character
     * data in a single chunk, or they may split it into several
     * chunks; however, all of the characters in any single event
     * must come from the same external entity, so that the Locator
     * provides useful information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * <p>Note that some parsers will report whitespace using the
     * ignorableWhitespace() method rather than this one (validating
     * parsers must do so).</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #ignorableWhitespace 
     * @see org.xml.sax.Locator
     */
    public abstract void characters (char ch[], int start, int length)
	throws SAXException;
    
    
    /**
     * Receive notification of ignorable whitespace in element content.
     *
     * <p>Validating Parsers must use this method to report each chunk
     * of ignorable whitespace (see the W3C XML 1.0 recommendation,
     * section 2.10): non-validating parsers may also use this method
     * if they are capable of parsing and using content models.</p>
     *
     * <p>SAX parsers may return all contiguous whitespace in a single
     * chunk, or they may split it into several chunks; however, all of
     * the characters in any single event must come from the same
     * external entity, so that the Locator provides useful
     * information.</p>
     *
     * <p>The application must not attempt to read from the array
     * outside of the specified range.</p>
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param length The number of characters to read from the array.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #characters
     */
    public abstract void ignorableWhitespace (char ch[], int start, int length)
	throws SAXException;
    
    
    /**
     * Receive notification of a processing instruction.
     *
     * <p>The Parser will invoke this method once for each processing
     * instruction found: note that processing instructions may occur
     * before or after the main document element.</p>
     *
     * <p>A SAX parser should never report an XML declaration (XML 1.0,
     * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
     * using this method.</p>
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if
     *        none was supplied.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public abstract void processingInstruction (String target, String data)
	throws SAXException;
    
}

// end of DocumentHandler.java
"
org/apache/xerces/dom/DeferredNotationImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.apache.xerces.utils.StringPool;

import org.w3c.dom.*;

/**
 * Notations are how the Document Type Description (DTD) records hints
 * about the format of an XML ""unparsed entity"" -- in other words,
 * non-XML data bound to this document type, which some applications
 * may wish to consult when manipulating the document. A Notation
 * represents a name-value pair, with its nodeName being set to the
 * declared name of the notation.
 * <P>
 * Notations are also used to formally declare the ""targets"" of
 * Processing Instructions.
 * <P>
 * Note that the Notation's data is non-DOM information; the DOM only
 * records what and where it is.
 * <P>
 * See the XML 1.0 spec, sections 4.7 and 2.6, for more info.
 * <P>
 * Level 1 of the DOM does not support editing Notation contents.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredNotationImpl
    extends NotationImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 5705337172887990848L;

    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredNotationImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);

        fNodeIndex = nodeIndex;
        syncData(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /**
     * Synchronizes the data. This is special because of the way
     * that the ""fast"" notation stores its information internally.
     */
    protected void synchronizeData() {

        // no need to synchronize again
        syncData(false);

        // name
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument();
        name = ownerDocument.getNodeNameString(fNodeIndex);

        // public and system ids
        StringPool pool = ownerDocument.getStringPool();
        int extraDataIndex = ownerDocument.getNodeValue(fNodeIndex);
        ownerDocument.getNodeType(extraDataIndex);
        publicId = pool.toString(ownerDocument.getNodeName(extraDataIndex));
        systemId = pool.toString(ownerDocument.getNodeValue(extraDataIndex));

    } // synchronizeData()

} // class DeferredNotationImpl
"
org/apache/xerces/dom/DeferredDocumentImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import java.util.Vector;

import org.apache.xerces.framework.XMLAttrList;
import org.apache.xerces.utils.StringPool;

import org.w3c.dom.*;

/**
 * The Document interface represents the entire HTML or XML document.
 * Conceptually, it is the root of the document tree, and provides the
 * primary access to the document's data.
 * <P>
 * Since elements, text nodes, comments, processing instructions,
 * etc. cannot exist outside the context of a Document, the Document
 * interface also contains the factory methods needed to create these
 * objects. The Node objects created have a ownerDocument attribute
 * which associates them with the Document within whose context they
 * were created.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DeferredDocumentImpl
    extends DocumentImpl
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 5186323580749626857L;

    // debugging

    /** To include code for printing the ref count tables. */
    private static final boolean DEBUG_PRINT_REF_COUNTS = false;

    /** To include code for printing the internal tables. */
    private static final boolean DEBUG_PRINT_TABLES = false;

    /** To debug identifiers set to true and recompile. */
    private static final boolean DEBUG_IDS = false;

    // protected

    /** Chunk shift. */
    protected static final int CHUNK_SHIFT = 11;           // 2^11 = 2k

    /** Chunk size. */
    protected static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);

    /** Chunk mask. */
    protected static final int CHUNK_MASK = CHUNK_SIZE - 1;

    /** Initial chunk size. */
    protected static final int INITIAL_CHUNK_COUNT = (1 << (16 - CHUNK_SHIFT));   // 2^16 = 64k

    //
    // Data
    //

    // lazy-eval information

    /** Node count. */
    protected transient int fNodeCount = 0;

    /** Node types. */
    protected transient int fNodeType[][];

    /** Node names. */
    protected transient int fNodeName[][];

    /** Node values. */
    protected transient int fNodeValue[][];

    /** Node parents. */
    protected transient int fNodeParent[][];

    /** Node first children. */
    protected transient int fNodeLastChild[][];

    /** Node prev siblings. */
    protected transient int fNodePrevSib[][];

    /** Node namespace URI. */
    protected transient int fNodeURI[][];

    /** Identifier count. */
    protected transient int fIdCount;

    /** Identifier name indexes. */
    protected transient int fIdName[];

    /** Identifier element indexes. */
    protected transient int fIdElement[];

    /** String pool cache. */
    protected transient StringPool fStringPool;

	/** DOM2: For namespace support in the deferred case.
	 */
	// Implementation Note: The deferred element and attribute must know how to
	// interpret the int representing the qname.
    protected boolean fNamespacesEnabled = false;

    //
    // Constructors
    //

    /**
     * NON-DOM: Actually creating a Document is outside the DOM's spec,
     * since it has to operate in terms of a particular implementation.
     */
    public DeferredDocumentImpl(StringPool stringPool) {
        this(stringPool, false);
    } // <init>(ParserState)

    /**
     * NON-DOM: Actually creating a Document is outside the DOM's spec,
     * since it has to operate in terms of a particular implementation.
     */
    public DeferredDocumentImpl(StringPool stringPool, boolean namespacesEnabled) {
        this(stringPool, namespacesEnabled, false);
    } // <init>(ParserState,boolean)

    /** Experimental constructor. */
    public DeferredDocumentImpl(StringPool stringPool,
                                boolean namespaces, boolean grammarAccess) {
        super(grammarAccess);

        fStringPool = stringPool;

        syncData(true);
        syncChildren(true);

        fNamespacesEnabled = namespaces;

    } // <init>(StringPool,boolean,boolean)

    //
    // Public methods
    //

    /** Returns the cached parser.getNamespaces() value.*/
    boolean getNamespacesEnabled() {
        return fNamespacesEnabled;
    }

    // internal factory methods

    /** Creates a document node in the table. */
    public int createDocument() {
        int nodeIndex = createNode(Node.DOCUMENT_NODE);
        return nodeIndex;
    }

    /** Creates a doctype. */
    public int createDocumentType(int rootElementNameIndex, int publicId, int systemId) {

        // create node
        int nodeIndex = createNode(Node.DOCUMENT_TYPE_NODE);
        int chunk     = nodeIndex >> CHUNK_SHIFT;
        int index     = nodeIndex & CHUNK_MASK;

        // added for DOM2: createDoctype factory method includes
        // name, publicID, systemID

        // create extra data node
        int extraDataIndex = createNode((short)0); // node type unimportant
        int echunk = extraDataIndex >> CHUNK_SHIFT;
        int eindex = extraDataIndex & CHUNK_MASK;

        // save name, public id, system id
        setChunkIndex(fNodeName, rootElementNameIndex, chunk, index);
        setChunkIndex(fNodeValue, extraDataIndex, chunk, index);
        setChunkIndex(fNodeName, publicId, echunk, eindex);
        setChunkIndex(fNodeValue, systemId, echunk, eindex);

        // return node index
        return nodeIndex;
        
    } // createDocumentType(int,int,int):int
    
    public void setInternalSubset(int doctypeIndex, int subsetIndex) {
        int chunk     = doctypeIndex >> CHUNK_SHIFT;
        int index     = doctypeIndex & CHUNK_MASK;
        int extraDataIndex = fNodeValue[chunk][index];
        int echunk = extraDataIndex >> CHUNK_SHIFT;
        int eindex = extraDataIndex & CHUNK_MASK;
        fNodeLastChild[echunk][eindex]  = subsetIndex;
    }

    /** Creates a notation in the table. */
    public int createNotation(int notationName, int publicId, int systemId) throws Exception {

        // create node
        int nodeIndex = createNode(Node.NOTATION_NODE);
        int chunk     = nodeIndex >> CHUNK_SHIFT;
        int index     = nodeIndex & CHUNK_MASK;

        // create extra data node
        int extraDataIndex = createNode((short)0); // node type unimportant
        int echunk = extraDataIndex >> CHUNK_SHIFT;
        int eindex = extraDataIndex & CHUNK_MASK;

        // save name, public id, system id, and notation name
        setChunkIndex(fNodeName, notationName, chunk, index);
        setChunkIndex(fNodeValue, extraDataIndex, chunk, index);
        setChunkIndex(fNodeName, publicId, echunk, eindex);
        setChunkIndex(fNodeValue, systemId, echunk, eindex);

        // return node index
        return nodeIndex;

    } // createNotation(int,int,int):int

    /** Creates an entity in the table. */
    public int createEntity(int entityName, int publicId, int systemId, int notationName) throws Exception {

        // create node
        int nodeIndex = createNode(Node.ENTITY_NODE);
        int chunk     = nodeIndex >> CHUNK_SHIFT;
        int index     = nodeIndex & CHUNK_MASK;

        // create extra data node
        int extraDataIndex = createNode((short)0); // node type unimportant
        int echunk = extraDataIndex >> CHUNK_SHIFT;
        int eindex = extraDataIndex & CHUNK_MASK;

        // save name, public id, system id, and notation name
        setChunkIndex(fNodeName, entityName, chunk, index);
        setChunkIndex(fNodeValue, extraDataIndex, chunk, index);
        setChunkIndex(fNodeName, publicId, echunk, eindex);
        setChunkIndex(fNodeValue, systemId, echunk, eindex);
        setChunkIndex(fNodeLastChild, notationName, echunk, eindex);

        // return node index
        return nodeIndex;

    } // createEntity(int,int,int,int):int

    /** Creates an entity reference node in the table. */
    public int createEntityReference(int nameIndex) throws Exception {

        // create node
        int nodeIndex = createNode(Node.ENTITY_REFERENCE_NODE);
        int chunk     = nodeIndex >> CHUNK_SHIFT;
        int index     = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeName, nameIndex, chunk, index);

        // return node index
        return nodeIndex;

    } // createEntityReference(int):int

    /** Creates an element node in the table. */
    public int createElement(int elementNameIndex,
                             XMLAttrList attrList, int attrListIndex) {
        return createElement(elementNameIndex, -1, attrList, attrListIndex);
    }

    /** Creates an element node with a URI in the table. */
    public int createElement(int elementNameIndex, int elementURIIndex,
                             XMLAttrList attrList, int attrListIndex) {

        // create node
        int elementNodeIndex = createNode(Node.ELEMENT_NODE);
        int elementChunk     = elementNodeIndex >> CHUNK_SHIFT;
        int elementIndex     = elementNodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeName, elementNameIndex, elementChunk, elementIndex);
        setChunkIndex(fNodeURI, elementURIIndex, elementChunk, elementIndex);

        // create attributes
        if (attrListIndex != -1) {
            int first = attrList.getFirstAttr(attrListIndex);
            int lastAttrNodeIndex = -1;
            int lastAttrChunk = -1;
            int lastAttrIndex = -1;
            for (int index = first;
                 index != -1;
                 index = attrList.getNextAttr(index)) {

                // create attribute
                int attrNodeIndex =
                    createAttribute(attrList.getAttrName(index),
                                    attrList.getAttrURI(index),
                                    attrList.getAttValue(index),
                                    attrList.isSpecified(index));
                int attrChunk = attrNodeIndex >> CHUNK_SHIFT;
                int attrIndex  = attrNodeIndex & CHUNK_MASK;
                setChunkIndex(fNodeParent, elementNodeIndex, attrChunk, attrIndex);

                // add links
                if (index == first) {
                    setChunkIndex(fNodeValue, attrNodeIndex, elementChunk, elementIndex);
                }
                else {
                    setChunkIndex(fNodePrevSib, attrNodeIndex, lastAttrChunk, lastAttrIndex);
                }

                // save last chunk and index
                lastAttrNodeIndex = attrNodeIndex;
                lastAttrChunk     = attrChunk;
                lastAttrIndex     = attrIndex;
            }
        }

        // return node index
        return elementNodeIndex;

    } // createElement(int,XMLAttrList,int):int

    /** Creates an attribute in the table. */
    public int createAttribute(int attrNameIndex,
                               int attrValueIndex, boolean specified) {
        return createAttribute(attrNameIndex, -1, attrValueIndex, specified);
    }

    /** Creates an attribute with a URI in the table. */
    public int createAttribute(int attrNameIndex, int attrURIIndex,
                               int attrValueIndex, boolean specified) {

        // create node
        int nodeIndex = createNode(NodeImpl.ATTRIBUTE_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeName, attrNameIndex, chunk, index);
        setChunkIndex(fNodeURI, attrURIIndex, chunk, index);
        setChunkIndex(fNodeValue, specified ? 1 : 0, chunk, index);

        // append value as text node
        int textNodeIndex = createTextNode(attrValueIndex, false);
        appendChild(nodeIndex, textNodeIndex);

        // return node index
        return nodeIndex;

    } // createAttribute(int,int,boolean):int

    /** Creates an element definition in the table. */
    public int createElementDefinition(int elementNameIndex) {

        // create node
        int nodeIndex = createNode(NodeImpl.ELEMENT_DEFINITION_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeName, elementNameIndex, chunk, index);

        // return node index
        return nodeIndex;

    } // createElementDefinition(int):int

    /** Creates a text node in the table. */
    public int createTextNode(int dataIndex, boolean ignorableWhitespace) {

        // create node
        int nodeIndex = createNode(Node.TEXT_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeValue, dataIndex, chunk, index);
        // use last child to store ignorableWhitespace info
        setChunkIndex(fNodeLastChild,
                      ignorableWhitespace ?  1 : 0, chunk, index);

        // return node index
        return nodeIndex;

    } // createTextNode(int,boolean):int

    /** Creates a CDATA section node in the table. */
    public int createCDATASection(int dataIndex, boolean ignorableWhitespace) {

        // create node
        int nodeIndex = createNode(Node.CDATA_SECTION_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeValue, dataIndex, chunk, index);
        // use last child to store ignorableWhitespace info
        setChunkIndex(fNodeLastChild,
                      ignorableWhitespace ?  1 : 0, chunk, index);

        // return node index
        return nodeIndex;

    } // createCDATASection(int,boolean):int

    /** Creates a processing instruction node in the table. */
    public int createProcessingInstruction(int targetIndex, int dataIndex) {

        // create node
        int nodeIndex = createNode(Node.PROCESSING_INSTRUCTION_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeName, targetIndex, chunk, index);
        setChunkIndex(fNodeValue, dataIndex, chunk, index);

        // return node index
        return nodeIndex;

    } // createProcessingInstruction(int,int):int

    /** Creates a comment node in the table. */
    public int createComment(int dataIndex) {

        // create node
        int nodeIndex = createNode(Node.COMMENT_NODE);
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        setChunkIndex(fNodeValue, dataIndex, chunk, index);

        // return node index
        return nodeIndex;

    } // createComment(int):int

    /** Appends a child to the specified parent in the table. */
    public void appendChild(int parentIndex, int childIndex) {

        // append parent index
        int pchunk = parentIndex >> CHUNK_SHIFT;
        int pindex = parentIndex & CHUNK_MASK;
        int cchunk = childIndex >> CHUNK_SHIFT;
        int cindex = childIndex & CHUNK_MASK;
        setChunkIndex(fNodeParent, parentIndex, cchunk, cindex);

        // set previous sibling of new child
        int olast = getChunkIndex(fNodeLastChild, pchunk, pindex);
        setChunkIndex(fNodePrevSib, olast, cchunk, cindex);

        // update parent's last child
        setChunkIndex(fNodeLastChild, childIndex, pchunk, pindex);


    } // appendChild(int,int)

    /** Adds an attribute node to the specified element. */
    public int setAttributeNode(int elemIndex, int attrIndex) {

        int echunk = elemIndex >> CHUNK_SHIFT;
        int eindex = elemIndex & CHUNK_MASK;
        int achunk = attrIndex >> CHUNK_SHIFT;
        int aindex = attrIndex & CHUNK_MASK;

        // see if this attribute is already here
        String attrName =
            fStringPool.toString(getChunkIndex(fNodeName, achunk, aindex));
        int oldAttrIndex = getChunkIndex(fNodeValue, echunk, eindex);
        int nextIndex = -1;
        int oachunk = -1;
        int oaindex = -1;
        while (oldAttrIndex != -1) {
            oachunk = oldAttrIndex >> CHUNK_SHIFT;
            oaindex = oldAttrIndex & CHUNK_MASK;
            String oldAttrName =
              fStringPool.toString(getChunkIndex(fNodeName, oachunk, oaindex));
            if (oldAttrName.equals(attrName)) {
                break;
            }
            nextIndex = oldAttrIndex;
            oldAttrIndex = getChunkIndex(fNodePrevSib, oachunk, oaindex);
        }

        // remove old attribute
        if (oldAttrIndex != -1) {

            // patch links
            int prevIndex = getChunkIndex(fNodePrevSib, oachunk, oaindex);
            if (nextIndex == -1) {
                setChunkIndex(fNodeValue, prevIndex, echunk, eindex);
            }
            else {
                int pchunk = nextIndex >> CHUNK_SHIFT;
                int pindex = nextIndex & CHUNK_MASK;
                setChunkIndex(fNodePrevSib, prevIndex, pchunk, pindex);
            }

            // remove connections to siblings
            clearChunkIndex(fNodeType, oachunk, oaindex);
            clearChunkIndex(fNodeName, oachunk, oaindex);
            clearChunkIndex(fNodeValue, oachunk, oaindex);
            clearChunkIndex(fNodeParent, oachunk, oaindex);
            clearChunkIndex(fNodePrevSib, oachunk, oaindex);
            int attrTextIndex =
                clearChunkIndex(fNodeLastChild, oachunk, oaindex);
            int atchunk = attrTextIndex >> CHUNK_SHIFT;
            int atindex = attrTextIndex & CHUNK_MASK;
            clearChunkIndex(fNodeType, atchunk, atindex);
            clearChunkIndex(fNodeValue, atchunk, atindex);
            clearChunkIndex(fNodeParent, atchunk, atindex);
            clearChunkIndex(fNodeLastChild, atchunk, atindex);
        }

        // add new attribute
        int prevIndex = getChunkIndex(fNodeValue, echunk, eindex);
        setChunkIndex(fNodeValue, attrIndex, echunk, eindex);
        setChunkIndex(fNodePrevSib, prevIndex, achunk, aindex);

        // return
        return oldAttrIndex;

    } // setAttributeNode(int,int):int

    /** Inserts a child before the specified node in the table. */
    public int insertBefore(int parentIndex, int newChildIndex, int refChildIndex) {

        if (refChildIndex == -1) {
            appendChild(parentIndex, newChildIndex);
            return newChildIndex;
        }

        int pchunk = parentIndex >> CHUNK_SHIFT;
        int pindex = parentIndex & CHUNK_MASK;
        int nchunk = newChildIndex >> CHUNK_SHIFT;
        int nindex = newChildIndex & CHUNK_MASK;
        int rchunk = refChildIndex >> CHUNK_SHIFT;
        int rindex = refChildIndex & CHUNK_MASK;

        // 1) if ref.prev != null then
        //      begin
        //        new.prev := ref.prev;
        //      end;
        int nextIndex = -1;
        int index = -1;
        for (index = getChunkIndex(fNodeLastChild, pchunk, pindex);
             index != -1;
             index = getChunkIndex(fNodePrevSib, index >> CHUNK_SHIFT, index & CHUNK_MASK)) {

            if (nextIndex == refChildIndex) {
                break;
            }
            nextIndex = index;
        }
        if (index != -1) {
            int ochunk = index >> CHUNK_SHIFT;
            int oindex = index & CHUNK_MASK;
            setChunkIndex(fNodePrevSib, newChildIndex, ochunk, oindex);
        }
        // 2) ref.prev := new;
        setChunkIndex(fNodePrevSib, refChildIndex, nchunk, nindex);

        return newChildIndex;

    } // insertBefore(int,int,int):int

    /** Sets the last child of the parentIndex to childIndex. */
    public void setAsLastChild(int parentIndex, int childIndex) {

        int pchunk = parentIndex >> CHUNK_SHIFT;
        int pindex = parentIndex & CHUNK_MASK;
        int chunk = childIndex >> CHUNK_SHIFT;
        int index = childIndex & CHUNK_MASK;
        setChunkIndex(fNodeLastChild, childIndex, pchunk, pindex);
    } // setAsLastChild(int,int)

    /** 
     * Returns the parent node of the given node. 
     * <em>Calling this method does not free the parent index.</em>
     */
    public int getParentNode(int nodeIndex) {
        return getParentNode(nodeIndex, false);
    }

    /** 
     * Returns the parent node of the given node. 
     * @param free True to free parent node.
     */
    public int getParentNode(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        return free ? clearChunkIndex(fNodeParent, chunk, index)
                    : getChunkIndex(fNodeParent, chunk, index);

    } // getParentNode(int):int

    /** Returns the last child of the given node. */
    public int getLastChild(int nodeIndex) {
        return getLastChild(nodeIndex, true);
    }

    /** 
     * Returns the last child of the given node. 
     * @param free True to free child index.
     */
    public int getLastChild(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        return free ? clearChunkIndex(fNodeLastChild, chunk, index)
                    : getChunkIndex(fNodeLastChild, chunk, index);

    } // getLastChild(int,boolean):int

    /** 
     * Returns the prev sibling of the given node.
     * This is post-normalization of Text Nodes.
     */
    public int getPrevSibling(int nodeIndex) {
        return getPrevSibling(nodeIndex, true);
    }

    /** 
     * Returns the prev sibling of the given node.
     * @param free True to free sibling index.
     */
    public int getPrevSibling(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        nodeIndex = free ? clearChunkIndex(fNodePrevSib, chunk, index)
                         : getChunkIndex(fNodePrevSib, chunk, index);

        while (nodeIndex != -1 && getChunkIndex(fNodeType, chunk, index) == Node.TEXT_NODE) {
            nodeIndex = getChunkIndex(fNodePrevSib, chunk, index);
            chunk = nodeIndex >> CHUNK_SHIFT;
            index = nodeIndex & CHUNK_MASK;
        }

        return nodeIndex;

    } // getPrevSibling(int,boolean):int

    /**
     * Returns the <i>real</i> prev sibling of the given node,
     * directly from the data structures. Used by TextImpl#getNodeValue()
     * to normalize values.
     */
    public int getRealPrevSibling(int nodeIndex) {
        return getRealPrevSibling(nodeIndex, true);
    }

    /**
     * Returns the <i>real</i> prev sibling of the given node.
     * @param free True to free sibling index.
     */
    public int getRealPrevSibling(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        return free ? clearChunkIndex(fNodePrevSib, chunk, index)
                    : getChunkIndex(fNodePrevSib, chunk, index);

    } // getReadPrevSibling(int,boolean):int

    /**
     * Returns the index of the element definition in the table
     * with the specified name index, or -1 if no such definition
     * exists.
     */
    public int lookupElementDefinition(int elementNameIndex) {

        if (fNodeCount > 1) {

            // find doctype
            int docTypeIndex = -1;
            int nchunk = 0;
            int nindex = 0;
            for (int index = getChunkIndex(fNodeLastChild, nchunk, nindex);
                 index != -1;
                 index = getChunkIndex(fNodePrevSib, nchunk, nindex)) {

                nchunk = index >> CHUNK_SHIFT;
                nindex = index  & CHUNK_MASK;
                if (getChunkIndex(fNodeType, nchunk, nindex) == Node.DOCUMENT_TYPE_NODE) {
                    docTypeIndex = index;
                    break;
                }
            }

            // find element definition
            if (docTypeIndex == -1) {
                return -1;
            }
            nchunk = docTypeIndex >> CHUNK_SHIFT;
            nindex = docTypeIndex & CHUNK_MASK;
            for (int index = getChunkIndex(fNodeLastChild, nchunk, nindex);
                 index != -1;
                 index = getChunkIndex(fNodePrevSib, nchunk, nindex)) {

                nchunk = index >> CHUNK_SHIFT;
                nindex = index & CHUNK_MASK;
                if (getChunkIndex(fNodeName, nchunk, nindex) == elementNameIndex) {
                    return index;
                }
            }
        }

        return -1;

    } // lookupElementDefinition(int):int

    /** Instantiates the requested node object. */
    public DeferredNode getNodeObject(int nodeIndex) {

        // is there anything to do?
        if (nodeIndex == -1) {
            return null;
        }

        // get node type
        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        int type = clearChunkIndex(fNodeType, chunk, index);

        // create new node
        DeferredNode node = null;
        switch (type) {

            //
            // Standard DOM node types
            //

            case Node.ATTRIBUTE_NODE: {
		if (fNamespacesEnabled) {
		    node = new DeferredAttrNSImpl(this, nodeIndex);
		} else {
		    node = new DeferredAttrImpl(this, nodeIndex);
		}
                break;
            }

            case Node.CDATA_SECTION_NODE: {
                node = new DeferredCDATASectionImpl(this, nodeIndex);
                break;
            }

            case Node.COMMENT_NODE: {
                node = new DeferredCommentImpl(this, nodeIndex);
                break;
            }

            // NOTE: Document fragments can never be ""fast"".
            //
            //       The parser will never ask to create a document
            //       fragment during the parse. Document fragments
            //       are used by the application *after* the parse.
            //
            // case Node.DOCUMENT_FRAGMENT_NODE: { break; }
            case Node.DOCUMENT_NODE: {
                // this node is never ""fast""
                node = this;
                break;
            }

            case Node.DOCUMENT_TYPE_NODE: {
                node = new DeferredDocumentTypeImpl(this, nodeIndex);
                // save the doctype node
                docType = (DocumentTypeImpl)node;
                break;
            }

            case Node.ELEMENT_NODE: {

                if (DEBUG_IDS) {
                    System.out.println(""getNodeObject(ELEMENT_NODE): ""+nodeIndex);
                }

                // create node
		if (fNamespacesEnabled) {
		    node = new DeferredElementNSImpl(this, nodeIndex);
		} else {
		    node = new DeferredElementImpl(this, nodeIndex);
		}

                // save the document element node
                if (docElement == null) {
                    docElement = (ElementImpl)node;
                }

                // check to see if this element needs to be
                // registered for its ID attributes
                if (fIdElement != null) {
                    int idIndex = DeferredDocumentImpl.binarySearch(fIdElement, 0, fIdCount-1, nodeIndex);
                    while (idIndex != -1) {

                        if (DEBUG_IDS) {
                            System.out.println(""  id index: ""+idIndex);
                            System.out.println(""  fIdName[""+idIndex+
                                               ""]: ""+fIdName[idIndex]);
                        }

                        // register ID
                        int nameIndex = fIdName[idIndex];
                        if (nameIndex != -1) {
                            String name = fStringPool.toString(nameIndex);
                            if (DEBUG_IDS) {
                                System.out.println(""  name: ""+name);
                                System.out.print(""getNodeObject()#"");
                            }
                            putIdentifier0(name, (Element)node);
                            fIdName[idIndex] = -1;
                        }

                        // continue if there are more IDs for
                        // this element
                        if (idIndex + 1 < fIdCount &&
                            fIdElement[idIndex + 1] == nodeIndex) {
                            idIndex++;
                        }
                        else {
                            idIndex = -1;
                        }
                    }
                }
                break;
            }

            case Node.ENTITY_NODE: {
                node = new DeferredEntityImpl(this, nodeIndex);
                break;
            }

            case Node.ENTITY_REFERENCE_NODE: {
                node = new DeferredEntityReferenceImpl(this, nodeIndex);
                break;
            }

            case Node.NOTATION_NODE: {
                node = new DeferredNotationImpl(this, nodeIndex);
                break;
            }

            case Node.PROCESSING_INSTRUCTION_NODE: {
                node = new DeferredProcessingInstructionImpl(this, nodeIndex);
                break;
            }

            case Node.TEXT_NODE: {
                node = new DeferredTextImpl(this, nodeIndex);
                break;
            }

            //
            // non-standard DOM node types
            //

            case NodeImpl.ELEMENT_DEFINITION_NODE: {
                node = new DeferredElementDefinitionImpl(this, nodeIndex);
                break;
            }

            default: {
                throw new IllegalArgumentException(""type: ""+type);
            }

        } // switch node type

        // store and return
        if (node != null) {
            return node;
        }

        // error
        throw new IllegalArgumentException();

    } // createNodeObject(int):Node

    /** Returns the name of the given node. */
    public String getNodeNameString(int nodeIndex) {
        return getNodeNameString(nodeIndex, true);
    } // getNodeNameString(int):String

    /** 
     * Returns the name of the given node. 
     * @param free True to free the string index.
     */
    public String getNodeNameString(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return null;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        int nameIndex = free 
                      ? clearChunkIndex(fNodeName, chunk, index)
                      : getChunkIndex(fNodeName, chunk, index);
        if (nameIndex == -1) {
            return null;
        }

        return fStringPool.toString(nameIndex);

    } // getNodeNameString(int,boolean):String

    /** Returns the value of the given node. */
    public String getNodeValueString(int nodeIndex) {
        return getNodeValueString(nodeIndex, true);
    } // getNodeValueString(int):String

    /** 
     * Returns the value of the given node. 
     * @param free True to free the string index.
     */
    public String getNodeValueString(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return null;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        int valueIndex = free
                       ? clearChunkIndex(fNodeValue, chunk, index)
                       : getChunkIndex(fNodeValue, chunk, index);
        if (valueIndex == -1) {
            return null;
        }

        return fStringPool.toString(valueIndex);

    } // getNodeValueString(int,boolean):String

    /** Returns the real int name of the given node. */
    public int getNodeName(int nodeIndex) {
        return getNodeName(nodeIndex, true);
    }

    /** 
     * Returns the real int name of the given node. 
     * @param free True to free the name index.
     */
    public int getNodeName(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        return free ? clearChunkIndex(fNodeName, chunk, index)
                    : getChunkIndex(fNodeName, chunk, index);

    } // getNodeName(int,boolean):int

    /**
     * Returns the real int value of the given node.
     *  Used by AttrImpl to store specified value (1 == true).
     */
    public int getNodeValue(int nodeIndex) {
        return getNodeValue(nodeIndex, true);
    }

    /**
     * Returns the real int value of the given node.
     * @param free True to free the value index. 
     */
    public int getNodeValue(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        return free ? clearChunkIndex(fNodeValue, chunk, index)
                    : getChunkIndex(fNodeValue, chunk, index);

    } // getNodeValue(int,boolean):int

    /** Returns the type of the given node. */
    public short getNodeType(int nodeIndex) {
        return getNodeType(nodeIndex, true);
    }

    /** 
     * Returns the type of the given node. 
     * @param True to free type index.
     */
    public short getNodeType(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        if (free) {
            return (short)clearChunkIndex(fNodeType, chunk, index);
        }
        return (short)getChunkIndex(fNodeType, chunk, index);

    } // getNodeType(int):int

    /** Returns the URI of the given node. */
    public short getNodeURI(int nodeIndex) {
        return getNodeURI(nodeIndex, true);
    }

    /** 
     * Returns the URI of the given node. 
     * @param True to free URI index.
     */
    public short getNodeURI(int nodeIndex, boolean free) {

        if (nodeIndex == -1) {
            return -1;
        }

        int chunk = nodeIndex >> CHUNK_SHIFT;
        int index = nodeIndex & CHUNK_MASK;
        if (free) {
            return (short)clearChunkIndex(fNodeURI, chunk, index);
        }
        return (short)getChunkIndex(fNodeURI, chunk, index);

    } // getNodeURI(int):int

    // identifier maintenance

    /** Registers an identifier name with a specified element node. */
    public void putIdentifier(int nameIndex, int elementNodeIndex) {

        if (DEBUG_IDS) {
            System.out.println(""putIdentifier(""+nameIndex+"", ""+elementNodeIndex+')'+
                               "" // ""+
                               fStringPool.toString(nameIndex)+
                               "", ""+
                               fStringPool.toString(getChunkIndex(fNodeName, elementNodeIndex >> CHUNK_SHIFT, elementNodeIndex & CHUNK_MASK)));
        }

        // initialize arrays
        if (fIdName == null) {
            fIdName    = new int[64];
            fIdElement = new int[64];
        }

        // resize arrays
        if (fIdCount == fIdName.length) {
            int idName[] = new int[fIdCount * 2];
            System.arraycopy(fIdName, 0, idName, 0, fIdCount);
            fIdName = idName;

            int idElement[] = new int[idName.length];
            System.arraycopy(fIdElement, 0, idElement, 0, fIdCount);
            fIdElement = idElement;
        }

        // store identifier
        fIdName[fIdCount] = nameIndex;
        fIdElement[fIdCount] = elementNodeIndex;
        fIdCount++;

    } // putIdentifier(int,int)

    //
    // DEBUG
    //

    /** Prints out the tables. */
    public void print() {

        if (DEBUG_PRINT_REF_COUNTS) {
            System.out.print(""num\t"");
            System.out.print(""type\t"");
            System.out.print(""name\t"");
            System.out.print(""val\t"");
            System.out.print(""par\t"");
            System.out.print(""fch\t"");
            System.out.print(""nsib"");
            System.out.println();
            for (int i = 0; i < fNodeType.length; i++) {
                if (fNodeType[i] != null) {
                    // separator
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.print(""--------"");
                    System.out.println();

                    // set count
                    System.out.print(i);
                    System.out.print('\t');
                    System.out.print(fNodeType[i][CHUNK_SIZE]);
                    System.out.print('\t');
                    System.out.print(fNodeName[i][CHUNK_SIZE]);
                    System.out.print('\t');
                    System.out.print(fNodeValue[i][CHUNK_SIZE]);
                    System.out.print('\t');
                    System.out.print(fNodeParent[i][CHUNK_SIZE]);
                    System.out.print('\t');
                    System.out.print(fNodeLastChild[i][CHUNK_SIZE]);
                    System.out.print('\t');
                    System.out.print(fNodePrevSib[i][CHUNK_SIZE]);
                    System.out.println();

                    // clear count
                    System.out.print(i);
                    System.out.print('\t');
                    System.out.print(fNodeType[i][CHUNK_SIZE + 1]);
                    System.out.print('\t');
                    System.out.print(fNodeName[i][CHUNK_SIZE + 1]);
                    System.out.print('\t');
                    System.out.print(fNodeValue[i][CHUNK_SIZE + 1]);
                    System.out.print('\t');
                    System.out.print(fNodeParent[i][CHUNK_SIZE + 1]);
                    System.out.print('\t');
                    System.out.print(fNodeLastChild[i][CHUNK_SIZE + 1]);
                    System.out.print('\t');
                    System.out.print(fNodePrevSib[i][CHUNK_SIZE + 1]);
                    System.out.println();
                }
            }
        }

        if (DEBUG_PRINT_TABLES) {
            // This assumes that the document is small
            System.out.println(""# start table"");
            for (int i = 0; i < fNodeCount; i++) {
                int chunk = i >> CHUNK_SHIFT;
                int index = i & CHUNK_MASK;
                if (i % 10 == 0) {
                    System.out.print(""num\t"");
                    System.out.print(""type\t"");
                    System.out.print(""name\t"");
                    System.out.print(""val\t"");
                    System.out.print(""par\t"");
                    System.out.print(""fch\t"");
                    System.out.print(""nsib"");
                    System.out.println();
                }
                System.out.print(i);
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodeType, chunk, index));
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodeName, chunk, index));
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodeValue, chunk, index));
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodeParent, chunk, index));
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodeLastChild, chunk, index));
                System.out.print('\t');
                System.out.print(getChunkIndex(fNodePrevSib, chunk, index));
                /***
                System.out.print(fNodeType[0][i]);
                System.out.print('\t');
                System.out.print(fNodeName[0][i]);
                System.out.print('\t');
                System.out.print(fNodeValue[0][i]);
                System.out.print('\t');
                System.out.print(fNodeParent[0][i]);
                System.out.print('\t');
                System.out.print(fNodeFirstChild[0][i]);
                System.out.print('\t');
                System.out.print(fNodeLastChild[0][i]);
                System.out.print('\t');
                System.out.print(fNodePrevSib[0][i]);
                System.out.print('\t');
                System.out.print(fNodeNextSib[0][i]);
                /***/
                System.out.println();
            }
            System.out.println(""# end table"");
        }

    } // print()

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return 0;
    }

    //
    // Protected methods
    //

    /** access to string pool. */
    protected StringPool getStringPool() {
        return fStringPool;
    }

    /** Synchronizes the node's data. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff up enough nodes to fill identifiers hash
        if (fIdElement != null) {

            // REVISIT: There has to be a more efficient way of
            //          doing this. But keep in mind that the
            //          tree can have been altered and re-ordered
            //          before all of the element nodes with ID
            //          attributes have been registered. For now
            //          this is reasonable and safe. -Ac

            IntVector path = new IntVector();
            for (int i = 0; i < fIdCount; i++) {

                // ignore if it's already been registered
                int elementNodeIndex = fIdElement[i];
                int idNameIndex      = fIdName[i];
                if (idNameIndex == -1) {
                    continue;
                }

                // find path from this element to the root
                path.removeAllElements();
                int index = elementNodeIndex;
                do {
                    path.addElement(index);
                    int pchunk = index >> CHUNK_SHIFT;
                    int pindex = index & CHUNK_MASK;
                    index = getChunkIndex(fNodeParent, pchunk, pindex);
                } while (index != -1);

                // Traverse path (backwards), fluffing the elements
                // along the way. When this loop finishes, ""place""
                // will contain the reference to the element node
                // we're interested in. -Ac
                Node place = this;
                for (int j = path.size() - 2; j >= 0; j--) {
                    index = path.elementAt(j);
                    Node child = place.getLastChild();
                    while (child != null) {
                        if (child instanceof DeferredNode) {
                            int nodeIndex = ((DeferredNode)child).getNodeIndex();
                            if (nodeIndex == index) {
                                place = child;
                                break;
                            }
                        }
                        child = child.getPreviousSibling();
                    }
                }

                // register the element
                Element element = (Element)place;
                String  name    = fStringPool.toString(idNameIndex);
                putIdentifier0(name, element);
                fIdName[i] = -1;

                // see if there are more IDs on this element
                while (fIdElement[i + 1] == elementNodeIndex) {
                    name = fStringPool.toString(fIdName[++i]);
                    putIdentifier0(name, element);
                }
            }

        } // if identifiers

    } // synchronizeData()

    /**
     * Synchronizes the node's children with the internal structure.
     * Fluffing the children at once solves a lot of work to keep
     * the two structures in sync. The problem gets worse when
     * editing the tree -- this makes it a lot easier.
     */
    protected void synchronizeChildren() {

        if (syncData()) {
            synchronizeData();
            /*
             * when we have elements with IDs this method is being recursively
             * called from synchronizeData, in which case we've already gone
             * through the following and we can now simply stop here.
             */
            if (!syncChildren()) {
                return;
            }
        }

        // no need to sync in the future
        syncChildren(false);

        getNodeType(0);

        // create children and link them as siblings
        ChildNode first = null;
        ChildNode last = null;
        for (int index = getLastChild(0);
             index != -1;
             index = getPrevSibling(index)) {

            ChildNode node = (ChildNode)getNodeObject(index);
            if (last == null) {
                last = node;
            }
            else {
                first.previousSibling = node;
            }
            node.ownerNode = this;
            node.owned(true);
            node.nextSibling = first;
            first = node;

            // save doctype and document type
            int type = node.getNodeType();
            if (type == Node.ELEMENT_NODE) {
                docElement = (ElementImpl)node;
            }
            else if (type == Node.DOCUMENT_TYPE_NODE) {
                docType = (DocumentTypeImpl)node;
            }
        }

        if (first != null) {
            firstChild = first;
            first.firstChild(true);
            lastChild(last);
        }

    } // synchronizeChildren()

    // utility methods

    /** Ensures that the internal tables are large enough. */
    protected boolean ensureCapacity(int chunk, int index) {

        // create buffers
        if (fNodeType == null) {
            fNodeType       = new int[INITIAL_CHUNK_COUNT][];
            fNodeName       = new int[INITIAL_CHUNK_COUNT][];
            fNodeValue      = new int[INITIAL_CHUNK_COUNT][];
            fNodeParent     = new int[INITIAL_CHUNK_COUNT][];
            fNodeLastChild  = new int[INITIAL_CHUNK_COUNT][];
            fNodePrevSib    = new int[INITIAL_CHUNK_COUNT][];
            fNodeURI        = new int[INITIAL_CHUNK_COUNT][];
        }

        // return true if table is already big enough
        try {
            return fNodeType[chunk][index] != 0;
        }

        // resize the tables
        catch (ArrayIndexOutOfBoundsException ex) {
            int newsize = chunk * 2;

            int[][] newArray = new int[newsize][];
            System.arraycopy(fNodeType, 0, newArray, 0, chunk);
            fNodeType = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodeName, 0, newArray, 0, chunk);
            fNodeName = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodeValue, 0, newArray, 0, chunk);
            fNodeValue = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodeParent, 0, newArray, 0, chunk);
            fNodeParent = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodeLastChild, 0, newArray, 0, chunk);
            fNodeLastChild = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodePrevSib, 0, newArray, 0, chunk);
            fNodePrevSib = newArray;

            newArray = new int[newsize][];
            System.arraycopy(fNodeURI, 0, newArray, 0, chunk);
            fNodeURI = newArray;
        }

        catch (NullPointerException ex) {
            // ignore
        }

        // create chunks
        createChunk(fNodeType, chunk);
        createChunk(fNodeName, chunk);
        createChunk(fNodeValue, chunk);
        createChunk(fNodeParent, chunk);
        createChunk(fNodeLastChild, chunk);
        createChunk(fNodePrevSib, chunk);
        createChunk(fNodeURI, chunk);

        // success
        return true;

    } // ensureCapacity(int,int):boolean

    /** Creates a node of the specified type. */
    protected int createNode(short nodeType) {

        // ensure tables are large enough
        int chunk = fNodeCount >> CHUNK_SHIFT;
        int index = fNodeCount & CHUNK_MASK;
        ensureCapacity(chunk, index);

        // initialize node
        setChunkIndex(fNodeType, nodeType, chunk, index);

        // return node index number
        return fNodeCount++;

    } // createNode(short):int

    /**
     * Performs a binary search for a target value in an array of
     * values. The array of values must be in ascending sorted order
     * before calling this method and all array values must be
     * non-negative.
     *
     * @param values  The array of values to search.
     * @param start   The starting offset of the search.
     * @param end     The ending offset of the search.
     * @param target  The target value.
     *
     * @return This function will return the <i>first</i> occurrence
     *         of the target value, or -1 if the target value cannot
     *         be found.
     */
    protected static int binarySearch(final int values[],
                                      int start, int end, int target) {

        if (DEBUG_IDS) {
            System.out.println(""binarySearch(), target: ""+target);
        }

        // look for target value
        while (start <= end) {

            // is this the one we're looking for?
            int middle = (start + end) / 2;
            int value  = values[middle];
            if (DEBUG_IDS) {
                System.out.print(""  value: ""+value+"", target: ""+target+"" // "");
                print(values, start, end, middle, target);
            }
            if (value == target) {
                while (middle > 0 && values[middle - 1] == target) {
                    middle--;
                }
                if (DEBUG_IDS) {
                    System.out.println(""FOUND AT ""+middle);
                }
                return middle;
            }

            // is this point higher or lower?
            if (value > target) {
                end = middle - 1;
            }
            else {
                start = middle + 1;
            }

        } // while

        // not found
        if (DEBUG_IDS) {
            System.out.println(""NOT FOUND!"");
        }
        return -1;

    } // binarySearch(int[],int,int,int):int

    //
    // Private methods
    //

    /** Creates the specified chunk in the given array of chunks. */
    private final void createChunk(int data[][], int chunk) {
        data[chunk] = new int[CHUNK_SIZE + 2];
        for (int i = 0; i < CHUNK_SIZE; i++) {
            data[chunk][i] = -1;
        }
    }

    /**
     * Sets the specified value in the given of data at the chunk and index.
     *
     * @return Returns the old value.
     */
    private final int setChunkIndex(int data[][], int value, int chunk, int index) {
        if (value == -1) {
            return clearChunkIndex(data, chunk, index);
        }
        int ovalue = data[chunk][index];
        if (ovalue == -1) {
            data[chunk][CHUNK_SIZE]++;
        }
        data[chunk][index] = value;
        return ovalue;
    }

    /**
     * Returns the specified value in the given data at the chunk and index.
     */
    private final int getChunkIndex(int data[][], int chunk, int index) {
        return data[chunk] != null ? data[chunk][index] : -1;
    }

    /**
     * Clears the specified value in the given data at the chunk and index.
     * Note that this method will clear the given chunk if the reference
     * count becomes zero.
     *
     * @return Returns the old value.
     */
    private final int clearChunkIndex(int data[][], int chunk, int index) {
        int value = data[chunk] != null ? data[chunk][index] : -1;
        if (value != -1) {
            data[chunk][CHUNK_SIZE + 1]++;
            data[chunk][index] = -1;
            if (data[chunk][CHUNK_SIZE] == data[chunk][CHUNK_SIZE + 1]) {
                data[chunk] = null;
            }
        }
        return value;
    }

    /**
     * This version of putIdentifier is needed to avoid fluffing
     * all of the paths to ID attributes when a node object is
     * created that contains an ID attribute.
     */
    private final void putIdentifier0(String idName, Element element) {

        if (DEBUG_IDS) {
            System.out.println(""putIdentifier0(""+
                               idName+"", ""+
                               element+')');
        }

        // create hashtable
        if (identifiers == null) {
            identifiers = new java.util.Hashtable();
        }

        // save ID and its associated element
        identifiers.put(idName, element);

    } // putIdentifier0(String,Element)

    /** Prints the ID array. */
    private static void print(int values[], int start, int end,
                              int middle, int target) {

        if (DEBUG_IDS) {
            System.out.print(start);
            System.out.print("" ["");
            for (int i = start; i < end; i++) {
                if (middle == i) {
                    System.out.print(""!"");
                }
                System.out.print(values[i]);
                if (values[i] == target) {
                    System.out.print(""*"");
                }
                if (i < end - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""] ""+end);
        }

    } // print(int[],int,int,int,int)

    //
    // Classes
    //

    /**
     * A simple integer vector.
     */
    static class IntVector {

        //
        // Data
        //

        /** Data. */
        private int data[];

        /** Size. */
        private int size;

        //
        // Public methods
        //

        /** Returns the length of this vector. */
        public int size() {
            return size;
        }

        /** Returns the element at the specified index. */
        public int elementAt(int index) {
            return data[index];
        }

        /** Appends an element to the end of the vector. */
        public void addElement(int element) {
            ensureCapacity(size + 1);
            data[size++] = element;
        }

        /** Clears the vector. */
        public void removeAllElements() {
            size = 0;
        }

        //
        // Private methods
        //

        /** Makes sure that there is enough storage. */
        private void ensureCapacity(int newsize) {

            if (data == null) {
                data = new int[newsize + 15];
            }
            else if (newsize > data.length) {
                int newdata[] = new int[newsize + 15];
                System.arraycopy(data, 0, newdata, 0, data.length);
                data = newdata;
            }

        } // ensureCapacity(int)

    } // class IntVector

} // class DeferredDocumentImpl
"
org/apache/xerces/dom/DocumentTypeImpl.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * This class represents a Document Type <em>declaraction</em> in
 * the document itself, <em>not</em> a Document Type Definition (DTD).
 * An XML document may (or may not) have such a reference.
 * <P>
 * DocumentType is an Extended DOM feature, used in XML documents but
 * not in HTML.
 * <P>
 * Note that Entities and Notations are no longer children of the
 * DocumentType, but are parentless nodes hung only in their
 * appropriate NamedNodeMaps.
 * <P>
 * This area is UNDERSPECIFIED IN REC-DOM-Level-1-19981001
 * Most notably, absolutely no provision was made for storing
 * and using Element and Attribute information. Nor was the linkage
 * between Entities and Entity References nailed down solidly.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DocumentTypeImpl 
    extends ChildAndParentNode
    implements DocumentType {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 7751299192316526485L;
    
    //
    // Data
    //

    /** Document type name. */
    protected String name;

    /** Entities. */
    protected NamedNodeMapImpl entities;
    
    /** Notations. */
    protected NamedNodeMapImpl notations;

    // NON-DOM

    /** Elements. */
    protected NamedNodeMapImpl elements;
    
    // DOM2: support public ID.
    protected String publicID;
    
    // DOM2: support system ID.
    protected String systemID;
    
    // DOM2: support internal subset.
    protected String internalSubset;

    //
    // Constructors
    //

    /** Factory method for creating a document type node. */
    public DocumentTypeImpl(DocumentImpl ownerDocument, String name) {
        super(ownerDocument);

        this.name = name;
        // DOM
        entities  = new NamedNodeMapImpl(this, null);
        notations = new NamedNodeMapImpl(this, null);

        // NON-DOM
        elements = new NamedNodeMapImpl(this,null);

    } // <init>(DocumentImpl,String)
  
    /** Factory method for creating a document type node. */
    public DocumentTypeImpl(DocumentImpl ownerDocument, String qualifiedName, 
                            String publicID, String systemID) {
        this(ownerDocument, qualifiedName);
        this.publicID = publicID;
        this.systemID = systemID;

    } // <init>(DocumentImpl,String)
    
    //
    // DOM2: methods.
    //
    
    /**
     * Introduced in DOM Level 2. <p>
     * 
     * Return the public identifier of this Document type.
     * @since WD-DOM-Level-2-19990923
     */
    public String getPublicId() {
        if (syncData()) {
            synchronizeData();
        }
        return publicID;
    }
    /**
     * Introduced in DOM Level 2. <p>
     * 
     * Return the system identifier of this Document type.
     * @since WD-DOM-Level-2-19990923
     */
    public String getSystemId() {
        if (syncData()) {
            synchronizeData();
        }
        return systemID;
    }
    
    /**
     * NON-DOM. <p>
     *
     * Set the internalSubset given as a string.
     */
    public void setInternalSubset(String internalSubset) {
        if (syncData()) {
            synchronizeData();
        }
        this.internalSubset = internalSubset;
    }

    /**
     * Introduced in DOM Level 2. <p>
     * 
     * Return the internalSubset given as a string.
     * @since WD-DOM-Level-2-19990923
     */
    public String getInternalSubset() {
        if (syncData()) {
            synchronizeData();
        }
        return internalSubset;
    }
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.DOCUMENT_TYPE_NODE;
    }
    
    /**
     * Returns the document type name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    /** Clones the node. */
    public Node cloneNode(boolean deep) {

    	DocumentTypeImpl newnode = (DocumentTypeImpl)super.cloneNode(deep);
    	// NamedNodeMaps must be cloned explicitly, to avoid sharing them.
    	newnode.entities  = entities.cloneMap(newnode);
    	newnode.notations = notations.cloneMap(newnode);
    	newnode.elements  = elements.cloneMap(newnode);

    	return newnode;

    } // cloneNode(boolean):Node

    /**
     * NON-DOM
     * set the ownerDocument of this node and its children
     */
    void setOwnerDocument(DocumentImpl doc) {
        super.setOwnerDocument(doc);
        entities.setOwnerDocument(doc);
        notations.setOwnerDocument(doc);
        elements.setOwnerDocument(doc);
    }

    //
    // DocumentType methods
    //

    /**
     * Name of this document type. If we loaded from a DTD, this should
     * be the name immediately following the DOCTYPE keyword.
     */
    public String getName() {

        if (syncData()) {
            synchronizeData();
        }
    	return name;

    } // getName():String

    /**
     * Access the collection of general Entities, both external and
     * internal, defined in the DTD. For example, in:
     * <p>
     * <pre>
     *   &lt;!doctype example SYSTEM ""ex.dtd"" [
     *     &lt;!ENTITY foo ""foo""&gt;
     *     &lt;!ENTITY bar ""bar""&gt;
     *     &lt;!ENTITY % baz ""baz""&gt;
     *     ]&gt;
     * </pre>
     * <p>
     * The Entities map includes foo and bar, but not baz. It is promised that
     * only Nodes which are Entities will exist in this NamedNodeMap.
     * <p>
     * For HTML, this will always be null.
     * <p>
     * Note that ""built in"" entities such as &amp; and &lt; should be
     * converted to their actual characters before being placed in the DOM's
     * contained text, and should be converted back when the DOM is rendered
     * as XML or HTML, and hence DO NOT appear here.
     */
    public NamedNodeMap getEntities() {
        if (syncChildren()) {
            synchronizeChildren();
            }
    	return entities;
    }

    /**
     * Access the collection of Notations defined in the DTD.  A
     * notation declares, by name, the format of an XML unparsed entity
     * or is used to formally declare a Processing Instruction target.
     */
    public NamedNodeMap getNotations() {
        if (syncChildren()) {
            synchronizeChildren();
            }
    	return notations;
    }

    //
    // Public methods
    //

    /**
     * NON-DOM: Subclassed to flip the entities' and notations' readonly switch
     * as well.
     * @see NodeImpl#setReadOnly
     */
    public void setReadOnly(boolean readOnly, boolean deep) {
    	
        if (syncChildren()) {
            synchronizeChildren();
            }
        setReadOnly(readOnly, deep);

        // set read-only property
        elements.setReadOnly(readOnly, true);
        entities.setReadOnly(readOnly, true);
    	notations.setReadOnly(readOnly, true);

    } // setReadOnly(boolean,boolean)
    
    /**
     * NON-DOM: Access the collection of ElementDefinitions.
     * @see ElementDefinitionImpl
     */
    public NamedNodeMap getElements() {
        if (syncChildren()) {
            synchronizeChildren();
        }
    	return elements;
    }

} // class DocumentTypeImpl
"
org/apache/xerces/dom/CommentImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * Represents an XML (or HTML) comment.
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class CommentImpl 
    extends CharacterDataImpl 
    implements CharacterData, Comment {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -2685736833408134044L;

    //
    // Constructors
    //

    /** Factory constructor. */
    public CommentImpl(DocumentImpl ownerDoc, String data) {
    	super(ownerDoc, data);
    }
    
    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return Node.COMMENT_NODE;
    }

    /** Returns the node name. */
    public String getNodeName() {
        return ""#comment"";
    }

} // class CommentImpl
"
org/apache/xerces/validators/datatype/DecimalValidator.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.validators.datatype;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Vector;
import org.apache.xerces.validators.schema.SchemaSymbols;

/**
 *
 * DecimalValidator validates that content satisfies the W3C XML Datatype for decimal
 *
 * @author Ted Leung
 * @version
 */

public class DecimalValidator implements DatatypeValidator {

    BigDecimal fMaxInclusive = null;
    boolean fIsMaxInclusive = false;
    BigDecimal fMaxExclusive = null;
    boolean fIsMaxExclusive = false;
    BigDecimal fMinInclusive = null;
    boolean fIsMinInclusive = false;
    BigDecimal fMinExclusive = null;
    boolean fIsMinExclusive = false;
    BigDecimal fEnumValues[] = null;
    boolean fHasEnums = false;
    int fPrecision = 0;
    boolean fIsPrecision = false;
    int fScale = 0;
    boolean fIsScale = false;
    DecimalValidator fBaseValidator = null;
    private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider();
    private Locale fLocale = null;

    /**
     * validate that a string matches the decimal datatype
     *
     * validate returns true or false depending on whether the string content is a
     * W3C decimal type.
     * 
     * @param content A string containing the content to be validated
     *
     * @exception throws InvalidDatatypeException if the content is
     *  is not a W3C decimal type
     */

    public void validate(String content) throws InvalidDatatypeValueException {
        BigDecimal d = null;
        try {
            d = new BigDecimal(content);
        } catch (NumberFormatException nfe) {
            throw new InvalidDatatypeValueException(
                                                   getErrorString(DatatypeMessageProvider.NotDecimal,
                                                                  DatatypeMessageProvider.MSG_NONE,
                                                                  new Object[] { content}));
        }
        if (fIsScale)
            if (d.scale() > fScale)
                throw new InvalidDatatypeValueException(
                                                       getErrorString(DatatypeMessageProvider.ScaleExceeded,
                                                                      DatatypeMessageProvider.MSG_NONE,
                                                                      new Object[] { content}));
        if (fIsPrecision) {
            int precision = d.movePointRight(d.scale()).toString().length() - 
                            ((d.signum() < 0) ? 1 : 0); // account for minus sign
            if (precision > fPrecision)
                throw new InvalidDatatypeValueException(
                                                       getErrorString(DatatypeMessageProvider.PrecisionExceeded,
                                                                      DatatypeMessageProvider.MSG_NONE,
                                                                      new Object[] {content} ));
        }
        boundsCheck(d);
        if (fHasEnums)
            enumCheck(d);
    }

    public void validate(int contentIndex) throws InvalidDatatypeValueException {
    }

    //REVISIT: candidate for public API
    boolean ensureFacetsAreConsistent(Hashtable facets) {
        boolean facetsAreConsistent = true;
        for (Enumeration e = facets.keys(); facetsAreConsistent && e.hasMoreElements();) {
            String key = (String) e.nextElement();
            String value = null;
            if (key.equals(SchemaSymbols.ELT_ENUMERATION))
                continue;  // ENUM values passed as a vector & handled after bounds facets	    
            value = (String) facets.get(key);   
            BigDecimal decimalValue = null;
            try {
                decimalValue = new BigDecimal(value);
            } catch (NumberFormatException nfe) {
                facetsAreConsistent = false;
            }
            if (key.equals(SchemaSymbols.ELT_MININCLUSIVE ) && fIsMinInclusive) {
                facetsAreConsistent = (fMinInclusive.compareTo(decimalValue) < 0);
            } else if (key.equals(SchemaSymbols.ELT_MINEXCLUSIVE) && fIsMinExclusive) {
                facetsAreConsistent = (fMinExclusive.compareTo(decimalValue) < 0);
            } else if (key.equals(SchemaSymbols.ELT_MAXINCLUSIVE) && fIsMaxInclusive) {
                facetsAreConsistent = (fMaxInclusive.compareTo(decimalValue) >= 0);
            } else if (key.equals(SchemaSymbols.ELT_MAXEXCLUSIVE) && fIsMaxExclusive) {
                facetsAreConsistent = (fMaxExclusive.compareTo(decimalValue) > 0);
            } else if (key.equals(SchemaSymbols.ELT_SCALE) && fIsScale && fIsPrecision) {
                facetsAreConsistent = fScale <= fPrecision;
            }
        }
        return facetsAreConsistent;
    }

    public void setFacets(Hashtable facets, String derivationBy) throws UnknownFacetException, IllegalFacetException, IllegalFacetValueException {
        if( facets == null ) // No facets to set should not be here
            return; 

        if (fBaseValidator != null)
            if (!fBaseValidator.ensureFacetsAreConsistent(facets))
                throw new IllegalFacetValueException(
                                                    getErrorString(DatatypeMessageProvider.FacetsInconsistent,
                                                                   DatatypeMessageProvider.MSG_NONE, 
                                                                   null));


        fIsMinInclusive = fIsMinExclusive = fIsMaxInclusive = fIsMaxExclusive = fHasEnums = false;
        for (Enumeration e = facets.keys(); e.hasMoreElements();) {
            String key = (String) e.nextElement();
            String value = null;
            if (key.equals(SchemaSymbols.ELT_ENUMERATION))
                continue;  // ENUM values passed as a vector & handled after bounds facets	    
            value = (String) facets.get(key);   
            BigDecimal decimalValue = null;
            try {
                decimalValue = new BigDecimal(value);
            } catch (NumberFormatException nfe) {
                throw new IllegalFacetValueException(
                                                    getErrorString(DatatypeMessageProvider.IllegalFacetValue,
                                                                   DatatypeMessageProvider.MSG_NONE,
                                                                   new Object [] { value, key}));
            }
            if (key.equals(SchemaSymbols.ELT_MININCLUSIVE)) {
                fIsMinInclusive = true;
                fMinInclusive = decimalValue;
            } else if (key.equals(SchemaSymbols.ELT_MINEXCLUSIVE)) {
                fIsMinExclusive = true;
                fMinExclusive = decimalValue;
            } else if (key.equals(SchemaSymbols.ELT_MAXINCLUSIVE)) {
                fIsMaxInclusive = true;
                fMaxInclusive = decimalValue;
            } else if (key.equals(SchemaSymbols.ELT_MAXEXCLUSIVE)) {
                fIsMaxExclusive = true;
                fMaxExclusive = decimalValue;
            } else if (key.equals(SchemaSymbols.ELT_ENUMERATION)) {
            } else if (key.equals(SchemaSymbols.ELT_PRECISION)) {
                fIsPrecision = true;
                fPrecision = decimalValue.intValue();
            } else if (key.equals(SchemaSymbols.ELT_SCALE)) {
                fIsScale = true;
                fScale = decimalValue.intValue();
            } else if (key.equals(SchemaSymbols.ELT_LENGTH) ||
                       key.equals(SchemaSymbols.ELT_MINLENGTH) ||
                       key.equals(SchemaSymbols.ELT_MAXLENGTH) ||
                       key.equals(SchemaSymbols.ELT_ENCODING) ||
                       key.equals(SchemaSymbols.ELT_PERIOD) ||
                       key.equals(SchemaSymbols.ELT_PATTERN) )
                throw new IllegalFacetException(
                                               getErrorString(DatatypeMessageProvider.IllegalDecimalFacet,
                                                              DatatypeMessageProvider.MSG_NONE,
                                                              null));
            else
                throw new UnknownFacetException(
                                               getErrorString(DatatypeMessageProvider.UnknownFacet,
                                                              DatatypeMessageProvider.MSG_NONE,
                                                              new Object [] { key}));
        }

        // check for scale <= precision
        if (fIsScale && fIsPrecision && fScale > fPrecision)
            throw new IllegalFacetException(
                                           getErrorString(DatatypeMessageProvider.ScaleLargerThanPrecision,
                                                          DatatypeMessageProvider.MSG_NONE,
                                                          null));

        // check the enum values after any range constraints are in place
        Vector v = (Vector) facets.get(SchemaSymbols.ELT_ENUMERATION);    
        if (v != null) {
            fHasEnums = true;
            fEnumValues = new BigDecimal[v.size()];
            for (int i = 0; i < v.size(); i++)
                try {
                    fEnumValues[i] = new BigDecimal((String) v.elementAt(i));
                    boundsCheck(fEnumValues[i]);
                } catch (InvalidDatatypeValueException idve) {
                    throw new IllegalFacetValueException(
                                                        getErrorString(DatatypeMessageProvider.InvalidEnumValue,
                                                                       DatatypeMessageProvider.MSG_NONE,
                                                                       new Object [] { v.elementAt(i)}));
                } catch (NumberFormatException nfe) {
                    System.out.println(""Internal Error parsing enumerated values for decimal type"");
                }
        }

    }

    public void setFacets(int facets[]) throws UnknownFacetException, IllegalFacetException, IllegalFacetValueException, ConstrainException {
    }

    public void setBasetype(String base) {
        //fBaseValidator = (DecimalValidator) base;
    }

    /*
     * check that a facet is in range, assumes that facets are compatible -- compatibility ensured by setFacets
     */
    private void boundsCheck(BigDecimal d) throws InvalidDatatypeValueException {
        boolean minOk = false;
        boolean maxOk = false;
        if (fIsMaxInclusive)
            maxOk = (d.compareTo(fMaxInclusive) <= 0);
        else if (fIsMaxExclusive)
            maxOk = (d.compareTo(fMaxExclusive) < 0);
        else
            maxOk = (!fIsMaxInclusive && !fIsMaxExclusive);

        if (fIsMinInclusive)
            minOk = (d.compareTo(fMinInclusive) >= 0);
        else if (fIsMinExclusive)
            minOk = (d.compareTo(fMinInclusive) > 0);
        else
            minOk = (!fIsMinInclusive && !fIsMinExclusive);
        if (!(minOk && maxOk))
            throw new InvalidDatatypeValueException(
                                                   getErrorString(DatatypeMessageProvider.OutOfBounds,
                                                                  DatatypeMessageProvider.MSG_NONE,
                                                                  new Object [] { d}));
    }

    private void enumCheck(BigDecimal v) throws InvalidDatatypeValueException {
        for (int i = 0; i < fEnumValues.length; i++) {
            if (v == fEnumValues[i]) return;
        }
        throw new InvalidDatatypeValueException(
                                               getErrorString(DatatypeMessageProvider.NotAnEnumValue,
                                                              DatatypeMessageProvider.MSG_NONE,
                                                              new Object [] { v}));
    }

    /**
     * set the locate to be used for error messages
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }

    private String getErrorString(int major, int minor, Object args[]) {
        try {
            return fMessageProvider.createMessage(fLocale, major, minor, args);
        } catch (Exception e) {
            return ""Illegal Errorcode ""+minor;
        }
    }

    /*
    public static void main(String args[]) {
        // simple unit test
        try {
            DatatypeValidator v = new DecimalValidator();
            Hashtable facets = new Hashtable();
            facets.put(""minInclusive"",""0"");
            DatatypeValidator nonneg = new DecimalValidator();
            nonneg.setBasetype(v);
            nonneg.setFacets(facets);
            facets = new Hashtable();
            facets.put(""minInclusive"",""-1"");
            DatatypeValidator bad = new DecimalValidator();
            bad.setBasetype(nonneg);
            bad.setFacets(facets);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    */

    public int compare( DatatypeValidator o1, DatatypeValidator o2){
        return 0;
    }
}
"
org/apache/xerces/framework/XMLDTDScanner.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

import org.apache.xerces.readers.XMLEntityHandler;
import org.apache.xerces.readers.DefaultEntityHandler;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;
import org.apache.xerces.utils.XMLCharacterProperties;
import org.apache.xerces.utils.XMLMessages;
import org.apache.xerces.validators.common.Grammar;
import org.apache.xerces.validators.common.GrammarResolver;
import org.apache.xerces.validators.common.XMLAttributeDecl;
import org.apache.xerces.validators.common.XMLElementDecl;
import org.apache.xerces.validators.dtd.DTDGrammar;

import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

import java.util.StringTokenizer;
/**
 * Default implementation of an XML DTD scanner.
 * <p>
 * Clients who wish to scan a DTD should implement
 * XMLDTDScanner.EventHandler to provide the desired behavior
 * when various DTD components are encountered.
 * <p>
 * To process the DTD, the client application should follow the 
 * following sequence:
 * <ol>
 *  <li>call scanDocTypeDecl() to scan the DOCTYPE declaration
 *  <li>call getReadingExternalEntity() to determine if scanDocTypeDecl found an
 *      external subset
 * <li>if scanning an external subset, call scanDecls(true) to process the external subset
 * </ol>
 *
 * @see XMLDTDScanner.EventHandler
 * @version $Id$
 */
public final class XMLDTDScanner {
    //
    // Constants
    //
    //
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    //
    private static final char[] version_string = { 'v','e','r','s','i','o','n' };
    //
    // [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'
    //
    private static final char[] element_string = { 'E','L','E','M','E','N','T' };
    //
    // [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children
    //
    private static final char[] empty_string = { 'E','M','P','T','Y' };
    private static final char[] any_string = { 'A','N','Y' };
    //
    // [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*'
    //                | '(' S? '#PCDATA' S? ')'
    //
    private static final char[] pcdata_string = { '#','P','C','D','A','T','A' };
    //
    // [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
    //
    private static final char[] attlist_string = { 'A','T','T','L','I','S','T' };
    //
    // [55] StringType ::= 'CDATA'
    //
    private static final char[] cdata_string = { 'C','D','A','T','A' };
    //
    // [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES'
    //                        | 'NMTOKEN' | 'NMTOKENS'
    //
    // Note: We search for common substrings always trying to move forward
    //
    //  'ID'      - Common prefix of ID, IDREF and IDREFS
    //  'REF'     - Common substring of IDREF and IDREFS after matching ID prefix
    //  'ENTIT'   - Common prefix of ENTITY and ENTITIES
    //  'IES'     - Suffix of ENTITIES
    //  'NMTOKEN' - Common prefix of NMTOKEN and NMTOKENS
    //
    private static final char[] id_string = { 'I','D' };
    private static final char[] ref_string = { 'R','E','F' };
    private static final char[] entit_string = { 'E','N','T','I','T' };
    private static final char[] ies_string = { 'I','E','S' };
    private static final char[] nmtoken_string = { 'N','M','T','O','K','E','N' };
    //
    // [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
    // [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
    //
    private static final char[] notation_string = { 'N','O','T','A','T','I','O','N' };
    //
    // [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
    //
    private static final char[] required_string = { '#','R','E','Q','U','I','R','E','D' };
    private static final char[] implied_string = { '#','I','M','P','L','I','E','D' };
    private static final char[] fixed_string = { '#','F','I','X','E','D' };
    //
    // [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'
    //
    private static final char[] include_string = { 'I','N','C','L','U','D','E' };
    //
    // [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'
    //
    private static final char[] ignore_string = { 'I','G','N','O','R','E' };
    //
    // [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
    // [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
    //
    private static final char[] entity_string = { 'E','N','T','I','T','Y' };
    //
    // [75] ExternalID ::= 'SYSTEM' S SystemLiteral
    //                     | 'PUBLIC' S PubidLiteral S SystemLiteral
    // [83] PublicID ::= 'PUBLIC' S PubidLiteral
    //
    private static final char[] system_string = { 'S','Y','S','T','E','M' };
    private static final char[] public_string = { 'P','U','B','L','I','C' };
    //
    // [76] NDataDecl ::= S 'NDATA' S Name
    //
    private static final char[] ndata_string = { 'N','D','A','T','A' };
    //
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    //
    private static final char[] encoding_string = { 'e','n','c','o','d','i','n','g' };
    //
    // Instance Variables
    //
    private DTDGrammar fDTDGrammar = null;
    private GrammarResolver fGrammarResolver = null;
    private boolean fNamespacesEnabled = false;
    private boolean fValidationEnabled = false;
    private XMLElementDecl fTempElementDecl = new XMLElementDecl();
    private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl();
    private QName fElementQName = new QName();
    private QName fAttributeQName = new QName();
    private QName fElementRefQName = new QName();
    private EventHandler fEventHandler = null;
    private StringPool fStringPool = null;
    private XMLErrorReporter fErrorReporter = null;
    private XMLEntityHandler fEntityHandler = null;
    private XMLEntityHandler.EntityReader fEntityReader = null;
    private XMLEntityHandler.CharBuffer fLiteralData = null;
    private int fReaderId = -1;
    private int fSystemLiteral = -1;
    private int fPubidLiteral = -1;
    private int[] fOpStack = null;
    private int[] fNodeIndexStack = null;
    private int[] fPrevNodeIndexStack = null;
    private int fScannerState = SCANNER_STATE_INVALID;
    private int fIncludeSectDepth = 0;
    private int fDoctypeReader = -1;
    private int fExternalSubsetReader = -1;
    private int fDefaultAttValueReader = -1;
    private int fDefaultAttValueElementType = -1;
    private int fDefaultAttValueAttrName = -1;
    private int fDefaultAttValueOffset = -1;
    private int fDefaultAttValueMark = -1;
    private int fEntityValueReader = -1;
    private int fEntityValueMark = -1;
    private int fXMLSpace = -1;
    private int fDefault = -1;
    private int fPreserve = -1;
    private int fScannerMarkupDepth = 0;
    private int fScannerParenDepth = 0;
    //
    // Constructors
    //
    public XMLDTDScanner(StringPool stringPool,
                         XMLErrorReporter errorReporter,
                         XMLEntityHandler entityHandler,
                         XMLEntityHandler.CharBuffer literalData) {
        fStringPool = stringPool;
        fErrorReporter = errorReporter;
        fEntityHandler = entityHandler;
        fLiteralData = literalData;
        init();
    }

    /**
     * Set the event handler
     *
     * @param eventHandler The place to send our callbacks.
     */
    public void setEventHandler(XMLDTDScanner.EventHandler eventHandler) {
        fEventHandler = eventHandler;
    }

    /** Sets the grammar resolver. */
    public void setGrammarResolver(GrammarResolver resolver) {
        fGrammarResolver = resolver;
    }

    /** set fValidationEnabled  **/
    public void setValidationEnabled(boolean enabled) {
        fValidationEnabled = enabled;
    }

    /**
     * Is the XMLDTDScanner reading from an external entity?
     *
     * This will be true, in particular if there was an external subset
     *
     * @return true if the XMLDTDScanner is reading from an external entity.
     */
    public boolean getReadingExternalEntity() {
        return fReaderId != fDoctypeReader;
    }
    /**
     * Is the scanner reading a ContentSpec?
     * 
     * @return true if the scanner is reading a ContentSpec
     */
    public boolean getReadingContentSpec() {
        return getScannerState() == SCANNER_STATE_CONTENTSPEC;
    }
    /**
     * Report the markup nesting depth.  This allows a client to
     * perform validation checks for correct markup nesting.  This keeps
     * scanning and validation separate.
     *
     * @return the markup nesting depth
     */
    public int markupDepth() {
        return fScannerMarkupDepth;
    }
    private int increaseMarkupDepth() {
        return fScannerMarkupDepth++;
    }
    private int decreaseMarkupDepth() {
        return fScannerMarkupDepth--;
    }
    /**
     * Report the parenthesis nesting depth.  This allows a client to
     * perform validation checks for correct parenthesis balancing.  This keeps 
     * scanning and validation separate.
     *
     * @return the parenthesis depth
     */
    public int parenDepth() {
        return fScannerParenDepth;
    }
    private void setParenDepth(int parenDepth) {
        fScannerParenDepth = parenDepth;
    }
    private void increaseParenDepth() {
        fScannerParenDepth++;
    }
    private void decreaseParenDepth() {
        fScannerParenDepth--;
    }
    //
    //
    //
    /**
     * Allow XMLDTDScanner to be reused.  This method is called from an
     * XMLParser reset method, which passes the StringPool to be used
     * by the reset DTD scanner instance.
     *
     * @param stringPool the string pool to be used by XMLDTDScanner.  
     */
    public void reset(StringPool stringPool, XMLEntityHandler.CharBuffer literalData) throws Exception {
        fStringPool = stringPool;
        fLiteralData = literalData;
        fEntityReader = null;
        fReaderId = -1;
        fSystemLiteral = -1;
        fPubidLiteral = -1;
        fOpStack = null;
        fNodeIndexStack = null;
        fPrevNodeIndexStack = null;
        fScannerState = SCANNER_STATE_INVALID;
        fIncludeSectDepth = 0;
        fDoctypeReader = -1;
        fExternalSubsetReader = -1;
        fDefaultAttValueReader = -1;
        fDefaultAttValueElementType = -1;
        fDefaultAttValueAttrName = -1;
        fDefaultAttValueOffset = -1;
        fDefaultAttValueMark = -1;
        fEntityValueReader = -1;
        fEntityValueMark = -1;
        fScannerMarkupDepth = 0;
        fScannerParenDepth = 0;
        init();
    }
    private void init() {
        fXMLSpace = fStringPool.addSymbol(""xml:space"");
        fDefault = fStringPool.addSymbol(""default"");
        fPreserve = fStringPool.addSymbol(""preserve"");
    }

    //
    // Interfaces
    //

    /**
     * This interface must be implemented by the users of the XMLDTDScanner class.
     * These methods form the abstraction between the implementation semantics and the
     * more generic task of scanning the DTD-specific XML grammar.
     */
    public interface EventHandler {

        /** Start of DTD. */
        public void callStartDTD() throws Exception;

        /** End of DTD. */
        public void callEndDTD() throws Exception;

        /**
         * Signal the Text declaration of an external entity.
         *
         * @param version the handle in the string pool for the version number
         * @param encoding the handle in the string pool for the encoding
         * @exception java.lang.Exception
         */
        public void callTextDecl(int version, int encoding) throws Exception;
        /**
         * Called when the doctype decl is scanned
         *
         * @param rootElementType handle of the rootElement
         * @param publicId StringPool handle of the public id
         * @param systemId StringPool handle of the system id
         * @exception java.lang.Exception
         */
        public void doctypeDecl(QName rootElement, int publicId, int systemId) throws Exception;
        /**
         * Called when the DTDScanner starts reading from the external subset
         *
         * @param publicId StringPool handle of the public id
         * @param systemId StringPool handle of the system id
         * @exception java.lang.Exception
         */
        public void startReadingFromExternalSubset(int publicId, int systemId) throws Exception;
        /**
         * Called when the DTDScanner stop reading from the external subset
         *
         * @exception java.lang.Exception
         */
        public void stopReadingFromExternalSubset() throws Exception;
        /**
         * Add an element declaration (forward reference)
         *
         * @param handle to the name of the element being declared
         * @return handle to the element whose declaration was added
         * @exception java.lang.Exception
         */
        public int addElementDecl(QName elementDecl) throws Exception;
        /**
         * Add an element declaration
         *
         * @param handle to the name of the element being declared
         * @param contentSpecType handle to the type name of the content spec
         * @param ContentSpec handle to the content spec node for the contentSpecType
         * @return handle to the element declaration that was added 
         * @exception java.lang.Exception
         */
        public int addElementDecl(QName elementDecl, int contentSpecType, int contentSpec, boolean isExternal) throws Exception;
        /**
         * Add an attribute definition
         *
         * @param handle to the element whose attribute is being declared
         * @param attName StringPool handle to the attribute name being declared
         * @param attType type of the attribute
         * @param enumeration StringPool handle of the attribute's enumeration list (if any)
         * @param attDefaultType an integer value denoting the DefaultDecl value
         * @param attDefaultValue StringPool handle of this attribute's default value
         * @return handle to the attribute definition
         * @exception java.lang.Exception
         */
        public int addAttDef(QName elementDecl, QName attributeDecl, 
                             int attType, boolean attList, int enumeration, 
                             int attDefaultType, int attDefaultValue, boolean isExternal) throws Exception;
        /**
         * create an XMLContentSpec for a leaf
         *
         * @param nameIndex StringPool handle to the name (Element) for the node
         * @return handle to the newly create XMLContentSpec
         * @exception java.lang.Exception
         */
        public int addUniqueLeafNode(int nameIndex) throws Exception;
        /**
         * Create an XMLContentSpec for a single non-leaf
         * 
         * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_*
         * @param nodeValue handle to an XMLContentSpec
         * @return handle to the newly create XMLContentSpec
         * @exception java.lang.Exception
         */
        public int addContentSpecNode(int nodeType, int nodeValue) throws Exception;
        /**
         * Create an XMLContentSpec for a two child leaf
         *
         * @param nodeType the type of XMLContentSpec to create - from XMLContentSpec.CONTENTSPECNODE_*
         * @param leftNodeIndex handle to an XMLContentSpec
         * @param rightNodeIndex handle to an XMLContentSpec
         * @return handle to the newly create XMLContentSpec
         * @exception java.lang.Exception
         */
        public int addContentSpecNode(int nodeType, int leftNodeIndex, int rightNodeIndex) throws Exception;
        /**
         * Create a string representation of an XMLContentSpec tree
         * 
         * @param handle to an XMLContentSpec
         * @return String representation of the content spec tree
         * @exception java.lang.Exception
         */
        public String getContentSpecNodeAsString(int nodeIndex) throws Exception;
        /**
         * Start the scope of an entity declaration.
         *
         * @return <code>true</code> on success; otherwise
         *         <code>false</code> if the entity declaration is recursive.
         * @exception java.lang.Exception
         */
        public boolean startEntityDecl(boolean isPE, int entityName) throws Exception;
        /**
         * End the scope of an entity declaration.
         * @exception java.lang.Exception
         */
        public void endEntityDecl() throws Exception;
        /**
         * Add a declaration for an internal parameter entity
         *
         * @param name StringPool handle of the parameter entity name
         * @param value StringPool handle of the parameter entity value
         * @return handle to the parameter entity declaration
         * @exception java.lang.Exception
         */
        public int addInternalPEDecl(int name, int value) throws Exception;
        /**
         * Add a declaration for an external parameter entity
         *
         * @param name StringPool handle of the parameter entity name
         * @param publicId StringPool handle of the publicId
         * @param systemId StringPool handle of the systemId
         * @return handle to the parameter entity declaration
         * @exception java.lang.Exception
         */
        public int addExternalPEDecl(int name, int publicId, int systemId) throws Exception;
        /**
         * Add a declaration for an internal entity
         *
         * @param name StringPool handle of the entity name
         * @param value StringPool handle of the entity value
         * @return handle to the entity declaration
         * @exception java.lang.Exception
         */
        public int addInternalEntityDecl(int name, int value) throws Exception;
        /**
         * Add a declaration for an entity
         *
         * @param name StringPool handle of the entity name
         * @param publicId StringPool handle of the publicId
         * @param systemId StringPool handle of the systemId
         * @return handle to the entity declaration
         * @exception java.lang.Exception
         */
        public int addExternalEntityDecl(int name, int publicId, int systemId) throws Exception;
        /**
         * Add a declaration for an unparsed entity
         *
         * @param name StringPool handle of the entity name
         * @param publicId StringPool handle of the publicId
         * @param systemId StringPool handle of the systemId
         * @param notationName StringPool handle of the notationName
         * @return handle to the entity declaration
         * @exception java.lang.Exception
         */
        public int addUnparsedEntityDecl(int name, int publicId, int systemId, int notationName) throws Exception;
        /**
         * Called when the scanner start scanning an enumeration
         * @return StringPool handle to a string list that will hold the enumeration names
         * @exception java.lang.Exception
         */
        public int startEnumeration() throws Exception;
        /**
         * Add a name to an enumeration
         * @param enumIndex StringPool handle to the string list for the enumeration
         * @param elementType handle to the element that owns the attribute with the enumeration
         * @param attrName StringPool handle to the name of the attribut with the enumeration
         * @param nameIndex StringPool handle to the name to be added to the enumeration
         * @param isNotationType true if the enumeration is an enumeration of NOTATION names
         * @exception java.lang.Exception
         */
        public void addNameToEnumeration(int enumIndex, int elementType, int attrName, int nameIndex, boolean isNotationType) throws Exception;
        /**
         * Finish processing an enumeration
         *
         * @param enumIndex handle to the string list which holds the enumeration to be finshed.
         * @exception java.lang.Exception
         */
        public void endEnumeration(int enumIndex) throws Exception;
        /**
         * Add a declaration for a notation
         *
         * @param notationName
         * @param publicId
         * @param systemId
         * @return handle to the notation declaration
         * @exception java.lang.Exception
         */
        public int addNotationDecl(int notationName, int publicId, int systemId) throws Exception;
        /**
         * Called when a comment has been scanned
         *
         * @param data StringPool handle of the comment text
         * @exception java.lang.Exception
         */
        public void callComment(int data) throws Exception;
        /**
         * Called when a processing instruction has been scanned
         * @param piTarget StringPool handle of the PI target
         * @param piData StringPool handle of the PI data
         * @exception java.lang.Exception
         */
        public void callProcessingInstruction(int piTarget, int piData) throws Exception;
        /**
         * Supports DOM Level 2 internalSubset additions.
         * Called when the internal subset is completely scanned.
         */
        public void internalSubset(int internalSubset) throws Exception;
    }
    //
    //
    //
    
    /** Report a recoverable xml error. */
    protected void reportRecoverableXMLError(int majorCode, int minorCode, 
                                             int stringIndex1) 
        throws Exception {

        Object[] args = { fStringPool.toString(stringIndex1) };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);

    } // reportRecoverableXMLError(int,int,int)

    /** Report a recoverable xml error. */
    protected void reportRecoverableXMLError(int majorCode, int minorCode, 
                                         String string1) throws Exception {

        Object[] args = { string1 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);

    } // reportRecoverableXMLError(int,int,String)
    
    /** Report a recoverable xml error. */
    protected void reportRecoverableXMLError(int majorCode, int minorCode, 
                                             String string1, String string2) 
        throws Exception {

        Object[] args = { string1, string2 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);

    } // reportRecoverableXMLError(int,int,String,String)
    
 
    private void reportFatalXMLError(int majorCode, int minorCode) throws Exception {
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   null,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void reportFatalXMLError(int majorCode, int minorCode, int stringIndex1) throws Exception {
        Object[] args = { fStringPool.toString(stringIndex1) };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void reportFatalXMLError(int majorCode, int minorCode, String string1) throws Exception {
        Object[] args = { string1 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void reportFatalXMLError(int majorCode, int minorCode, int stringIndex1, int stringIndex2) throws Exception {
        Object[] args = { fStringPool.toString(stringIndex1),
                          fStringPool.toString(stringIndex2) };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void reportFatalXMLError(int majorCode, int minorCode, String string1, String string2) throws Exception {
        Object[] args = { string1, string2 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void reportFatalXMLError(int majorCode, int minorCode, String string1, String string2, String string3) throws Exception {
        Object[] args = { string1, string2, string3 };
        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                   XMLMessages.XML_DOMAIN,
                                   majorCode,
                                   minorCode,
                                   args,
                                   XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
    }
    private void abortMarkup(int majorCode, int minorCode) throws Exception {
        reportFatalXMLError(majorCode, minorCode);
        skipPastEndOfCurrentMarkup();
    }
    private void abortMarkup(int majorCode, int minorCode, int stringIndex1) throws Exception {
        reportFatalXMLError(majorCode, minorCode, stringIndex1);
        skipPastEndOfCurrentMarkup();
    }
    private void abortMarkup(int majorCode, int minorCode, String string1) throws Exception {
        reportFatalXMLError(majorCode, minorCode, string1);
        skipPastEndOfCurrentMarkup();
    }
    private void abortMarkup(int majorCode, int minorCode, int stringIndex1, int stringIndex2) throws Exception {
        reportFatalXMLError(majorCode, minorCode, stringIndex1, stringIndex2);
        skipPastEndOfCurrentMarkup();
    }
    private void skipPastEndOfCurrentMarkup() throws Exception {
        fEntityReader.skipToChar('>');
        if (fEntityReader.lookingAtChar('>', true))
            decreaseMarkupDepth();
    }
    //
    //
    //
    static private final int SCANNER_STATE_INVALID = -1;
    static private final int SCANNER_STATE_END_OF_INPUT = 0;
    static private final int SCANNER_STATE_DOCTYPEDECL = 50;
    static private final int SCANNER_STATE_MARKUP_DECL = 51;
    static private final int SCANNER_STATE_TEXTDECL = 53;
    static private final int SCANNER_STATE_COMMENT = 54;
    static private final int SCANNER_STATE_PI = 55;
    static private final int SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE = 56;
    static private final int SCANNER_STATE_CONTENTSPEC = 57;
    static private final int SCANNER_STATE_ENTITY_VALUE = 58;
    static private final int SCANNER_STATE_SYSTEMLITERAL = 59;
    static private final int SCANNER_STATE_PUBIDLITERAL = 60;

    private int setScannerState(int scannerState) {
        int prevState = fScannerState;
        fScannerState = scannerState;
        return prevState;
    }
    private int getScannerState() {
        return fScannerState;
    }
    private void restoreScannerState(int scannerState) {
        if (fScannerState != SCANNER_STATE_END_OF_INPUT)
            fScannerState = scannerState;
    }
    /**
     * Change readers
     *
     * @param nextReader the new reader that the scanner will use
     * @param nextReaderId id of the reader to change to
     * @exception throws java.lang.Exception
     */
    public void readerChange(XMLEntityHandler.EntityReader nextReader, int nextReaderId) throws Exception {
        fEntityReader = nextReader;
        fReaderId = nextReaderId;
        if (fScannerState == SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE) {
            fDefaultAttValueOffset = fEntityReader.currentOffset();
            fDefaultAttValueMark = fDefaultAttValueOffset;
        } else if (fScannerState == SCANNER_STATE_ENTITY_VALUE) {
            fEntityValueMark = fEntityReader.currentOffset();
        }
    }
    /**
     * Handle the end of input
     *
     * @param entityName the handle in the string pool of the name of the entity which has reached end of input
     * @param moreToFollow if true, there is still input left to process in other readers
     * @exception java.lang.Exception
     */
    public void endOfInput(int entityNameIndex, boolean moreToFollow) throws Exception {
        if (fValidationEnabled ) {
            int readerDepth = fEntityHandler.getReaderDepth();
            if (getReadingContentSpec()) {
                int parenDepth = parenDepth();
                if (readerDepth != parenDepth) {
                    reportRecoverableXMLError(XMLMessages.MSG_IMPROPER_GROUP_NESTING,
                                                XMLMessages.VC_PROPER_GROUP_PE_NESTING,
                                                entityNameIndex);
                }
            } else {
                int markupDepth = markupDepth();
                if (readerDepth != markupDepth) {
                    reportRecoverableXMLError(XMLMessages.MSG_IMPROPER_DECLARATION_NESTING,
                                                XMLMessages.VC_PROPER_DECLARATION_PE_NESTING,
                                                entityNameIndex);
                }
            }
        }
        //REVISIT, why are we doing this?
        moreToFollow = fReaderId != fExternalSubsetReader;

//      System.out.println(""current Scanner state "" + getScannerState() +"",""+ fScannerState + moreToFollow);
        switch (fScannerState) {
        case SCANNER_STATE_INVALID:
            throw new RuntimeException(""FWK004 XMLDTDScanner.endOfInput: cannot happen: 2""+""\n2"");
        case SCANNER_STATE_END_OF_INPUT:
            break;
        case SCANNER_STATE_MARKUP_DECL:
            if (!moreToFollow && fIncludeSectDepth > 0) {
                reportFatalXMLError(XMLMessages.MSG_INCLUDESECT_UNTERMINATED,
                                    XMLMessages.P62_UNTERMINATED);
            }
            break;
        case SCANNER_STATE_DOCTYPEDECL:
            throw new RuntimeException(""FWK004 XMLDTDScanner.endOfInput: cannot happen: 2.5""+""\n2.5"");
//            break;
        case SCANNER_STATE_TEXTDECL:
// REVISIT            reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
            break;
        case SCANNER_STATE_SYSTEMLITERAL:
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_SYSTEMID_UNTERMINATED,
                                    XMLMessages.P11_UNTERMINATED);
            } else {
// REVISIT                reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
            }
            break;
        case SCANNER_STATE_PUBIDLITERAL:
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_PUBLICID_UNTERMINATED,
                                    XMLMessages.P12_UNTERMINATED);
            } else {
// REVISIT                reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
            }
            break;
        case SCANNER_STATE_COMMENT:
            if (!moreToFollow && !getReadingExternalEntity()) {
                reportFatalXMLError(XMLMessages.MSG_COMMENT_UNTERMINATED,
                                    XMLMessages.P15_UNTERMINATED);
            } else {
                //
                // REVISIT - HACK !!!  code changed to pass incorrect OASIS test 'invalid--001'
                //  Uncomment the next line to conform to the spec...
                //
                //reportFatalXMLError(XMLMessages.MSG_COMMENT_NOT_IN_ONE_ENTITY,
                //                    XMLMessages.P78_NOT_WELLFORMED);
            }
            break;
        case SCANNER_STATE_PI:
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_PI_UNTERMINATED,
                                    XMLMessages.P16_UNTERMINATED);
            } else {
                reportFatalXMLError(XMLMessages.MSG_PI_NOT_IN_ONE_ENTITY,
                                    XMLMessages.P78_NOT_WELLFORMED);
            }
            break;
        case SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE:
            if (!moreToFollow) {
                reportFatalXMLError(XMLMessages.MSG_ATTRIBUTE_VALUE_UNTERMINATED,
                                    XMLMessages.P10_UNTERMINATED,
                                    fDefaultAttValueElementType,
                                    fDefaultAttValueAttrName);
            } else if (fReaderId == fDefaultAttValueReader) {
// REVISIT                reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
            } else {
                fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
            }
            break;
        case SCANNER_STATE_CONTENTSPEC:
            break;
        case SCANNER_STATE_ENTITY_VALUE:
            if (fReaderId == fEntityValueReader) {
// REVISIT                reportFatalXMLError(XMLMessages.MSG_ATTVAL0);
            } else {
                fEntityReader.append(fLiteralData, fEntityValueMark, fEntityReader.currentOffset() - fEntityValueMark);
            }
            break;
        default:
            throw new RuntimeException(""FWK004 XMLDTDScanner.endOfInput: cannot happen: 3""+""\n3"");
        }
        if (!moreToFollow) {
            setScannerState(SCANNER_STATE_END_OF_INPUT);
        }
    }
    //
    // [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
    //
    private int scanCharRef() throws Exception {
        int valueOffset = fEntityReader.currentOffset();
        boolean hex = fEntityReader.lookingAtChar('x', true);
        int num = fEntityReader.scanCharRef(hex);
        if (num < 0) {
            switch (num) {
            case XMLEntityHandler.CHARREF_RESULT_SEMICOLON_REQUIRED:
                reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_CHARREF,
                                    XMLMessages.P66_SEMICOLON_REQUIRED);
                return -1;
            case XMLEntityHandler.CHARREF_RESULT_INVALID_CHAR:
                int majorCode = hex ? XMLMessages.MSG_HEXDIGIT_REQUIRED_IN_CHARREF :
                                      XMLMessages.MSG_DIGIT_REQUIRED_IN_CHARREF;
                int minorCode = hex ? XMLMessages.P66_HEXDIGIT_REQUIRED :
                                      XMLMessages.P66_DIGIT_REQUIRED;
                reportFatalXMLError(majorCode, minorCode);
                return -1;
            case XMLEntityHandler.CHARREF_RESULT_OUT_OF_RANGE:
                num = 0x110000; // this will cause the right error to be reported below...
                break;
            }
        }
        //
        //  [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF]        // any Unicode character, excluding the
        //               | [#xE000-#xFFFD] | [#x10000-#x10FFFF] // surrogate blocks, FFFE, and FFFF.
        //
        if (num < 0x20) {
            if (num == 0x09 || num == 0x0A || num == 0x0D) {
                return num;
            }
        } else if (num <= 0xD7FF || (num >= 0xE000 && (num <= 0xFFFD || (num >= 0x10000 && num <= 0x10FFFF)))) {
            return num;
        }
        int valueLength = fEntityReader.currentOffset() - valueOffset;
        reportFatalXMLError(XMLMessages.MSG_INVALID_CHARREF,
                            XMLMessages.WFC_LEGAL_CHARACTER,
                            fEntityReader.addString(valueOffset, valueLength));
        return -1;
    }
    //
    // From the standard:
    //
    // [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
    //
    // Called after scanning past '<!--'
    //
    private void scanComment() throws Exception
    {
        int commentOffset = fEntityReader.currentOffset();
        boolean sawDashDash = false;
        int previousState = setScannerState(SCANNER_STATE_COMMENT);
        while (fScannerState == SCANNER_STATE_COMMENT) {
            if (fEntityReader.lookingAtChar('-', false)) {
                int nextEndOffset = fEntityReader.currentOffset();
                int endOffset = 0;
                fEntityReader.lookingAtChar('-', true);
                int offset = fEntityReader.currentOffset();
                int count = 1;
                while (fEntityReader.lookingAtChar('-', true)) {
                    count++;
                    endOffset = nextEndOffset;
                    nextEndOffset = offset;
                    offset = fEntityReader.currentOffset();
                }
                if (count > 1) {
                    if (fEntityReader.lookingAtChar('>', true)) {
                        if (!sawDashDash && count > 2) {
                            reportFatalXMLError(XMLMessages.MSG_DASH_DASH_IN_COMMENT,
                                                XMLMessages.P15_DASH_DASH);
                            sawDashDash = true;
                        }
                        decreaseMarkupDepth();
                        fDTDGrammar.callComment(fEntityReader.addString(commentOffset, endOffset - commentOffset));
                        restoreScannerState(previousState);
                        return;
                    } else if (!sawDashDash) {
                        reportFatalXMLError(XMLMessages.MSG_DASH_DASH_IN_COMMENT,
                                            XMLMessages.P15_DASH_DASH);
                        sawDashDash = true;
                    }
                }
            } else {
                if (!fEntityReader.lookingAtValidChar(true)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_COMMENT,
                                                XMLMessages.P15_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        }
                    }
                }
            }
        }
        restoreScannerState(previousState);
    }
    //
    // From the standard:
    //
    // [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
    // [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
    //
    private void scanPI(int piTarget) throws Exception
    {
        String piTargetString = fStringPool.toString(piTarget);
        if (piTargetString.length() == 3 &&
            (piTargetString.charAt(0) == 'X' || piTargetString.charAt(0) == 'x') &&
            (piTargetString.charAt(1) == 'M' || piTargetString.charAt(1) == 'm') &&
            (piTargetString.charAt(2) == 'L' || piTargetString.charAt(2) == 'l')) {
            abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                        XMLMessages.P17_RESERVED_PITARGET);
            return;
        }
        int prevState = setScannerState(SCANNER_STATE_PI);
        int piDataOffset = -1;
        int piDataLength = 0;
        if (!fEntityReader.lookingAtSpace(true)) {
            if (!fEntityReader.lookingAtChar('?', true) || !fEntityReader.lookingAtChar('>', true)) {
                if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                    abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_IN_PI,
                                XMLMessages.P16_WHITESPACE_REQUIRED);
                    restoreScannerState(prevState);
                }
                return;
            }
            decreaseMarkupDepth();
            restoreScannerState(prevState);
        } else {
            fEntityReader.skipPastSpaces();
            piDataOffset = fEntityReader.currentOffset();
            while (fScannerState == SCANNER_STATE_PI) {
                while (fEntityReader.lookingAtChar('?', false)) {
                    int offset = fEntityReader.currentOffset();
                    fEntityReader.lookingAtChar('?', true);
                    if (fEntityReader.lookingAtChar('>', true)) {
                        piDataLength = offset - piDataOffset;
                        decreaseMarkupDepth();
                        restoreScannerState(prevState);
                        break;
                    }
                }
                if (fScannerState != SCANNER_STATE_PI)
                    break;
                if (!fEntityReader.lookingAtValidChar(true)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                        if (invChar >= 0) {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_PI,
                                                XMLMessages.P16_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        }
                        skipPastEndOfCurrentMarkup();
                        restoreScannerState(prevState);
                    }
                    return;
                }
            }
        }
        int piData = piDataLength == 0 ?
                     StringPool.EMPTY_STRING : fEntityReader.addString(piDataOffset, piDataLength);
        fDTDGrammar.callProcessingInstruction(piTarget, piData);
    }
    //
    // From the standard:
    //
    // [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?
    //                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
    // [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl
    //                     | NotationDecl | PI | Comment
    //
    // Called after scanning '<!DOCTYPE'
    //
    /**
     * This routine is called after the &lt;!DOCTYPE portion of a DOCTYPE
     * line has been called.  scanDocTypeDecl goes onto scan the rest of the DOCTYPE
     * decl.  If an internal DTD subset exists, it is scanned. If an external DTD
     * subset exists, scanDocTypeDecl sets up the state necessary to process it.
     *
     * @return true if successful
     * @exception java.lang.Exception
     */
    public boolean scanDoctypeDecl() throws Exception
    {
        //System.out.println(""XMLDTDScanner#scanDoctypeDecl()"");

        fDTDGrammar = new DTDGrammar(fStringPool, fEventHandler);
        fDTDGrammar.callStartDTD();
        increaseMarkupDepth();
        fEntityReader = fEntityHandler.getEntityReader();
        fReaderId = fEntityHandler.getReaderId();
        fDoctypeReader = fReaderId;
        setScannerState(SCANNER_STATE_DOCTYPEDECL);
        if (!fEntityReader.lookingAtSpace(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL,
                        XMLMessages.P28_SPACE_REQUIRED);
            return false;
        }
        fEntityReader.skipPastSpaces();
        scanElementType(fEntityReader, ' ', fElementQName);
        if (fElementQName.rawname == -1) {
            abortMarkup(XMLMessages.MSG_ROOT_ELEMENT_TYPE_REQUIRED,
                        XMLMessages.P28_ROOT_ELEMENT_TYPE_REQUIRED);
            return false;
        }
        boolean lbrkt;
        boolean scanExternalSubset = false;
        int publicId = -1;
        int systemId = -1;
        if (fEntityReader.lookingAtSpace(true)) {
            fEntityReader.skipPastSpaces();
            if (!(lbrkt = fEntityReader.lookingAtChar('[', true)) && !fEntityReader.lookingAtChar('>', false)) {
                if (!scanExternalID(false)) {
                    skipPastEndOfCurrentMarkup();
                    return false;
                }
                scanExternalSubset = true;
                publicId = fPubidLiteral;
                systemId = fSystemLiteral;
                fEntityReader.skipPastSpaces();
                lbrkt = fEntityReader.lookingAtChar('[', true);
            }
        } else
            lbrkt = fEntityReader.lookingAtChar('[', true);
        fDTDGrammar.doctypeDecl(fElementQName, publicId, systemId);
        if (lbrkt) {
            scanDecls(false);
            fEntityReader.skipPastSpaces();
        }
        if (!fEntityReader.lookingAtChar('>', true)) {
            if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                abortMarkup(XMLMessages.MSG_DOCTYPEDECL_UNTERMINATED,
                            XMLMessages.P28_UNTERMINATED,
                            fElementQName.rawname);
            }
            return false;
        }

        decreaseMarkupDepth();

        //System.out.println(""  scanExternalSubset: ""+scanExternalSubset);
        if (scanExternalSubset) {
            ((DefaultEntityHandler) fEntityHandler).startReadingFromExternalSubset( fStringPool.toString(publicId),
                                                                                    fStringPool.toString(systemId),
                                                                                    markupDepth());
            fDTDGrammar.startReadingFromExternalSubset(publicId, systemId);
        }

        fGrammarResolver.putGrammar("""", fDTDGrammar);


        return true;
    }
    //
    // [75] ExternalID ::= 'SYSTEM' S SystemLiteral
    //                     | 'PUBLIC' S PubidLiteral S SystemLiteral
    // [83] PublicID ::= 'PUBLIC' S PubidLiteral
    //
    private boolean scanExternalID(boolean scanPublicID) throws Exception
    {
        fSystemLiteral = -1;
        fPubidLiteral = -1;
        int offset = fEntityReader.currentOffset();
        if (fEntityReader.skippedString(system_string)) {
            if (!fEntityReader.lookingAtSpace(true)) {
                reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID,
                                    XMLMessages.P75_SPACE_REQUIRED);
                return false;
            }
            fEntityReader.skipPastSpaces();
            return scanSystemLiteral();
        }
        if (fEntityReader.skippedString(public_string)) {
            if (!fEntityReader.lookingAtSpace(true)) {
                reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID,
                                    XMLMessages.P75_SPACE_REQUIRED);
                return false;
            }
            fEntityReader.skipPastSpaces();
            if (!scanPubidLiteral())
                return false;
            if (scanPublicID) {
                //
                // [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
                //
                if (!fEntityReader.lookingAtSpace(true))
                    return true; // no S, not an ExternalID
                fEntityReader.skipPastSpaces();
                if (fEntityReader.lookingAtChar('>', false)) // matches end of NotationDecl
                    return true;
            } else {
                if (!fEntityReader.lookingAtSpace(true)) {
                    reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID,
                                        XMLMessages.P75_SPACE_REQUIRED);
                    return false;
                }
                fEntityReader.skipPastSpaces();
            }
            return scanSystemLiteral();
        }
        reportFatalXMLError(XMLMessages.MSG_EXTERNALID_REQUIRED,
                            XMLMessages.P75_INVALID);
        return false;
    }
    //
    // [11] SystemLiteral ::= ('""' [^""]* '""') | (""'"" [^']* ""'"")
    //
    // REVISIT - need to look into uri escape mechanism for non-ascii characters.
    //
    private boolean scanSystemLiteral() throws Exception
    {
        boolean single;
        if (!(single = fEntityReader.lookingAtChar('\'', true)) && !fEntityReader.lookingAtChar('\""', true)) {
            reportFatalXMLError(XMLMessages.MSG_QUOTE_REQUIRED_IN_SYSTEMID,
                                XMLMessages.P11_QUOTE_REQUIRED);
            return false;
        }
        int prevState = setScannerState(SCANNER_STATE_SYSTEMLITERAL);
        int offset = fEntityReader.currentOffset();
        char qchar = single ? '\'' : '\""';
        boolean dataok = true;
        boolean fragment = false;
        while (!fEntityReader.lookingAtChar(qchar, false)) {
//ericye
//System.out.println(""XMLDTDScanner#scanDoctypeDecl() 3333333, ""+fReaderId+"", "" + fScannerState+"", "" +fExternalSubsetReader);
            if (fEntityReader.lookingAtChar('#', true)) {
                fragment = true;
            } else if (!fEntityReader.lookingAtValidChar(true)) {
//System.out.println(""XMLDTDScanner#scanDoctypeDecl() 555555 scan state: "" + fScannerState);
                dataok = false;
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return false;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_SYSTEMID,
                                        XMLMessages.P11_INVALID_CHARACTER,
                                        Integer.toHexString(invChar));
                }
            }
        }
        if (dataok) {
            fSystemLiteral = fEntityReader.addString(offset, fEntityReader.currentOffset() - offset);
            if (fragment) {
                // NOTE: RECOVERABLE ERROR
                Object[] args = { fStringPool.toString(fSystemLiteral) };
                fErrorReporter.reportError(fErrorReporter.getLocator(),
                                           XMLMessages.XML_DOMAIN,
                                           XMLMessages.MSG_URI_FRAGMENT_IN_SYSTEMID,
                                           XMLMessages.P11_URI_FRAGMENT,
                                           args,
                                           XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
            }
        }
        fEntityReader.lookingAtChar(qchar, true);
        restoreScannerState(prevState);
        return dataok;
    }
    //
    // [12] PubidLiteral ::= '""' PubidChar* '""' | ""'"" (PubidChar - ""'"")* ""'""
    // [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
    //
    private boolean scanPubidLiteral() throws Exception
    {
        boolean single;
        if (!(single = fEntityReader.lookingAtChar('\'', true)) && !fEntityReader.lookingAtChar('\""', true)) {
            reportFatalXMLError(XMLMessages.MSG_QUOTE_REQUIRED_IN_PUBLICID,
                                XMLMessages.P12_QUOTE_REQUIRED);
            return false;
        }
        char qchar = single ? '\'' : '\""';
        int prevState = setScannerState(SCANNER_STATE_PUBIDLITERAL);
        boolean dataok = true;
        while (true) {
            if (fEntityReader.lookingAtChar((char)0x09, true)) {
                dataok = false;
                reportFatalXMLError(XMLMessages.MSG_PUBIDCHAR_ILLEGAL,
                                    XMLMessages.P12_INVALID_CHARACTER, ""9"");
            }
            if (!fEntityReader.lookingAtSpace(true))
                break;
        }
        int offset = fEntityReader.currentOffset();
        int dataOffset = fLiteralData.length();
        int toCopy = offset;
        while (true) {
            if (fEntityReader.lookingAtChar(qchar, true)) {
                if (dataok && offset - toCopy > 0)
                    fEntityReader.append(fLiteralData, toCopy, offset - toCopy);
                break;
            }
            if (fEntityReader.lookingAtChar((char)0x09, true)) {
                dataok = false;
                reportFatalXMLError(XMLMessages.MSG_PUBIDCHAR_ILLEGAL,
                                    XMLMessages.P12_INVALID_CHARACTER, ""9"");
                continue;
            }
            if (fEntityReader.lookingAtSpace(true)) {
                if (dataok && offset - toCopy > 0)
                    fEntityReader.append(fLiteralData, toCopy, offset - toCopy);
                while (true) {
                    if (fEntityReader.lookingAtChar((char)0x09, true)) {
                        dataok = false;
                        reportFatalXMLError(XMLMessages.MSG_PUBIDCHAR_ILLEGAL,
                                            XMLMessages.P12_INVALID_CHARACTER, ""9"");
                        break;
                    } else if (!fEntityReader.lookingAtSpace(true)) {
                        break;
                    }
                }
                if (fEntityReader.lookingAtChar(qchar, true))
                    break;
                if (dataok) {
                    fLiteralData.append(' ');
                    offset = fEntityReader.currentOffset();
                    toCopy = offset;
                }
                continue;
            }
            if (!fEntityReader.lookingAtValidChar(true)) {
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return false;
                dataok = false;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_PUBLICID,
                                        XMLMessages.P12_INVALID_CHARACTER,
                                        Integer.toHexString(invChar));
                }
            }
            if (dataok)
                offset = fEntityReader.currentOffset();
        }
        if (dataok) {
            int dataLength = fLiteralData.length() - dataOffset;
            fPubidLiteral = fLiteralData.addString(dataOffset, dataLength);
            String publicId = fStringPool.toString(fPubidLiteral);
            int invCharIndex = validPublicId(publicId);
            if (invCharIndex >= 0) {
                reportFatalXMLError(XMLMessages.MSG_PUBIDCHAR_ILLEGAL,
                                    XMLMessages.P12_INVALID_CHARACTER,
                                    Integer.toHexString(publicId.charAt(invCharIndex)));
                return false;
            }
        }
        restoreScannerState(prevState);
        return dataok;
    }
    //
    // [??] intSubsetDecl = '[' (markupdecl | PEReference | S)* ']'
    //
    // [31] extSubsetDecl ::= ( markupdecl | conditionalSect | PEReference | S )*
    // [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'
    //
    // [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl
    //                     | NotationDecl | PI | Comment
    //
    // [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'
    //
    // [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
    //
    // [70] EntityDecl ::= GEDecl | PEDecl
    // [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
    // [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
    //
    // [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
    //
    // [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
    //
    // [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
    //
    // [61] conditionalSect ::= includeSect | ignoreSect
    // [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'
    // [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'
    // [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*
    // [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)
    //
    /**
     * Scan markup declarations
     *
     * @param extSubset true if the scanner is scanning an external subset, false
     *                  if it is scanning an internal subset
     * @exception java.lang.Exception
     */
    public void scanDecls(boolean extSubset) throws Exception
    {
        int subsetOffset = fEntityReader.currentOffset();
        if (extSubset)
            fExternalSubsetReader = fReaderId;
        fIncludeSectDepth = 0;
        boolean parseTextDecl = extSubset;
        int prevState = setScannerState(SCANNER_STATE_MARKUP_DECL);
        while (fScannerState == SCANNER_STATE_MARKUP_DECL) {

            boolean newParseTextDecl = false;
            if (!extSubset && fEntityReader.lookingAtChar(']', false)) {
                int subsetLength = fEntityReader.currentOffset() - subsetOffset;
                fDTDGrammar.internalSubset(fEntityReader.addString(subsetOffset, subsetLength));
                fEntityReader.lookingAtChar(']', true);
                restoreScannerState(prevState);
                return;
            }
            if (fEntityReader.lookingAtChar('<', true)) {
                int olddepth = markupDepth();
                increaseMarkupDepth();
                if (fEntityReader.lookingAtChar('!', true)) {
                    if (fEntityReader.lookingAtChar('-', true)) {
                        if (fEntityReader.lookingAtChar('-', true)) {
                            scanComment();
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                        XMLMessages.P29_NOT_RECOGNIZED);
                        }
                    } else if (fEntityReader.lookingAtChar('[', true) && getReadingExternalEntity()) {
                        checkForPEReference(false);
                        if (fEntityReader.skippedString(include_string)) {
                            checkForPEReference(false);
                            if (!fEntityReader.lookingAtChar('[', true)) {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                            XMLMessages.P29_NOT_RECOGNIZED);
                            } else {
                                fIncludeSectDepth++;
                            }
                        } else if (fEntityReader.skippedString(ignore_string)) {
                            checkForPEReference(false);
                            if (!fEntityReader.lookingAtChar('[', true)) {
                                abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                            XMLMessages.P29_NOT_RECOGNIZED);
                            } else
                                scanIgnoreSectContents();
                        } else {
                            abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                        XMLMessages.P29_NOT_RECOGNIZED);
                        }
                    } else if (fEntityReader.skippedString(element_string)) {
                        scanElementDecl();
                    }
                    else if (fEntityReader.skippedString(attlist_string))
                        scanAttlistDecl();
                    else if (fEntityReader.skippedString(entity_string))
                        scanEntityDecl();
                    else if (fEntityReader.skippedString(notation_string))
                        scanNotationDecl();
                    else {
                        abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                    XMLMessages.P29_NOT_RECOGNIZED);
                    }
                } else if (fEntityReader.lookingAtChar('?', true)) {
                    int piTarget = fEntityReader.scanName(' ');
                    if (piTarget == -1) {
                        abortMarkup(XMLMessages.MSG_PITARGET_REQUIRED,
                                    XMLMessages.P16_REQUIRED);
                    } else if (""xml"".equals(fStringPool.toString(piTarget))) {
                        if (fEntityReader.lookingAtSpace(true)) {
                            if (parseTextDecl) { // a TextDecl looks like a PI with the target 'xml'
                                scanTextDecl();
                            } else {
                                abortMarkup(XMLMessages.MSG_TEXTDECL_MUST_BE_FIRST,
                                            XMLMessages.P30_TEXTDECL_MUST_BE_FIRST);
                            }
                        } else { // a PI target matching 'xml'
                            abortMarkup(XMLMessages.MSG_RESERVED_PITARGET,
                                        XMLMessages.P17_RESERVED_PITARGET);
                        }
                    } else // PI
                        scanPI(piTarget);
                } else {
                    abortMarkup(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                XMLMessages.P29_NOT_RECOGNIZED);
                }
            } else if (fEntityReader.lookingAtSpace(true)) {
                fEntityReader.skipPastSpaces();
            } else if (fEntityReader.lookingAtChar('%', true)) {
                //
                // [69] PEReference ::= '%' Name ';'
                //
                int nameOffset = fEntityReader.currentOffset();
                fEntityReader.skipPastName(';');
                int nameLength = fEntityReader.currentOffset() - nameOffset;
                if (nameLength == 0) {
                    reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_NAME_REQUIRED);
                } else if (!fEntityReader.lookingAtChar(';', true)) {
                    reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_SEMICOLON_REQUIRED,
                                        fEntityReader.addString(nameOffset, nameLength));
                } else {
                    int peNameIndex = fEntityReader.addSymbol(nameOffset, nameLength);
                    newParseTextDecl = fEntityHandler.startReadingFromEntity(peNameIndex, markupDepth(), XMLEntityHandler.ENTITYREF_IN_DTD_AS_MARKUP);
                }
            } else if (fIncludeSectDepth > 0 && fEntityReader.lookingAtChar(']', true)) {
                if (!fEntityReader.lookingAtChar(']', true) || !fEntityReader.lookingAtChar('>', true)) {
                    abortMarkup(XMLMessages.MSG_INCLUDESECT_UNTERMINATED,
                                XMLMessages.P62_UNTERMINATED);
                } else
                    decreaseMarkupDepth();
                fIncludeSectDepth--;
            } else {
                if (!fEntityReader.lookingAtValidChar(false)) {
                    int invChar = fEntityReader.scanInvalidChar();
                    if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                        break;
                    if (invChar >= 0) {
                        if (!extSubset) {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_INTERNAL_SUBSET,
                                                XMLMessages.P28_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        } else {
                            reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_EXTERNAL_SUBSET,
                                                XMLMessages.P30_INVALID_CHARACTER,
                                                Integer.toHexString(invChar));
                        }
                    }
                } else {
                    reportFatalXMLError(XMLMessages.MSG_MARKUP_NOT_RECOGNIZED_IN_DTD,
                                        XMLMessages.P29_NOT_RECOGNIZED);
                    fEntityReader.lookingAtValidChar(true);
                }
            }
            parseTextDecl = newParseTextDecl;
        }
        if (extSubset) {

            ((DefaultEntityHandler) fEntityHandler).stopReadingFromExternalSubset();

            fDTDGrammar.stopReadingFromExternalSubset();
            fDTDGrammar.callEndDTD();
            // REVISIT: What should the namspace URI of a DTD be?
            fGrammarResolver.putGrammar("""", fDTDGrammar);
        }
    }
    //
    // [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*
    // [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)
    //
    private void scanIgnoreSectContents() throws Exception
    {
        int initialDepth = ++fIncludeSectDepth;
        while (true) {
            if (fEntityReader.lookingAtChar('<', true)) {
                //
                // These tests are split so that we handle cases like
                // '<<![' and '<!<![' which we might otherwise miss.
                //
                if (fEntityReader.lookingAtChar('!', true) && fEntityReader.lookingAtChar('[', true))
                    fIncludeSectDepth++;
            } else if (fEntityReader.lookingAtChar(']', true)) {
                //
                // The same thing goes for ']<![' and '<]]>', etc.
                //
                if (fEntityReader.lookingAtChar(']', true)) {
                    while (fEntityReader.lookingAtChar(']', true)) {
                        /* empty loop body */
                    }
                    if (fEntityReader.lookingAtChar('>', true)) {
                        if (fIncludeSectDepth-- == initialDepth) {
                            decreaseMarkupDepth();
                            return;
                        }
                    }
                }
            } else if (!fEntityReader.lookingAtValidChar(true)) {
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_IGNORESECT,
                                        XMLMessages.P65_INVALID_CHARACTER,
                                        Integer.toHexString(invChar));
                }
            }
        }
    }
    //
    // From the standard:
    //
    // [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    // [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
    //
    private void scanTextDecl() throws Exception {
        int version = -1;
        int encoding = -1;
        final int TEXTDECL_START = 0;
        final int TEXTDECL_VERSION = 1;
        final int TEXTDECL_ENCODING = 2;
        final int TEXTDECL_FINISHED = 3;
        int prevState = setScannerState(SCANNER_STATE_TEXTDECL);
        int state = TEXTDECL_START;
        do {
            fEntityReader.skipPastSpaces();
            int offset = fEntityReader.currentOffset();
            if (state == TEXTDECL_START && fEntityReader.skippedString(version_string)) {
                state = TEXTDECL_VERSION;
            } else if (fEntityReader.skippedString(encoding_string)) {
                state = TEXTDECL_ENCODING;
            } else {
                abortMarkup(XMLMessages.MSG_ENCODINGDECL_REQUIRED,
                            XMLMessages.P77_ENCODINGDECL_REQUIRED);
                restoreScannerState(prevState);
                return;
            }
            int length = fEntityReader.currentOffset() - offset;
            fEntityReader.skipPastSpaces();
            if (!fEntityReader.lookingAtChar('=', true)) {
                int minorCode = state == TEXTDECL_VERSION ?
                                XMLMessages.P24_EQ_REQUIRED :
                                XMLMessages.P80_EQ_REQUIRED;
                abortMarkup(XMLMessages.MSG_EQ_REQUIRED_IN_TEXTDECL, minorCode,
                            fEntityReader.addString(offset, length));
                restoreScannerState(prevState);
                return;
            }
            fEntityReader.skipPastSpaces();
            int result = fEntityReader.scanStringLiteral();
            switch (result) {
            case XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED:
            {
                int minorCode = state == TEXTDECL_VERSION ?
                                XMLMessages.P24_QUOTE_REQUIRED :
                                XMLMessages.P80_QUOTE_REQUIRED;
                abortMarkup(XMLMessages.MSG_QUOTE_REQUIRED_IN_TEXTDECL, minorCode,
                            fEntityReader.addString(offset, length));
                restoreScannerState(prevState);
                return;
            }
            case XMLEntityHandler.STRINGLIT_RESULT_INVALID_CHAR:
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState != SCANNER_STATE_END_OF_INPUT) {
                    if (invChar >= 0) {
                        int minorCode = state == TEXTDECL_VERSION ?
                                        XMLMessages.P26_INVALID_CHARACTER :
                                        XMLMessages.P81_INVALID_CHARACTER;
                        reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_TEXTDECL, minorCode,
                                            Integer.toHexString(invChar));
                    }
                    skipPastEndOfCurrentMarkup();
                    restoreScannerState(prevState);
                }
                return;
            default:
                break;
            }
            switch (state) {
            case TEXTDECL_VERSION:
                //
                // version=""...""
                //
                version = result;
                String versionString = fStringPool.toString(version);
                if (!""1.0"".equals(versionString)) {
                    if (!validVersionNum(versionString)) {
                        abortMarkup(XMLMessages.MSG_VERSIONINFO_INVALID,
                                    XMLMessages.P26_INVALID_VALUE,
                                    versionString);
                        restoreScannerState(prevState);
                        return;
                    }
                    // NOTE: RECOVERABLE ERROR
                    Object[] args = { versionString };
                    fErrorReporter.reportError(fErrorReporter.getLocator(),
                                               XMLMessages.XML_DOMAIN,
                                               XMLMessages.MSG_VERSION_NOT_SUPPORTED,
                                               XMLMessages.P26_NOT_SUPPORTED,
                                               args,
                                               XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
                    // REVISIT - hope it is a compatible version...
                    // skipPastEndOfCurrentMarkup();
                    // return;
                }
                if (!fEntityReader.lookingAtSpace(true)) {
                    abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_IN_TEXTDECL,
                                XMLMessages.P80_WHITESPACE_REQUIRED);
                    restoreScannerState(prevState);
                    return;
                }
                break;
            case TEXTDECL_ENCODING:
                //
                // encoding = ""...""
                //
                encoding = result;
                String encodingString = fStringPool.toString(encoding);
                if (!validEncName(encodingString)) {
                    abortMarkup(XMLMessages.MSG_ENCODINGDECL_INVALID,
                                XMLMessages.P81_INVALID_VALUE,
                                encodingString);
                    restoreScannerState(prevState);
                    return;
                }
                fEntityReader.skipPastSpaces();
                state = TEXTDECL_FINISHED;
                break;
            }
        } while (state != TEXTDECL_FINISHED);
        if (!fEntityReader.lookingAtChar('?', true) || !fEntityReader.lookingAtChar('>', true)) {
            abortMarkup(XMLMessages.MSG_TEXTDECL_UNTERMINATED,
                        XMLMessages.P77_UNTERMINATED);
            restoreScannerState(prevState);
            return;
        }
        decreaseMarkupDepth();
        fDTDGrammar.callTextDecl(version, encoding);
        restoreScannerState(prevState);
    }

    /**
     * Scans an element declaration.
     * <pre>
     * [45] elementdecl ::= '&lt;!ELEMENT' S Name S contentspec S? '&gt;'
     * </pre>
     */
    private void scanElementDecl() throws Exception {
        
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL,
                        XMLMessages.P45_SPACE_REQUIRED);
            return;
        }
        checkForElementTypeWithPEReference(fEntityReader, ' ', fElementQName);
        if (fElementQName.rawname == -1) {
            abortMarkup(XMLMessages.MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL,
                        XMLMessages.P45_ELEMENT_TYPE_REQUIRED);
            return;
        }
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL,
                        XMLMessages.P45_SPACE_REQUIRED,
                        fElementQName.rawname);
            return;
        }
        int contentSpecType = -1;
        int contentSpec = -1;
        if (fEntityReader.skippedString(empty_string)) {
            contentSpecType = XMLElementDecl.TYPE_EMPTY;
        } else if (fEntityReader.skippedString(any_string)) {
            contentSpecType = XMLElementDecl.TYPE_ANY;
        } else if (!fEntityReader.lookingAtChar('(', true)) {
            abortMarkup(XMLMessages.MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL,
                        XMLMessages.P45_CONTENTSPEC_REQUIRED,
                        fElementQName.rawname);
            return;
        } else {
            int contentSpecReader = fReaderId;
            int contentSpecReaderDepth = fEntityHandler.getReaderDepth();
            int prevState = setScannerState(SCANNER_STATE_CONTENTSPEC);
            int oldDepth = parenDepth();
            fEntityHandler.setReaderDepth(oldDepth);
            increaseParenDepth();
            checkForPEReference(false);
            boolean skippedPCDATA = fEntityReader.skippedString(pcdata_string);
            if (skippedPCDATA) {
                contentSpecType = XMLElementDecl.TYPE_MIXED;
                // REVISIT: Validation. Should we pass in QName?
                contentSpec = scanMixed(fElementQName);
            } else {
                contentSpecType = XMLElementDecl.TYPE_CHILDREN;
                // REVISIT: Validation. Should we pass in QName?
                contentSpec = scanChildren(fElementQName);
            }
            boolean success = contentSpec != -1;
            restoreScannerState(prevState);
            fEntityHandler.setReaderDepth(contentSpecReaderDepth);
            if (!success) {
                setParenDepth(oldDepth);
                skipPastEndOfCurrentMarkup();
                return;
            } else {
                if (parenDepth() != oldDepth) // REVISIT - should not be needed
                    // System.out.println(""nesting depth mismatch"");
                    ;
            }
        }
        checkForPEReference(false);
        if (!fEntityReader.lookingAtChar('>', true)) {
            abortMarkup(XMLMessages.MSG_ELEMENTDECL_UNTERMINATED,
                        XMLMessages.P45_UNTERMINATED,
                        fElementQName.rawname);
            return;
        }
        decreaseMarkupDepth();
        int elementIndex = fDTDGrammar.getElementDeclIndex(fElementQName.localpart, -1);
        boolean elementDeclIsExternal = getReadingExternalEntity();
        if (elementIndex == -1) {
            elementIndex = fDTDGrammar.addElementDecl(fElementQName, contentSpecType, contentSpec, elementDeclIsExternal);
            //System.out.println(""XMLDTDScanner#scanElementDecl->DTDGrammar#addElementDecl: ""+elementIndex+"" (""+fElementQName.localpart+"",""+fStringPool.toString(fElementQName.localpart)+')');
        }
        else {
            //now check if we already add this element Decl by foward reference
            fDTDGrammar.getElementDecl(elementIndex, fTempElementDecl);
            if (fTempElementDecl.type == -1) {
                fTempElementDecl.type = contentSpecType;
                fTempElementDecl.contentSpecIndex = contentSpec;
                fDTDGrammar.setElementDeclDTD(elementIndex, fTempElementDecl);
                fDTDGrammar.setElementDeclIsExternal(elementIndex, elementDeclIsExternal);
            }
            else {
                //REVISIT, valiate VC duplicate element type. 
                if ( fValidationEnabled )
                    //&& 
                    // (elemenetDeclIsExternal==fDTDGrammar.getElementDeclIsExternal(elementIndex)
                {

                    reportRecoverableXMLError(
                        XMLMessages.MSG_ELEMENT_ALREADY_DECLARED,
                        XMLMessages.VC_UNIQUE_ELEMENT_TYPE_DECLARATION,
                        fStringPool.toString(fElementQName.rawname)
                        );
                }
            }
        }

    } // scanElementDecl()

    
    /**
     * Scans mixed content model. Called after scanning past '(' S? '#PCDATA'
     * <pre>
     * [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'
     * </pre>
     */
    private int scanMixed(QName element) throws Exception {

        int valueIndex = -1;  // -1 is special value for #PCDATA
        int prevNodeIndex = -1;
        boolean starRequired = false;
        int[] valueSeen = new int[32];
        int valueCount = 0;
        boolean dupAttrType = false;
        int nodeIndex = -1;

        while (true) {
            if (fValidationEnabled) {
                for (int i=0; i<valueCount;i++) {
                    if ( valueSeen[i] == valueIndex) {
                        dupAttrType = true;
                        break;
                    }
                }
            }
            if (dupAttrType && fValidationEnabled) {
                reportRecoverableXMLError(XMLMessages.MSG_DUPLICATE_TYPE_IN_MIXED_CONTENT,
                                          XMLMessages.VC_NO_DUPLICATE_TYPES,
                                          valueIndex);
                dupAttrType = false;

            }
            else {
                try {
                    valueSeen[valueCount] = valueIndex;
                }
                catch (ArrayIndexOutOfBoundsException ae) {
                    int[] newArray = new int[valueSeen.length*2];
                    System.arraycopy(valueSeen,0,newArray,0,valueSeen.length);
                    valueSeen[valueCount] = valueIndex;
                }
                valueCount++;

                nodeIndex = fDTDGrammar.addUniqueLeafNode(valueIndex);
            }

            checkForPEReference(false);
            if (!fEntityReader.lookingAtChar('|', true)) {
                if (!fEntityReader.lookingAtChar(')', true)) {
                    reportFatalXMLError(XMLMessages.MSG_CLOSE_PAREN_REQUIRED_IN_MIXED,
                                        XMLMessages.P51_CLOSE_PAREN_REQUIRED,
                                        element.rawname);
                    return -1;
                }
                decreaseParenDepth();
                if (nodeIndex == -1) {
                    nodeIndex = prevNodeIndex;
                } else if (prevNodeIndex != -1) {
                    nodeIndex = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE, prevNodeIndex, nodeIndex);
                }
                if (fEntityReader.lookingAtChar('*', true)) {
                    nodeIndex = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE, nodeIndex);
                } else if (starRequired) {
                    reportFatalXMLError(XMLMessages.MSG_MIXED_CONTENT_UNTERMINATED,
                                        XMLMessages.P51_UNTERMINATED,
                                        fStringPool.toString(element.rawname),
                                        fDTDGrammar.getContentSpecNodeAsString(nodeIndex));
                    return -1;
                }
                return nodeIndex;
            }
            if (nodeIndex != -1) {
                if (prevNodeIndex != -1) {
                    nodeIndex = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE, prevNodeIndex, nodeIndex);
                }
                prevNodeIndex = nodeIndex;
            }
            starRequired = true;
            checkForPEReference(false);
            checkForElementTypeWithPEReference(fEntityReader, ')', fElementRefQName);
            valueIndex = fElementRefQName.rawname;
            if (valueIndex == -1) {
                reportFatalXMLError(XMLMessages.MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT,
                                    XMLMessages.P51_ELEMENT_TYPE_REQUIRED,
                                    element.rawname);
                return -1;
            }
        }

    } // scanMixed(QName):int
    
    /**
     * Scans a children content model.
     * <pre>
     * [47] children ::= (choice | seq) ('?' | '*' | '+')?
     * [49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'
     * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
     * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
     * </pre>
     */
    private int scanChildren(QName element) throws Exception {
        
        int depth = 1;
        initializeContentModelStack(depth);
        while (true) {
            if (fEntityReader.lookingAtChar('(', true)) {
                increaseParenDepth();
                checkForPEReference(false);
                depth++;
                initializeContentModelStack(depth);
                continue;
            }
            checkForElementTypeWithPEReference(fEntityReader, ')', fElementRefQName);
            int valueIndex = fElementRefQName.rawname;
            if (valueIndex == -1) {
                reportFatalXMLError(XMLMessages.MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN,
                                    XMLMessages.P47_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED,
                                    element.rawname);
                return -1;
            }
            fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_LEAF, valueIndex);
            if (fEntityReader.lookingAtChar('?', true)) {
                fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE, fNodeIndexStack[depth]);
            } else if (fEntityReader.lookingAtChar('*', true)) {
                fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE, fNodeIndexStack[depth]);
            } else if (fEntityReader.lookingAtChar('+', true)) {
                fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE, fNodeIndexStack[depth]);
            }
            while (true) {
                checkForPEReference(false);
                if (fOpStack[depth] != XMLContentSpec.CONTENTSPECNODE_SEQ && fEntityReader.lookingAtChar('|', true)) {
                    if (fPrevNodeIndexStack[depth] != -1) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(fOpStack[depth], fPrevNodeIndexStack[depth], fNodeIndexStack[depth]);
                    }
                    fPrevNodeIndexStack[depth] = fNodeIndexStack[depth];
                    fOpStack[depth] = XMLContentSpec.CONTENTSPECNODE_CHOICE;
                    break;
                } else if (fOpStack[depth] != XMLContentSpec.CONTENTSPECNODE_CHOICE && fEntityReader.lookingAtChar(',', true)) {
                    if (fPrevNodeIndexStack[depth] != -1) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(fOpStack[depth], fPrevNodeIndexStack[depth], fNodeIndexStack[depth]);
                    }
                    fPrevNodeIndexStack[depth] = fNodeIndexStack[depth];
                    fOpStack[depth] = XMLContentSpec.CONTENTSPECNODE_SEQ;
                    break;
                } else {
                    if (!fEntityReader.lookingAtChar(')', true)) {
                        reportFatalXMLError(XMLMessages.MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN,
                                            XMLMessages.P47_CLOSE_PAREN_REQUIRED,
                                            element.rawname);
                    }
                    decreaseParenDepth();
                    if (fPrevNodeIndexStack[depth] != -1) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(fOpStack[depth], fPrevNodeIndexStack[depth], fNodeIndexStack[depth]);
                    }
                    int nodeIndex = fNodeIndexStack[depth--];
                    fNodeIndexStack[depth] = nodeIndex;
                    if (fEntityReader.lookingAtChar('?', true)) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE, fNodeIndexStack[depth]);
                    } else if (fEntityReader.lookingAtChar('*', true)) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE, fNodeIndexStack[depth]);
                    } else if (fEntityReader.lookingAtChar('+', true)) {
                        fNodeIndexStack[depth] = fDTDGrammar.addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE, fNodeIndexStack[depth]);
                    }
                    if (depth == 0) {
                        return fNodeIndexStack[0];
                    }
                }
            }
            checkForPEReference(false);
        }

    } // scanChildren(QName):int

    //
    // [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
    // [53] AttDef ::= S Name S AttType S DefaultDecl
    // [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
    //
    private void scanAttlistDecl() throws Exception
    {
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL,
                        XMLMessages.P52_SPACE_REQUIRED);
            return;
        }
        checkForElementTypeWithPEReference(fEntityReader, ' ', fElementQName);
        int elementTypeIndex = fElementQName.rawname;
        if (elementTypeIndex == -1) {
            abortMarkup(XMLMessages.MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL,
                        XMLMessages.P52_ELEMENT_TYPE_REQUIRED);
            return;
        }
        int elementIndex = fDTDGrammar.getElementDeclIndex(fElementQName.localpart, -1);
        if (elementIndex == -1) {
            elementIndex = fDTDGrammar.addElementDecl(fElementQName);
            //System.out.println(""XMLDTDScanner#scanAttListDecl->DTDGrammar#addElementDecl: ""+elementIndex+"" (""+fElementQName.localpart+"",""+fStringPool.toString(fElementQName.localpart)+')');
        }
        boolean sawSpace = checkForPEReference(true);
        if (fEntityReader.lookingAtChar('>', true)) {
            decreaseMarkupDepth();
            return;
        }
        // REVISIT - review this code...
        if (!sawSpace) {
            if (fEntityReader.lookingAtSpace(true)) {
                fEntityReader.skipPastSpaces();
            } else
                reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF,
                                    XMLMessages.P53_SPACE_REQUIRED);
        } else {
            if (fEntityReader.lookingAtSpace(true)) {
                fEntityReader.skipPastSpaces();
            }
        }
        if (fEntityReader.lookingAtChar('>', true)) {
            decreaseMarkupDepth();
            return;
        }
        while (true) {
            checkForAttributeNameWithPEReference(fEntityReader, ' ', fAttributeQName);
            int attDefName = fAttributeQName.rawname;
            if (attDefName == -1) {
                abortMarkup(XMLMessages.MSG_ATTRIBUTE_NAME_REQUIRED_IN_ATTDEF,
                            XMLMessages.P53_NAME_REQUIRED,
                            fElementQName.rawname);
                return;
            }
            if (!checkForPEReference(true)) {
                abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF,
                            XMLMessages.P53_SPACE_REQUIRED);
                return;
            }
            int attDefType = -1;
            boolean attDefList = false;
            int attDefEnumeration = -1;
            if (fEntityReader.skippedString(cdata_string)) {
                attDefType = XMLAttributeDecl.TYPE_CDATA;
            } else if (fEntityReader.skippedString(id_string)) {
                if (!fEntityReader.skippedString(ref_string)) {
                    attDefType = XMLAttributeDecl.TYPE_ID;
                } else if (!fEntityReader.lookingAtChar('S', true)) {
                    attDefType = XMLAttributeDecl.TYPE_IDREF;
                } else {
                    attDefType = XMLAttributeDecl.TYPE_IDREF;
                    attDefList = true;
                }
            } else if (fEntityReader.skippedString(entit_string)) {
                if (fEntityReader.lookingAtChar('Y', true)) {
                    attDefType = XMLAttributeDecl.TYPE_ENTITY;
                } else if (fEntityReader.skippedString(ies_string)) {
                    attDefType = XMLAttributeDecl.TYPE_ENTITY;
                    attDefList = true;
                } else {
                    abortMarkup(XMLMessages.MSG_ATTTYPE_REQUIRED_IN_ATTDEF,
                                XMLMessages.P53_ATTTYPE_REQUIRED,
                                elementTypeIndex, attDefName);
                    return;
                }
            } else if (fEntityReader.skippedString(nmtoken_string)) {
                if (fEntityReader.lookingAtChar('S', true)) {
                    attDefType = XMLAttributeDecl.TYPE_NMTOKEN;
                    attDefList = true;
                } else {
                    attDefType = XMLAttributeDecl.TYPE_NMTOKEN;
                }
            } else if (fEntityReader.skippedString(notation_string)) {
                if (!checkForPEReference(true)) {
                    abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE,
                                XMLMessages.P58_SPACE_REQUIRED,
                                elementTypeIndex, attDefName);
                    return;
                }
                if (!fEntityReader.lookingAtChar('(', true)) {
                    abortMarkup(XMLMessages.MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE,
                                XMLMessages.P58_OPEN_PAREN_REQUIRED,
                                elementTypeIndex, attDefName);
                    return;
                }
                increaseParenDepth();
                attDefType = XMLAttributeDecl.TYPE_NOTATION;
                attDefEnumeration = scanEnumeration(elementTypeIndex, attDefName, true);
                if (attDefEnumeration == -1) {
                    skipPastEndOfCurrentMarkup();
                    return;
                }
            } else if (fEntityReader.lookingAtChar('(', true)) {
                increaseParenDepth();
                attDefType = XMLAttributeDecl.TYPE_ENUMERATION;
                attDefEnumeration = scanEnumeration(elementTypeIndex, attDefName, false);
                if (attDefEnumeration == -1) {
                    skipPastEndOfCurrentMarkup();
                    return;
                }
            } else {
                abortMarkup(XMLMessages.MSG_ATTTYPE_REQUIRED_IN_ATTDEF,
                            XMLMessages.P53_ATTTYPE_REQUIRED,
                            elementTypeIndex, attDefName);
                return;
            }
            if (!checkForPEReference(true)) {
                abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF,
                            XMLMessages.P53_SPACE_REQUIRED,
                            elementTypeIndex, attDefName);
                return;
            }
            int attDefDefaultType = -1;
            int attDefDefaultValue = -1;
            if (fEntityReader.skippedString(required_string)) {
                attDefDefaultType = XMLAttributeDecl.DEFAULT_TYPE_REQUIRED;
            } else if (fEntityReader.skippedString(implied_string)) {
                attDefDefaultType = XMLAttributeDecl.DEFAULT_TYPE_IMPLIED;
            } else {
                if (fEntityReader.skippedString(fixed_string)) {
                    if (!fEntityReader.lookingAtSpace(true)) {
                        abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL,
                                    XMLMessages.P60_SPACE_REQUIRED,
                                    elementTypeIndex, attDefName);
                        return;
                    }
                    fEntityReader.skipPastSpaces();
                    attDefDefaultType = XMLAttributeDecl.DEFAULT_TYPE_FIXED;
                } else
                    attDefDefaultType = XMLAttributeDecl.DEFAULT_TYPE_DEFAULT;
                fElementQName.setValues(-1, elementTypeIndex, elementTypeIndex);
                fAttributeQName.setValues(-1, attDefName, attDefName);
                attDefDefaultValue = scanDefaultAttValue(fElementQName, fAttributeQName, 
                                                         attDefType, 
                                                         attDefEnumeration);

                //normalize and check VC: Attribute Default Legal
                if (attDefDefaultValue != -1 && attDefType != XMLAttributeDecl.TYPE_CDATA ) {
                    attDefDefaultValue = normalizeDefaultAttValue( fAttributeQName, attDefDefaultValue, 
                                                                attDefType, attDefEnumeration,
                                                                attDefList);
                }

                if (attDefDefaultValue == -1) {
                    skipPastEndOfCurrentMarkup();
                    return;
                }
            }
            if (attDefName == fXMLSpace) {
                boolean ok = false;
                if (attDefType == XMLAttributeDecl.TYPE_ENUMERATION) {
                    int index = attDefEnumeration;
                    if (index != -1) {
                        ok = fStringPool.stringListLength(index) == 2 &&
                             fStringPool.stringInList(index, fDefault) &&
                             fStringPool.stringInList(index, fPreserve);
                    }
                }
                if (!ok) {
                    reportFatalXMLError(XMLMessages.MSG_XML_SPACE_DECLARATION_ILLEGAL,
                                        XMLMessages.S2_10_DECLARATION_ILLEGAL,
                                        elementTypeIndex);
                }
            }
            sawSpace = checkForPEReference(true);
            if (fEntityReader.lookingAtChar('>', true)) {
                int attDefIndex = addAttDef(fElementQName, fAttributeQName, 
                                                        attDefType, attDefList, attDefEnumeration, 
                                                        attDefDefaultType, attDefDefaultValue, 
                                                        getReadingExternalEntity());
                //System.out.println(""XMLDTDScanner#scanAttlistDecl->DTDGrammar#addAttDef: ""+attDefIndex+
                //                   "" (""+fElementQName.localpart+"",""+fStringPool.toString(fElementQName.rawname)+')'+
                //                   "" (""+fAttributeQName.localpart+"",""+fStringPool.toString(fAttributeQName.rawname)+')');
                decreaseMarkupDepth();
                return;
            }
            // REVISIT - review this code...
            if (!sawSpace) {
                if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                } else
                    reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF,
                                        XMLMessages.P53_SPACE_REQUIRED);
            } else {
                if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                }
            }
            if (fEntityReader.lookingAtChar('>', true)) {
                int attDefIndex = addAttDef(fElementQName, fAttributeQName, 
                                                        attDefType, attDefList, attDefEnumeration, 
                                                        attDefDefaultType, attDefDefaultValue,
                                                        getReadingExternalEntity() );
                //System.out.println(""XMLDTDScanner#scanAttlistDecl->DTDGrammar#addAttDef: ""+attDefIndex+
                //                   "" (""+fElementQName.localpart+"",""+fStringPool.toString(fElementQName.rawname)+')'+
                //                   "" (""+fAttributeQName.localpart+"",""+fStringPool.toString(fAttributeQName.rawname)+')');
                decreaseMarkupDepth();
                return;
            }
            int attDefIndex = addAttDef(fElementQName, fAttributeQName, 
                                                    attDefType, attDefList, attDefEnumeration, 
                                                    attDefDefaultType, attDefDefaultValue,
                                                    getReadingExternalEntity());
            //System.out.println(""XMLDTDScanner#scanAttlistDecl->DTDGrammar#addAttDef: ""+attDefIndex+
            //                   "" (""+fElementQName.localpart+"",""+fStringPool.toString(fElementQName.rawname)+')'+
            //                   "" (""+fAttributeQName.localpart+"",""+fStringPool.toString(fAttributeQName.rawname)+')');
        }
    }

    private int addAttDef(QName element, QName attribute, 
                          int attDefType, boolean attDefList, int attDefEnumeration, 
                          int attDefDefaultType, int attDefDefaultValue,
                          boolean isExternal ) throws Exception {

        int elementIndex = fDTDGrammar.getElementDeclIndex(element.localpart, -1);
        if (elementIndex == -1) {
            // REPORT Internal error here
        }
        else {
            int attlistIndex = fDTDGrammar.getFirstAttributeDeclIndex(elementIndex);
            int dupID = -1;
            int dupNotation = -1;
            while (attlistIndex != -1) {
                fDTDGrammar.getAttributeDecl(attlistIndex, fTempAttributeDecl);

                // REVISIT: Validation. Attributes are also tuples.
                if (fStringPool.equalNames(fTempAttributeDecl.name.rawname, attribute.rawname)) {
                    /******
                    if (fWarningOnDuplicateAttDef) {
                        Object[] args = { fStringPool.toString(fElementType[elemChunk][elemIndex]),
                                          fStringPool.toString(attributeDecl.rawname) };
                        fErrorReporter.reportError(fErrorReporter.getLocator(),
                                                   XMLMessages.XML_DOMAIN,
                                                   XMLMessages.MSG_DUPLICATE_ATTDEF,
                                                   XMLMessages.P53_DUPLICATE,
                                                   args,
                                                   XMLErrorReporter.ERRORTYPE_WARNING);
                    }
                    ******/
                    return -1;
                }

                if (fValidationEnabled) {
                    if (attDefType == XMLAttributeDecl.TYPE_ID && 
                        fTempAttributeDecl.type == XMLAttributeDecl.TYPE_ID ) {
                        dupID = fTempAttributeDecl.name.rawname;
                    }
                    if (attDefType == XMLAttributeDecl.TYPE_NOTATION 
                        && fTempAttributeDecl.type == XMLAttributeDecl.TYPE_NOTATION) {
                        dupNotation = fTempAttributeDecl.name.rawname;
                    }
                }
                attlistIndex = fDTDGrammar.getNextAttributeDeclIndex(attlistIndex);
            }
            if (fValidationEnabled) {
                if (dupID != -1) {
                    Object[] args = { fStringPool.toString(element.rawname),
                                      fStringPool.toString(dupID),
                                      fStringPool.toString(attribute.rawname) };
                    fErrorReporter.reportError(fErrorReporter.getLocator(),
                                               XMLMessages.XML_DOMAIN,
                                               XMLMessages.MSG_MORE_THAN_ONE_ID_ATTRIBUTE,
                                               XMLMessages.VC_ONE_ID_PER_ELEMENT_TYPE,
                                               args,
                                               XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
                    return -1;
                }
                if (dupNotation != -1) {
                    Object[] args = { fStringPool.toString(element.rawname),
                                      fStringPool.toString(dupNotation),
                                      fStringPool.toString(attribute.rawname) };
                    fErrorReporter.reportError(fErrorReporter.getLocator(),
                                               XMLMessages.XML_DOMAIN,
                                               XMLMessages.MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE,
                                               XMLMessages.VC_ONE_NOTATION_PER_ELEMENT_TYPE,
                                               args,
                                               XMLErrorReporter.ERRORTYPE_RECOVERABLE_ERROR);
                    return -1;
                }
            }
        }
        return fDTDGrammar.addAttDef(element, attribute, 
                                     attDefType, attDefList, attDefEnumeration, 
                                     attDefDefaultType, attDefDefaultValue,
                                     isExternal);

    }
    //
    // [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
    // [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'
    //
    private int scanEnumeration(int elementType, int attrName, boolean isNotationType) throws Exception
    {
        int enumIndex = fDTDGrammar.startEnumeration();
        while (true) {
            checkForPEReference(false);
            int nameIndex = isNotationType ?
                            checkForNameWithPEReference(fEntityReader, ')') :
                            checkForNmtokenWithPEReference(fEntityReader, ')');
            if (nameIndex == -1) {
                if (isNotationType) {
                    reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_NOTATIONTYPE,
                                        XMLMessages.P58_NAME_REQUIRED,
                                        elementType,
                                        attrName);
                } else {
                    reportFatalXMLError(XMLMessages.MSG_NMTOKEN_REQUIRED_IN_ENUMERATION,
                                        XMLMessages.P59_NMTOKEN_REQUIRED,
                                        elementType,
                                        attrName);
                }
                fDTDGrammar.endEnumeration(enumIndex);
                return -1;
            }
            fDTDGrammar.addNameToEnumeration(enumIndex, elementType, attrName, nameIndex, isNotationType);
            /*****/
            if (isNotationType && !((DefaultEntityHandler)fEntityHandler).isNotationDeclared(nameIndex)) {
                Object[] args = { fStringPool.toString(elementType),
                    fStringPool.toString(attrName),
                    fStringPool.toString(nameIndex) };
                    ((DefaultEntityHandler)fEntityHandler).addRequiredNotation(nameIndex,
                                                       fErrorReporter.getLocator(),
                                                       XMLMessages.MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE,
                                                       XMLMessages.VC_NOTATION_DECLARED,
                                                       args);
            }
            /*****/
            checkForPEReference(false);
            if (!fEntityReader.lookingAtChar('|', true)) {
                fDTDGrammar.endEnumeration(enumIndex);
                if (!fEntityReader.lookingAtChar(')', true)) {
                    if (isNotationType) {
                        reportFatalXMLError(XMLMessages.MSG_NOTATIONTYPE_UNTERMINATED,
                                            XMLMessages.P58_UNTERMINATED,
                                        elementType,
                                        attrName);
                    } else {
                        reportFatalXMLError(XMLMessages.MSG_ENUMERATION_UNTERMINATED,
                                            XMLMessages.P59_UNTERMINATED,
                                        elementType,
                                        attrName);
                    }
                    return -1;
                }
                decreaseParenDepth();
                return enumIndex;
            }
        }
    }
    //
    // [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    //                   | ""'"" ([^<&'] | Reference)* ""'""
    //
    /**
     * Scan the default value in an attribute declaration
     *
     * @param elementType handle to the element that owns the attribute
     * @param attrName handle in the string pool for the attribute name
     * @return handle in the string pool for the default attribute value
     * @exception java.lang.Exception
     */
    public int scanDefaultAttValue(QName element, QName attribute) throws Exception
    {
        boolean single;
        if (!(single = fEntityReader.lookingAtChar('\'', true)) && !fEntityReader.lookingAtChar('\""', true)) {
            reportFatalXMLError(XMLMessages.MSG_QUOTE_REQUIRED_IN_ATTVALUE,
                                XMLMessages.P10_QUOTE_REQUIRED,
                                element.rawname,
                                attribute.rawname);
            return -1;
        }
        int previousState = setScannerState(SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE);
        char qchar = single ? '\'' : '\""';
        fDefaultAttValueReader = fReaderId;
        fDefaultAttValueElementType = element.rawname;
        fDefaultAttValueAttrName = attribute.rawname;
        boolean setMark = true;
        int dataOffset = fLiteralData.length();
        while (true) {
            fDefaultAttValueOffset = fEntityReader.currentOffset();
            if (setMark) {
                fDefaultAttValueMark = fDefaultAttValueOffset;
                setMark = false;
            }
            if (fEntityReader.lookingAtChar(qchar, true)) {
                if (fReaderId == fDefaultAttValueReader)
                    break;
                continue;
            }
            if (fEntityReader.lookingAtChar(' ', true)) {
                continue;
            }
            boolean skippedCR;
            if ((skippedCR = fEntityReader.lookingAtChar((char)0x0D, true)) || fEntityReader.lookingAtSpace(true)) {
                if (fDefaultAttValueOffset - fDefaultAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
                setMark = true;
                fLiteralData.append(' ');
                if (skippedCR)
                    fEntityReader.lookingAtChar((char)0x0A, true);
                continue;
            }
            if (fEntityReader.lookingAtChar('&', true)) {
                if (fDefaultAttValueOffset - fDefaultAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
                setMark = true;
                //
                // Check for character reference first.
                //
                if (fEntityReader.lookingAtChar('#', true)) {
                    int ch = scanCharRef();
                    if (ch != -1) {
                        if (ch < 0x10000)
                            fLiteralData.append((char)ch);
                        else {
                            fLiteralData.append((char)(((ch-0x00010000)>>10)+0xd800));
                            fLiteralData.append((char)(((ch-0x00010000)&0x3ff)+0xdc00));
                        }
                    }
                } else {
                    //
                    // Entity reference
                    //
                    int nameOffset = fEntityReader.currentOffset();
                    fEntityReader.skipPastName(';');
                    int nameLength = fEntityReader.currentOffset() - nameOffset;
                    if (nameLength == 0) {
                        reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_NAME_REQUIRED);
                    } else if (!fEntityReader.lookingAtChar(';', true)) {
                        reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_SEMICOLON_REQUIRED,
                                            fEntityReader.addString(nameOffset, nameLength));
                    } else {
                        int entityNameIndex = fEntityReader.addSymbol(nameOffset, nameLength);
                        fEntityHandler.startReadingFromEntity(entityNameIndex, markupDepth(), XMLEntityHandler.ENTITYREF_IN_DEFAULTATTVALUE);
                    }
                }
                continue;
            }
            if (fEntityReader.lookingAtChar('<', true)) {
                if (fDefaultAttValueOffset - fDefaultAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
                setMark = true;
                reportFatalXMLError(XMLMessages.MSG_LESSTHAN_IN_ATTVALUE,
                                    XMLMessages.WFC_NO_LESSTHAN_IN_ATTVALUE,
                                    element.rawname,
                                    attribute.rawname);
                continue;
            }
            //
            // REVISIT - HACK !!!  code added to pass incorrect OASIS test 'valid-sa-094'
            //  Remove this next section to conform to the spec...
            //
            if (!getReadingExternalEntity() && fEntityReader.lookingAtChar('%', true)) {
                int nameOffset = fEntityReader.currentOffset();
                fEntityReader.skipPastName(';');
                int nameLength = fEntityReader.currentOffset() - nameOffset;
                if (nameLength != 0 && fEntityReader.lookingAtChar(';', true)) {
                    reportFatalXMLError(XMLMessages.MSG_PEREFERENCE_WITHIN_MARKUP,
                                        XMLMessages.WFC_PES_IN_INTERNAL_SUBSET,
                                        fEntityReader.addString(nameOffset, nameLength));
                }
            }
            //
            // END HACK !!!
            //
            if (!fEntityReader.lookingAtValidChar(true)) {
                if (fDefaultAttValueOffset - fDefaultAttValueMark > 0)
                    fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
                setMark = true;
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return -1;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_ATTVALUE,
                                        XMLMessages.P10_INVALID_CHARACTER,
                                        fStringPool.toString(element.rawname),
                                        fStringPool.toString(attribute.rawname),
                                        Integer.toHexString(invChar));
                }
                continue;
            }
        }
        restoreScannerState(previousState);
        int dataLength = fLiteralData.length() - dataOffset;
        if (dataLength == 0) {
            return fEntityReader.addString(fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
        }
        if (fDefaultAttValueOffset - fDefaultAttValueMark > 0) {
            fEntityReader.append(fLiteralData, fDefaultAttValueMark, fDefaultAttValueOffset - fDefaultAttValueMark);
            dataLength = fLiteralData.length() - dataOffset;
        }
        return fLiteralData.addString(dataOffset, dataLength);
    }
    //
    // [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
    //
    private void scanNotationDecl() throws Exception
    {
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL,
                        XMLMessages.P82_SPACE_REQUIRED);
            return;
        }
        int notationName = checkForNameWithPEReference(fEntityReader, ' ');
        if (notationName == -1) {
            abortMarkup(XMLMessages.MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL,
                        XMLMessages.P82_NAME_REQUIRED);
            return;
        }
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL,
                        XMLMessages.P82_SPACE_REQUIRED,
                        notationName);
            return;
        }
        if (!scanExternalID(true)) {
            skipPastEndOfCurrentMarkup();
            return;
        }
        checkForPEReference(false);
        if (!fEntityReader.lookingAtChar('>', true)) {
            abortMarkup(XMLMessages.MSG_NOTATIONDECL_UNTERMINATED,
                        XMLMessages.P82_UNTERMINATED,
                        notationName);
            return;
        }
        decreaseMarkupDepth();
        /****
        System.out.println(fStringPool.toString(notationName)+"",""
                           +fStringPool.toString(fPubidLiteral) + "",""
                           +fStringPool.toString(fSystemLiteral) + "",""
                           +getReadingExternalEntity());
        /****/

        int notationIndex = ((DefaultEntityHandler) fEntityHandler).addNotationDecl( notationName, 
                                                                                     fPubidLiteral, 
                                                                                     fSystemLiteral,
                                                                                     getReadingExternalEntity());
        fDTDGrammar.addNotationDecl(notationName, fPubidLiteral, fSystemLiteral);
    }
    //
    // [70] EntityDecl ::= GEDecl | PEDecl
    // [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
    // [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
    // [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
    // [74] PEDef ::= EntityValue | ExternalID
    // [75] ExternalID ::= 'SYSTEM' S SystemLiteral
    //                     | 'PUBLIC' S PubidLiteral S SystemLiteral
    // [76] NDataDecl ::= S 'NDATA' S Name
    //  [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                      | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    // Called after scanning 'ENTITY'
    //
    private void scanEntityDecl() throws Exception
    {
        boolean isPEDecl = false;
        boolean sawPERef = false;
        if (fEntityReader.lookingAtSpace(true)) {
            fEntityReader.skipPastSpaces();
            if (!fEntityReader.lookingAtChar('%', true)) {
                isPEDecl = false; // <!ENTITY x ""x"">
            } else if (fEntityReader.lookingAtSpace(true)) {
                checkForPEReference(false); // <!ENTITY % x ""x"">
                isPEDecl = true;
            } else if (!getReadingExternalEntity()) {
                reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL,
                                    XMLMessages.P72_SPACE);
                isPEDecl = true;
            } else if (fEntityReader.lookingAtChar('%', false)) {
                checkForPEReference(false); // <!ENTITY %%x; ""x""> is legal
                isPEDecl = true;
            } else {
                sawPERef = true;
            }
        } else if (!getReadingExternalEntity() || !fEntityReader.lookingAtChar('%', true)) {
            // <!ENTITY[^ ]...> or <!ENTITY[^ %]...>
            reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL,
                                XMLMessages.P70_SPACE);
            isPEDecl = false;
        } else if (fEntityReader.lookingAtSpace(false)) {
            // <!ENTITY% ...>
            reportFatalXMLError(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL,
                                XMLMessages.P72_SPACE);
            isPEDecl = false;
        } else {
            sawPERef = true;
        }
        if (sawPERef) {
            while (true) {
                int nameOffset = fEntityReader.currentOffset();
                fEntityReader.skipPastName(';');
                int nameLength = fEntityReader.currentOffset() - nameOffset;
                if (nameLength == 0) {
                    reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_NAME_REQUIRED);
                } else if (!fEntityReader.lookingAtChar(';', true)) {
                    reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_SEMICOLON_REQUIRED,
                                        fEntityReader.addString(nameOffset, nameLength));
                } else {
                    int peNameIndex = fEntityReader.addSymbol(nameOffset, nameLength);
                    int readerDepth = (fScannerState == SCANNER_STATE_CONTENTSPEC) ? parenDepth() : markupDepth();
                    fEntityHandler.startReadingFromEntity(peNameIndex, readerDepth, XMLEntityHandler.ENTITYREF_IN_DTD_WITHIN_MARKUP);
                }
                fEntityReader.skipPastSpaces();
                if (!fEntityReader.lookingAtChar('%', true))
                    break;
                if (!isPEDecl) {
                    if (fEntityReader.lookingAtSpace(true)) {
                        checkForPEReference(false);
                        isPEDecl = true;
                        break;
                    }
                    isPEDecl = fEntityReader.lookingAtChar('%', true);
                }
            }
        }
        int entityName = checkForNameWithPEReference(fEntityReader, ' ');
        if (entityName == -1) {
            abortMarkup(XMLMessages.MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL,
                        XMLMessages.P70_REQUIRED_NAME);
            return;
        }
        if (!fDTDGrammar.startEntityDecl(isPEDecl, entityName)) {
            skipPastEndOfCurrentMarkup();
            return;
        }
        if (!checkForPEReference(true)) {
            abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL,
                        XMLMessages.P70_REQUIRED_SPACE,
                        entityName);
            fDTDGrammar.endEntityDecl();
            return;
        }
        if (isPEDecl) {
            boolean single;
            if ((single = fEntityReader.lookingAtChar('\'', true)) || fEntityReader.lookingAtChar('\""', true)) {
                int value = scanEntityValue(single);
                if (value == -1) {
                    skipPastEndOfCurrentMarkup();
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                checkForPEReference(false);
                if (!fEntityReader.lookingAtChar('>', true)) {
                    abortMarkup(XMLMessages.MSG_ENTITYDECL_UNTERMINATED,
                                XMLMessages.P72_UNTERMINATED,
                                entityName);
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                decreaseMarkupDepth();
                fDTDGrammar.endEntityDecl();

                // a hack by Eric
                //REVISIT
                fDTDGrammar.addInternalPEDecl(entityName, value);
                int entityIndex = ((DefaultEntityHandler) fEntityHandler).addInternalPEDecl(entityName, 
                                                                                            value, 
                                                                                            getReadingExternalEntity());

            } else {
                if (!scanExternalID(false)) {
                    skipPastEndOfCurrentMarkup();
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                checkForPEReference(false);
                if (!fEntityReader.lookingAtChar('>', true)) {
                    abortMarkup(XMLMessages.MSG_ENTITYDECL_UNTERMINATED,
                                XMLMessages.P72_UNTERMINATED,
                                entityName);
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                decreaseMarkupDepth();
                fDTDGrammar.endEntityDecl();

                //a hack by Eric
                //REVISIT
                fDTDGrammar.addExternalPEDecl(entityName, fPubidLiteral, fSystemLiteral);
                int entityIndex = ((DefaultEntityHandler) fEntityHandler).addExternalPEDecl(entityName, 
                                                                                            fPubidLiteral, 
                                                                                            fSystemLiteral, getReadingExternalEntity());
            }
        } else {
            boolean single;
            if ((single = fEntityReader.lookingAtChar('\'', true)) || fEntityReader.lookingAtChar('\""', true)) {
                int value = scanEntityValue(single);
                if (value == -1) {
                    skipPastEndOfCurrentMarkup();
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                checkForPEReference(false);
                if (!fEntityReader.lookingAtChar('>', true)) {
                    abortMarkup(XMLMessages.MSG_ENTITYDECL_UNTERMINATED,
                                XMLMessages.P71_UNTERMINATED,
                                entityName);
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                decreaseMarkupDepth();
                fDTDGrammar.endEntityDecl();

                //a hack by Eric
                //REVISIT
                fDTDGrammar.addInternalEntityDecl(entityName, value);
                int entityIndex = ((DefaultEntityHandler) fEntityHandler).addInternalEntityDecl(entityName, 
                                                                                                value, 
                                                                                                getReadingExternalEntity());
            } else {
                if (!scanExternalID(false)) {
                    skipPastEndOfCurrentMarkup();
                    fDTDGrammar.endEntityDecl();
                    return;
                }
                boolean unparsed = false;
                if (fEntityReader.lookingAtSpace(true)) {
                    fEntityReader.skipPastSpaces();
                    unparsed = fEntityReader.skippedString(ndata_string);
                }
                if (!unparsed) {
                    checkForPEReference(false);
                    if (!fEntityReader.lookingAtChar('>', true)) {
                        abortMarkup(XMLMessages.MSG_ENTITYDECL_UNTERMINATED,
                                    XMLMessages.P72_UNTERMINATED,
                                    entityName);
                        fDTDGrammar.endEntityDecl();
                        return;
                    }
                    decreaseMarkupDepth();
                    fDTDGrammar.endEntityDecl();

                    //a hack by Eric
                    //REVISIT
                    fDTDGrammar.addExternalEntityDecl(entityName, fPubidLiteral, fSystemLiteral);
                    int entityIndex = ((DefaultEntityHandler) fEntityHandler).addExternalEntityDecl(entityName, 
                                                                                                    fPubidLiteral, 
                                                                                                    fSystemLiteral, 
                                                                                                    getReadingExternalEntity());

                } else {
                    if (!fEntityReader.lookingAtSpace(true)) {
                        abortMarkup(XMLMessages.MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL,
                                    XMLMessages.P76_SPACE_REQUIRED,
                                    entityName);
                        fDTDGrammar.endEntityDecl();
                        return;
                    }
                    fEntityReader.skipPastSpaces();
                    int ndataOffset = fEntityReader.currentOffset();
                    fEntityReader.skipPastName('>');
                    int ndataLength = fEntityReader.currentOffset() - ndataOffset;
                    if (ndataLength == 0) {
                        abortMarkup(XMLMessages.MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL,
                                    XMLMessages.P76_REQUIRED,
                                    entityName);
                        fDTDGrammar.endEntityDecl();
                        return;
                    }
                    int notationName = fEntityReader.addSymbol(ndataOffset, ndataLength);
                    checkForPEReference(false);
                    if (!fEntityReader.lookingAtChar('>', true)) {
                        abortMarkup(XMLMessages.MSG_ENTITYDECL_UNTERMINATED,
                                    XMLMessages.P72_UNTERMINATED,
                                    entityName);
                        fDTDGrammar.endEntityDecl();
                        return;
                    }
                    decreaseMarkupDepth();
                    fDTDGrammar.endEntityDecl();
                    
                    //a hack by Eric
                    //REVISIT
                    fDTDGrammar.addUnparsedEntityDecl(entityName, fPubidLiteral, fSystemLiteral, notationName);
                    /****
                    System.out.println(""----addUnparsedEntity--- ""+ fStringPool.toString(entityName)+"",""
                                       +fStringPool.toString(notationName)+"",""
                                       +fStringPool.toString(fPubidLiteral) + "",""
                                       +fStringPool.toString(fSystemLiteral) + "",""
                                       +getReadingExternalEntity());
                    /****/
                    int entityIndex = ((DefaultEntityHandler) fEntityHandler).addUnparsedEntityDecl(entityName, 
                                                                                                    fPubidLiteral, 
                                                                                                    fSystemLiteral, 
                                                                                                    notationName, 
                                                                                                    getReadingExternalEntity());
                }
            }
        }
    }
    //
    //  [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    //                      | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    //
    private int scanEntityValue(boolean single) throws Exception
    {
        char qchar = single ? '\'' : '\""';
        fEntityValueMark = fEntityReader.currentOffset();
        int entityValue = fEntityReader.scanEntityValue(qchar, true);
        if (entityValue < 0)
            entityValue = scanComplexEntityValue(qchar, entityValue);
        return entityValue;
    }
    private int scanComplexEntityValue(char qchar, int result) throws Exception
    {
        int previousState = setScannerState(SCANNER_STATE_ENTITY_VALUE);
        fEntityValueReader = fReaderId;
        int dataOffset = fLiteralData.length();
        while (true) {
            switch (result) {
            case XMLEntityHandler.ENTITYVALUE_RESULT_FINISHED:
            {
                int offset = fEntityReader.currentOffset();
                fEntityReader.lookingAtChar(qchar, true);
                restoreScannerState(previousState);
                int dataLength = fLiteralData.length() - dataOffset;
                if (dataLength == 0) {
                    return fEntityReader.addString(fEntityValueMark, offset - fEntityValueMark);
                }
                if (offset - fEntityValueMark > 0) {
                    fEntityReader.append(fLiteralData, fEntityValueMark, offset - fEntityValueMark);
                    dataLength = fLiteralData.length() - dataOffset;
                }
                return fLiteralData.addString(dataOffset, dataLength);
            }
            case XMLEntityHandler.ENTITYVALUE_RESULT_REFERENCE:
            {
                int offset = fEntityReader.currentOffset();
                if (offset - fEntityValueMark > 0)
                    fEntityReader.append(fLiteralData, fEntityValueMark, offset - fEntityValueMark);
                fEntityReader.lookingAtChar('&', true);
                //
                // Check for character reference first.
                //
                if (fEntityReader.lookingAtChar('#', true)) {
                    int ch = scanCharRef();
                    if (ch != -1) {
                        if (ch < 0x10000)
                            fLiteralData.append((char)ch);
                        else {
                            fLiteralData.append((char)(((ch-0x00010000)>>10)+0xd800));
                            fLiteralData.append((char)(((ch-0x00010000)&0x3ff)+0xdc00));
                        }
                    }
                    fEntityValueMark = fEntityReader.currentOffset();
                } else {
                    //
                    // Entity reference
                    //
                    int nameOffset = fEntityReader.currentOffset();
                    fEntityReader.skipPastName(';');
                    int nameLength = fEntityReader.currentOffset() - nameOffset;
                    if (nameLength == 0) {
                        reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_NAME_REQUIRED);
                        fEntityValueMark = fEntityReader.currentOffset();
                    } else if (!fEntityReader.lookingAtChar(';', true)) {
                        reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_REFERENCE,
                                            XMLMessages.P68_SEMICOLON_REQUIRED,
                                            fEntityReader.addString(nameOffset, nameLength));
                        fEntityValueMark = fEntityReader.currentOffset();
                    } else {
                        //
                        // 4.4.7 Bypassed
                        //
                        // When a general entity reference appears in the EntityValue in an
                        // entity declaration, it is bypassed and left as is.
                        //
                        fEntityValueMark = offset;
                    }
                }
                break;
            }
            case XMLEntityHandler.ENTITYVALUE_RESULT_PEREF:
            {
                int offset = fEntityReader.currentOffset();
                if (offset - fEntityValueMark > 0)
                    fEntityReader.append(fLiteralData, fEntityValueMark, offset - fEntityValueMark);
                fEntityReader.lookingAtChar('%', true);
                int nameOffset = fEntityReader.currentOffset();
                fEntityReader.skipPastName(';');
                int nameLength = fEntityReader.currentOffset() - nameOffset;
                if (nameLength == 0) {
                    reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_NAME_REQUIRED);
                } else if (!fEntityReader.lookingAtChar(';', true)) {
                    reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE,
                                        XMLMessages.P69_SEMICOLON_REQUIRED,
                                        fEntityReader.addString(nameOffset, nameLength));
                } else if (!getReadingExternalEntity()) {
                    reportFatalXMLError(XMLMessages.MSG_PEREFERENCE_WITHIN_MARKUP,
                                        XMLMessages.WFC_PES_IN_INTERNAL_SUBSET,
                                        fEntityReader.addString(nameOffset, nameLength));
                } else {
                    int peNameIndex = fEntityReader.addSymbol(nameOffset, nameLength);
                    fEntityHandler.startReadingFromEntity(peNameIndex, markupDepth(), XMLEntityHandler.ENTITYREF_IN_ENTITYVALUE);
                }
                fEntityValueMark = fEntityReader.currentOffset();
                break;
            }
            case XMLEntityHandler.ENTITYVALUE_RESULT_INVALID_CHAR:
            {
                int offset = fEntityReader.currentOffset();
                if (offset - fEntityValueMark > 0)
                    fEntityReader.append(fLiteralData, fEntityValueMark, offset - fEntityValueMark);
                int invChar = fEntityReader.scanInvalidChar();
                if (fScannerState == SCANNER_STATE_END_OF_INPUT)
                    return -1;
                if (invChar >= 0) {
                    reportFatalXMLError(XMLMessages.MSG_INVALID_CHAR_IN_ENTITYVALUE,
                                        XMLMessages.P9_INVALID_CHARACTER,
                                        Integer.toHexString(invChar));
                }
                fEntityValueMark = fEntityReader.currentOffset();
                break;
            }
            case XMLEntityHandler.ENTITYVALUE_RESULT_END_OF_INPUT:
                // all the work is done by the previous reader, just invoke the next one now.
                break;
            default:
                break;
            }
            result = fEntityReader.scanEntityValue(fReaderId == fEntityValueReader ? qchar : -1, false);
        }
    }
    //
    //
    //
    private boolean checkForPEReference(boolean spaceRequired) throws Exception
    {
        boolean sawSpace = true;
        if (spaceRequired)
            sawSpace = fEntityReader.lookingAtSpace(true);
        fEntityReader.skipPastSpaces();
        if (!getReadingExternalEntity())
            return sawSpace;
        if (!fEntityReader.lookingAtChar('%', true))
            return sawSpace;
        while (true) {
            int nameOffset = fEntityReader.currentOffset();
            fEntityReader.skipPastName(';');
            int nameLength = fEntityReader.currentOffset() - nameOffset;
            if (nameLength == 0) {
                reportFatalXMLError(XMLMessages.MSG_NAME_REQUIRED_IN_PEREFERENCE,
                                    XMLMessages.P69_NAME_REQUIRED);
            } else if (!fEntityReader.lookingAtChar(';', true)) {
                reportFatalXMLError(XMLMessages.MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE,
                                    XMLMessages.P69_SEMICOLON_REQUIRED,
                                    fEntityReader.addString(nameOffset, nameLength));
            } else {
                int peNameIndex = fEntityReader.addSymbol(nameOffset, nameLength);
                int readerDepth = (fScannerState == SCANNER_STATE_CONTENTSPEC) ? parenDepth() : markupDepth();
                fEntityHandler.startReadingFromEntity(peNameIndex, readerDepth, XMLEntityHandler.ENTITYREF_IN_DTD_WITHIN_MARKUP);
            }
            fEntityReader.skipPastSpaces();
            if (!fEntityReader.lookingAtChar('%', true))
                return true;
        }
    }
    //
    // content model stack
    //
    private void initializeContentModelStack(int depth) {
        if (fOpStack == null) {
            fOpStack = new int[8];
            fNodeIndexStack = new int[8];
            fPrevNodeIndexStack = new int[8];
        } else if (depth == fOpStack.length) {
            int[] newStack = new int[depth * 2];
            System.arraycopy(fOpStack, 0, newStack, 0, depth);
            fOpStack = newStack;
            newStack = new int[depth * 2];
            System.arraycopy(fNodeIndexStack, 0, newStack, 0, depth);
            fNodeIndexStack = newStack;
            newStack = new int[depth * 2];
            System.arraycopy(fPrevNodeIndexStack, 0, newStack, 0, depth);
            fPrevNodeIndexStack = newStack;
        }
        fOpStack[depth] = -1;
        fNodeIndexStack[depth] = -1;
        fPrevNodeIndexStack[depth] = -1;
    }

    private boolean validVersionNum(String version) {
        return XMLCharacterProperties.validVersionNum(version);
    }

    private boolean validEncName(String encoding) {
        return XMLCharacterProperties.validEncName(encoding);
    }

    private int validPublicId(String publicId) {
        return XMLCharacterProperties.validPublicId(publicId);
    }

    private void scanElementType(XMLEntityHandler.EntityReader entityReader, 
                                char fastchar, QName element) throws Exception {

        if (!fNamespacesEnabled) {
            element.clear();
            element.localpart = entityReader.scanName(fastchar);
            element.rawname = element.localpart;
            return;
        }
        entityReader.scanQName(fastchar, element);
        if (entityReader.lookingAtChar(':', false)) {
            fErrorReporter.reportError(fErrorReporter.getLocator(),
                                       XMLMessages.XML_DOMAIN,
                                       XMLMessages.MSG_TWO_COLONS_IN_QNAME,
                                       XMLMessages.P5_INVALID_CHARACTER,
                                       null,
                                       XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
            entityReader.skipPastNmtoken(' ');
        }

    } // scanElementType(XMLEntityHandler.EntityReader,char,QName)

    public void checkForElementTypeWithPEReference(XMLEntityHandler.EntityReader entityReader, 
                                                   char fastchar, QName element) throws Exception {

        if (!fNamespacesEnabled) {
            element.clear();
            element.localpart = entityReader.scanName(fastchar);
            element.rawname = element.localpart;
            return;
        }
        entityReader.scanQName(fastchar, element);
        if (entityReader.lookingAtChar(':', false)) {
            fErrorReporter.reportError(fErrorReporter.getLocator(),
                                       XMLMessages.XML_DOMAIN,
                                       XMLMessages.MSG_TWO_COLONS_IN_QNAME,
                                       XMLMessages.P5_INVALID_CHARACTER,
                                       null,
                                       XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
            entityReader.skipPastNmtoken(' ');
        }

    } // checkForElementTypeWithPEReference(XMLEntityHandler.EntityReader,char,QName)

    public void checkForAttributeNameWithPEReference(XMLEntityHandler.EntityReader entityReader, 
                                                     char fastchar, QName attribute) throws Exception {

        if (!fNamespacesEnabled) {
            attribute.clear();
            attribute.localpart = entityReader.scanName(fastchar);
            attribute.rawname = attribute.localpart;
            return;
        }

        entityReader.scanQName(fastchar, attribute);
        if (entityReader.lookingAtChar(':', false)) {
            fErrorReporter.reportError(fErrorReporter.getLocator(),
                                       XMLMessages.XML_DOMAIN,
                                       XMLMessages.MSG_TWO_COLONS_IN_QNAME,
                                       XMLMessages.P5_INVALID_CHARACTER,
                                       null,
                                       XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
            entityReader.skipPastNmtoken(' ');
        }

    } // checkForAttributeNameWithPEReference(XMLEntityHandler.EntityReader,char,QName)

    public int checkForNameWithPEReference(XMLEntityHandler.EntityReader entityReader, char fastcheck) throws Exception {
        //
        // REVISIT - what does this have to do with PE references?
        //
        int valueIndex = entityReader.scanName(fastcheck);
        return valueIndex;
    }

    public int checkForNmtokenWithPEReference(XMLEntityHandler.EntityReader entityReader, char fastcheck) throws Exception {
        //
        // REVISIT - what does this have to do with PE references?
        //
        int nameOffset = entityReader.currentOffset();
        entityReader.skipPastNmtoken(fastcheck);
        int nameLength = entityReader.currentOffset() - nameOffset;
        if (nameLength == 0)
            return -1;
        int valueIndex = entityReader.addSymbol(nameOffset, nameLength);
        return valueIndex;
    }

    public int scanDefaultAttValue(QName element, QName attribute, 
                                   int attType, int enumeration) throws Exception {
        /***/
        if (fValidationEnabled && attType == XMLAttributeDecl.TYPE_ID) {
            reportRecoverableXMLError(XMLMessages.MSG_ID_DEFAULT_TYPE_INVALID,
                                      XMLMessages.VC_ID_ATTRIBUTE_DEFAULT,
                                      fStringPool.toString(attribute.rawname));
        }
        /***/
        int defaultAttValue = scanDefaultAttValue(element, attribute);
        if (defaultAttValue == -1)
            return -1;
        // REVISIT
        /***
        if (attType != fCDATASymbol) {
            // REVISIT: Validation. Should we pass in the element or is this
            //          default attribute value normalization?
            defaultAttValue = fValidator.normalizeAttValue(null, attribute, defaultAttValue, attType, enumeration);
        }
        /***/
        return defaultAttValue;
    }

    public int normalizeDefaultAttValue( QName attribute, int defaultAttValue, 
                                         int attType, int enumeration, 
                                         boolean list) throws Exception {
            //
            // Normalize attribute based upon attribute type...
            //
            String attValue = fStringPool.toString(defaultAttValue);

            if (list) {
                StringTokenizer tokenizer = new StringTokenizer(attValue);
                StringBuffer sb = new StringBuffer(attValue.length());
                boolean ok = true;
                if (tokenizer.hasMoreTokens()) {
                    while (true) {
                        String nmtoken = tokenizer.nextToken();
                        if (attType == XMLAttributeDecl.TYPE_NMTOKEN) {
                            if (fValidationEnabled && !XMLCharacterProperties.validNmtoken(nmtoken)) {
                                ok = false;
                            }
                        }
                        else if (attType == XMLAttributeDecl.TYPE_IDREF || attType == XMLAttributeDecl.TYPE_ENTITY) {
                            if (fValidationEnabled && !XMLCharacterProperties.validName(nmtoken)) {
                                ok = false;
                            }
                            // REVISIT: a Hack!!! THis is to pass SUN test /invalid/attr11.xml and attr12.xml
                            // not consistent with XML1.0 spec VC: Attribute Default Legal
                            if (fValidationEnabled && attType == XMLAttributeDecl.TYPE_ENTITY)
                            if (! ((DefaultEntityHandler) fEntityHandler).isUnparsedEntity(defaultAttValue)) {
                                reportRecoverableXMLError(XMLMessages.MSG_ENTITY_INVALID,
                                                          XMLMessages.VC_ENTITY_NAME,
                                                          fStringPool.toString(attribute.rawname), nmtoken);
                            }

                        }
                        sb.append(nmtoken);
                        if (!tokenizer.hasMoreTokens()) {
                            break;
                        }
                        sb.append(' ');
                    }
                }
                String newAttValue = sb.toString();
                if (fValidationEnabled && (!ok || newAttValue.length() == 0)) {
                    reportRecoverableXMLError(XMLMessages.MSG_ATT_DEFAULT_INVALID,
                                              XMLMessages.VC_ATTRIBUTE_DEFAULT_LEGAL,
                                              fStringPool.toString(attribute.rawname), newAttValue);
                }
                if (!newAttValue.equals(attValue)) {
                    defaultAttValue = fStringPool.addString(newAttValue);
                }
                return defaultAttValue;
            }
            else {
                String newAttValue = attValue.trim();

                if (fValidationEnabled) {
                    // REVISIT - can we release the old string?
                    if (newAttValue != attValue) {
                       defaultAttValue = fStringPool.addSymbol(newAttValue);
                    } 
                    else {
                       defaultAttValue = fStringPool.addSymbol(defaultAttValue);
                    }
                    if (attType == XMLAttributeDecl.TYPE_ENTITY ||
                        attType == XMLAttributeDecl.TYPE_ID ||
                        attType == XMLAttributeDecl.TYPE_IDREF ||
                        attType == XMLAttributeDecl.TYPE_NOTATION)  {

                        // REVISIT: A Hack!!! THis is to pass SUN test /invalid/attr11.xml and attr12.xml
                        // not consistent with XML1.0 spec VC: Attribute Default Legal
                        if (attType == XMLAttributeDecl.TYPE_ENTITY)
                        if (! ((DefaultEntityHandler) fEntityHandler).isUnparsedEntity(defaultAttValue)) {
                            reportRecoverableXMLError(XMLMessages.MSG_ENTITY_INVALID,
                                                      XMLMessages.VC_ENTITY_NAME,
                                                      fStringPool.toString(attribute.rawname), newAttValue);
                        }
                        
                        if (!XMLCharacterProperties.validName(newAttValue)) {
                            reportRecoverableXMLError(XMLMessages.MSG_ATT_DEFAULT_INVALID,
                                                      XMLMessages.VC_ATTRIBUTE_DEFAULT_LEGAL,
                                                      fStringPool.toString(attribute.rawname), newAttValue);
                        }

                    }
                    else if (attType == XMLAttributeDecl.TYPE_NMTOKEN ||
                             attType == XMLAttributeDecl.TYPE_ENUMERATION ) {

                        if (!XMLCharacterProperties.validNmtoken(newAttValue)) {
                            reportRecoverableXMLError(XMLMessages.MSG_ATT_DEFAULT_INVALID,
                                                      XMLMessages.VC_ATTRIBUTE_DEFAULT_LEGAL,
                                                      fStringPool.toString(attribute.rawname), newAttValue);
                        }
                    }
                    
                    if (attType == XMLAttributeDecl.TYPE_NOTATION ||
                        attType == XMLAttributeDecl.TYPE_ENUMERATION ) {

                        if ( !fStringPool.stringInList(enumeration, defaultAttValue) ) {
                            reportRecoverableXMLError(XMLMessages.MSG_ATT_DEFAULT_INVALID,
                                                      XMLMessages.VC_ATTRIBUTE_DEFAULT_LEGAL,
                                                      fStringPool.toString(attribute.rawname), newAttValue);
                        }
                    }

                } 
                else if (newAttValue != attValue) {
                    // REVISIT - can we release the old string?
                    defaultAttValue = fStringPool.addSymbol(newAttValue);
                }
            }

            return defaultAttValue;
    }
    /***
    public boolean scanDoctypeDecl(boolean standalone) throws Exception {
        fStandaloneReader = standalone ? fEntityHandler.getReaderId() : -1;
        fDeclsAreExternal = false;
        if (!fDTDScanner.scanDoctypeDecl()) {
            return false;
        }
        if (fDTDScanner.getReadingExternalEntity()) {
            fDTDScanner.scanDecls(true);
        }
        fDTDHandler.endDTD();
        return true;
    }
    /***/

} // class XMLDTDScanner
"
org/apache/xerces/readers/XMLDeclRecognizer.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import org.apache.xerces.framework.XMLErrorReporter;
import org.apache.xerces.utils.ChunkyByteArray;
import org.apache.xerces.utils.StringPool;
import java.util.Stack;

/**
 * Abstract base class for encoding recognizers.
 *
 * When we encounter an external entity, including the document entity,
 * and do not know what the encoding of the underlying byte stream is,
 * we need to look at the contents of the stream to find out.  We do this
 * by asking a set of ""recognizers"" to look at the stream data and if
 * the recognizer can understand the encoding it will try to read an
 * XML or text declaration, if present, and construct the appropriate
 * reader for that encoding.  The recognizer subclasses will typically
 * use the prescanXMLDeclOrTextDecl() method if the stream looks like
 * it does begin with such a declaration using a temporary reader that
 * can support the calls needed to scan through the encoding declaration.
 */
public abstract class XMLDeclRecognizer {

    /**
     * Register the standard recognizers.
     *
     * @param recognizerStack The stack of recognizers used by the parser.
     */
    public static void registerDefaultRecognizers(Stack recognizerStack) {
        recognizerStack.push(new EBCDICRecognizer());
        recognizerStack.push(new UCSRecognizer());
        recognizerStack.push(new UTF8Recognizer());
    }

    /**
     * Subclasses override this method to support recognizing their encodings.
     *
     * @param readerFactory the factory object to use when constructing the entity reader.
     * @param entityHandler the entity handler to get entity readers from
     * @param errorReporter where to report errors
     * @param sendCharDataAsCharArray true if the reader should use char arrays, not string handles.
     * @param stringPool the <code>StringPool</code> to put strings in
     * @param data initial bytes to perform recognition on
     * @param xmlDecl true if attempting to recognize fron an XMLDecl, false if trying to recognize from a TextDecl.
     * @param allowJavaEncodingName true if Java's encoding names are allowed, false if they are not.
     * @return The reader that will be used to process the contents of the data stream.
     * @exception java.lang.Exception
     */
    public abstract XMLEntityHandler.EntityReader recognize(XMLEntityReaderFactory readerFactory,
                                                            XMLEntityHandler entityHandler,
                                                            XMLErrorReporter errorReporter,
                                                            boolean sendCharDataAsCharArray,
                                                            StringPool stringPool,
                                                            ChunkyByteArray data,
                                                            boolean xmlDecl,
                                                            boolean allowJavaEncodingName) throws Exception;

    //
    // From the standard:
    //
    // [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    // [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
    // [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
    //
    /**
     * Support for getting the value of an EncodingDecl using an XMLReader.
     *
     * This is the minimal logic from the scanner to recognize an XMLDecl or TextDecl using
     * the XMLReader interface.
     *
     * @param entityReader data source for prescan
     * @param xmlDecl true if attempting to recognize from an XMLDecl, false if trying to recognize from a TextDecl.
     * @return <code>StringPool</code> handle to the name of the encoding recognized
     * @exception java.lang.Exception
     */
    protected int prescanXMLDeclOrTextDecl(XMLEntityHandler.EntityReader entityReader, boolean xmlDecl) throws Exception
    {
        if (!entityReader.lookingAtChar('<', true)) {
            return -1;
        }
        if (!entityReader.lookingAtChar('?', true)) {
            return -1;
        }
        if (!entityReader.skippedString(xml_string)) {
            return -1;
        }
        entityReader.skipPastSpaces();
        boolean single;
        char qchar;
        if (entityReader.skippedString(version_string)) {
            entityReader.skipPastSpaces();
            if (!entityReader.lookingAtChar('=', true)) {
                return -1;
            }
            entityReader.skipPastSpaces();
            int versionIndex = entityReader.scanStringLiteral();
            if (versionIndex < 0) {
                return -1;
            }
            if (!entityReader.lookingAtSpace(true)) {
                return -1;
            }
            entityReader.skipPastSpaces();
        }
        else if (xmlDecl) {
            return -1;
        }
        if (!entityReader.skippedString(encoding_string)) {
            return -1;
        }
        entityReader.skipPastSpaces();
        if (!entityReader.lookingAtChar('=', true)) {
            return -1;
        }
        entityReader.skipPastSpaces();
        int encodingIndex = entityReader.scanStringLiteral();
        return encodingIndex;
    }
    //
    // [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    // [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
    //
    private static final char[] xml_string = { 'x','m','l' };
    //
    // [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | "" VersionNum "")
    //
    private static final char[] version_string = { 'v','e','r','s','i','o','n' };
    //
    // [80] EncodingDecl ::= S 'encoding' Eq ('""' EncName '""' |  ""'"" EncName ""'"" )
    //
    private static final char[] encoding_string = { 'e','n','c','o','d','i','n','g' };
}
"
org/apache/xerces/dom/ElementDefinitionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * NON-DOM CLASS: Describe one of the Elements (and its associated
 * Attributes) defined in this Document Type.
 * <p>
 * I've included this in Level 1 purely as an anchor point for default
 * attributes. In Level 2 it should enable the ChildRule support.
 *
 * @version
 */
public class ElementDefinitionImpl 
    extends ParentNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = -8373890672670022714L;
    
    //
    // Data
    //

    /** Element definition name. */
    protected String name;

    /** Default attributes. */
    protected NamedNodeMapImpl attributes;

    //
    // Constructors
    //

    /** Factory constructor. */
    public ElementDefinitionImpl(DocumentImpl ownerDocument, String name) {
    	super(ownerDocument);
        this.name = name;
        attributes = new NamedNodeMapImpl(ownerDocument, null);
    }

    //
    // Node methods
    //

    /** 
     * A short integer indicating what type of node this is. The named
     * constants for this value are defined in the org.w3c.dom.Node interface.
     */
    public short getNodeType() {
        return NodeImpl.ELEMENT_DEFINITION_NODE;
    }

    /**
     * Returns the element definition name
     */
    public String getNodeName() {
        if (syncData()) {
            synchronizeData();
        }
        return name;
    }

    /**
     * Replicate this object.
     */
    public Node cloneNode(boolean deep) {

    	ElementDefinitionImpl newnode =
            (ElementDefinitionImpl) super.cloneNode(deep);
    	// NamedNodeMap must be explicitly replicated to avoid sharing
    	newnode.attributes = attributes.cloneMap(newnode);
    	return newnode;

    } // cloneNode(boolean):Node

    /**
     * Query the attributes defined on this Element.
     * <p>
     * In the base implementation this Map simply contains Attribute objects
     * representing the defaults. In a more serious implementation, it would
     * contain AttributeDefinitionImpl objects for all declared Attributes,
     * indicating which are Default, DefaultFixed, Implicit and/or Required.
     * 
     * @return org.w3c.dom.NamedNodeMap containing org.w3c.dom.Attribute
     */
    public NamedNodeMap getAttributes() {

        if (syncChildren()) {
            synchronizeChildren();
        }
    	return attributes;

    } // getAttributes():NamedNodeMap

} // class ElementDefinitionImpl
"
org/apache/xerces/dom/LCount.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */
package org.apache.xerces.dom;

import java.io.*;
import java.util.Vector;

import org.w3c.dom.*;

import org.w3c.dom.events.*;
//import org.w3c.dom.events.*;


/** Internal class LCount is used to track the number of
    listeners registered for a given event name, as an entry
    in a global hashtable. This should allow us to avoid generating,
    or discard, events for which no listeners are registered. 
    
    ***** There should undoubtedly be methods here to manipulate
    this table. At the moment that code's residing in NodeImpl.
    Move it when we have a chance to do so. Sorry; we were
    rushed.
    
    ***** Also, I'm currently asking ""are there any listeners""
    by testing captures+bubbles+defaults =? 0. It would probably
    make sense to have a separate ""total"" field, calculated at
    add/remove, to save a few cycles during dispatch. Fix.
    
    ???? CONCERN: Hashtables are known to be ""overserialized"" in
    current versions of Java. That may impact performance.
    
    ???? CONCERN: The hashtable should probably be a per-document object.
    Finer granularity would be even better, but would cost more cycles to
    resolve and might not save enough event traffic to be worth the investment.
*/
class LCount 
{ 
    static java.util.Hashtable lCounts=new java.util.Hashtable();
    public int captures=0,bubbles=0,defaults=0;

    static LCount lookup(String evtName)
    {
        LCount lc=(LCount)lCounts.get(evtName);
        if(lc==null)
            lCounts.put(evtName,(lc=new LCount()));
        return lc;	        
    }
} // class LCount
"
org/apache/xerces/dom/DOMExceptionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.apache.xerces.domx.DOMException;
//import org.w3c.dom.DOMException;

/**
 * DOMExceptions are thrown when one of the
 * DOM implementation classes discovers an error condition. The
 * architecture is defined in terms of the ExceptionCode, but in the
 * standard Java API this has been extended so the exception may also
 * carry a text string. Standard exception codes are:
 * <UL>
 * <LI>
 * INDEX_SIZE_ERR: index or size is negative, or greater than the
 * allowed value.
 * <LI>
 * WSTRING_SIZE_ERR: the specified range of text does not fit into the
 * string representation used in this implementation. Only arises in
 * implementations whose strings have a maximum-size limit. The DOM
 * provides workarounds to support those languages, generally by
 * having the DOM extract a managable substring on their behalf.
 * <LI>
 * HIERARCHY_REQUEST_ERR: user tried to insert a node somewhere it
 * doesn't belong... such as adding a child to a Text node.
 * <LI>
 * WRONG_DOCUMENT_ERR: a node is used in a different document than the
 * one that created it (that doesn't support it). Currently, the DOM
 * doesn't promise that nodes can be moved from document to document
 * even if they're both using the same underlying implementation.
 * Level 2 of the DOM spec may address this.
 * <LI>
 * INVALID_NAME_ERR: an invalid name is specified.
 * <LI>
 * NO_DATA_ALLOWED_ERR: data is specified for a node which does not
 * support data.
 * <LI>
 * NO_MODIFICATION_ALLOWED_ERR: an attempt is made to modify an object
 * where modifications are not allowed.
 * <LI>
 * NOT_FOUND_ERR: an attempt was made to reference a node in a context
 * where it does not exist.
 * <LI>
 * NOT_SUPPORTED_ERR: the implementation does not support the type of
 * object requested.
 * <LI>
 * INUSE_ATTRIBUTE_ERR: an attempt is made to add an attribute object
 * that is already in use elsewhere.
 * </UL>
 *
 * @version
 * @since  PR-DOM-Level-1-19980818.
 */
public class DOMExceptionImpl 
    extends DOMException {

    //
    // Constructors
    //

    /** Constructs a dom exception. */
    public DOMExceptionImpl(short code, String message) {
	    super(code, message);
    }    

} // class DOMExceptionImpl
"
org/w3c/dom/Attr.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>Attr</code> interface represents an attribute in an 
 * <code>Element</code> object. Typically the allowable values for the 
 * attribute are defined in a document type definition.
 * <p><code>Attr</code> objects inherit the <code>Node</code>  interface, but 
 * since they are not actually child nodes of the element  they describe, the 
 * DOM does not consider them part of the document  tree.  Thus, the 
 * <code>Node</code> attributes <code>parentNode</code> ,  
 * <code>previousSibling</code> , and <code>nextSibling</code> have a  
 * <code>null</code> value for <code>Attr</code> objects. The DOM takes the  
 * view that attributes are properties of elements rather than having a  
 * separate identity from the elements they are associated with;  this should 
 * make it more efficient to implement such features as default attributes 
 * associated with all elements of a  given type.  Furthermore, 
 * <code>Attr</code> nodes may not be immediate children of a 
 * <code>DocumentFragment</code> . However, they can be associated with 
 * <code>Element</code> nodes contained within a <code>DocumentFragment</code>
 *  . In short, users and implementors of the DOM need to be aware that  
 * <code>Attr</code> nodes have some things in  common with other objects 
 * inheriting the <code>Node</code> interface,  but they also are quite 
 * distinct.
 * <p> The attribute's effective value is determined as follows: if this  
 * attribute has been explicitly assigned any value, that value is the  
 * attribute's effective value; otherwise, if there is a declaration for  
 * this attribute, and that declaration includes a default value, then  that 
 * default value is the attribute's effective value; otherwise, the  
 * attribute does not exist on this element in the structure model until  it 
 * has been explicitly added.  Note that the <code>nodeValue</code>  
 * attribute on the <code>Attr</code> instance can also be used to retrieve 
 * the string version of the attribute's value(s). 
 * <p> In XML, where the value of an attribute can contain entity references, 
 * the child nodes of the <code>Attr</code> node provide a representation in 
 * which entity references are not expanded. These child nodes may be either 
 * <code>Text</code> or <code>EntityReference</code> nodes. Because the 
 * attribute type may be unknown, there are no tokenized attribute values. 
 */
public interface Attr extends Node {
    /**
     *  Returns the name of this attribute. 
     */
    public String getName();

    /**
     *  If this attribute was explicitly given a value in the original 
     * document, this is <code>true</code> ; otherwise, it is 
     * <code>false</code> . Note that the implementation is in charge of this 
     * attribute, not the user. If the user changes the value of the 
     * attribute (even if it ends up having the same value as the default 
     * value) then the <code>specified</code> flag is automatically flipped 
     * to <code>true</code> .  To re-specify the attribute as the default 
     * value from the DTD, the user must delete the attribute. The 
     * implementation will then make a new attribute available with 
     * <code>specified</code> set to <code>false</code> and the default value 
     * (if one exists).
     * <br> In summary: If the attribute has an assigned value in the document 
     * then  <code>specified</code> is <code>true</code> , and the value is 
     * the  assigned value. If the attribute has no assigned value in the 
     * document and has  a default value in the DTD, then 
     * <code>specified</code> is <code>false</code> ,  and the value is the 
     * default value in the DTD. If the attribute has no assigned value in 
     * the document and has  a value of #IMPLIED in the DTD, then the  
     * attribute does not appear  in the structure model of the document.
     */
    public boolean getSpecified();

    /**
     *  On retrieval, the value of the attribute is returned as a string. 
     * Character and general entity references are replaced with their 
     * values. See also the method <code>getAttribute</code> on the  
     * <code>Element</code> interface.
     * <br> On setting, this creates a <code>Text</code> node with the unparsed
     *  contents of the string. I.e. any characters that an XML processor 
     * would recognize as markup are instead treated as literal text. See 
     * also the method <code>setAttribute</code> on the  <code>Element</code> 
     * interface.
     * @exception DOMException
     *    NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     */
    public String getValue();
    public void setValue(String value)
                            throws DOMException;

    /**
     *  The <code>Element</code> node this attribute is attached to or 
     * <code>null</code> if this attribute is not in use.
     * @since DOM Level 2
     */
    public Element getOwnerElement();

}

"
org/apache/xerces/framework/XMLAttrList.java,true,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.framework;

import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.StringPool;

import org.xml.sax.AttributeList;
import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

/**
 * An instance of this class is used to represent the set of attributes
 * for an element that are either directly specified or provided through
 * a default value in the grammar for the document.   XMLAttrList carries
 * the attributes associated with an element from the scanner up to the
 * application level (via the SAX AtributeList).  Because all the attributes
 * are bundled up together before being presented to the application, we don't
 * have a way to build up an attribute value from pieces, most notably entity
 * references.
 * <p>
 * There is typically one instance of this class for each instance of a
 * parser.  The parser may either use this object to hold the attributes
 * of a single element, calling releaseAttrList() before each new element,
 * or it may use this object to hold the attributes of all of the elements
 * in the document.
 * <p>
 * To start saving a new set of attributes, the startAttrList() method is
 * called, returning a handle for the attribute list.  All addAttr() calls
 * will be added to the set until a call is made to endAttrList().  A handle
 * of -1 is used to indicate that there are no attributes in the set.
 * <p>
 * When an attribute is added to the set, the type of the attribute and an
 * indicator of whether it was specified explicitly or through a default is
 * provided.
 * <p>
 * The attributes in the set may be accessed either through the getFirstAttr()
 * and getNextAttr() iteration interface, or the getAttributeList() method
 * may be used to access the attribute list through the SAX <code>AttributeList</code>
 * interface.
 *
 * @version $Id$
 */
public final class XMLAttrList 
    implements AttributeList {

    //
    // Constants
    //

    // Chunk size constants

    private static final int CHUNK_SHIFT = 5;           // 2^5 = 32
    private static final int CHUNK_SIZE = (1 << CHUNK_SHIFT);
    private static final int CHUNK_MASK = CHUNK_SIZE - 1;
    private static final int INITIAL_CHUNK_COUNT = (1 << (10 - CHUNK_SHIFT));   // 2^10 = 1k

    // Flags (bits)

    private static final int ATTFLAG_SPECIFIED = 1;
    private static final int ATTFLAG_LASTATTR  = 2;

    //
    // Data
    //

    // Instance variables

    private StringPool fStringPool = null;
    private int fCurrentHandle = -1;
    private int fAttributeListHandle = -1;
    private int fAttributeListLength = 0;
    private int fAttrCount = 0;
    private int[][] fAttPrefix = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fAttLocalpart = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fAttName = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fAttURI = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fAttValue = new int[INITIAL_CHUNK_COUNT][];
    private int[][] fAttType = new int[INITIAL_CHUNK_COUNT][];
    private byte[][] fAttFlags = new byte[INITIAL_CHUNK_COUNT][];

    // utility

    private QName fAttributeQName = new QName();

    /**
     * Constructor
     *
     * @param stringPool The string pool instance to use.
     */
    public XMLAttrList(StringPool stringPool) {
        fStringPool = stringPool;
    }

    /**
     * Reset this instance to an ""empty"" state.
     *
     * @param stringPool The string pool instance to use.
     */
    public void reset(StringPool stringPool) {
        fStringPool = stringPool;
        fCurrentHandle = -1;
        fAttributeListHandle = -1;
        fAttributeListLength = 0;
        fAttrCount = 0;
    }

    public int addAttr(int attrName, int attValue, 
                       int attType, boolean specified, boolean search) throws Exception
    {
        fAttributeQName.setValues(-1, attrName, attrName);
        return addAttr(fAttributeQName, attValue, attType, specified, search);
    }
    /**
     * Add an attribute to the current set.
     *
     * @param attrName The name of the attribute, an index in the string pool.
     * @param attValue The value of the attribute, an index in the string pool.
     * @param attType The type of the attribute, an index in the string pool.
     * @param specified <code>true</code> if the attribute is specified directly; otherwise
     *                  <code>false</code> is the attribute is provided through a default.
     * @param search <code>true</code> if the list should be searched for a duplicate.
     * @return The index of this attribute; or -1 is <code>search</code> was <code>true</code>
     *         and <code>attrName</code> was already present.
     */
    public int addAttr(QName attribute, 
                       int attValue, int attType, 
                       boolean specified, boolean search) throws Exception {

        int chunk;
        int index;
        if (search) {
            chunk = fCurrentHandle >> CHUNK_SHIFT;
            index = fCurrentHandle & CHUNK_MASK;
            for (int attrIndex = fCurrentHandle; attrIndex < fAttrCount; attrIndex++) {
                // REVISIT: Should this be localpart?
                if (fStringPool.equalNames(fAttName[chunk][index], attribute.rawname)) {
                    return -1;
                }
                if (++index == CHUNK_SIZE) {
                    chunk++;
                    index = 0;
                }
            }
        } else {
            chunk = fAttrCount >> CHUNK_SHIFT;
            index = fAttrCount & CHUNK_MASK;
        }
        ensureCapacity(chunk, index);
        fAttPrefix[chunk][index] = attribute.prefix;
        fAttLocalpart[chunk][index] = attribute.localpart;
        fAttName[chunk][index] = attribute.rawname;
        fAttURI[chunk][index] = attribute.uri;
        fAttValue[chunk][index] = attValue;
        fAttType[chunk][index] = attType;
        fAttFlags[chunk][index] = (byte)(specified ? ATTFLAG_SPECIFIED : 0);
        return fAttrCount++;

    } // addAttr(QName,int,int,boolean,boolean):int

    /**
     * Start a new set of attributes.
     *
     * @return The handle for the new set of attributes.
     */
    public int startAttrList() {
        fCurrentHandle = fAttrCount;
        return fCurrentHandle;
    }

    /**
     * Terminate the current set of attributes.
     */
    public void endAttrList() {
        int attrIndex = fAttrCount - 1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        fAttFlags[chunk][index] |= ATTFLAG_LASTATTR;
        fCurrentHandle = -1;
    }

    /**
     * Get the prefix of the attribute.
     */
    public int getAttrPrefix(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttPrefix[chunk][index];
    }

    /**
     * Return the localpart of the attribute.
     */
    public int getAttrLocalpart(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttLocalpart[chunk][index];
    }

    // REVISIT: Should this be renamed ""getAttrRawname"" to match?
    /**
     * Get the name of the attribute
     *
     * @param attrIndex The index of the attribute.
     * @return The name of the attribute, an index in the string pool.
     */
    public int getAttrName(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttName[chunk][index];
    }
    
    /** Sets the uri of the attribute. */
    public void setAttrURI(int attrIndex, int uri) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        fAttURI[chunk][index] = uri;
    }

    /** Return the uri of the attribute. */
    public int getAttrURI(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttURI[chunk][index];
    }

    /**
     * Get the value of the attribute
     *
     * @param attrIndex The index of the attribute.
     * @return The value of the attribute, an index in the string pool.
     */
    public int getAttValue(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttValue[chunk][index];
    }

    /** Sets the type of the attribute. */
    public void setAttType(int attrIndex, int attTypeIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        fAttType[chunk][index] = attTypeIndex;
    }

    /**
     * Get the type of the attribute
     *
     * @param attrIndex The index of the attribute.
     * @return The type of the attribute, an index in the string pool.
     */
    public int getAttType(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return -1;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return fAttType[chunk][index];
    }

    /**
     * Was the attribute explicitly supplied or was it provided through a default?
     *
     * @param attrIndex The index of the attribute.
     * @return <code>true</code> if the attribute was specified directly; otherwise
     *         <code>false</code> is the attribute was provided through a default.
     */
    public boolean isSpecified(int attrIndex) {
        if (attrIndex < 0 || attrIndex >= fAttrCount)
            return true;
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        return (fAttFlags[chunk][index] & ATTFLAG_SPECIFIED) != 0;
    }

    /**
     * Make the resources of the current attribute list available for reuse.
     *
     * @param The attribute list handle.
     */
    public void releaseAttrList(int attrListHandle) {
        if (attrListHandle == -1)
            return;
        int chunk = attrListHandle >> CHUNK_SHIFT;
        int index = attrListHandle & CHUNK_MASK;
        while (true) {
            boolean last = (fAttFlags[chunk][index] & ATTFLAG_LASTATTR) != 0;
            fAttPrefix[chunk][index] = -1;
            fAttLocalpart[chunk][index] = -1;
            fAttName[chunk][index] = -1;
            fAttURI[chunk][index] = -1;
            if ((fAttFlags[chunk][index] & ATTFLAG_SPECIFIED) != 0)
                fStringPool.releaseString(fAttValue[chunk][index]);
            fAttValue[chunk][index] = -1;
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
            if (last)
                break;
        }
        int lastIndex = (chunk << CHUNK_SHIFT) + index;
        if (fAttrCount == lastIndex)
            fAttrCount = attrListHandle;
    }

    /** 
     * Get the first attribute in the attribute list.
     *
     * @param attrListHandle The attribute list handle.
     * @return The index of the first attribute in the specified
     *         attribute list or -1 if the handle is invalid.
     */
    public int getFirstAttr(int attrListHandle) {
        if (attrListHandle < 0 || attrListHandle >= fAttrCount) {
            return -1;
        }
        // the first attribute in a list is implemented as
        // the same index of the attribute list handle
        return attrListHandle;
    }

    /**
     * Get the next attribute in the attribute list.
     *
     * @param attrIndex The attribute index.
     * @return The index of the next attribute after <code>attrIndex</code> in
     *         the same attribute list or -1 if there is no next index.
     */
    public int getNextAttr(int attrIndex) {
        if (attrIndex < 0 || attrIndex + 1 >= fAttrCount) {
            return -1;
        }
        int chunk = attrIndex >> CHUNK_SHIFT;
        int index = attrIndex & CHUNK_MASK;
        if ((fAttFlags[chunk][index] & ATTFLAG_LASTATTR) != 0) {
            return -1;
        }
        // attribute lists are implemented in the
        // chunks one after another with the last
        // attribute having a ""last"" flag set
        return attrIndex + 1;
    }

    /* AttributeList support */

    /**
     * Setup this instance to respond as an <code>AttributeList</code> implementation.
     *
     * @return This instance as an <code>AttributeList</code>.
     */
    public AttributeList getAttributeList(int attrListHandle) {
        fAttributeListHandle = attrListHandle;
        if (fAttributeListHandle == -1)
            fAttributeListLength = 0;
        else {
            int chunk = fAttributeListHandle >> CHUNK_SHIFT;
            int index = fAttributeListHandle & CHUNK_MASK;
            fAttributeListLength = 1;
            while ((fAttFlags[chunk][index] & ATTFLAG_LASTATTR) == 0) {
                if (++index == CHUNK_SIZE) {
                    chunk++;
                    index = 0;
                }
                fAttributeListLength++;
            }
        }
        return this;
    }

    /**
     * Return the number of attributes in this list.
     *
     * <p>The SAX parser may provide attributes in any
     * arbitrary order, regardless of the order in which they were
     * declared or specified.  The number of attributes may be
     * zero.</p>
     *
     * @return The number of attributes in the list.
     */
    public int getLength() {
        return fAttributeListLength;
    }

    /**
     * Return the prefix of an attribute in this list (by position).
     */
    public String getPrefix(int i) {
        if (i < 0 || i >= fAttributeListLength) {
            return null;
        }
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        return fStringPool.toString(fAttPrefix[chunk][index]);
    }

    /**
     * Return the local part of an attribute in this list (by position).
     */
    public String getLocalpart(int i) {
        if (i < 0 || i >= fAttributeListLength) {
            return null;
        }
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        return fStringPool.toString(fAttLocalpart[chunk][index]);
    }

    /**
     * Return the name of an attribute in this list (by position).
     *
     * <p>The names must be unique: the SAX parser shall not include the
     * same attribute twice.  Attributes without values (those declared
     * #IMPLIED without a value specified in the start tag) will be
     * omitted from the list.</p>
     *
     * <p>If the attribute name has a namespace prefix, the prefix
     * will still be attached.</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The name of the indexed attribute, or null
     *         if the index is out of range.
     * @see #getLength
     */
    public String getName(int i) {
        if (i < 0 || i >= fAttributeListLength)
            return null;
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        return fStringPool.toString(fAttName[chunk][index]);
    }

    /** Returns the URI of an attribute in this list (by position). */
    public String getURI(int i) {
        if (i < 0 || i >= fAttributeListLength)
            return null;
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        return fStringPool.toString(fAttURI[chunk][index]);
    }

    /**
     * Return the type of an attribute in the list (by position).
     *
     * <p>The attribute type is one of the strings ""CDATA"", ""ID"",
     * ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"", ""ENTITY"", ""ENTITIES"",
     * or ""NOTATION"" (always in upper case).</p>
     *
     * <p>If the parser has not read a declaration for the attribute,
     * or if the parser does not report attribute types, then it must
     * return the value ""CDATA"" as stated in the XML 1.0 Recommentation
     * (clause 3.3.3, ""Attribute-Value Normalization"").</p>
     *
     * <p>For an enumerated attribute that is not a notation, the
     * parser will report the type as ""NMTOKEN"".</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The attribute type as a string, or
     *         null if the index is out of range.
     * @see #getLength
     * @see #getType(java.lang.String)
     */
    public String getType(int i) {
        if (i < 0 || i >= fAttributeListLength)
            return null;
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        int attType = fAttType[chunk][index];
        if (attType == fStringPool.addSymbol(""ENUMERATION""))
            attType = fStringPool.addSymbol(""NMTOKEN"");
        return fStringPool.toString(attType);
    }

    /**
     * Return the value of an attribute in the list (by position).
     *
     * <p>If the attribute value is a list of tokens (IDREFS,
     * ENTITIES, or NMTOKENS), the tokens will be concatenated
     * into a single string separated by whitespace.</p>
     *
     * @param i The index of the attribute in the list (starting at 0).
     * @return The attribute value as a string, or
     *         null if the index is out of range.
     * @see #getLength
     * @see #getValue(java.lang.String)
     */
    public String getValue(int i) {
        if (i < 0 || i >= fAttributeListLength)
            return null;
        int chunk = (fAttributeListHandle + i) >> CHUNK_SHIFT;
        int index = (fAttributeListHandle + i) & CHUNK_MASK;
        return fStringPool.toString(fAttValue[chunk][index]);
    }

    /**
     * Return the type of an attribute in the list (by name).
     *
     * <p>The return value is the same as the return value for
     * getType(int).</p>
     *
     * <p>If the attribute name has a namespace prefix in the document,
     * the application must include the prefix here.</p>
     *
     * @param name The name of the attribute.
     * @return The attribute type as a string, or null if no
     *         such attribute exists.
     * @see #getType(int)
     */
    public String getType(String name) {
        int nameIndex = fStringPool.addSymbol(name);
        if (nameIndex == -1)
            return null;
        int chunk = fAttributeListHandle >> CHUNK_SHIFT;
        int index = fAttributeListHandle & CHUNK_MASK;
        for (int i = 0; i < fAttributeListLength; i++) {
            if (fStringPool.equalNames(fAttName[chunk][index], nameIndex)) {
                int attType = fAttType[chunk][index];
                if (attType == fStringPool.addSymbol(""ENUMERATION""))
                    attType = fStringPool.addSymbol(""NMTOKEN"");
                return fStringPool.toString(attType);
            }
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
        return null;
    }

    /**
     * Return the value of an attribute in the list (by name).
     *
     * <p>The return value is the same as the return value for
     * getValue(int).</p>
     *
     * <p>If the attribute name has a namespace prefix in the document,
     * the application must include the prefix here.</p>
     *
     * @param i The index of the attribute in the list.
     * @return The attribute value as a string, or null if
     *         no such attribute exists.
     * @see #getValue(int)
     */
    public String getValue(String name) {
        int nameIndex = fStringPool.addSymbol(name);
        if (nameIndex == -1)
            return null;
        int chunk = fAttributeListHandle >> CHUNK_SHIFT;
        int index = fAttributeListHandle & CHUNK_MASK;
        for (int i = 0; i < fAttributeListLength; i++) {
            if (fStringPool.equalNames(fAttName[chunk][index], nameIndex))
                return fStringPool.toString(fAttValue[chunk][index]);
            if (++index == CHUNK_SIZE) {
                chunk++;
                index = 0;
            }
        }
        return null;
    }

    //
    // Private methods
    //

    /* Expand our internal data structures as needed. */
    private boolean ensureCapacity(int chunk, int index) {

        try {
            return fAttName[chunk][index] != 0;
        } catch (ArrayIndexOutOfBoundsException ex) {
            int[][] newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttPrefix, 0, newIntArray, 0, chunk);
            fAttPrefix = newIntArray;
            newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttLocalpart, 0, newIntArray, 0, chunk);
            fAttLocalpart = newIntArray;
            newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttName, 0, newIntArray, 0, chunk);
            fAttName = newIntArray;
            newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttURI, 0, newIntArray, 0, chunk);
            fAttURI = newIntArray;
            newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttValue, 0, newIntArray, 0, chunk);
            fAttValue = newIntArray;
            newIntArray = new int[chunk * 2][];
            System.arraycopy(fAttType, 0, newIntArray, 0, chunk);
            fAttType = newIntArray;
            byte[][] newByteArray = new byte[chunk * 2][];
            System.arraycopy(fAttFlags, 0, newByteArray, 0, chunk);
            fAttFlags = newByteArray;
        } catch (NullPointerException ex) {
        }
        fAttPrefix[chunk] = new int[CHUNK_SIZE];
        fAttLocalpart[chunk] = new int[CHUNK_SIZE];
        fAttName[chunk] = new int[CHUNK_SIZE];
        fAttURI[chunk] = new int[CHUNK_SIZE];
        fAttValue[chunk] = new int[CHUNK_SIZE];
        fAttType[chunk] = new int[CHUNK_SIZE];
        fAttFlags[chunk] = new byte[CHUNK_SIZE];
        return true;

    } // ensureCapacity(int,int):boolean

} // class XMLAttrList
"
org/apache/xerces/dom/DeferredElementDefinitionImpl.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.dom;

import org.w3c.dom.*;

/**
 * NON-DOM CLASS: Describe one of the Elements (and its associated
 * Attributes) defined in this Document Type.
 * <p>
 * I've included this in Level 1 purely as an anchor point for default
 * attributes. In Level 2 it should enable the ChildRule support.
 *
 * @version
 */
public class DeferredElementDefinitionImpl 
    extends ElementDefinitionImpl 
    implements DeferredNode {

    //
    // Constants
    //

    /** Serialization version. */
    static final long serialVersionUID = 6703238199538041591L;
    
    //
    // Data
    //

    /** Node index. */
    protected transient int fNodeIndex;

    //
    // Constructors
    //

    /**
     * This is the deferred constructor. Only the fNodeIndex is given here.
     * All other data, can be requested from the ownerDocument via the index.
     */
    DeferredElementDefinitionImpl(DeferredDocumentImpl ownerDocument, int nodeIndex) {
        super(ownerDocument, null);
        
        fNodeIndex = nodeIndex;
        syncData(true);
        syncChildren(true);

    } // <init>(DeferredDocumentImpl,int)

    //
    // DeferredNode methods
    //

    /** Returns the node index. */
    public int getNodeIndex() {
        return fNodeIndex;
    }

    //
    // Protected methods
    //

    /** Synchronizes the data (name and value) for fast nodes. */
    protected void synchronizeData() {

        // no need to sync in the future
        syncData(false);

        // fluff data
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument;
        name = ownerDocument.getNodeNameString(fNodeIndex);

    } // synchronizeData()

    /** Synchronizes the default attribute values. */
    protected void synchronizeChildren() {

        // attributes are now synced
        syncChildren(false);

        // create attributes node map
        DeferredDocumentImpl ownerDocument =
            (DeferredDocumentImpl)this.ownerDocument;
        attributes = new NamedNodeMapImpl(ownerDocument, null);

        // Default attributes dangle as children of the element
        // definition ""node"" in the internal fast table.
        for (int nodeIndex = ownerDocument.getLastChild(fNodeIndex);
             nodeIndex != -1;
             nodeIndex = ownerDocument.getPrevSibling(nodeIndex)) {
            Node attr = ownerDocument.getNodeObject(nodeIndex);
            attributes.setNamedItem(attr);
        }

    } // synchronizeChildren()

} // class DeferredElementDefinitionImpl
"
org/apache/xerces/utils/XMLMessageProvider.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import java.util.Locale;

/**
 * Interface describing how to provide localized error messages to the XMLErrorReporter
 *
 * @see org.apache.xerces.framework.XMLErrorReporter
 */
public interface XMLMessageProvider {
    /**
     * Set the locale to be used for error messages
     *
     * @param locale the new locale
     */
    public void setLocale(Locale locale);
    /**
     * Get the locale being used for error messages
     *
     * @return the locale
     */
    public Locale getLocale();
    /**
     * Creates a message from the specified key and replacement
     * arguments, localized to the given locale.
     *
     * @param locale    The requested locale of the message to be
     *                  created.
     * @param key       The key for the message text.
     * @param args      The arguments to be used as replacement text
     *                  in the message created.
     */
    public String createMessage(Locale locale, int majorCode, int minorCode, Object args[]);
};
"
org/xml/sax/ErrorHandler.java,true,"// SAX error handler.
// No warranty; no copyright -- use this as you will.
// $Id: ErrorHandler.java,v 1.4 2000/05/05 17:46:27 david Exp $

package org.xml.sax;


/**
 * Basic interface for SAX error handlers.
 *
 * <blockquote>
 * <em>This module, both source code and documentation, is in the
 * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>
 * </blockquote>
 *
 * <p>If a SAX application needs to implement customized error
 * handling, it must implement this interface and then register an
 * instance with the XML reader using the
 * {@link org.xml.sax.XMLReader#setErrorHandler setErrorHandler}
 * method.  The parser will then report all errors and warnings
 * through this interface.</p>
 *
 * <p><strong>WARNING:</strong> If an application does <em>not</em>
 * register an ErrorHandler, XML parsing errors will go unreported
 * and bizarre behaviour may result.</p>
 *
 * <p>For XML processing errors, a SAX driver must use this interface 
 * instead of throwing an exception: it is up to the application 
 * to decide whether to throw an exception for different types of 
 * errors and warnings.  Note, however, that there is no requirement that 
 * the parser continue to provide useful information after a call to 
 * {@link #fatalError fatalError} (in other words, a SAX driver class 
 * could catch an exception and report a fatalError).</p>
 *
 * @since SAX 1.0
 * @author David Megginson, 
 *         <a href=""mailto:sax@megginson.com"">sax@megginson.com</a>
 * @version 2.0
 * @see org.xml.sax.Parser#setErrorHandler
 * @see org.xml.sax.SAXParseException 
 */
public interface ErrorHandler {
    
    
    /**
     * Receive notification of a warning.
     *
     * <p>SAX parsers will use this method to report conditions that
     * are not errors or fatal errors as defined by the XML 1.0
     * recommendation.  The default behaviour is to take no action.</p>
     *
     * <p>The SAX parser must continue to provide normal parsing events
     * after invoking this method: it should still be possible for the
     * application to process the document through to the end.</p>
     *
     * <p>Filters may use this method to report other, non-XML warnings
     * as well.</p>
     *
     * @param exception The warning information encapsulated in a
     *                  SAX parse exception.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.SAXParseException 
     */
    public abstract void warning (SAXParseException exception)
	throws SAXException;
    
    
    /**
     * Receive notification of a recoverable error.
     *
     * <p>This corresponds to the definition of ""error"" in section 1.2
     * of the W3C XML 1.0 Recommendation.  For example, a validating
     * parser would use this callback to report the violation of a
     * validity constraint.  The default behaviour is to take no
     * action.</p>
     *
     * <p>The SAX parser must continue to provide normal parsing events
     * after invoking this method: it should still be possible for the
     * application to process the document through to the end.  If the
     * application cannot do so, then the parser should report a fatal
     * error even if the XML 1.0 recommendation does not require it to
     * do so.</p>
     *
     * <p>Filters may use this method to report other, non-XML errors
     * as well.</p>
     *
     * @param exception The error information encapsulated in a
     *                  SAX parse exception.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.SAXParseException 
     */
    public abstract void error (SAXParseException exception)
	throws SAXException;
    
    
    /**
     * Receive notification of a non-recoverable error.
     *
     * <p>This corresponds to the definition of ""fatal error"" in
     * section 1.2 of the W3C XML 1.0 Recommendation.  For example, a
     * parser would use this callback to report the violation of a
     * well-formedness constraint.</p>
     *
     * <p>The application must assume that the document is unusable
     * after the parser has invoked this method, and should continue
     * (if at all) only for the sake of collecting addition error
     * messages: in fact, SAX parsers are free to stop reporting any
     * other events once this method has been invoked.</p>
     *
     * @param exception The error information encapsulated in a
     *                  SAX parse exception.  
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see org.xml.sax.SAXParseException
     */
    public abstract void fatalError (SAXParseException exception)
	throws SAXException;
    
}

// end of ErrorHandler.java
"
org/apache/xerces/utils/XMLMessages.java,false,"/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       ""This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).""
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names ""Xerces"" and ""Apache Software Foundation"" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called ""Apache"",
 *    nor may ""Apache"" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.utils;

import java.util.Locale;
import java.util.ResourceBundle;
import java.util.ListResourceBundle;

/**
 * XMLMessages provides error messages for the XML 1.0 Recommendation and for 
 * the Namespaces Recommendation
 *
 */
public class XMLMessages implements XMLMessageProvider {
    /**
     * The domain of messages concerning the XML 1.0 specification.
     */
    public static final String XML_DOMAIN = ""http://www.w3.org/TR/1998/REC-xml-19980210"";
    public static final String XMLNS_DOMAIN = ""http://www.w3.org/TR/1999/REC-xml-names-19990114"";

    /**
     *
     */
    public void setLocale(Locale locale) {
        fLocale = locale;
    }
    /**
     *
     */
    public Locale getLocale() {
        return fLocale;
    }

    /**
     * Creates a message from the specified key and replacement
     * arguments, localized to the given locale.
     *
     * @param locale    The requested locale of the message to be
     *                  created.
     * @param key       The key for the message text.
     * @param args      The arguments to be used as replacement text
     *                  in the message created.
     */
    public String createMessage(Locale locale, int majorCode, int minorCode, Object args[]) {
        boolean throwex = false;
        if (fResourceBundle == null || locale != fLocale) {
            if (locale != null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.XMLMessages"", locale);
            if (fResourceBundle == null)
                fResourceBundle = ListResourceBundle.getBundle(""org.apache.xerces.msg.XMLMessages"");
        }
        if (majorCode < 0 || majorCode >= fgMessageKeys.length - 1) {
            majorCode = MSG_BAD_MAJORCODE;
            throwex = true;
        }
        String msgKey = fgMessageKeys[majorCode];
        String msg = fResourceBundle.getString(msgKey);
        if (args != null) {
            try {
                msg = java.text.MessageFormat.format(msg, args);
            } catch (Exception e) {
                msg = fResourceBundle.getString(fgMessageKeys[MSG_FORMAT_FAILURE]);
                msg += "" "" + fResourceBundle.getString(msgKey);
            }
        }
/*
        if (minorCode > 0 && minorCode < fgConstraints.length - 1) {
            Constraint c = fgConstraints[minorCode];
            String prefix = ""{ "" + c.sections;
            if (c.productions != null && c.productions.length() != 0)
                prefix = prefix + "" "" + c.productions;
            msg = prefix + "" } "" + msg;
        }
 */
        if (throwex) {
            throw new RuntimeException(msg);
        }
        return msg;
    }
    //
    //
    //
    private Locale fLocale = null;
    private ResourceBundle fResourceBundle = null;
    //
    //
    //
    public static final int
        MSG_BAD_MAJORCODE = 0,              //  majorCode parameter to createMessage was out of bounds
        MSG_FORMAT_FAILURE = 1,             //  exception thrown during messageFormat call
        MSG_LESSTHAN_IN_ATTVALUE = 2,       //  '<' found in attribute value
        MSG_ROOT_ELEMENT_TYPE = 3,          //  document root element type does not match the doctypedecl Name
        MSG_IDREFS_INVALID = 4,             //  attributes of type IDREFS must match the Names production
        MSG_NMTOKENS_INVALID = 5,           //  attributes of type NMTOKENS must match the Nmtokens production
        MSG_RESERVED_PITARGET = 6,          //  PITarget matching [Xx][Mm][Ll] is reserved
        MSG_SPACE_REQUIRED_IN_PI = 7,       //  white space is required between PITarget and data
        MSG_INVALID_CHAR_IN_PI = 8,         //  invalid character found in PI data
        MSG_DASH_DASH_IN_COMMENT = 9,       //  the string ""--"" in not allowed in comments
        MSG_INVALID_CHAR_IN_COMMENT = 10,   //  invalid character found in comment
        MSG_INVALID_CHARREF = 11,           //  invalid value for character reference
        MSG_INVALID_CHAR_IN_ATTVALUE = 12,  //  invalid character found in attribute value
        MSG_QUOTE_REQUIRED_IN_ATTVALUE = 13, //  attribute value was not a quoted string
        MSG_NAME_REQUIRED_IN_REFERENCE = 14, //  a Name did not follow the '&' in the entity reference
        MSG_SEMICOLON_REQUIRED_IN_REFERENCE = 15, //  a ';' did not follow the Name in the entity reference
        MSG_DIGIT_REQUIRED_IN_CHARREF = 16,  //  a decimal representation did not follow the ""&#"" in the character reference
        MSG_HEXDIGIT_REQUIRED_IN_CHARREF = 17, //  a hexadecimal representation did not follow the ""&#x"" in the character reference
        MSG_SEMICOLON_REQUIRED_IN_CHARREF = 18, //  the ';' delimiter was not found in the character reference
        MSG_QUOTE_REQUIRED_IN_SYSTEMID = 19, //  system identifier was not a quoted string
        MSG_INVALID_CHAR_IN_SYSTEMID = 20,  //  invalid character found in system identifier
        MSG_QUOTE_REQUIRED_IN_PUBLICID = 21, //  public identifier was not a quoted string
        MSG_INVALID_CHAR_IN_PUBLICID = 22,  //  invalid character found in public identifier
        MSG_INCLUDESECT_UNTERMINATED = 23,  //  includeSect must end with ""]]>""
        MSG_IGNORESECT_UNTERMINATED = 24,   //  ignoreSect must end with ""]]>""
        MSG_INVALID_CHAR_IN_IGNORESECT = 25, //  invalid character found in ignoreSect
        MSG_ELEMENT_UNTERMINATED = 26,      //  element type not followed by attributes, "">"" or ""/>""
        MSG_EQ_REQUIRED_IN_ATTRIBUTE = 27,   //  attribute name not followed by ""=""
        MSG_ATTRIBUTE_NOT_UNIQUE = 28,      //  specified attributes must be unique within the element tag
        MSG_ENCODINGDECL_REQUIRED = 29,      //  the ""encoding"" declaration is required in a text declaration
        MSG_VERSIONINFO_REQUIRED = 30,       //  the ""version"" is required in the XML declaration
        MSG_EQ_REQUIRED_IN_XMLDECL = 31,     //  the '=' character must follow \""{0}\"" in the XML declaration
        MSG_EQ_REQUIRED_IN_TEXTDECL = 32,    //  the '=' character must follow \""{0}\"" in the text declaration
        MSG_QUOTE_REQUIRED_IN_XMLDECL = 33,  //  quote missing in the XML declaration
        MSG_QUOTE_REQUIRED_IN_TEXTDECL = 34, //  quote missing in the text declaration
        MSG_INVALID_CHAR_IN_XMLDECL = 35,   //  invalid character found in the XML declaration
        MSG_INVALID_CHAR_IN_TEXTDECL = 36,  //  invalid character found in the text declaration
        MSG_VERSIONINFO_INVALID = 37,       //  Invalid XML version format, \""{0}\""
        MSG_VERSION_NOT_SUPPORTED = 38,     //  unsupported XML version
        MSG_SPACE_REQUIRED_IN_TEXTDECL = 39, //  white space required between version and encoding
        MSG_ENCODINGDECL_INVALID = 40,      //  invalid encoding name
        MSG_SDDECL_INVALID = 41,            //  invalid \""standalone\"" attribute value. Must be ""yes"" or ""no""
        MSG_XMLDECL_UNTERMINATED = 42,      //  ""\""?>\"" expected.
        MSG_TEXTDECL_UNTERMINATED = 43,     //  ""\""?>\"" expected.
        MSG_INVALID_CHAR_IN_INTERNAL_SUBSET = 44, //  invalid character found in the internal subset of the dtd
        MSG_INVALID_CHAR_IN_EXTERNAL_SUBSET = 45, //  invalid character found in the external subset of the dtd
        MSG_INVALID_CHAR_IN_ENTITYVALUE = 46, //  invalid character found in entity value
        MSG_MIXED_CONTENT_UNTERMINATED = 47, //  mixed content model with element types must end with "")*""
        MSG_NAME_REQUIRED_IN_PEREFERENCE = 48, //  a Name did not follow the '&' in the parameter entity reference
        MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE = 49, //  a ';' did not follow the Name in the parameter entity reference
        MSG_EXTERNALID_REQUIRED = 50,        //  an external id did not begin with SYSTEM or PUBLIC
        MSG_PEREFERENCE_WITHIN_MARKUP = 51, //  a PEReference is not allowed within markup in the internal subset of the DTD
        MSG_INVALID_CHAR_IN_PROLOG = 52,    //  invalid character found in prolog
        MSG_INVALID_CHAR_IN_MISC = 53,      //  invalid character found in trailing misc
        MSG_INVALID_CHAR_IN_CDSECT = 54,    //  invalid character found in cdata section
        MSG_INVALID_CHAR_IN_CONTENT = 55,   //  invalid character found in content
        MSG_ETAG_REQUIRED = 56,              //  end of input before end of element content
        MSG_ETAG_UNTERMINATED = 57,         //  the end-tag did not end with a '>'
        MSG_ATTRIBUTE_NAME_REQUIRED_IN_ATTDEF = 58, //  attribute name expected
        MSG_ATTTYPE_REQUIRED_IN_ATTDEF = 59, //  attribute type expected
        MSG_PUBIDCHAR_ILLEGAL = 60,        //  illegal character found in public identifier
        MSG_ENCODING_NOT_SUPPORTED = 61,   //  encoding is not supported
        MSG_ENTITY_NOT_DECLARED = 62,      //  entity was not declared
        MSG_REFERENCE_TO_UNPARSED_ENTITY = 63,
        MSG_REFERENCE_TO_EXTERNAL_ENTITY = 64,
        MSG_XML_LANG_INVALID = 65,         //  xml:lang attribute value does not match LanguageID production
        MSG_CDSECT_UNTERMINATED = 66,      //  CDATA sections must end with ""]]>""
        MSG_DUPLICATE_TYPE_IN_MIXED_CONTENT = 67,
        MSG_ELEMENT_ENTITY_MISMATCH = 68,
        MSG_ID_DEFAULT_TYPE_INVALID = 69,
        MSG_ENCODING_REQUIRED = 70,
        MSG_RECURSIVE_REFERENCE = 71,
        MSG_RECURSIVE_PEREFERENCE = 72,
        MSG_IMPROPER_DECLARATION_NESTING = 73, // ""Parameter entity replacement text must include declarations or proper pairs of ''<'' and ''>''. (entity: \""%{0};\"")""
        MSG_IMPROPER_GROUP_NESTING = 74,    // ""Parameter entity replacement text must include proper pairs of parentheses in content model, \""%{0};\"".""
        MSG_ID_INVALID = 75,
        MSG_ID_NOT_UNIQUE = 76,
        MSG_IDREF_INVALID = 77,
        MSG_NMTOKEN_INVALID = 78,
        MSG_ENTITY_INVALID = 79,
        MSG_ENTITIES_INVALID = 80,
        MSG_ELEMENT_WITH_ID_REQUIRED = 81,
        MSG_ATTRIBUTE_NOT_DECLARED = 82,
        MSG_ELEMENT_NOT_DECLARED = 83,
        MSG_AVAILABLE1 = 84,
        MSG_DUPLICATE_ATTDEF = 85,
        MSG_MORE_THAN_ONE_ID_ATTRIBUTE = 86,
        MSG_CONTENT_INVALID = 87,
        MSG_CONTENT_INCOMPLETE = 88,
        MSG_ELEMENT_ALREADY_DECLARED = 89,
        MSG_ATTRIBUTE_VALUE_NOT_IN_LIST = 90,
        MSG_AVAILABLE2 = 91,
        MSG_UNDECLARED_ELEMENT_IN_CONTENTSPEC = 92,
        MSG_FIXED_ATTVALUE_INVALID = 93,
        MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED = 94,
        MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED = 95,
        MSG_AVAILABLE3 = 96,
        MSG_AVAILABLE4 = 97,
        MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN = 98,
        MSG_AVAILABLE5 = 99,
        MSG_SYSTEMID_UNTERMINATED = 100,
        MSG_PUBLICID_UNTERMINATED = 101,
        MSG_EXTERNAL_ENTITY_NOT_PERMITTED = 102,
        MSG_AVAILABLE6 = 103,
        MSG_XMLDECL_MUST_BE_FIRST = 104,
        MSG_TEXTDECL_MUST_BE_FIRST = 105,
        MSG_ELEMENTDECL_UNTERMINATED = 106,
        MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL = 107,
        MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL = 108,
        MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL = 109,
        MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL = 110,
        MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL = 111,
        MSG_ENTITYDECL_UNTERMINATED = 112,
        MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL = 113,
        MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL = 114,
        MSG_NAME_REQUIRED_IN_NOTATIONTYPE = 115,
        MSG_NMTOKEN_REQUIRED_IN_ENUMERATION = 116,
        MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE = 117,
        MSG_NOTATIONTYPE_UNTERMINATED = 118,
        MSG_ENUMERATION_UNTERMINATED = 119,
        MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL = 120,
        MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE = 121,
        MSG_NOTATIONDECL_UNTERMINATED = 122,
        MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE = 123,
        MSG_CDEND_IN_CONTENT = 124,
        MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL = 125,
        MSG_TWO_COLONS_IN_QNAME = 126,
        MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT = 127,
        MSG_MARKUP_NOT_RECOGNIZED_IN_MISC = 128,
        MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG = 129,
        MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE = 130,
        MSG_PITARGET_REQUIRED = 131,
        MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE = 132,
        MSG_URI_FRAGMENT_IN_SYSTEMID = 133,
        MSG_ROOT_ELEMENT_REQUIRED = 134,
        MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL = 135,
        MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE = 136,
        MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL = 137,
        MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF = 138,
        MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF = 139,
        MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF = 140,
        MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL = 141,
        MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL = 142,
        MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE = 143,
        MSG_XML_SPACE_DECLARATION_ILLEGAL = 144,
        MSG_CLOSE_PAREN_REQUIRED_IN_MIXED = 145,
        MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL = 146,
        MSG_DOCTYPEDECL_UNTERMINATED = 147,
        MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL = 148,
        MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT = 149,
        MSG_MARKUP_NOT_RECOGNIZED_IN_DTD = 150,
        MSG_ATTRIBUTE_VALUE_UNTERMINATED = 151,
        MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN = 152,
        MSG_ROOT_ELEMENT_TYPE_REQUIRED = 153,
        MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID = 154,
        MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL = 155,
        MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL = 156,
        MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL = 157,
        MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID = 158,
        MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL = 159,
        MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID = 160,
        MSG_REFERENCE_NOT_IN_ONE_ENTITY = 161,
        MSG_COMMENT_NOT_IN_ONE_ENTITY = 162,
        MSG_COMMENT_UNTERMINATED = 163,
        MSG_PI_UNTERMINATED = 164,
        MSG_PI_NOT_IN_ONE_ENTITY = 165,
        MSG_REFERENCE_UNTERMINATED = 166,
        MSG_PREFIX_DECLARED = 167,
        MSG_ATT_DEFAULT_INVALID = 168,

        // ...
        MSG_MAX_CODE = 200;

    private static final String[] fgMessageKeys = {
        ""BadMajorCode"",                 //   0, ""The majorCode parameter to createMessage was out of bounds.""
        ""FormatFailed"",                 //   1, ""An internal error occurred while formatting the following message:""
        ""LessthanInAttValue"",           //   2, ""The attribute value must not contain the '<' character.""
        ""RootElementTypeMustMatchDoctypedecl"", //   3, ""The document root element type \""{1}\"" must match the document type declaration name \""{0}\"".""
        ""IDREFSInvalid"",                //   4, ""Attribute value \""{1}\"" of type IDREFS must be one or more names.""
        ""NMTOKENSInvalid"",              //   5, ""Attribute value \""{1}\"" of type NMTOKENS must contain one or more name tokens.""
        ""ReservedPITarget"",             //   6, ""The processing instruction target matching \""[xX][mM][lL]\"" is not allowed.""
        ""SpaceRequiredInPI"",            //   7, ""White space is required between the processing instruction target and data.""
        ""InvalidCharInPI"",              //   8, ""An invalid XML character (Unicode: 0x{0}) was found in the processing instruction.""
        ""DashDashInComment"",            //   9, ""The string \""--\"" is not permitted within comments.""
        ""InvalidCharInComment"",         //  10, ""An invalid XML character (Unicode: 0x{0}) was found in the comment.""
        ""InvalidCharRef"",               //  11, ""Character reference \""&#{0}\"" is an invalid XML character.""
        ""InvalidCharInAttValue"",        //  12, ""An invalid XML character (Unicode: 0x{0}) was found in the attribute value.""
        ""QuoteRequiredInAttValue"",      //  13, ""The attribute value must begin with either a single or double quote character.""
        ""NameRequiredInReference"",      //  14, ""The entity name must immediately follow the '&' in the entity reference.""
        ""SemicolonRequiredInReference"", //  15, ""The entity reference must end with the ';' delimiter.""
        ""DigitRequiredInCharRef"",       //  16, ""A decimal representation must immediately follow the \""&#\"" in the character reference.""
        ""HexdigitRequiredInCharRef"",    //  17, ""A hexadecimal representation must immediately follow the \""&#x\"" in the character reference.""
        ""SemicolonRequiredInCharRef"",   //  18, ""The character reference must end with the ';' delimiter.""
        ""QuoteRequiredInSystemID"",      //  19, ""The system identifier must begin with either a single or double quote character.""
        ""InvalidCharInSystemID"",        //  20, ""An invalid XML character (Unicode: 0x{0}) was found in the system identifier.""
        ""QuoteRequiredInPublicID"",      //  21, ""The public identifier must begin with either a single or double quote character.""
        ""InvalidCharInPublicID"",        //  22, ""An invalid XML character (Unicode: 0x{0}) was found in the public identifier.""
        ""IncludeSectUnterminated"",      //  23, ""The included conditional section must end with \""]]>\"".""
        ""IgnoreSectUnterminated"",       //  24, ""The excluded conditional section must end with \""]]>\"".""
        ""InvalidCharInIgnoreSect"",      //  25, ""An invalid XML character (Unicode: 0x{0}) was found in the excluded conditional section.""
        ""ElementUnterminated"",          //  26, ""Element type \""{0}\"" must be followed by either attribute specifications, \"">\"" or \""/>\"".""
        ""EqRequiredInAttribute"",        //  27, ""Attribute name \""{1}\"" must be followed by the '=' character.""
        ""AttributeNotUnique"",           //  28, ""Attribute \""{1}\"" was already specified for element \""{0}\"".""
        ""EncodingDeclRequired"",         //  29, ""The encoding declaration is required within a text declaration.""
        ""VersionInfoRequired"",          //  30, ""The version is required within an XML declaration.""
        ""EqRequiredInXMLDecl"",          //  31, ""The '=' character must follow \""{0}\"" in the XML declaration.""
        ""EqRequiredInTextDecl"",         //  32, ""The '=' character must follow \""{0}\"" in the text declaration.""
        ""QuoteRequiredInXMLDecl"",       //  33, ""The value following \""{0}\"" in an XML declaration must be a quoted string.""
        ""QuoteRequiredInTextDecl"",      //  34, ""The value following \""{0}\"" in a text declaration must be a quoted string.""
        ""InvalidCharInXMLDecl"",         //  35, ""An invalid XML character (Unicode: 0x{0}) was found in the XML declaration.""
        ""InvalidCharInTextDecl"",        //  36, ""An invalid XML character (Unicode: 0x{0}) was found in the text declaration.""
        ""VersionInfoInvalid"",           //  37, ""Invalid version \""{0}\"".""
        ""VersionNotSupported"",          //  38, ""XML version \""{0}\"" is not supported.""
        ""SpaceRequiredInTextDecl"",      //  39, ""White space is required between the version and the encoding declaration.""
        ""EncodingDeclInvalid"",          //  40, ""Invalid encoding name \""{0}\"".""
        ""SDDeclInvalid"",                //  41, ""The standalone document declaration value must be \""yes\"" or \""no\"", not \""{0}\"".""
        ""XMLDeclUnterminated"",          //  42, ""The XML declaration must end with \""?>\"".""
        ""TextDeclUnterminated"",         //  43, ""The text declaration must end with \""?>\"".""
        ""InvalidCharInInternalSubset"",  //  44, ""An invalid XML character (Unicode: 0x{0}) was found in the internal subset of the DTD.""
        ""InvalidCharInExternalSubset"",  //  45, ""An invalid XML character (Unicode: 0x{0}) was found in the external subset of the DTD.""
        ""InvalidCharInEntityValue"",     //  46, ""An invalid XML character (Unicode: 0x{0}) was found in the literal entity value.""
        ""MixedContentUnterminated"",     //  47, ""The mixed content model \""(0}\"" must end with \"")*\"".""
        ""NameRequiredInPEReference"",    //  48, ""The entity name must immediately follow the '%' in the parameter entity reference.""
        ""SemicolonRequiredInPEReference"", //  49, ""The parameter entity reference must end with the ';' delimiter.""
        ""ExternalIDRequired"",           //  50, ""The external entity declaration must begin with either \""SYSTEM\"" or \""PUBLIC\"".""
        ""PEReferenceWithinMarkup"",      //  51, ""The parameter entity reference \""%(0);\"" cannot occur within markup in the internal subset of the DTD.""
        ""InvalidCharInProlog"",          //  52, ""An invalid XML character (Unicode: 0x{0}) was found in the prolog of the document.""
        ""InvalidCharInMisc"",            //  53, ""An invalid XML character (Unicode: 0x{0}) was found in markup after the end of the element content.""
        ""InvalidCharInCDSect"",          //  54, ""An invalid XML character (Unicode: 0x{0}) was found in the CDATA section.""
        ""InvalidCharInContent"",         //  55, ""An invalid XML character (Unicode: 0x{0}) was found in the element content of the document.""
        ""ETagRequired"",                 //  56, ""The element type \""{0}\"" must be terminated by the matching end-tag \""</{0}>\"".""
        ""ETagUnterminated"",             //  57, ""The end-tag for element type \""{0}\"" must end with a ''>'' delimiter.""
        ""AttNameRequiredInAttDef"",      //  58, ""The attribute name must be specified in the attribute-list declaration for element \""{0}\"".""
        ""AttTypeRequiredInAttDef"",      //  59, ""The attribute type must be specified in the attribute-list declaration of attribute \""{1}\"" for element \""{0}\"".""
        ""PubidCharIllegal"",             //  60, ""The character (Unicode: 0x{0}) is not permitted in the public identifier.""
        ""EncodingNotSupported"",         //  61, ""The encoding \""{0}\"" is not supported.""
        ""EntityNotDeclared"",            //  62, ""The entity \""{0}\"" was referenced, but not declared.""
        ""ReferenceToUnparsedEntity"",    //  63, ""The unparsed entity reference \""&{0};\"" is not permitted.""
        ""ReferenceToExternalEntity"",    //  64, ""The external entity reference \""&{0};\"" is not permitted in an attribute value.""
        ""XMLLangInvalid"",               //  65, ""The xml:lang attribute value \""{0}\"" is an invalid language identifier.""
        ""CDSectUnterminated"",           //  66, ""The CDATA section must end with \""]]>\"".""
        ""DuplicateTypeInMixedContent"",  //  67, ""The element type \""{0}\"" was already specified in this content model.""
        ""ElementEntityMismatch"",        //  68, ""The element \""{0}\"" must start and end within the same entity.""
        ""IDDefaultTypeInvalid"",         //  69, ""The ID attribute \""{0}\"" must have a declared default of \""#IMPLIED\"" or \""#REQUIRED\"".""
        ""EncodingRequired"",             //  70, ""A parsed entity not encoded in either UTF-8 or UTF-16 must contain an encoding declaration.""
        ""RecursiveReference"",           //  71, ""Recursive reference \""&{0};\"". (Reference path: {1})""
        ""RecursivePEReference"",         //  72, ""Recursive reference \""%{0};\"". (Reference path: {1})""
        ""ImproperDeclarationNesting"",   //  73, ""The replacement text of parameter entity \""(0)\"" must include properly nested declarations.""
        ""ImproperGroupNesting"",         //  74, ""The replacement text of parameter entity \""(0)\"" must include properly nested pairs of parentheses in content model.""
        ""IDInvalid"",                    //  75, ""Attribute value \""{1}\"" of type ID must be a name.""
        ""IDNotUnique"",                  //  76, ""Attribute value \""(1}\"" of type ID must be unique within the document.""
        ""IDREFInvalid"",                 //  77, ""Attribute value \""(1}\"" of type IDREF must be a name.""
        ""NMTOKENInvalid"",               //  78, ""Attribute value \""(1}\"" of type NMTOKEN must be a name token.""
        ""ENTITYInvalid"",                //  79, ""Attribute value \""(1}\"" of type ENTITY must be the name of an unparsed entity.""
        ""ENTITIESInvalid"",              //  80, ""Attribute value \""(1}\"" of type ENTITIES must be the names of one or more unparsed entities.""
        ""MSG_ELEMENT_WITH_ID_REQUIRED"", //  81, ""MSG_ELEMENT_WITH_ID_REQUIRED""
        ""MSG_ATTRIBUTE_NOT_DECLARED"",   //  82, ""MSG_ATTRIBUTE_NOT_DECLARED""
        ""MSG_ELEMENT_NOT_DECLARED"",     //  83, ""MSG_ELEMENT_NOT_DECLARED""
        ""MSG_AVAILABLE1"",               //  84,
        ""MSG_DUPLICATE_ATTDEF"",         //  85, ""MSG_DUPLICATE_ATTDEF""
        ""MSG_MORE_THAN_ONE_ID_ATTRIBUTE"", //  86, ""MSG_MORE_THAN_ONE_ID_ATTRIBUTE""
        ""MSG_CONTENT_INVALID"",          //  87, ""MSG_CONTENT_INVALID""
        ""MSG_CONTENT_INCOMPLETE"",       //  88, ""MSG_CONTENT_INCOMPLETE""
        ""MSG_ELEMENT_ALREADY_DECLARED"", //  89, ""MSG_ELEMENT_ALREADY_DECLARED""
        ""MSG_ATTRIBUTE_VALUE_NOT_IN_LIST"", //  90, ""MSG_ATTRIBUTE_VALUE_NOT_IN_LIST""
        ""MSG_AVAILABLE2"",               //  91,
        ""UndeclaredElementInContentSpec"", //   92, ""The content model of element \""{0}\"" refers to the undeclared element \""{1}\"".""
        ""MSG_FIXED_ATTVALUE_INVALID"",   //  93, ""MSG_FIXED_ATTVALUE_INVALID""
        ""MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED"", //  94, ""MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED""
        ""MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED"", //  95, ""MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED""
        ""MSG_AVAILABLE3"",               //  96,
        ""MSG_AVAILABLE4"",               //  97,
        ""MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"", //  98, ""MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN""
        ""MSG_AVAILABLE5"",               //  99,
        ""SystemIDUnterminated"",         // 100, ""MSG_SYSTEMID_UNTERMINATED""
        ""PublicIDUnterminated"",         // 101, ""MSG_PUBLICID_UNTERMINATED""
        ""MSG_EXTERNAL_ENTITY_NOT_PERMITTED"", // 102, ""MSG_EXTERNAL_ENTITY_NOT_PERMITTED""
        ""MSG_AVAILABLE6"",               // 103,
        ""XMLDeclMustBeFirst"",           // 104, ""MSG_XMLDECL_MUST_BE_FIRST""
        ""TextDeclMustBeFirst"",          // 105, ""MSG_TEXTDECL_MUST_BE_FIRST""
        ""ElementDeclUnterminated"",      // 106, ""MSG_ELEMENTDECL_UNTERMINATED""
        ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL"",     // 107, ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL"",     // 108, ""MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL"",     // 109, ""MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL""
        ""MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL"",     // 110, ""MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL""
        ""MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"",     // 111, ""MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL""
        ""EntityDeclUnterminated"",       // 112, ""MSG_ENTITYDECL_UNTERMINATED""
        ""MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL"",     // 113, ""MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL""
        ""MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL"",     // 114, ""MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL""
        ""MSG_NAME_REQUIRED_IN_NOTATIONTYPE"",     // 115, ""MSG_NAME_REQUIRED_IN_NOTATIONTYPE""
        ""MSG_NMTOKEN_REQUIRED_IN_ENUMERATION"",     // 116, ""MSG_NMTOKEN_REQUIRED_IN_ENUMERATION""
        ""MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE"",     // 117, ""MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE""
        ""NotationTypeUnterminated"",     // 118, ""MSG_NOTATIONTYPE_UNTERMINATED""
        ""EnumerationUnterminated"",      // 119, ""MSG_ENUMERATION_UNTERMINATED""
        ""MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL"", // 120, ""MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL""
        ""MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE"", // 121, ""MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE""
        ""NotationDeclUnterminated"",     // 122, ""MSG_NOTATIONDECL_UNTERMINATED""
        ""MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE"",     // 123, ""MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE""
        ""CDEndInContent"",               // 124, ""MSG_CDEND_IN_CONTENT""
        ""MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL"",     // 125, ""MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL""
        ""TwoColonsInQName"",             // 126, """"
        ""MarkupNotRecognizedInContent"", // 127, ""MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT""
        ""MarkupNotRecognizedInMisc"",    // 128, ""MSG_MARKUP_NOT_RECOGNIZED_IN_MISC""
        ""MarkupNotRecognizedInProlog"",  // 129, ""MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG""
        ""MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE"",     // 130, ""MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE""
        ""PITargetRequired"",             // 131, ""MSG_PITARGET_REQUIRED""
        ""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"",     // 132, ""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE""
        ""MSG_URI_FRAGMENT_IN_SYSTEMID"", // 133, ""MSG_URI_FRAGMENT_IN_SYSTEMID""
        ""RootElementRequired"",          // 134, ""MSG_ROOT_ELEMENT_REQUIRED""
        ""MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL"",     // 135, ""MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL""
        ""MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE"",     // 136, ""MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE""
        ""MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL"",     // 137, ""MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF"",     // 138, ""MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF""
        ""MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF"",     // 139, ""MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF""
        ""MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF"",     // 140, ""MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF""
        ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL"",     // 141, ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL"",     // 142, ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL""
        ""MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE"",     // 143, ""MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE""
        ""MSG_XML_SPACE_DECLARATION_ILLEGAL"",     // 144, ""MSG_XML_SPACE_DECLARATION_ILLEGAL""
        ""MSG_CLOSE_PAREN_REQUIRED_IN_MIXED"",     // 145, ""MSG_CLOSE_PAREN_REQUIRED_IN_MIXED""
        ""MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL"",     // 146, ""MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL""
        ""DoctypedeclUnterminated"", // 147, ""MSG_DOCTYPEDECL_UNTERMINATED""
        ""MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL"",     // 148, ""MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL""
        ""MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT"",     // 149, ""MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT""
        ""MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"",     // 150, ""MSG_MARKUP_NOT_RECOGNIZED_IN_DTD""
        ""AttributeValueUnterminated"",   // 151, ""MSG_ATTRIBUTE_VALUE_UNTERMINATED""
        ""MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"",     // 152, ""MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN""
        ""MSG_ROOT_ELEMENT_TYPE_REQUIRED"",     // 153, ""MSG_ROOT_ELEMENT_TYPE_REQUIRED""
        ""MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID"",     // 154, ""MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID""
        ""MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL"",     // 155, ""MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL"",     // 156, ""MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL"",     // 157, ""MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID"",     // 158, ""MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID""
        ""MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL"",     // 159, ""MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL""
        ""MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID"",     // 160, ""MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID""
        ""ReferenceNotInOneEntity"",      // 161, ""MSG_REFERENCE_NOT_IN_ONE_ENTITY""
        ""CommentNotInOneEntity"",        // 162, ""MSG_COMMENT_MUST_BEGIN_AND_END_IN_THE_SAME_ENTITY""
        ""CommentUnterminated"",          // 163, ""MSG_COMMENT_UNTERMINATED""
        ""PIUnterminated"",               // 164, ""MSG_PI_UNTERMINATED""
        ""PINotInOneEntity"",             // 165, ""MSG_PI_MUST_BEGIN_AND_END_IN_THE_SAME_ENTITY""
        ""ReferenceUnterminated"",        // 166, ""MSG_REFERENCE_UNTERMINATED""
        ""PrefixDeclared"",               // 167, ""MSG_PREFIX_DECLARED""
        ""MSG_ATT_DEFAULT_INVALID"",      // 168, ""MSG_ATT_DEFAULT_INVALID""

        // ...
        """"                              //
    };

    public static final int
        VC_ROOT_ELEMENT_TYPE = 1,           // 2.8 VC: Root Element Type
        VC_IDREF = 2,                       // 3.3.1 VC: IDREF
        VC_NAME_TOKEN = 3,                  // 3.3.1 VC: Name Token
        P17_RESERVED_PITARGET = 4,          // 2.6 [17] PITarget matching [Xx][Mm][Ll] is reserved
        P16_WHITESPACE_REQUIRED = 5,        // 2.6 [16] White space required between PITarget and data
        P16_INVALID_CHARACTER = 6,          // 2.6 [16] Invalid character in PI data
        P15_DASH_DASH = 7,                  // 2.5 [15] The string ""--"" must not occur within comments
        P15_INVALID_CHARACTER = 8,          // 2.5 [15] Invalid character in comment
        WFC_LEGAL_CHARACTER = 9,            // 4.1 [66] WFC: Legal Character
        P10_INVALID_CHARACTER = 10,         // 2.3 [10] Invalid character in AttValue
        WFC_NO_LESSTHAN_IN_ATTVALUE = 11,   // 3.1 [41] WFC: No < in Attribute Values
        P10_QUOTE_REQUIRED = 12,             // 2.3 [10] No quote delimiter in AttValue
        P68_NAME_REQUIRED = 13,              // 4.1 [68] Name missing in EntityRef
        P68_SEMICOLON_REQUIRED = 14,         // 4.1 [68] An EntityRef must end with a ';'
        P66_DIGIT_REQUIRED = 15,             // 4.1 [66] A ""&#"" CharRef must contain at least one decimal digit
        P66_HEXDIGIT_REQUIRED = 16,          // 4.1 [66] A ""&#x"" CharRef must contain at least one hexadecimal digit
        P66_SEMICOLON_REQUIRED = 17,         // 4.1 [66] A CharRef must end with a ';'
        P11_QUOTE_REQUIRED = 18,             // 2.3 [11] No quote delimiter in SystemLiteral
        P11_INVALID_CHARACTER = 19,         // 2.3 [11] Invalid character in SystemLiteral
        P12_QUOTE_REQUIRED = 20,             // 2.3 [12] No quote delimiter in PubidLiteral
        P12_INVALID_CHARACTER = 21,         // 2.3 [12] Invalid character in PubidLiteral
        P62_UNTERMINATED = 22,              // 3.4 [62] Included conditional sections must end with ""]]>""
        P63_UNTERMINATED = 23,              // 3.4 [63] Excluded conditional sections must end with ""]]>""
        P65_INVALID_CHARACTER = 24,         // 3.4 [64] Invalid character in excluded conditional section
        P40_UNTERMINATED = 25,              // 3.1 [40] Element type must be followed by attributes, "">"" or ""/>""
        P41_EQ_REQUIRED = 26,                // 3.1 [41] Attribute name must be followed by an '=' character
        WFC_UNIQUE_ATT_SPEC = 27,           // 3.1 [40] [44] Attribute must only appear once
        P77_ENCODINGDECL_REQUIRED = 28,      // 4.3.1 [77] The encoding declaration is not optional
        P23_VERSIONINFO_REQUIRED = 29,       // 2.8 [23] The version is not optional
        P24_EQ_REQUIRED = 30,                // 2.8 [24] An '=' is required after the version
        P32_EQ_REQUIRED = 31,                // 2.9 [32] An '=' is required in a standalone document declaration
        P80_EQ_REQUIRED = 32,                // 4.3.3 [80] An '=' is required in an encoding declaration
        P24_QUOTE_REQUIRED = 33,             // 2.8 [24] The version is a quoted string
        P32_QUOTE_REQUIRED = 34,             // 2.9 [32] The standalone document declaration value is a quoted string
        P80_QUOTE_REQUIRED = 35,             // 4.3.3 [80] The encoding name value is a quoted string
        P26_INVALID_CHARACTER = 36,         // 2.8 [26] The version contained an invalid XML character
        P32_INVALID_CHARACTER = 37,         // 2.9 [32] The standalone document declaration value contained an invalid XML character
        P81_INVALID_CHARACTER = 38,         // 4.3.3 [81] The encoding name value contained an invalid XML character
        P26_INVALID_VALUE = 39,             // 2.8 [26] The version was not in the correct format
        P26_NOT_SUPPORTED = 40,             // 2.8 [26] The version specified is not supported
        P80_WHITESPACE_REQUIRED = 41,       // 4.3.3 [80] Whitespace required between version and encoding
        P81_INVALID_VALUE = 42,             // 4.3.3 [81] The encoding name value was not in the correct format
        P32_INVALID_VALUE = 43,             // 2.9 [32] The standalone document declaration value was not ""yes"" or ""no""
        P23_UNTERMINATED = 44,              // 2.8 [23] An XML declaration must end with ""?>""
        P77_UNTERMINATED = 45,              // 4.3.1 [77] A text declaration must end with ""?>""
        P28_INVALID_CHARACTER = 46,         // 2.8 [28] Invalid character in the internal subset of the DTD
        P30_INVALID_CHARACTER = 47,         // 2.8 [30] Invalid character in the external subset or an external entity within DTD
        P9_INVALID_CHARACTER = 48,          // 2.3 [9] Invalid character in EntityValue
        P51_UNTERMINATED = 49,              // 3.2.2 [51] Mixed content model with element types must end with "")*""
        P69_NAME_REQUIRED = 50,              // 4.1 [69] Name missing in PEReference
        P69_SEMICOLON_REQUIRED = 51,         // 4.1 [69] An PEReference must end with a ';'
        P75_INVALID = 52,                   // 4.2.2 [75] An ExternalId must begin with either ""SYSTEM"" or ""PUBLIC""
        WFC_PES_IN_INTERNAL_SUBSET = 53,    // 2.8 [28] PEReferences in the internal subset cannot occur within markup declarations
        P22_INVALID_CHARACTER = 54,         // 2.8 [22] Invalid character in prolog
        P27_INVALID_CHARACTER = 55,         // 2.8 [27] Invalid character in Misc
        P20_INVALID_CHARACTER = 56,         // 2.7 [20] Invalid character in CDSect
        P43_INVALID_CHARACTER = 57,         // 3.1 [43] Invalid character in content
        P39_UNTERMINATED = 58,              // 3 [39] Element type must be followed by attributes, "">"" or ""/>""
        P42_UNTERMINATED = 59,              // 3.1 [42] end-tag must end with '>'
        P81_NOT_SUPPORTED = 60,             // 4.3.3 [81] The encoding is not supported
        WFC_ENTITY_DECLARED = 61,           // 4.1 [68] The entity was referenced, but not declared
        VC_ENTITY_DECLARED = 62,            // 4.1 [68] The entity was referenced, but not declared
        WFC_PARSED_ENTITY = 63,             // 4.1 [68] An unparsed entity was referenced
        WFC_NO_EXTERNAL_ENTITY_REFERENCES = 64, // 3.1 [42] reference to external entity in AttValue
        P33_INVALID = 65,                   // 2.12 [33] xml:lang attribute value must match LanguageID production
        P18_UNTERMINATED = 66,              // 2.7 [18] CDATA sections must end with ""]]>""
        VC_NO_DUPLICATE_TYPES = 67,         // 3.2.2 [51] The same type must not appear more than once in a mixed content declaration
        P78_NOT_WELLFORMED = 68,            // 4.3.2 [78] 
        VC_ID_ATTRIBUTE_DEFAULT = 69,       // 3.3.1 [54] 
        P53_NAME_REQUIRED = 70,              // 3.3 [53] 
        P53_ATTTYPE_REQUIRED = 71,           // 3.3 [53] 
        P81_REQUIRED = 72,                  // 4.3.3 [81] 
        WFC_NO_RECURSION = 73,              // 4.1 [68] 
        VC_PROPER_DECLARATION_PE_NESTING = 74, // 2.8 [29] 
        VC_PROPER_GROUP_PE_NESTING = 75,    // 3.2.1 [47] 
        VC_ID = 76,                         // 3.3.1 [56] 
        VC_ENTITY_NAME = 77,                // 3.3.1 [56] 
        VC_ATTRIBUTE_VALUE_TYPE = 78,       // 3.1 [41] 
        VC_ELEMENT_VALID = 79,              // 3 [39] 
        VC_STANDALONE_DOCUMENT_DECLARATION = 80, // 2.9 [32] 
        VC_ONE_ID_PER_ELEMENT_TYPE = 81,    // 3.3.1 [56] 
        VC_UNIQUE_ELEMENT_TYPE_DECLARATION = 82, // 3.2 [45] 
        P45_UNDECLARED_ELEMENT_IN_CONTENTSPEC = 83, // 3.2 [45] 

        VC_NOTATION_ATTRIBUTES = 84,
        P53_DUPLICATE = 85,
        VC_ENUMERATION = 86,
        VC_FIXED_ATTRIBUTE_DEFAULT = 87,
        VC_REQUIRED_ATTRIBUTE = 88,
        VC_NOTATION_DECLARED = 89,
        P58_NAME_REQUIRED = 90,
        P58_UNTERMINATED = 91,
        P59_NMTOKEN_REQUIRED = 92,
        P59_UNTERMINATED = 93,
        P70_SPACE = 94,
        P70_REQUIRED_NAME = 95,
        P70_REQUIRED_SPACE = 96,
        P71_UNTERMINATED = 97,
        P72_SPACE = 98,
        P72_UNTERMINATED = 99,
        P76_REQUIRED = 100,
        P82_NAME_REQUIRED = 101,
        P82_SPACE_REQUIRED = 102,
        P82_UNTERMINATED = 103,
        P14_INVALID = 104,
        P16_PITARGET_REQUIRED = 105,
        P16_REQUIRED = 106,
        P1_ELEMENT_REQUIRED = 107,
        P22_NOT_RECOGNIZED = 108,
        P27_NOT_RECOGNIZED = 109,
        P43_NOT_RECOGNIZED = 110,
        P52_ELEMENT_TYPE_REQUIRED = 111,
        P52_SPACE_REQUIRED = 112,
        P53_SPACE_REQUIRED = 113,
        P58_OPEN_PAREN_REQUIRED = 114,
        P58_SPACE_REQUIRED = 115,
        P60_SPACE_REQUIRED = 116,
        S2_10_DECLARATION_ILLEGAL = 117,
        P39_ELEMENT_TYPE_REQUIRED = 118,
        P28_ROOT_ELEMENT_TYPE_REQUIRED = 119,
        P28_SPACE_REQUIRED = 120,
        P28_UNTERMINATED = 121,
        P29_NOT_RECOGNIZED = 122,
        P45_CONTENTSPEC_REQUIRED = 123,
        P45_ELEMENT_TYPE_REQUIRED = 124,
        P45_SPACE_REQUIRED = 125,
        P45_UNTERMINATED = 126,
        P47_CLOSE_PAREN_REQUIRED = 127,
        P47_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED = 128,
        P51_CLOSE_PAREN_REQUIRED = 129,
        P51_ELEMENT_TYPE_REQUIRED = 130,
        P75_SPACE_REQUIRED = 131,
        P76_SPACE_REQUIRED = 132,
        P15_UNTERMINATED = 133,
        P16_UNTERMINATED = 134,
        P67_UNTERMINATED = 135,
        P10_UNTERMINATED = 136,
        P22_XMLDECL_MUST_BE_FIRST = 137,
        P30_TEXTDECL_MUST_BE_FIRST = 138,
        P5_INVALID_CHARACTER = 139,
        P11_UNTERMINATED = 140,
        P12_UNTERMINATED = 141,
        P11_URI_FRAGMENT = 142,
        VC_ONE_NOTATION_PER_ELEMENT_TYPE = 143,
        NC_PREFIX_DECLARED = 144,
        VC_ATTRIBUTE_DEFAULT_LEGAL = 145,

        // ...
        CONSTRAINT_MAX_CODE = 200;

/*
    private static final Constraint[] fgConstraints = {
        new Constraint(null, null, null, null),
    // VC_ROOT_ELEMENT_TYPE = 1
        new Constraint(""2.8"", """", ""2.8 VC: Root Element Type"",
                       ""Validity Constraint: Root Element Type\n"" +
                       ""The Name in the document type declaration must match the element type of the\n"" +
                       ""root element.""),
    // VC_IDREF = 2
        new Constraint(""3.3.1 2.3"", ""[56] [6]"", ""3.3.1 VC: IDREF"",
                       ""Validity Constraint: IDREF\n"" +
                       ""[56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'\n"" +
                       ""Values of type IDREF must match the Name production, and values of type\n"" +
                       ""IDREFS must match Names; each Name must match the value of an ID attribute\n"" +
                       ""on some element in the XML document; i.e. IDREF values must match the value\n"" +
                       ""of some ID attribute.""),
    // VC_NAME_TOKEN = 3
        new Constraint(""3.3.1 2.3"", ""[56] [8]"", ""3.3.1 VC: Name Token"",
                       ""Validity Constraint: Name Token\n"" +
                       ""Values of type NMTOKEN must match the Nmtoken production; values of type\n"" +
                       ""NMTOKENS must match Nmtokens.""),
    // P17_RESERVED_PITARGET = 4
        new Constraint(""2.6"", ""[17]"", ""2.6 [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))"",
                       ""[17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))\n"" +
                       ""The target names \""XML\"", \""xml\"", and so on are reserved for standardization\n"" +
                       ""in this or future versions of this specification.""),
    // P16_WHITESPACE_REQUIRED = 5
        new Constraint(""2.6 2.3"", ""[16] [3]"", ""2.6 [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'"",
                       ""[16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\n"" +
                       ""[3] S ::= (#x20 | #x9 | #xD | #xA)+\n"" +
                       ""White space is required between the PITarget and any additional characters\n"" +
                       ""that are to be passed through to the application.""),
    // P16_INVALID_CHARACTER = 6
        new Constraint(""2.6 2.2"", ""[16] [2]"", ""2.6 [2] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'"",
                       ""[16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\n"" +
                       ""[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n"" +
                       ""Processing instruction data is required to contain legal XML characters.""),
    // P15_DASH_DASH = 7
        new Constraint(""2.5"", ""[15]"", ""2.5 [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'"",
                       ""[15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'\n"" +
                       ""For compatibility, the string \""--\"" (double-hyphen) must not occur within comments.""),
    // P15_INVALID_CHARACTER = 8
        new Constraint(""2.5 2.2"", ""[15] [2]"", ""2.5 [2] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'"",
                       ""[15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'\n"" +
                       ""[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n"" +
                       ""Comments are required to contain legal XML characters.""),
    // WFC_LEGAL_CHARACTER = 9
        new Constraint(""4.1"", ""[66] [2]"", ""4.1 WFC: Legal Character"",
                       ""Well-Formedness Constraint: Legal Character\n"" +
                       ""[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'\n"" +
                       ""[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n"" +
                       ""Characters referred to using character references must match the production\n"" +
                       ""for Char.""),
    // P10_INVALID_CHARACTER = 10
        new Constraint(""2.3"", ""[10]"", ""2.3 [10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\"""",
                       ""[10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\""\n"" +
                       ""Attribute values are required to contain legal XML characters.""),
    // WFC_NO_LESSTHAN_IN_ATTVALUE = 11
        new Constraint(""3.1 2.3"", ""[41] [10]"", ""3.1 WFC: No < in Attribute Values"",
                       ""Well-Formedness Constraint: No < in Attribute Values\n"" +
                       ""[41] Attribute ::= Name Eq AttValue\n"" +
                       ""[10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\""\n"" +
                       ""The replacement text of any entity referred to directly or indirectly in an\n"" +
                       ""attribute value (other than \""&lt;\"") must not contain a <.""),
    // P10_QUOTE_REQUIRED = 12
        new Constraint(""2.3"", ""[10]"", ""2.3 [10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\"""",
                       ""[10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\""\n"" +
                       ""Attribute values are specified using quoted strings.""),
    // P68_NAME_REQUIRED = 13
        new Constraint(""4.1"", ""[68]"", ""4.1 [68] EntityRef ::= '&' Name ';'"",
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""The '&' delimiter must be followed by a valid Name in an entity reference.""),
    // P68_SEMICOLON_REQUIRED = 14
        new Constraint(""4.1"", ""[68]"", ""4.1 [68] EntityRef ::= '&' Name ';'"",
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""An entity reference must end with a ';' delimiter.""),
    // P66_DIGIT_REQUIRED = 15
        new Constraint(""4.1"", ""[66]"", ""4.1 [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'"",
                       ""[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'\n"" +
                       ""If the character reference begins with \""&#\"", not \""&#x\"", the digits up\n"" +
                       ""to the terminating ; provide a decimal representation of the character's\n"" +
                       ""code point in ISO/IEC 10646.""),
    // P66_HEXDIGIT_REQUIRED = 16
        new Constraint(""4.1"", ""[66]"", ""4.1 [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'"",
                       ""[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'\n"" +
                       ""If the character reference begins with \""&#x\"", the digits and letters up to\n"" +
                       ""the terminating ; provide a hexadecimal representation of the character's\n"" +
                       ""code point in ISO/IEC 10646.""),
    // P66_SEMICOLON_REQUIRED = 17
        new Constraint(""4.1"", ""[66]"", ""4.1 [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'"",
                       ""[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'\n"" +
                       ""A character reference must end with a ';' delimiter.""),
    // P11_QUOTE_REQUIRED = 18
        new Constraint(""2.3"", ""[11]"", ""2.3 [11] SystemLiteral ::= ('\""' [^\""]* '\""') | (\""'\"" [^']* \""'\"")"",
                       ""[11] SystemLiteral ::= ('\""' [^\""]* '\""') | (\""'\"" [^']* \""'\"")\n"" +
                       ""System identifiers are specified using quoted strings.""),
    // P11_INVALID_CHARACTER = 19
        new Constraint(""2.3"", ""[11]"", ""2.3 [11] SystemLiteral ::= ('\""' [^\""]* '\""') | (\""'\"" [^']* \""'\"")"",
                       ""[11] SystemLiteral ::= ('\""' [^\""]* '\""') | (\""'\"" [^']* \""'\"")\n"" +
                       ""System identifiers are required to contain legal XML characters.""),
    // P12_QUOTE_REQUIRED = 20
        new Constraint(""2.3"", ""[12]"", ""2.3 [12] PubidLiteral ::= '\""' PubidChar* '\""' | \""'\"" (PubidChar - \""'\"")* \""'\"""",
                       ""[12] PubidLiteral ::= '\""' PubidChar* '\""' | \""'\"" (PubidChar - \""'\"")* \""'\""\n"" +
                       ""Public identifiers are specified using quoted strings.""),
    // P12_INVALID_CHARACTER = 21
        new Constraint(""2.3"", ""[13]"", ""2.3 [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]"",
                       ""[13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\n"" +
                       ""Public identifiers must consist of PubidChar characters.""),
    // P62_UNTERMINATED = 22
        new Constraint(""3.4"", ""[62]"", ""3.4 [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'"",
                       ""[62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'\n"" +
                       ""Included conditional section must be terminated by \""]]>\"".""),
    // P63_UNTERMINATED = 23
        new Constraint(""3.4"", ""[63]"", ""3.4 [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'"",
                       ""[63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'\n"" +
                       ""Excluded conditional sections must be terminated by \""]]>\"".""),
    // P65_INVALID_CHARACTER = 24
        new Constraint(""3.4"", ""[65]"", ""3.4 [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)"",
                       ""[65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)\n"" +
                       ""Excluded conditional sections are required to contain legal XML characters.""),
    // P40_UNTERMINATED = 25
        new Constraint(""3.1"", ""[40]"", ""3.1 [40] STag ::= '<' Name (S Attribute)* S? '>'"",
                       ""[40] STag ::= '<' Name (S Attribute)* S? '>'\n"" +
                       ""[39] element ::= EmptyElemTag | STag content ETag\n"" +
                       ""[44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'\n"" +
                       ""Element type name must be followed by Attribute, \"">\"" or \""/>\"".""),
    // P41_EQ_REQUIRED = 26
        new Constraint(""3.1"", ""[41]"", ""3.1 [41] Attribute ::= Name Eq AttValue"",
                       ""[41] Attribute ::= Name Eq AttValue\n"" +
                       ""[25] Eq ::= S? '=' S?\n"" +
                       ""Attribute name must be followed by an '=' character.""),
    // WFC_UNIQUE_ATT_SPEC = 27
        new Constraint(""3.1"", ""[40] [44]"", ""3.1 WFC: Unique Att Spec"",
                       ""Well-Formedness Constraint: Unique Att Spec\n"" +
                       ""[40] STag ::= '<' Name (S Attribute)* S? '>'\n"" +
                       ""[44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'\n"" +
                       ""No attribute name may appear more than once in the same start-tag or\n"" +
                       ""empty-element tag.""),
    // P77_ENCODINGDECL_REQUIRED = 28
        new Constraint(""4.3.1"", ""[77]"", ""4.3.1 [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'"",
                       ""[77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'\n"" +
                       ""The encoding declaration is required in a text declaration.""),
    // P23_VERSIONINFO_REQUIRED = 29
        new Constraint(""2.8"", ""[23]"", ""2.8 [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'"",
                       ""[23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\n"" +
                       ""The version is required in an XML declaration.""),
    // P24_EQ_REQUIRED = 30
        new Constraint(""2.8"", ""[24]"", ""2.8 [24] VersionInfo ::= S 'version' Eq (\""'\"" VersionNum \""'\"" | '\""' VersionNum '\""')"",
                       ""[24] VersionInfo ::= S 'version' Eq (\""'\"" VersionNum \""'\"" | '\""' VersionNum '\""')\n"" +
                       ""[25] Eq ::= S? '=' S?\n"" +
                       ""The '=' character must follow \""version\"" in VersionInfo.""),
    // P32_EQ_REQUIRED = 31
        new Constraint(""2.9"", ""[32]"", ""2.9 [32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')"",
                       ""[32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')\n"" +
                       ""[25] Eq ::= S? '=' S?\n"" +
                       ""The '=' character must follow \""standalone\"" in SDDecl.""),
    // P80_EQ_REQUIRED = 32
        new Constraint(""4.3.3"", ""[80]"", ""4.3.3 [80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")"",
                       ""[80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")\n"" +
                       ""[25] Eq ::= S? '=' S?\n"" +
                       ""The '=' character must follow \""encoding\"" in EncodingDecl.""),
    // P24_QUOTE_REQUIRED = 33
        new Constraint(""2.8"", ""[24]"", ""2.8 [24] VersionInfo ::= S 'version' Eq (\""'\"" VersionNum \""'\"" | '\""' VersionNum '\""')"",
                       ""[24] VersionInfo ::= S 'version' Eq (\""'\"" VersionNum \""'\"" | '\""' VersionNum '\""')\n"" +
                       ""The version is specified using a quoted string.""),
    // P32_QUOTE_REQUIRED = 34
        new Constraint(""2.9"", ""[32]"", ""2.9 [32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')"",
                       ""[32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')\n"" +
                       ""The standalone document declaration value is specified using a quoted string.""),
    // P80_QUOTE_REQUIRED = 35
        new Constraint(""4.3.3"", ""[80]"", ""4.3.3 [80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")"",
                       ""[80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")\n"" +
                       ""The encoding name value is specified using a quoted string.""),
    // P26_INVALID_CHARACTER = 36
        new Constraint(""2.8"", ""[26]"", ""2.8 [26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+"",
                       ""[26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+\n"" +
                       ""The version is required to contain legal XML characters..""),
    // P32_INVALID_CHARACTER = 37
        new Constraint(""2.9"", ""[32]"", ""2.9 [32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')"",
                       ""[32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')\n"" +
                       ""The standalone document declaration value is required to contain legal XML characters.""),
    // P81_INVALID_CHARACTER = 38
        new Constraint(""4.3.3"", ""[81]"", ""4.3.3 [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"",
                       ""[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\n"" +
                       ""The encoding name value is required to contain legal XML characters.""),
    // P26_INVALID_VALUE = 39
        new Constraint(""2.8"", ""[26]"", ""2.8 [26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+"",
                       ""[26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+\n"" +
                       ""The version value must match the production for VersionNum.""),
    // P26_NOT_SUPPORTED = 40
        new Constraint(""2.8"", ""[26]"", ""2.8 [26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+"",
                       ""[26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+\n"" +
                       ""Processors may signal an error if they receive documents labeled with versions\n"" +
                       ""they do not support.""),
    // P80_WHITESPACE_REQUIRED = 41
        new Constraint(""4.3.3"", ""[80]"", ""4.3.3 [80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")"",
                       ""[80] EncodingDecl ::= S 'encoding' Eq ('\""' EncName '\""' | \""'\"" EncName \""'\"")\n"" +
                       ""Whitespace is required between the version and the encoding declaration.""),
    // P81_INVALID_VALUE = 42
        new Constraint(""4.3.3"", ""[81]"", ""4.3.3 [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"",
                       ""[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\n"" +
                       ""The encoding name value must match the production for EncName.""),
    // P32_INVALID_VALUE = 43
        new Constraint(""2.9"", ""[32]"", ""2.9 [32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')"",
                       ""[32] SDDecl ::= S 'standalone' Eq (\""'\"" ('yes' | 'no') \""'\"" | '\""' ('yes' | 'no') '\""')\n"" +
                       ""The standalone document declaration must have a value of \""yes\"" or \""no\"".""),
    // P23_UNTERMINATED = 44
        new Constraint(""2.8"", ""[23]"", ""2.8 [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'"",
                       ""[23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\n"" +
                       ""The XML declaration must be terminated by \""?>\"".""),
    // P77_UNTERMINATED = 45
        new Constraint(""4.3.1"", ""[77]"", ""4.3.1 [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'"",
                       ""[77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'\n"" +
                       ""The text declaration must be terminated by \""?>\"".""),
    // P28_INVALID_CHARACTER = 46
        new Constraint(""2.8"", ""[28]"", ""2.8 [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | PEReference | S)* ']' S?)? '>'"",
                       ""[28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | PEReference | S)* ']' S?)? '>'\n"" +
                       ""The internal subset of the DTD is required to contain legal XML characters.""),
    // P30_INVALID_CHARACTER = 47
        new Constraint(""2.8"", ""[30]"", ""2.8 [30] extSubset ::= TextDecl? extSubsetDecl"",
                       ""[30] extSubset ::= TextDecl? extSubsetDecl\n"" +
                       ""[31] extSubsetDecl ::= ( markupdecl | conditionalSect | PEReference | S )*\n"" +
                       ""External entities in the DTD are required to contain legal XML characters.""),
    // P9_INVALID_CHARACTER = 48
        new Constraint(""2.3"", ""[9]"", ""2.3 [9] EntityValue ::= '\""' ([^%&\""] | PEReference | Reference)* '\""' | \""'\"" ([^%&'] | PEReference | Reference)* \""'\"""",
                       ""[9] EntityValue ::= '\""' ([^%&\""] | PEReference | Reference)* '\""' | \""'\"" ([^%&'] | PEReference | Reference)* \""'\""\n"" +
                       ""An entity value is required to contain legal XML characters.""),
    // P51_UNTERMINATED = 49
        new Constraint(""3.2.2"", ""[51]"", ""3.2.2 [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'"",
                       ""[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'\n"" +
                       ""A mixed content model with child element types must be terminated by \"")*\"".""),
    // P69_NAME_REQUIRED = 50
        new Constraint(""4.1"", ""[69]"", ""4.1 [69] PEReference ::= '%' Name ';'"",
                       ""[69] PEReference ::= '%' Name ';'\n"" +
                       ""The '&' delimiter must be followed by a valid Name in a parameter entity reference.""),
    // P69_SEMICOLON_REQUIRED = 51
        new Constraint(""4.1"", ""[69]"", ""4.1 [69] PEReference ::= '%' Name ';'"",
                       ""[69] PEReference ::= '%' Name ';'\n"" +
                       ""A parameter entity reference must end with a ';' delimiter.""),
    // P75_INVALID = 52
        new Constraint(""4.2.2"", ""[75]"", ""4.2.2 [75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral"",
                       ""[75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral\n"" +
                       ""An external entity declaration must begin with either \""SYSTEM\"" or \""PUBLIC\"".""),
    // WFC_PES_IN_INTERNAL_SUBSET = 53
        new Constraint(""2.8"", ""[40] [44]"", ""2.8 WFC: PEs in Internal Subset"",
                       ""Well-Formedness Constraint: PEs in Internal Subset\n"" +
                       ""[28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | PEReference | S)* ']' S?)? '>'\n"" +
                       ""In the internal DTD subset, parameter-entity references can occur only where\n"" +
                       ""markup declarations can occur, not within markup declarations.""),
    // P22_INVALID_CHARACTER = 54
        new Constraint(""2.8"", ""[22]"", ""2.8 [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?"",
                       ""[22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?\n"" +
                       ""The prolog is required to contain legal XML characters.""),
    // P27_INVALID_CHARACTER = 55
        new Constraint(""2.8"", ""[27]"", ""2.8 [27] Misc ::= Comment | PI |  S"",
                       ""[27] Misc ::= Comment | PI |  S\n"" +
                       ""The markup after the end of the element content is required to contain legal XML characters.""),
    // P20_INVALID_CHARACTER = 56
        new Constraint(""2.7"", ""[20]"", ""2.7 [20] CData ::= (Char* - (Char* ']]>' Char*))"",
                       ""[20] CData ::= (Char* - (Char* ']]>' Char*))\n"" +
                       ""CDATA sections are required to contain legal XML characters.""),
    // P43_INVALID_CHARACTER = 57
        new Constraint(""3.1"", ""[43]"", ""3.1 [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*"",
                       ""[43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*\n"" +
                       ""The content of elements is required to contain legal XML characters.""),
    // P39_UNTERMINATED = 58
        new Constraint(""3"", ""[39]"", ""3 [39] element ::= EmptyElemTag | STag content ETag"",
                       ""[39] element ::= EmptyElemTag | STag content ETag\n"" +
                       ""The end of every element that begins with a start-tag must be marked by an\n"" +
                       ""end-tag containing a name that echoes the element's type as given in the\n"" +
                       ""start-tag.""),
    // P42_UNTERMINATED = 59
        new Constraint(""3.1"", ""[42]"", ""3.1 [42] ETag ::= '</' Name S? '>'"",
                       ""[42] ETag ::= '</' Name S? '>'\n"" +
                       ""An end-tag must be terminated by a '>' delimiter.""),
    // P81_NOT_SUPPORTED = 60
        new Constraint(""4.3.3"", ""[81]"", ""4.3.3 [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"",
                       ""[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\n"" +
                       ""It is a fatal error when an XML processor encounters an entity with an\n"" +
                       ""encoding that it is unable to process.\n""),
    // WFC_ENTITY_DECLARED = 61
        new Constraint(""4.1"", ""[68]"", ""4.1 WFC: Entity Declared"",
                       ""Well-Formedness Constraint: Entity Declared\n"" +
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""In a document without any DTD, a document with only an internal DTD subset\n"" +
                       ""which contains no parameter entity references, or a document with\n"" +
                       ""\""standalone='yes'\"", the Name given in the entity reference must match that\n"" +
                       ""in an entity declaration, except that well-formed documents need not declare\n"" +
                       ""any of the following entities: amp, lt, gt, apos, quot. The declaration of a\n"" +
                       ""parameter entity must precede any reference to it. Similarly, the\n"" +
                       ""declaration of a general entity must precede any reference to it which\n"" +
                       ""appears in a default value in an attribute-list declaration. Note that if\n"" +
                       ""entities are declared in the external subset or in external parameter\n"" +
                       ""entities, a non-validating processor is not obligated to read and process\n"" +
                       ""their declarations; for such documents, the rule that an entity must be\n"" +
                       ""declared is a well-formedness constraint only if standalone='yes'.""),
    // VC_ENTITY_DECLARED = 62
        new Constraint(""4.1"", ""[68]"", ""4.1 VC: Entity Declared"",
                       ""Validity Constraint: Entity Declared\n"" +
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""In a document with an external subset or external parameter entities with\n"" +
                       ""\""standalone='no'\"", the Name given in the entity reference must match that in\n"" +
                       ""an entity declaration. For interoperability, valid documents should declare\n"" +
                       ""the entities amp, lt, gt, apos, quot, in the form specified in\n"" +
                       ""\""4.6 Predefined Entities\"". The declaration of a parameter entity must\n"" +
                       ""precede any reference to it. Similarly, the declaration of a general entity\n"" +
                       ""must precede any reference to it which appears in a default value in an\n"" +
                       ""attribute-list declaration.""),
    // WFC_PARSED_ENTITY = 63
        new Constraint(""4.1"", ""[68]"", ""4.1 WFC: Parsed Entity"",
                       ""Well-Formedness Constraint: Parsed Entity\n"" +
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""An entity reference must not contain the name of an unparsed entity.\n"" +
                       ""Unparsed entities may be referred to only in attribute values declared to be\n"" +
                       ""of type ENTITY or ENTITIES.""),
    // WFC_NO_EXTERNAL_ENTITY_REFERENCES = 64
        new Constraint(""3.1 2.3"", ""[41] [10]"", ""4.1 WFC: No External Entity References"",
                       ""Well-Formedness Constraint: No External Entity References\n"" +
                       ""[41] Attribute ::= Name Eq AttValue\n"" +
                       ""[10] AttValue ::= '\""' ([^<&\""] | Reference)* '\""' | \""'\"" ([^<&'] | Reference)* \""'\""\n"" +
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""Attribute values cannot contain direct or indirect entity references to\n"" +
                       ""external entities.""),
    // P33_INVALID = 65
        new Constraint(""2.12"", ""[33]"", ""2.12 [33] LanguageID ::= Langcode ('-' Subcode)*"",
                       ""[33] LanguageID ::= Langcode ('-' Subcode)*\n"" +
                       ""[34] Langcode ::= ISO639Code |  IanaCode |  UserCode\n"" +
                       ""[35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])\n"" +
                       ""[36] IanaCode ::= ('i' | 'I') '-' ([a-z] | [A-Z])+\n"" +
                       ""[37] UserCode ::= ('x' | 'X') '-' ([a-z] | [A-Z])+\n"" +
                       ""[38] Subcode ::= ([a-z] | [A-Z])+\n"" +
                       ""An xml:lang attribute value must match the LanguageID production.""),
    // P18_UNTERMINATED = 66
        new Constraint(""2.7"", ""[18]"", ""2.7 [18] CDSect ::= CDStart CData CDEnd"",
                       ""[18] CDSect ::= CDStart CData CDEnd\n"" +
                       ""[19] CDStart ::= '<![CDATA['\n"" +
                       ""[20] CData ::= (Char* - (Char* ']]>' Char*))\n"" +
                       ""[21] CDEnd ::= ']]>'\n"" +
                       ""CDATA sections must be terminated by \""]]>\"".""),
    // VC_NO_DUPLICATE_TYPES = 67
        new Constraint(""3.2.2"", ""[51]"", ""3.2.2 VC: No Duplicate Types"",
                       ""Validity Constraint: No Duplicate Types\n"" +
                       ""[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'\n"" +
                       ""The same name must not appear more than once in a single mixed-content\n"" +
                       ""declaration.""),
    // P78_NOT_WELLFORMED = 68
        new Constraint(""4.3.2"", ""[78]"", ""4.3.2 [78] extParsedEnt ::= TextDecl? content"",
                       ""[78] extParsedEnt ::= TextDecl? content\n"" +
                       ""An internal general parsed entity is well-formed if its replacement text\n"" +
                       ""matches the production labeled content.\n\n"" +
                       ""A consequence of well-formedness in entities is that the logical and\n"" +
                       ""physical structures in an XML document are properly nested; no start-tag,\n"" +
                       ""end-tag, empty-element tag, element, comment, processing instruction,\n"" +
                       ""character reference, or entity reference can begin in one entity and end in\n"" +
                       ""another.""),
    // VC_ID_ATTRIBUTE_DEFAULT = 69
        new Constraint(""3.3.1 3.3"", ""[54] [53]"", ""3.3.1 VC: ID Attribute Default"",
                       ""Validity Constraint: ID Attribute Default\n"" +
                       ""[53] AttDef ::= S Name S AttType S DefaultDecl\n"" +
                       ""[54] AttType ::= StringType | TokenizedType | EnumeratedType\n"" +
                       ""[60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)\n"" +
                       ""An ID attribute must have a declared default of #IMPLIED or #REQUIRED.""),
    // P53_NAME_REQUIRED = 70
        new Constraint(""3.3"", ""[53]"", ""3.3 [53] AttDef ::= S Name S AttType S DefaultDecl"",
                       ""[52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'\n"" +
                       ""[53] AttDef ::= S Name S AttType S DefaultDecl\n"" +
                       ""In an attribute-list declaration, the Name in the AttDef rule is the name\n"" +
                       ""of the attribute.""),
    // P53_ATTTYPE_REQUIRED = 71
        new Constraint(""3.3"", ""[53]"", ""3.3 [53] AttDef ::= S Name S AttType S DefaultDecl"",
                       ""[52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'\n"" +
                       ""[53] AttDef ::= S Name S AttType S DefaultDecl\n"" +
                       "".""),
    // P81_REQUIRED = 72
        new Constraint(""4.3.3"", ""[81]"", ""4.3.3 [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"",
                       ""[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*\n"" +
                       ""Parsed entities which are stored in an encoding other than UTF-8 or\n"" +
                       ""UTF-16 must begin with an XML declaration or a text declaration that\n"" +
                       ""contains an encoding declaration.""),
    // WFC_NO_RECURSION = 73
        new Constraint(""4.1"", ""[68]"", ""4.1 WFC: No Recursion"",
                       ""Well-Formedness Constraint: No Recursion\n"" +
                       ""[68] EntityRef ::= '&' Name ';'\n"" +
                       ""[69] PEReference ::= '%' Name ';'\n"" +
                       ""A parsed entity must not contain a recursive reference to itself, either\n"" +
                       ""directly or indirectly.""),
    // VC_PROPER_DECLARATION_PE_NESTING = 74
        new Constraint(""2.8"", ""[29]"", ""2.8 VC: Proper Declaration/PE Nesting"",
                       ""Validity Constraint: Proper Declaration/PE Nesting\n"" +
                       ""[29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment\n"" +
                       ""Parameter-entity replacement text must be properly nested with markup\n"" +
                       ""declarations. That is to say, if either the first character or the last\n"" +
                       ""character of a markup declaration (markupdecl above) is contained in the\n"" +
                       ""replacement text for a parameter-entity reference, both must be contained in\n"" +
                       ""the same replacement text.""),
    // VC_PROPER_GROUP_PE_NESTING = 75
        new Constraint(""3.2.1"", ""[47]"", ""3.2.1 VC: Proper Group/PE Nesting"",
                       ""Validity Constraint: Proper Group/PE Nesting\n"" +
                       ""[47] children ::= (choice | seq) ('?' | '*' | '+')?\n"" +
                       ""[48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?\n"" +
                       ""[49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'\n"" +
                       ""[50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'\n"" +
                       ""[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'\n"" +
                       ""Parameter-entity replacement text must be properly nested with parenthetized\n"" +
                       ""groups. That is to say, if either of the opening or closing parentheses in a\n"" +
                       ""choice, seq, or Mixed construct is contained in the replacement text for a\n"" +
                       ""parameter entity, both must be contained in the same replacement text.""),
    // VC_ID = 76
        new Constraint(""3.3.1"", ""[56]"", ""3.3.1 VC: ID"",
                       ""Validity Constraint: ID\n"" +
                       ""[56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'\n"" +
                       ""Values of type ID must match the Name production. A name must not appear\n"" +
                       ""more than once in an XML document as a value of this type; i.e., ID values\n"" +
                       ""must uniquely identify the elements which bear them.""),
    // VC_ENTITY_NAME = 77
        new Constraint(""3.3.1"", ""[56]"", ""3.3.1 VC: Entity Name"",
                       ""Validity Constraint: Entity Name\n"" +
                       ""[56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'\n"" +
                       ""Values of type ENTITY must match the Name production, values of type\n"" +
                       ""ENTITIES must match Names; each Name must match the name of an unparsed\n"" +
                       ""entity declared in the DTD.""),
    // VC_ATTRIBUTE_VALUE_TYPE = 78
        new Constraint(""3.1"", ""[41]"", ""3.1 VC: Attribute Value Type"",
                       ""Validity Constraint: Attribute Value Type\n"" +
                       ""[41] Attribute ::= Name Eq AttValue\n"" +
                       ""The attribute must have been declared; the value must be of the type\n"" +
                       ""declared for it.""),
    // VC_ELEMENT_VALID = 79
        new Constraint(""3"", ""[39]"", ""3 VC: Element Valid"",
                       ""Validity Constraint: Element Valid\n"" +
                       ""[39] element ::= EmptyElemTag | STag content ETag\n"" +
                       ""An element is valid if there is a declaration matching elementdecl where the\n"" +
                       ""Name matches the element type, and one of the following holds:\n\n"" +
                       ""  1. The declaration matches EMPTY and the element has no content.\n"" +
                       ""  2. The declaration matches children and the sequence of child elements\n"" +
                       ""     belongs to the language generated by the regular expression in the\n"" +
                       ""     content model, with optional white space (characters matching the\n"" +
                       ""     nonterminal S) between each pair of child elements.\n"" +
                       ""  3. The declaration matches Mixed and the content consists of character\n"" +
                       ""     data and child elements whose types match names in the content model.\n"" +
                       ""  4. The declaration matches ANY, and the types of any child elements have\n"" +
                       ""     been declared.""),
    // VC_STANDALONE_DOCUMENT_DECLARATION = 80
        new Constraint(""2.9"", ""[32]"", ""2.9 VC: Standalone Document Declaration"",
                       ""Validity Constraint: Standalone Document Declaration\n"" +
                       ""[32] SDDecl ::= S 'standalone' Eq ((\""'\"" ('yes' | 'no') \""'\"") | ('\""' ('yes' | 'no') '\""'))\n"" +
                       ""The standalone document declaration must have the value \""no\"" if any external\n"" +
                       ""markup declarations contain declarations of:\n\n"" +
                       ""   * attributes with default values, if elements to which these attributes\n"" +
                       ""     apply appear in the document without specifications of values for these\n"" +
                       ""     attributes, or\n"" +
                       ""   * entities (other than amp, lt, gt, apos, quot), if references to those\n"" +
                       ""     entities appear in the document, or\n"" +
                       ""   * attributes with values subject to normalization, where the attribute\n"" +
                       ""     appears in the document with a value which will change as a result of\n"" +
                       ""     normalization, or\n"" +
                       ""   * element types with element content, if white space occurs directly\n"" +
                       ""     within any instance of those types.""),
    // VC_ONE_ID_PER_ELEMENT_TYPE = 81
        new Constraint(""3.3.1"", ""[56]"", ""3.3.1 VC: One ID per Element Type"",
                       ""Validity Constraint: One ID per Element Type\n"" +
                       ""[56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'\n"" +
                       ""No element type may have more than one ID attribute specified.""),
    // VC_UNIQUE_ELEMENT_TYPE_DECLARATION = 82
        new Constraint(""3.2"", ""[45]"", ""3.2 VC: Unique Element Type Declaration"",
                       ""Validity Constraint: Unique Element Type Declaration\n"" +
                       ""[45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'\n"" +
                       ""No element type may be declared more than once.""),
    // P45_UNDECLARED_ELEMENT_IN_CONTENTSPEC = 83
        new Constraint(""3.2"", ""[45]"", ""3.2 [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'"",
                       ""[45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'\n"" +
                       ""At user option, an XML processor may issue a warning when a declaration\n"" +
                       ""mentions an element type for which no declaration is provided, but this\n"" +
                       ""is not an error.""),

    // VC_NOTATION_ATTRIBUTES = 84
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P53_DUPLICATE = 85
        new Constraint(""?.?"", ""[??]"", """", """"),
    // VC_ENUMERATION = 86
        new Constraint(""?.?"", ""[??]"", """", """"),
    // VC_FIXED_ATTRIBUTE_DEFAULT = 87
        new Constraint(""?.?"", ""[??]"", """", """"),
    // VC_REQUIRED_ATTRIBUTE = 88
        new Constraint(""?.?"", ""[??]"", """", """"),
    // VC_NOTATION_DECLARED = 89
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P58_NAME_REQUIRED = 90
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P58_UNTERMINATED = 91
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P59_NMTOKEN_REQUIRED = 92
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P59_UNTERMINATED = 93
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P70_SPACE = 94
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P70_REQUIRED_NAME = 95
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P70_REQUIRED_SPACE = 96
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P71_UNTERMINATED = 97
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P72_SPACE = 98
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P72_UNTERMINATED = 99
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P76_REQUIRED = 100
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P82_NAME_REQUIRED = 101
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P82_SPACE_REQUIRED = 102
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P82_UNTERMINATED = 103
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P14_INVALID = 104
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P16_PITARGET_REQUIRED = 105
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P16_REQUIRED = 106
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P1_ELEMENT_REQUIRED = 107
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P22_NOT_RECOGNIZED = 108
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P27_NOT_RECOGNIZED = 109
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P43_NOT_RECOGNIZED = 110
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P52_ELEMENT_TYPE_REQUIRED = 111
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P52_SPACE_REQUIRED = 112
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P53_SPACE_REQUIRED = 113
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P58_OPEN_PAREN_REQUIRED = 114
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P58_SPACE_REQUIRED = 115
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P60_SPACE_REQUIRED = 116
        new Constraint(""?.?"", ""[??]"", """", """"),
    // S2_10_DECLARATION_ILLEGAL = 117
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P39_ELEMENT_TYPE_REQUIRED = 118
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P28_ROOT_ELEMENT_TYPE_REQUIRED = 119
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P28_SPACE_REQUIRED = 120
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P28_UNTERMINATED = 121
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P29_NOT_RECOGNIZED = 122
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P45_CONTENTSPEC_REQUIRED = 123
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P45_ELEMENT_TYPE_REQUIRED = 124
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P45_SPACE_REQUIRED = 125
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P45_UNTERMINATED = 126
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P47_CLOSE_PAREN_REQUIRED = 127
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P47_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED = 128
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P51_CLOSE_PAREN_REQUIRED = 129
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P51_ELEMENT_TYPE_REQUIRED = 130
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P75_SPACE_REQUIRED = 131
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P76_SPACE_REQUIRED = 132
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P15_UNTERMINATED = 133
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P16_UNTERMINATED = 134
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P67_UNTERMINATED = 135
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P10_UNTERMINATED = 136
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P22_XMLDECL_MUST_BE_FIRST = 137
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P30_TEXTDECL_MUST_BE_FIRST = 138
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P5_INVALID_CHARACTER = 139
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P11_UNTERMINATED = 140
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P12_UNTERMINATED = 141
        new Constraint(""?.?"", ""[??]"", """", """"),
    // P11_URI_FRAGMENT = 142
        new Constraint(""?.?"", ""[??]"", """", """"),
    // VC_ONE_NOTATION_PER_ELEMENT_TYPE = 143
        new Constraint(""3.3.1"", ""[58]"", ""VC: One Notation per Element Type"",
                       ""Validity Constraint: One Notation per Element Type\n"" +
                       ""[58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'\n"" +
                       ""No element type may have more than one NOTATION attribute specified.""),
    // NC_PREFIX_DECLARED = 144
        new Constraint(""4."", """", ""NC: Prefix Declared"", """"),

        // ...
        new Constraint(null, null, null, null)
    };
 */
}

/*
class Constraint {
    String sections;
    String productions;
    String shortDesc;
    String longDesc;
    Constraint(String sections, String productions, String shortDesc, String longDesc) {
        this.sections = sections;
        this.productions = productions;
        this.shortDesc = shortDesc;
        this.longDesc = longDesc;
    }
}
 */
"
org/w3c/dom/Text.java,true,"/*
 * Copyright (c) 2000 World Wide Web Consortium,
 * (Massachusetts Institute of Technology, Institut National de
 * Recherche en Informatique et en Automatique, Keio University). All
 * Rights Reserved. This program is distributed under the W3C's Software
 * Intellectual Property License. This program is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See W3C License http://www.w3.org/Consortium/Legal/ for more
 * details.
 */

package org.w3c.dom;

/**
 *  The <code>Text</code> interface inherits from <code>CharacterData</code> 
 * and represents the textual content (termed  character  data in XML) of an 
 * <code>Element</code> or <code>Attr</code> .  If there is no markup inside 
 * an element's content, the text is contained in a single object 
 * implementing the <code>Text</code> interface that is the only child of the 
 * element. If there is markup, it is parsed into the  information items 
 * (elements,  comments, etc.) and <code>Text</code>  nodes that form the 
 * list of children of the element.
 * <p> When a document is first made available via the DOM, there is  only one 
 * <code>Text</code> node for each block of text. Users may create  adjacent 
 * <code>Text</code> nodes that represent the  contents of a given element 
 * without any intervening markup, but should be aware that there is no way 
 * to represent the separations between these nodes in XML or HTML, so they 
 * will not (in general) persist between DOM editing sessions. The 
 * <code>normalize()</code> method on <code>Element</code> merges any such 
 * adjacent <code>Text</code> objects into a single node for each block of 
 * text.
 */
public interface Text extends CharacterData {
    /**
     *  Breaks this node into two  nodes at the specified <code>offset</code> 
     * , keeping both in the tree as siblings. This node then only contains 
     * all the content up to the <code>offset</code> point. A new node of the 
     * same type, which is inserted as the next sibling of this node, 
     * contains all the content at and after the <code>offset</code> point. 
     * When the <code>offset</code> is equal to the length of this node, the 
     * new node has no data.
     * @param offset  The  16-bit unit offset at which to split, starting from 
     *   <code>0</code> .
     * @return  The new node, of the same type as this node.
     * @exception DOMException
     *    INDEX_SIZE_ERR: Raised if the specified offset is negative or 
     *   greater than the number of 16-bit units in <code>data</code> .
     *   <br> NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     */
    public Text splitText(int offset)
                          throws DOMException;

}

"
