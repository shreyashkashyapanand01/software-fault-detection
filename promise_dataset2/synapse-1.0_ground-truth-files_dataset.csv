File,Bug,SRC
org/apache/synapse/config/xml/ProxyServiceFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.axis2.wsdl.WSDLConstants;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Creates a ProxyService instance using the XML fragment specification
 * <p/>
 * <proxy-service name=""string"" [transports=""(http |https |jms )+|all""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <enableSec/>?
 *    <enableRM/>?
 *    <policy key=""string"">?
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxy-service>
 */
public class ProxyServiceFactory {

    private static final Log log = LogFactory.getLog(ProxyServiceFactory.class);

    public static ProxyService createProxy(OMElement elem) {

        ProxyService proxy = new ProxyService();

        OMAttribute name = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
        if (name == null) {
            handleException(""The 'name' attribute is required for a Proxy service definition"");
        } else {
            proxy.setName(name.getAttributeValue());
        }

        OMAttribute statistics = elem.getAttribute(
                new QName(Constants.NULL_NAMESPACE, Constants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (Constants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    proxy.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_ON);
                } else if (Constants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    proxy.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_OFF);
                }
            }
        }

        OMAttribute trans = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""transports""));
        if (trans != null) {
            String transports = trans.getAttributeValue();
            if (transports == null || ProxyService.ALL_TRANSPORTS.equals(transports)) {
                // default to all transports using service name as destination
            } else {
                StringTokenizer st = new StringTokenizer(transports, "" ,"");
                ArrayList transportList = new ArrayList();
                while (st.hasMoreTokens()) {
                    String token = st.nextToken();
                    if (token.length() != 0) {
                        transportList.add(token);
                    }
                }
                proxy.setTransports(transportList);
            }
        }
        OMAttribute trace = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, Constants.TRACE_ATTRIB_NAME));
        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(Constants.TRACE_ENABLE)) {
                    proxy.setTraceState(org.apache.synapse.Constants.TRACING_ON);
                } else if (traceValue.equals(Constants.TRACE_DISABLE)) {
                    proxy.setTraceState(org.apache.synapse.Constants.TRACING_OFF);
                }
            }
        }
        OMAttribute startOnLoad = elem.getAttribute(
                new QName(Constants.NULL_NAMESPACE, ""startOnLoad""));
        if (startOnLoad != null) {
            proxy.setStartOnLoad(Boolean.valueOf(startOnLoad.getAttributeValue()).booleanValue());
        } else {
            proxy.setStartOnLoad(true);
        }

        // setting the description of the proxy service
        OMElement descriptionElement = elem.getFirstChildWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""description""));
        if (descriptionElement != null) {
            proxy.setDescription(descriptionElement.getText().trim());
        }

        // read definition of the target of this proxy service. The target could be an 'endpoint'
        // or a named sequence. If none of these are specified, the messages would be mediated
        // by the Synapse main mediator
        OMElement target = elem.getFirstChildWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""target""));
        if (target != null) {
            boolean isTargetOk = false;
            SequenceMediatorFactory mediatorFactory = new SequenceMediatorFactory();
            OMAttribute inSequence = target.getAttribute(new QName(Constants.NULL_NAMESPACE, ""inSequence""));
            if (inSequence != null) {
                proxy.setTargetInSequence(inSequence.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement inSequenceElement = target.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""inSequence""));
                if (inSequenceElement != null) {
                    proxy.setTargetInLineInSequence(mediatorFactory.createAnonymousSequence(inSequenceElement));
                    isTargetOk = true;
                }
            }
            OMAttribute outSequence = target.getAttribute(new QName(Constants.NULL_NAMESPACE, ""outSequence""));
            if (outSequence != null) {
                proxy.setTargetOutSequence(outSequence.getAttributeValue());
            } else {
                OMElement outSequenceElement = target.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""outSequence""));
                if (outSequenceElement != null) {
                    proxy.setTargetInLineOutSequence(mediatorFactory.createAnonymousSequence(outSequenceElement));
                } else {
                    handleException(""Target for the proxy service must declare an out sequence"");
                }
            }
            OMAttribute faultSequence = target.getAttribute(new QName(Constants.NULL_NAMESPACE, ""faultSequence""));
            if (faultSequence != null) {
                proxy.setTargetFaultSequence(faultSequence.getAttributeValue());
            } else {
                OMElement faultSequenceElement = target.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""faultSequence""));
                if (faultSequenceElement != null) {
                    proxy.setTargetInLineFaultSequence(mediatorFactory.createAnonymousSequence(faultSequenceElement));
                }
            }
            OMAttribute tgtEndpt = target.getAttribute(new QName(Constants.NULL_NAMESPACE, ""endpoint""));
            if (tgtEndpt != null) {
                proxy.setTargetEndpoint(tgtEndpt.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement endpointElement = target.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""endpoint""));
                if (endpointElement != null) {
                    EndpointFactory fac = EndpointAbstractFactory.getEndpointFactroy(endpointElement);
                    proxy.setTargetInLineEndpoint(fac.createEndpoint(endpointElement, true));
                    isTargetOk = true;
                }
            }
            if(!isTargetOk) {
                handleException(""Target of the proxy service must declare either an inSequence or endpoint or both"");
            }
        } else {
            handleException(""Target is required for a Proxy service definition"");
        }

        // read the WSDL, Schemas and Policies and set to the proxy service
        OMElement wsdl = elem.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""publishWSDL""));
        if (wsdl != null) {
            OMAttribute wsdlkey = wsdl.getAttribute(new QName(Constants.NULL_NAMESPACE, ""key""));
            if (wsdlkey != null) {
                proxy.setWSDLKey(wsdlkey.getAttributeValue());
            } else {
                OMAttribute wsdlURI = wsdl.getAttribute(new QName(Constants.NULL_NAMESPACE, ""uri""));
                if (wsdlURI != null) {
                    try {
                        proxy.setWsdlURI(new URI(wsdlURI.getAttributeValue()));
                    } catch (URISyntaxException e) {
                        String msg = ""Error creating uri for proxy service wsdl"";
                        log.error(msg);
                        handleException(msg, e);
                    }
                } else {
                    OMElement wsdl11 = wsdl.getFirstChildWithName(new QName(WSDLConstants.WSDL1_1_NAMESPACE, ""definitions""));
                    if (wsdl11 != null) {
                        proxy.setInLineWSDL(wsdl11);
                    } else {
                        OMElement wsdl20 = wsdl.getFirstChildWithName(new QName(WSDLConstants.WSDL2_0_NAMESPACE, ""descriptions""));
                        if (wsdl20 != null) {
                            proxy.setInLineWSDL(wsdl20);
                        }
                    }
                }
            }
        }

//        OMElement schema = elem.getFirstChildWithName(
//                new QName(Constants.SYNAPSE_NAMESPACE, ""schema""));
        Iterator policies = elem.getChildrenWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""policy""));
        while (policies.hasNext()) {
            Object o = policies.next();
            if (o instanceof OMElement) {
                OMElement policy = (OMElement) o;
                OMAttribute key = policy.getAttribute(new QName(Constants.NULL_NAMESPACE, ""key""));
                if (key != null) {
                    proxy.addServiceLevelPolicy(key.getAttributeValue());
                } else {
                    handleException(""Policy element does not specify the policy key"");
                }
            } else {
                handleException(""Invalid 'policy' element found under element 'policies'"");
            }
        }

        Iterator props = elem.getChildrenWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""parameter""));
        while (props.hasNext()) {
            Object o = props.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
                OMElement propertyValue = prop.getFirstElement();
                if (pname != null) {
                    if (propertyValue != null) {
                        proxy.addParameter(pname.getAttributeValue(), propertyValue);
                    } else {
                        proxy.addParameter(pname.getAttributeValue(), prop.getText().trim());
                    }
                } else {
                    handleException(""Invalid property specified for proxy service : "" + name);
                }
            } else {
                handleException(""Invalid property specified for proxy service : "" + name);
            }
        }

        if (elem.getFirstChildWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""enableRM"")) != null) {
            proxy.setWsRMEnabled(true);
        }

        if (elem.getFirstChildWithName(
                new QName(Constants.SYNAPSE_NAMESPACE, ""enableSec"")) != null) {
            proxy.setWsSecEnabled(true);
        }

        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

}
"
org/apache/synapse/config/xml/OutMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

import javax.xml.namespace.QName;

/**
 * Creates an Out mediator instance
 *
 * <pre>
 * &lt;out&gt;
 *    mediator+
 * &lt;/out&gt;
 * </pre>
 */
public class OutMediatorFactory extends AbstractListMediatorFactory {

    private static final QName OUT_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""out"");

    public Mediator createMediator(OMElement elem) {
        OutMediator filter = new OutMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(filter,elem);

        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return OUT_Q;
    }
}
"
org/apache/synapse/config/xml/FaultMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.FaultMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Creates a fault mediator instance
 *
 * <pre>
 * &lt;makefault [version=""soap11|soap12""]&gt;
 *   &lt;code (value=""literal"" | expression=""xpath"")/&gt;
 *   &lt;reason (value=""literal"" | expression=""xpath"")&gt;
 *   &lt;node&gt;?
 *   &lt;role&gt;?
 *   &lt;detail&gt;?
 * &lt;/makefault&gt;
 * </pre>
 */
public class FaultMediatorFactory extends AbstractMediatorFactory  {

    private static final QName FAULT_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""makefault"");

    private static final QName ATT_VERSION_Q = new QName(Constants.NULL_NAMESPACE, ""version"");
    private static final QName CODE_Q        = new QName(Constants.SYNAPSE_NAMESPACE, ""code"");
    private static final QName REASON_Q      = new QName(Constants.SYNAPSE_NAMESPACE, ""reason"");
    private static final QName NODE_Q        = new QName(Constants.SYNAPSE_NAMESPACE, ""node"");
    private static final QName ROLE_Q        = new QName(Constants.SYNAPSE_NAMESPACE, ""role"");
    private static final QName DETAIL_Q      = new QName(Constants.SYNAPSE_NAMESPACE, ""detail"");

    private static final QName ATT_VALUE_Q = new QName(Constants.NULL_NAMESPACE, ""value"");
    private static final QName ATT_EXPR_Q  = new QName(Constants.NULL_NAMESPACE, ""expression"");

    private static final String SOAP11 = ""soap11"";
    private static final String SOAP12 = ""soap12"";

    private static final Log log = LogFactory.getLog(FaultMediatorFactory.class);

    public Mediator createMediator(OMElement elem) {

        FaultMediator faultMediator = new FaultMediator();

        OMAttribute version = elem.getAttribute(ATT_VERSION_Q);
        if (version != null) {
            if (SOAP11.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP11);
            } else if (SOAP12.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP12);
            }else {
                String msg = ""Invalid SOAP version"";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement code = elem.getFirstChildWithName(CODE_Q);
        if (code != null) {
            OMAttribute value = code.getAttribute(ATT_VALUE_Q);
            OMAttribute expression = code.getAttribute(ATT_EXPR_Q);

            if (value != null) {
                String strValue = value.getAttributeValue();
                String prefix, name;
                if (strValue.indexOf("":"") != -1) {
                    prefix = strValue.substring(0, strValue.indexOf("":""));
                    name = strValue.substring(strValue.indexOf("":"")+1);
                } else {
                    String msg = ""A QName is expected for fault code as prefix:name"";
                    log.error(msg);
                    throw new SynapseException(msg);
                }
                faultMediator.setFaultCodeValue(
                    new QName(OMElementUtils.getNameSpaceWithPrefix(prefix, code), name, prefix));
                
            } else if (expression != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, code, log);
                    faultMediator.setFaultCodeExpr(xp);
                } catch (JaxenException je) {
                    String msg = ""Invalid fault code expression : "" + je.getMessage();
                    log.error(msg);
                    throw new SynapseException(msg, je);
                }
            } else {
                String msg = ""A 'value' or 'expression' attribute must specify the fault code"";
                log.error(msg);
                throw new SynapseException(msg);
            }

        } else {
            String msg = ""The fault code is a required attribute for the makefault mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        OMElement reason = elem.getFirstChildWithName(REASON_Q);
        if (reason != null) {
            OMAttribute value = reason.getAttribute(ATT_VALUE_Q);
            OMAttribute expression = reason.getAttribute(ATT_EXPR_Q);

            if (value != null) {
                faultMediator.setFaultReasonValue(value.getAttributeValue());
            } else if (expression != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, reason, log);
                    faultMediator.setFaultReasonExpr(xp);

                } catch (JaxenException je) {
                    String msg = ""Invalid fault reason expression : "" + je.getMessage();
                    log.error(msg);
                    throw new SynapseException(msg, je);
                }
            } else {
                String msg = ""A 'value' or 'expression' attribute must specify the fault code"";
                log.error(msg);
                throw new SynapseException(msg);
            }

        } else {
            String msg = ""The fault reason is a required attribute for the makefault mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(faultMediator,elem);

        OMElement node = elem.getFirstChildWithName(NODE_Q);
        if (node != null && node.getText() != null) {
            try {
                faultMediator.setFaultNode(new URI(node.getText()));
            } catch (URISyntaxException e) {
                String msg = ""Invalid URI specified for fault node : "" + node.getText();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement role = elem.getFirstChildWithName(ROLE_Q);
        if (role != null && role.getText() != null) {
            try {
                faultMediator.setFaultRole(new URI(role.getText()));
            } catch (URISyntaxException e) {
                String msg = ""Invalid URI specified for fault role : "" + role.getText();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement detail = elem.getFirstChildWithName(DETAIL_Q);
        if (detail != null && detail.getText() != null) {
            faultMediator.setFaultDetail(detail.getText());
        }

        return faultMediator;
    }

    public QName getTagQName() {
        return FAULT_Q;
    }
}
"
org/apache/synapse/statistics/impl/SequenceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The data structure to hold statistics related to Sequences
 *
 */

public class SequenceStatisticsStack implements StatisticsStack {

    /** The list to hols SequenceStatistics */
    private List sequenceStatisticsList = new ArrayList();

    /**
     * To put a statistics
     *
     * @param sequenceName       - The name of the sequence
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String sequenceName, long initTime, boolean isInFlow,
                    boolean isStatisticsEnable, boolean isFault) {
        sequenceStatisticsList.add(new SequenceStatistics(sequenceName, initTime,
                isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        int top = sequenceStatisticsList.size();
        if (top > 0) {
            popSequenceStatistics(sequenceStatisticsList.size() - 1, statisticsCollector);
        }
    }

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (!sequenceStatisticsList.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator seqIterator = sequenceStatisticsList.iterator();
                 seqIterator.hasNext();) {
                SequenceStatistics sequenceStatistics =
                        (SequenceStatistics) seqIterator.next();
                if (sequenceStatistics != null) {
                    if (sequenceStatistics.isStatisticsEnable &&
                            sequenceStatistics.sequenceName != null &&
                            sequenceStatistics.sequenceName.equals(name)
                            ) {
                        statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                                !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                                System.currentTimeMillis(), sequenceStatistics.isFault);
                    }
                    tobeRemoved.add(sequenceStatistics);
                }
            }
            sequenceStatisticsList.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        int i = sequenceStatisticsList.size() - 1;
        for (; i >= 0; i--) {
            popSequenceStatistics(i, statisticsCollector);
        }
    }

    /**
     * A helper method to pop a SequenceStatistics
     * @param index
     * @param statisticsCollector
     */
    private void popSequenceStatistics(int index, StatisticsCollector statisticsCollector) {
        if (index >= 0) {
            SequenceStatistics sequenceStatistics =
                    (SequenceStatistics) sequenceStatisticsList.get(index);
            if (sequenceStatistics != null) {
                if (sequenceStatistics.isStatisticsEnable &&
                        sequenceStatistics.sequenceName != null) {
                    statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                            !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                            System.currentTimeMillis(), sequenceStatistics.isFault);
                }
                sequenceStatisticsList.remove(index);
            }
        }
    }

    /**
     * The SequenceStatistics data structure
     */
    class SequenceStatistics {

        /** The name of the Sequence */
        String sequenceName;
        /** The time which starts to collect statistics */
        long initTime;
        /** To check whether IN message flow or not */
        boolean isInFlow;
        /** To check whether statistics is enabled or not */
        boolean isStatisticsEnable;
        /** To indicate whether this is fault or not*/
        private boolean isFault;

        public SequenceStatistics(String sequenceName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean isFault) {
            this.sequenceName = sequenceName;
            this.initTime = initTime;
            isInFlow = inFlow;
            isStatisticsEnable = statisticsEnable;
            this.isFault = isFault;
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            final SequenceStatistics that = (SequenceStatistics) o;

            if (!sequenceName.equals(that.sequenceName)) return false;

            return true;
        }

        public int hashCode() {
            return sequenceName.hashCode();
        }
    }

}
"
org/apache/synapse/config/XMLToObjectMapper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.OMNode;

/**
 * Defines the interface which should be implemented by a mapper that could
 * convert a XML resource into a known Object such as WSDL, XSD, etc..
 */
public interface XMLToObjectMapper {

    /**
     * Create an application object from the given OMNode
     * @param om the XML
     * @return a suitable application object
     */
    public Object getObjectFromOMNode(OMNode om);
}
"
org/apache/synapse/core/axis2/TimeoutHandler.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.mediators.transform.FaultMediator;
import org.apache.synapse.mediators.MediatorFaultHandler;

import java.util.TimerTask;
import java.util.Map;
import java.util.Iterator;
import java.util.Stack;

/**
 * An object of this class is registered to be invoked in some predefined time intervals. This
 * checks the timeouts of callbacks stored in the SynapseCallbackReceiver and removes all expired
 * callbacks. Timeouts of the callbacks are stored as the time, not the duration. So that the
 * time or the interval of invoking this class does not affect the correctness of the timeouts,
 * although longer intervals would introduce larger error between the actual timeout and the
 * specified timeout.
 *
 * For each invocation this gets a time value to be compared against the timeouts of the callback
 * objects. This time is the System.currentTimeMillis() for Java 1.4 and System.nanoTime() for
 * Java 1.5 and later.
 */
public class TimeoutHandler extends TimerTask {

    /** The callback map - already a Collections.synchronized() hash map */
    private Map callbackStore = null;
    /** a lock to prevent concurrent execution while ensuring least overhead */
    private Object lock = new Object();
    private boolean alreadyExecuting = false;

    public TimeoutHandler(Map callbacks) {
        this.callbackStore = callbacks;
    }

    /**
     * Checks if the timeout has expired for each callback in the callback store. If expired, removes
     * the callback. If specified sends a fault message to the client about the timeout.
     */
    public void run() {
        if (alreadyExecuting) return;

        synchronized(lock) {
            alreadyExecuting = true;
            try {
                processCallbacks();
            } catch (Exception ignore) {}
            alreadyExecuting = false;
        }
    }

    private void processCallbacks() {

        // checks if callback store contains at least one entry before proceeding. otherwise getting
        // the time for doing nothing would be a inefficient task.

        // we have to synchronize this on the callbackStore as iterators of thread safe collections
        // are not thread safe. callbackStore can be modified concurrently by the SynapseCallbackReceiver.
        synchronized(callbackStore) {

            if (callbackStore.size() > 0) {

                long currentTime = currentTime();

                Iterator i = callbackStore.keySet().iterator();

                while (i.hasNext()) {
                    Object key = i.next();
                    AsyncCallback callback = (AsyncCallback) callbackStore.get(key);

                    if (callback.getTimeOutAction() != Constants.NONE) {

                        if (callback.getTimeOutOn() <= currentTime) {
                            callbackStore.remove(key);

                            if (callback.getTimeOutAction() == Constants.DISCARD_AND_FAULT) {

                                // actiavte the fault sequence of the current sequence mediator

                                MessageContext msgContext = callback.getSynapseOutMsgCtx();

                                // add an error code to the message context, so that error sequences
                                // can identify the cause of error
                                msgContext.setProperty(Constants.ERROR_CODE, Constants.TIME_OUT);

                                Stack faultStack = msgContext.getFaultStack();

                                for (int j = 0; j < faultStack.size(); j++) {
                                    Object o = faultStack.pop();
                                    if (o instanceof MediatorFaultHandler) {
                                        ((MediatorFaultHandler) o).handleFault(msgContext);
                                    }
                                }

                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the current time.
     *
     * @return  System.currentTimeMillis() on Java 1.4
     *          System.nanoTime() on Java 1.5 (todo: implement)
     */
    private long currentTime() {
        return System.currentTimeMillis();
    }
}
"
org/apache/synapse/mediators/builtin/LogMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * Logs the specified message into the configured logger. The log levels specify
 * which attributes would be logged, and is configurable. Additionally custom
 * properties may be defined to the logger, where literal values or expressions
 * could be specified for logging. The custom properties are printed into the log
 * using the defined separator (\n, "","" etc)
 */
public class LogMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(LogMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    public static final int CUSTOM = 0;
    public static final int SIMPLE = 1;
    public static final int HEADERS = 2;
    public static final int FULL = 3;
    public static final String DEFAULT_SEP = "", "";

    private int logLevel = SIMPLE;
    private String separator = DEFAULT_SEP;
    private List properties = new ArrayList();

    /**
     * Logs the current message according to the supplied semantics
     *
     * @param synCtx (current) message to be logged
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Log mediator :: mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Log mediator"");
        }
        String logMessage = getLogMessage(synCtx);
        log.info(logMessage);
        if (shouldTrace) {
            trace.trace(logMessage);
            trace.trace(""End : Log mediator"");
        }
        return true;
    }

    private String getLogMessage(MessageContext synCtx) {
        switch (logLevel) {
            case CUSTOM:
                return getCustomLogMessage(synCtx);
            case SIMPLE:
                return getSimpleLogMessage(synCtx);
            case HEADERS:
                return getHeadersLogMessage(synCtx);
            case FULL:
                return getFullLogMessage(synCtx);
            default:
                return ""Invalid log level specified"";
        }
    }

    private String getCustomLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getSimpleLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        if (synCtx.getTo() != null)
            sb.append(""To: "" + synCtx.getTo().getAddress());
        else
            sb.append(""To: "");
        if (synCtx.getFrom() != null)
            sb.append(separator + ""From: "" + synCtx.getFrom().getAddress());
        if (synCtx.getWSAAction() != null)
            sb.append(separator + ""WSAction: "" + synCtx.getWSAAction());
        if (synCtx.getSoapAction() != null)
            sb.append(separator + ""SOAPAction: "" + synCtx.getSoapAction());
        if (synCtx.getReplyTo() != null)
            sb.append(separator + ""ReplyTo: "" + synCtx.getReplyTo().getAddress());
        if (synCtx.getMessageID() != null)
            sb.append(separator + ""MessageID: "" + synCtx.getMessageID());
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getHeadersLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        SOAPHeader header = synCtx.getEnvelope().getHeader();
        if (header != null) {
            Iterator iter = header.examineAllHeaderBlocks();
            while (iter.hasNext()) {
                Object o = iter.next();
                if (o instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock headerBlk = (SOAPHeaderBlock) o;
                    sb.append(separator + headerBlk.getLocalName() + "" : "" + headerBlk.getText());
                } else if (o instanceof OMElement) {
                    OMElement headerElem = (OMElement) o;
                    sb.append(separator + headerElem.getLocalName() + "" : "" + headerElem.getText());
                }
            }
        }
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getFullLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        sb.append(getSimpleLogMessage(synCtx));
        if (synCtx.getEnvelope() != null)
            sb.append(separator + ""Envelope: "" + synCtx.getEnvelope());        
        return trimLeadingSeparator(sb);
    }

    private void setCustomProperties(StringBuffer sb, MessageContext synCtx) {
        if (properties != null && !properties.isEmpty()) {
            Iterator iter = properties.iterator();
            while (iter.hasNext()) {
                MediatorProperty prop = (MediatorProperty) iter.next();
                sb.append(separator + prop.getName() + "" = "" +
                        (prop.getValue() != null ? prop.getValue() : prop.getEvaluatedExpression(synCtx)));
            }
        }
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getSeparator() {
        return separator;
    }

    public void setSeparator(String separator) {
        this.separator = separator;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }

    private String trimLeadingSeparator(StringBuffer sb) {
        String retStr = sb.toString();
        if (retStr.startsWith(separator)) {
            return retStr.substring(separator.length());
        } else {
            return retStr;
        }
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.MessageContext;

/**
 * This mediator represents an unnamed the list of mediator
 *
 */

public class AnonymousListMediator extends AbstractListMediator {

     public boolean mediate(MessageContext synCtx) {
         return super.mediate(synCtx);
     }

}
"
org/apache/synapse/registry/AbstractRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.config.Entry;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.Endpoint;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;

/**
 * Implements the core Registry lookup algorithm
 */
public abstract class AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(AbstractRegistry.class);

    /** The list of configuration properties */
    protected Map properties = new HashMap();

    /**
     * Get the resource for the given key from this registry
     * @param entry
     * @return the matching resultant object
     */
    public Object getResource(Entry entry) {

        OMNode omNode = null;
        RegistryEntry re = null;

        // we are dealing with a dynamic resource. Have we seen this before and processed
        // it at least once and have it cached already?

        // if we have an unexpired cached copy, return the cached object
        if (entry.isCached() && !entry.isExpired()) {
            return entry.getValue();

        // if we have not cached the referenced object, fetch it and its RegistryEntry
        } else if (!entry.isCached()) {
            omNode = lookup(entry.getKey());
            if (omNode == null) {
                return null;
            } else {
                re = getRegistryEntry(entry.getKey());
            }

        // if we have cached it before, and now the cache has expired
        // get its *new* registry entry and compare versions and pick new cache duration
        } else if (entry.isExpired()) {

            log.debug(""Cached object has expired for key : "" + entry.getKey());
            re = getRegistryEntry(entry.getKey());

            if (re.getVersion() != Long.MIN_VALUE &&
                re.getVersion() == entry.getVersion()) {
                log.debug(""Expired version number is same as current version in registry"");

                // renew cache lease for another cachable duration (as returned by the
                // new getRegistryEntry() call
                entry.setExpiryTime(
                    System.currentTimeMillis() + re.getCachableDuration());
                log.debug(""Renew cache lease for another "" + re.getCachableDuration() / 1000 + ""s"");

                // return cached object
                return entry.getValue();

            } else {
                omNode = lookup(entry.getKey());
            }
        }

        // if we get here, we have received the raw omNode from the
        // registry and our previous copy (if we had one) has expired or is not valid

        // if we have a XMLToObjectMapper for this entry, use it to convert this
        // resource into the appropriate object - e.g. sequence or endpoint
        if (entry.getMapper() != null) {
            entry.setValue(entry.getMapper().getObjectFromOMNode(omNode));

            if (entry.getValue() instanceof SequenceMediator) {
                SequenceMediator seq = (SequenceMediator) entry.getValue();
                seq.setDynamic(true);
                seq.setRegistryKey(entry.getKey());
            } else if (entry.getValue() instanceof Endpoint) {
                Endpoint ep = (Endpoint) entry.getValue();                
            }

        } else {
            // if the type of the object is known to have a mapper, create the
            // resultant Object using the known mapper, and cache this Object
            // else cache the raw OMNode
            if (re != null && re.getType() != null) {

                XMLToObjectMapper mapper = getMapper(re.getType());
                if (mapper != null) {
                    entry.setMapper(mapper);
                    entry.setValue(mapper.getObjectFromOMNode(omNode));

                } else {
                    entry.setValue(omNode);
                }
            }
        }

        // increment cache expiry time as specified by the last getRegistryEntry() call
        entry.setExpiryTime(System.currentTimeMillis() + re.getCachableDuration());
        entry.setVersion(re.getVersion());

        return entry.getValue();
    }

    private XMLToObjectMapper getMapper(URI type) {
        return null;
    }

    public String getProviderClass() {
        return this.getClass().getName();
    }

    public Map getConfigProperties() {
        return properties;
    }

    public void addConfigProperty(String name, String value) {
        properties.put(name, value);
    }
}
"
org/apache/synapse/statistics/Statistics.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 * The statistics data structure
 */

public class Statistics {

    /**  Maximum Processing time for a one way flow  */
    private long maxProcessingTime = 0;
    /** Minmum Processing time for a one way flow   */
    private long minProcessingTime = -1;
    /** Avarage Processing time for a one way flow */
    private double avgProcessingTime = 0;
    /** Total Processing time for a one way flow  */
    private double totalProcessingTime;
    /** The number of access count for a one way flow  */
    private int count = 0;
    /** The number of fault count for a one way flow  */
    private int faultCount = 0;

    /**
     * Update the statistics
     *
     * @param inTime  - The processing start time
     * @param outTime - The processing end time
     * @param isFault - A boolean value that indicate whether falut has occured or not
     */
    public void update(long inTime, long outTime, boolean isFault) {
        count++;
        if (isFault) {
            faultCount++;
        }
        long responseTime = outTime - inTime;
        if (maxProcessingTime < responseTime) {
            maxProcessingTime = responseTime;
        }
        if (minProcessingTime > responseTime) {
            minProcessingTime = responseTime;
        }
        if (minProcessingTime == -1) {
            minProcessingTime = responseTime;
        }
        totalProcessingTime = totalProcessingTime + responseTime;
        avgProcessingTime = totalProcessingTime / count;
    }

    /**
     * @return Returns the Maximum processing time
     */
    public long getMaxProcessingTime() {
        return maxProcessingTime;
    }

    /**
     * @return Returns the Avarage processing time
     */
    public double getAvgProcessingTime() {
        return avgProcessingTime;
    }

    /**
     * @return Returns the minimum processing time
     */
    public long getMinProcessingTime() {
        return minProcessingTime;
    }

    /**
     * @return Returns the fault count
     */
    public int getFaultCount() {
        return faultCount;
    }

    /**
     * @return Returns the total count that represents number of access in a one way flow
     */
    public int getCount() {
        return count;
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.endpoints.Endpoint;

/**
 * All endpoint serializers should implement this interface. Use EndpointAbstractSerializer to obtain
 * the correct EndpointSerializer implementation for a particular endpoint. EndpointSerializer implementation
 * may call other EndpointSerializer implementations to serialize nested endpoints.
 */
public interface EndpointSerializer {

    /**
     * Serializes the given endpoint implementation to an XML object.
     *
     * @param endpoint Endpoint implementation to be serialized.
     * @return OMElement containing XML configuration.
     */
    public OMElement serializeEndpoint(Endpoint endpoint);
}
"
org/apache/synapse/mediators/filters/OutMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The Out Mediator acts only on ""outgoing"" messages from synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class OutMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    private static final Log log = LogFactory.getLog(OutMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Out mediator mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        try {
            if (shouldTrace) {
                trace.trace(""Start : Out mediator"");
            }
            
            if (test(synCtx)) {
                log.debug(""Current message is outgoing.. executing child mediators"");
                return super.mediate(synCtx);
            } else {
                log.debug(""Current message is not outgoing.. skipping child mediators"");
                return true;
            }
        } finally {
            if (shouldTrace) {
                trace.trace(""End : Out mediator"");
            }
        }
    }

    /**
     * Apply mediation only on response messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return synCtx.isResponse();
    }
}
"
org/apache/synapse/config/xml/DropMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

import javax.xml.namespace.QName;

/**
 * This creates a drop mediator instance
 *
 * <pre>
 * &lt;drop/&gt;
 * </pre>
 */
public class DropMediatorFactory extends AbstractMediatorFactory  {

    private static final QName DROP_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""drop"");

    public Mediator createMediator(OMElement el) {

        Mediator dropMediator = new DropMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(dropMediator,el);

        return dropMediator;
    }

    public QName getTagQName() {
        return DROP_Q;
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.Collection;
import java.util.Iterator;

public abstract class AbstractMediatorSerializer implements MediatorSerializer {

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(Constants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(Constants.NULL_NAMESPACE, """");
    private static final Log log = LogFactory.getLog(AbstractMediatorSerializer.class);

    /**
     * Perform common functions and finalize the mediator serialization.
     * i.e. process any common attributes
     *
     * @param mediatorOmElement the OMElement being created
     * @param mediator          the Mediator instance being serialized
     */
    protected static void finalizeSerialization(OMElement mediatorOmElement, Mediator mediator) {
        int traceState = mediator.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.Constants.TRACING_ON) {
            traceValue = Constants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.Constants.TRACING_OFF) {
            traceValue = Constants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            mediatorOmElement.addAttribute(fac.createOMAttribute(
                Constants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }

    }

    public void serializeMediatorProperties(OMElement parent, Collection props) {

        Iterator iter = props.iterator();
        while (iter.hasNext()) {
            MediatorProperty mp = (MediatorProperty) iter.next();
            OMElement prop = fac.createOMElement(""property"", synNS, parent);
            if (mp.getName() != null) {
                prop.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
            } else {
                handleException(""Mediator property name missing"");
            }

            if (mp.getValue() != null) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));

            } else if (mp.getExpression() != null) {
                prop.addAttribute(fac.createOMAttribute(""expression"", nullNS,
                    mp.getExpression().toString()));
                serializeNamespaces(prop, mp.getExpression());

            } else {
                handleException(""Mediator property must have a literal value or be an expression"");
            }
        }
    }

    public void serializeProperties(OMElement parent, Collection props) {
        serializeMediatorProperties(parent, props);
    }

    public void serializeNamespaces(OMElement elem, AXIOMXPath xpath) {
        Iterator iter = xpath.getNamespaces().keySet().iterator();
        while (iter.hasNext()) {
            String prefix = (String) iter.next();
            String uri = xpath.getNamespaceContext().translateNamespacePrefixToUri(prefix);
            if (!Constants.SYNAPSE_NAMESPACE.equals(uri)) {
                elem.declareNamespace(uri, prefix);
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/core/axis2/AnonymousServiceFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axis2.util.CallbackReceiver;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;

import javax.xml.namespace.QName;

/**
 * Returns an anonymous service for the given QoS. If an instance does not already
 * exist, create one and set it to the Axis configuration
 */
public class AnonymousServiceFactory {

    private static final Log log = LogFactory.getLog(AnonymousServiceFactory.class);

    private static final String NONE            = ""__NONE__"";
    private static final String ADDR_ONLY       = ""__ADDR_ONLY__"";
    private static final String RM_AND_ADDR     = ""__RM_AND_ADDR__"";
    private static final String SEC_AND_ADDR    = ""__SEC_AND_ADDR__"";
    private static final String RM_SEC_AND_ADDR = ""__RM_SEC_AND_ADDR__"";

    public static final String DYNAMIC_OPERATION  = ""__DYNAMIC_OPERATION__"";

    private static final SynapseCallbackReceiver synapseCallback = new SynapseCallbackReceiver();

    /**
     * Creates an AxisService for the requested QoS for sending out messages
     * Callers must guarantee that if wsRMon or wsSecOn is required, that wsAddrOn is also set
     * @param axisCfg Axis2 configuration
     * @param wsAddrOn
     * @param wsRMOn
     * @param wsSecOn
     * @return An Axis service for the requested QoS
     */
    public static AxisService getAnonymousService(AxisConfiguration axisCfg,
        boolean wsAddrOn, boolean wsRMOn, boolean wsSecOn) {

        String servicekey = null;
        if (!wsAddrOn) {
            servicekey = NONE;
        } else {
            if (!wsSecOn && !wsRMOn) {
                servicekey = ADDR_ONLY;
            } else if (wsRMOn && !wsSecOn) {
                servicekey = RM_AND_ADDR;
            } else if (wsSecOn && !wsRMOn) {
                servicekey = SEC_AND_ADDR;
            } else {
                servicekey = RM_SEC_AND_ADDR;
            }
        }

        try {
            AxisService service = axisCfg.getService(servicekey);
            if (service == null) {
                synchronized (AnonymousServiceFactory.class) {

                    // fix with double locking, issue found on performance test
                    service = axisCfg.getService(servicekey);
                    if (service != null) {
                        return service;
                    }

                    service = createAnonymousService(axisCfg, servicekey);

                    if (wsAddrOn) {
                        service.engageModule(axisCfg.getModule(
                            Constants.ADDRESSING_MODULE_NAME), axisCfg);

                        if (wsRMOn) {
                            service.engageModule(axisCfg.getModule(
                                Constants.SANDESHA2_MODULE_NAME), axisCfg);
                        }
                        if (wsSecOn) {
                            service.engageModule(axisCfg.getModule(
                                Constants.RAMPART_MODULE_NAME), axisCfg);
                        }
                    }
                    // if WS-A is off, WS-Sec and WS-RM should be too
                }
            }
            return service;
        } catch (AxisFault e) {
            handleException(""Error retrieving anonymous service for QoS : "" + servicekey, e);
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Create a new Anonymous Axis service for OUT-IN as default MEP
     * @param axisCfg the Axis2 configuration
     * @return an anonymous service named with the given QoS key
     */
    private static AxisService createAnonymousService(
        AxisConfiguration axisCfg, String serviceKey) {

        try {
            DynamicAxisOperation dynamicOperation =
                new DynamicAxisOperation(new QName(DYNAMIC_OPERATION));
            dynamicOperation.setMessageReceiver(synapseCallback);
            AxisMessage inMsg = new AxisMessage();
            inMsg.setName(""in-message"");
            inMsg.setParent(dynamicOperation);
            AxisMessage outMsg = new AxisMessage();
            outMsg.setName(""out-message"");
            outMsg.setParent(dynamicOperation);
            dynamicOperation.addMessage(inMsg, WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
            dynamicOperation.addMessage(outMsg, WSDLConstants.MESSAGE_LABEL_IN_VALUE);
            AxisService axisAnonymousService  = new AxisService(serviceKey);
            axisAnonymousService.addOperation(dynamicOperation);
            axisCfg.addService(axisAnonymousService);
            axisCfg.getPhasesInfo().setOperationPhases(dynamicOperation);
            return axisAnonymousService;

        } catch (AxisFault e) {
            handleException(
                ""Error occured while creating an anonymous service for QoS : "" +
                 serviceKey, e);
        }
        return null;
    }

}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.woden.WSDLFactory;
import org.apache.woden.WSDLReader;
import org.apache.woden.WSDLException;
import org.apache.woden.types.NCName;
import org.apache.woden.wsdl20.xml.DescriptionElement;
import org.apache.woden.wsdl20.Description;
import org.apache.woden.wsdl20.Service;
import org.apache.woden.wsdl20.Endpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Currently this class is not used as woden is dependent on xerces, which is not included in the
 * current release.
 *  
 * Builder for WSDL 2.0 endpoints. This class extracts endpoint information from the given WSDL 2.0
 * documents.
 */
public class WSDL20EndpointBuilder {

/*  COMMENT DUE TO BUILD FAILURE - TO BE FIXED LATER WHEN WSDL 2.0 SUPPORT IS OFFICIALLY IN 
    private static Log log = LogFactory.getLog(WSDL20EndpointBuilder.class);

    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String serviceName, String portName) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            reader.setFeature(WSDLReader.FEATURE_VALIDATION, false);

            DescriptionElement descriptionElement = reader.readWSDL(wsdlURI);
            return createEndpointDefinitionFromWSDL(descriptionElement, serviceName, portName);

        } catch (WSDLException e) {
            handleException(""Couldn't process the given WSDL document."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (DescriptionElement dElement, String serviceName, String portName) {

        if (dElement == null) {
            throw new SynapseException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            throw new SynapseException(""Service is not specified."");
        }

        if (portName == null) {
            throw new SynapseException(""Port is not specified."");
        }

        Description description = dElement.toComponent();
        String tns = dElement.getTargetNamespace().toString();
        Service service = description.getService(new QName(tns, serviceName));
        if (service != null) {
            Endpoint wsdlEndpoint = service.getEndpoint(new NCName(portName));
            if (wsdlEndpoint != null) {
                String serviceURL = wsdlEndpoint.getAddress().toString();

                EndpointDefinition endpointDefinition = new EndpointDefinition();
                endpointDefinition.setAddress(serviceURL);

                return endpointDefinition;
            } else {
                handleException(""Specified port is not defined in the given WSDL."");
            }
        } else {
            handleException(""Specified service is not defined in the given WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }*/
}
"
org/apache/synapse/core/axis2/AsyncCallback.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.client.async.Callback;
import org.apache.axis2.client.async.AsyncResult;
import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;

/**
 * This class only ""holds"" the Synapse out message context for the Synapse callback message
 * receiver when a response is received or error is encountered
 */
public class AsyncCallback extends Callback {

    MessageContext synapseOutMsgCtx = null;

    /**
     * Time to timeout this callback.
     */
    private long timeOutOn;

    /**
     * Action to perform when timeout occurs.
     */
    private int timeOutAction = Constants.NONE;


    public AsyncCallback(org.apache.synapse.MessageContext synapseOutMsgCtx) {
        this.synapseOutMsgCtx = synapseOutMsgCtx;
    }

    public void onComplete(AsyncResult result) {}

    public void onError(Exception e) {}

    public void setSynapseOutMshCtx(MessageContext synapseOutMsgCtx) {
        this.synapseOutMsgCtx = synapseOutMsgCtx;
    }

    public MessageContext getSynapseOutMsgCtx() {
        return synapseOutMsgCtx;
    }

    public long getTimeOutOn() {
        return timeOutOn;
    }

    public void setTimeOutOn(long timeOutOn) {
        this.timeOutOn = timeOutOn;
    }

    public int getTimeOutAction() {
        return timeOutAction;
    }

    public void setTimeOutAction(int timeOutAction) {
        this.timeOutAction = timeOutAction;
    }
}
"
org/apache/synapse/endpoints/WSDLEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axiom.om.OMElement;

import java.util.Stack;

/**
 * WSDLEndpoint represents the endpoints built using a wsdl document. It stores the details about
 * the endpoint in a EndpointDefinition object. Once the WSDLEndpoint object is contructed, it should
 * not access the wsdl document at runtime to obtain endpoint information. If it is neccessary to
 * create an endpoint using a dynamic wsdl, store the endpoint configuration in the registry and
 * create a dynamic wsdl endpoint using that registry key.
 *
 * TODO: This should allow variuos policies to be applied on fine grained level (e.g. operations).
 */
public class WSDLEndpoint extends FaultHandler implements Endpoint {

    private static final Log log = LogFactory.getLog(AddressEndpoint.class);

    private String name = null;
    private String wsdlURI;
    private OMElement wsdlDoc;
    private String serviceName;
    private String portName;

    /**
     * Leaf level endpoints will be suspended for the specified time by this variable, after a
     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to suspended forever.
     */
    private long suspendOnFailDuration = -1;

    /**
     * Time to recover a failed endpoint. Value of this is calculated when endpoint is set as
     * failed by adding suspendOnFailDuration to current time.
     */
    private long recoverOn = Long.MAX_VALUE;

    private boolean active = true;
    private Endpoint parentEndpoint = null;
    private EndpointDefinition endpointDefinition = null;

    /**
     * Sends the message through this endpoint. This method just handles statistics related functions
     * and gives the message to the Synapse environment to send. It does not add any endpoint
     * specific details to the message context. These details are added only to the cloned message
     * context by the Axis2FlexibleMepClient. So that we can reuse the original message context for
     * resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        String eprAddress = null;
        if (endpointDefinition.getAddress() != null) {
            eprAddress = endpointDefinition.getAddress().toString();
            String endPointName = this.getName();
            if (endPointName == null) {
                endPointName = Constants.ANONYMOUS_ENDPOINTS;
            }
            // Setting Required property to collect the End Point statistics
            boolean statisticsEnable =
                    (org.apache.synapse.Constants.STATISTICS_ON
                            == endpointDefinition.getStatisticsEnable());
            if (statisticsEnable) {
                EndPointStatisticsStack endPointStatisticsStack = null;
                Object statisticsStackObj =
                        synCtx.getProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK);
                if (statisticsStackObj == null) {
                    endPointStatisticsStack = new EndPointStatisticsStack();
                    synCtx.setProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK,
                            endPointStatisticsStack);
                } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                    endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
                }
                if (endPointStatisticsStack != null) {
                    boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                    endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                            !synCtx.isResponse(), statisticsEnable, isFault);
                }
            }
            if (log.isDebugEnabled()) {
                log.debug(""Sending message to endpoint :: name = "" +
                        endPointName + "" resolved address = "" + eprAddress);
                log.debug(""Sending To: "" + (synCtx.getTo() != null ?
                        synCtx.getTo().getAddress() : ""null""));
                log.debug(""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                        synCtx.getSoapAction() : ""null""));
                log.debug(""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));
                log.debug(""Body : \n"" + synCtx.getEnvelope());
            }

            // register this as the immediate fault handler for this message.
            synCtx.pushFaultHandler(this);

            // add this as the last endpoint to process this message. it is used by statistics code.
            synCtx.setProperty(Constants.PROCESSED_ENDPOINT, this);

            synCtx.getEnvironment().send(endpointDefinition, synCtx);
        }
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // WSDLEndpoint does not contain any child endpoints. So this method will never be called.
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public long getSuspendOnFailDuration() {
        return suspendOnFailDuration;
    }

    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
        this.suspendOnFailDuration = suspendOnFailDuration;
    }

    public String getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(String wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public OMElement getWsdlDoc() {
        return wsdlDoc;
    }

    public void setWsdlDoc(OMElement wsdlDoc) {
        this.wsdlDoc = wsdlDoc;
    }

    public String getServiceName() {
        return serviceName;
    }

    public void setServiceName(String serviceName) {
        this.serviceName = serviceName;
    }

    public String getPortName() {
        return portName;
    }

    public void setPortName(String portName) {
        this.portName = portName;
    }

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
            }
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {

        if (!active) {
            if (suspendOnFailDuration != -1) {
                recoverOn = System.currentTimeMillis() + suspendOnFailDuration;
            } else {
                recoverOn = Long.MAX_VALUE;
            }
        }

        this.active = active;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public EndpointDefinition getEndpointDefinition() {
        return endpointDefinition;
    }

    public void setEndpointDefinition(EndpointDefinition endpointDefinition) {
        this.endpointDefinition = endpointDefinition;
    }
}
"
org/apache/synapse/config/xml/ClassMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.ClassMediator;
import org.apache.synapse.mediators.filters.FilterMediator;

/**
 * <pre>
 * &lt;class name=""class-name""&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorSerializer extends AbstractMediatorSerializer  {

    private static final Log log = LogFactory.getLog(ClassMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ClassMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        ClassMediator mediator = (ClassMediator) m;
        OMElement clazz = fac.createOMElement(""class"", synNS);
        finalizeSerialization(clazz, mediator);

        if (mediator.getClazz() != null) {
            clazz.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, mediator.getClazz().getName()));
        } else {
            handleException(""Invalid class mediator. "" +
                ""The class name is required"");
        }

        serializeProperties(clazz, mediator.getProperties());

        if (parent != null) {
            parent.addChild(clazz);
        }
        return clazz;
    }

    public String getMediatorClassName() {
        return ClassMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates FailoverEndpoint using a XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <failover>
 *       <endpoint>+
 *    </failover>
 * </endpoint>
 */
public class FailoverEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(FailoverEndpointFactory.class);

    private static FailoverEndpointFactory instance = new FailoverEndpointFactory();

    private FailoverEndpointFactory() {}

    public static FailoverEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        OMElement failoverElement = epConfig.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""failover""));
        if (failoverElement != null) {

            FailoverEndpoint failoverEndpoint = new FailoverEndpoint();

            // set endpoint name
            String name = epConfig.getAttributeValue(new QName(""name""));
            if (name != null) {
                failoverEndpoint.setName(name);
            }

            // set endpoints
            ArrayList endpoints = getEndpoints(failoverElement, failoverEndpoint);
            failoverEndpoint.setEndpoints(endpoints);

            return failoverEndpoint;
        }

        return null;
    }

    public Object getObjectFromOMNode(OMNode om) {
         if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement failoverElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = failoverElement.getChildrenWithName
                (org.apache.synapse.config.xml.Constants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/mediators/transform/XSLTMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.config.Util;
import org.apache.synapse.config.Entry;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.*;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * The XSLT mediator performs an XSLT transformation requested, using
 * the current message. The source attribute (if available) spcifies the source element
 * on which the transformation would be applied. It will default to the first child of
 * the messages' SOAP body, if it is omitted. Additional properties passed into this
 * mediator would become parameters for XSLT
 */
public class XSLTMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(XSLTMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * The resource key/name which refers to the XSLT to be used for the transformation
     */
    private String xsltKey = null;

    /**
     * The (optional) XPath expression which yeilds the source element for a transformation
     */
    private AXIOMXPath source = null;

    /**
     * Any parameters which should be passed into the XSLT transformation
     */
    private List properties = new ArrayList();

    /**
     * The Transformer instance used to perform XSLT transformations. This is not thread-safe
     *
     * @see javax.xml.transform.Transformer
     */
    private Transformer transformer = null;

    /**
     * Lock used to ensure thread-safe creation and use of the above Transformer
     */
    private final Object transformerLock = new Object();

    public static final String DEFAULT_XPATH = ""//s11:Envelope/s11:Body/child::*[position()=1] | "" +
            ""//s12:Envelope/s12:Body/child::*[position()=1]"";

    public XSLTMediator() {
        // create the default XPath
        try {
            this.source = new AXIOMXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            handleException(""Error creating source XPath expression"", e);
        }
    }

    /**
     * Transforms this message (or its element specified as the source) using the
     * given XSLT transformation
     *
     * @param synCtx the current message where the transformation will apply
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {
        try {
            log.debug(""XSLT mediator mediate()"");
            boolean shouldTrace = shouldTrace(synCtx.getTracingState());
            if (shouldTrace) {
                trace.trace(""Start : XSLT mediator"");
            }
            log.debug(""Performing XSLT transformation against resource with key : "" + xsltKey);
            performXLST(synCtx, shouldTrace);
            if (shouldTrace) {
                trace.trace(""Start : XSLT mediator"");
            }
            return true;
        } catch (Exception e) {
            handleException(""Unable to do the transformation"");
        }
        return false;
    }

    private void performXLST(MessageContext msgCtx, boolean shouldTrace) {

        Source transformSrc = null;
        ByteArrayOutputStream baosForTarget = new ByteArrayOutputStream();

        // create a new Stream result over a new BAOS..
        StreamResult transformTgt = new StreamResult(baosForTarget);

        OMNode sourceNode = getTransformSource(msgCtx);
        if (shouldTrace) {
            trace.trace(""Transformation source : "" + sourceNode.toString());
        }
        if (log.isDebugEnabled()) {
            log.debug(""Transformation source : "" + sourceNode);
        }

        try {
            // create a byte array output stream and serialize the source node into it
            ByteArrayOutputStream baosForSource = new ByteArrayOutputStream();
            XMLStreamWriter xsWriterForSource = XMLOutputFactory.newInstance().
                    createXMLStreamWriter(baosForSource);

            sourceNode.serialize(xsWriterForSource);
            transformSrc = new StreamSource(new ByteArrayInputStream(baosForSource.toByteArray()));

        } catch (XMLStreamException e) {
            handleException(""Error gettting transform source "" + e.getMessage(), e);
        }

        // build transformer - if necessary
        Entry dp = msgCtx.getConfiguration().getEntryDefinition(xsltKey);

        // if the xsltKey refers to a dynamic resource
        if (dp != null && dp.isDynamic()) {
            if (!dp.isCached() || dp.isExpired()) {
                synchronized (transformerLock) {
                    try {
                        transformer = TransformerFactory.newInstance().
                                newTransformer(Util.getStreamSource(
                                        msgCtx.getEntry(xsltKey)
                                ));
                    } catch (TransformerConfigurationException e) {
                        handleException(""Error creating XSLT transformer using : "" + xsltKey, e);
                    }
                }
            }

            // if the resource is not a dynamic, we will create a transformer only once
        } else {
            if (transformer == null) {
                synchronized (transformerLock) {
                    try {
                        transformer = TransformerFactory.newInstance().
                                newTransformer(
                                        Util.getStreamSource(
                                                msgCtx.getEntry(xsltKey)));
                    } catch (TransformerConfigurationException e) {
                        handleException(""Error creating XSLT transformer using : "" + xsltKey, e);
                    }
                }
            }
        }

        try {
            // perform transformation
            transformer.transform(transformSrc, transformTgt);

            StAXOMBuilder builder = new StAXOMBuilder(
                    new ByteArrayInputStream(baosForTarget.toByteArray()));
            OMElement result = builder.getDocumentElement();
            if (shouldTrace) {
                trace.trace(""Transformation result : "" + result.toString());
            }
            if (log.isDebugEnabled()) {
                log.debug(""Transformation result : "" + result);
            }

            // replace the sourceNode with the result.
            sourceNode.insertSiblingAfter(result);
            sourceNode.detach();

        } catch (TransformerException e) {
            handleException(""Error performing XSLT transformation "" + xsltKey, e);
        } catch (XMLStreamException e) {
            handleException(""Error building result from XSLT transformation"", e);
        }
    }


    /**
     * Return the OMNode to be used for the transformation. If a source XPath is not specified,
     * this will default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which the transformation should be performed
     */
    private OMNode getTransformSource(MessageContext synCtx) {

        try {
            Object o = source.evaluate(synCtx.getEnvelope());
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                        + source + "" must result in an OMNode"");
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath "" + source + "" on message"");
        }
        return null;
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public AXIOMXPath getSource() {
        return source;
    }

    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    public String getXsltKey() {
        return xsltKey;
    }

    public void setXsltKey(String xsltKey) {
        this.xsltKey = xsltKey;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }
}

	
"
org/apache/synapse/endpoints/SALoadbalanceEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.MessageContext;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axis2.context.OperationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * SALoadbalanceEndpoint supports session affinity based load balancing. Each of this endpoint
 * maintains a list of dispatchers. These dispatchers will be updated for both request (for client
 * initiated sessions) and response (for server initiated sessions). Once updated, each dispatcher
 * will check if has already encountered that session. If not, it will update the
 * session -> endpoint map. To update sessions for response messages, all SALoadbalanceEndpoint
 * objects are kept in a global property. When a message passes through SALoadbalanceEndpoints, each
 * endpoint appends its ""Synapse unique ID"" to the operation context. Once the response for that
 * message arrives, response sender checks first endpoint of the endpoint sequence from the operation
 * context and get that endpoint from the above mentioned global property. Then it will invoke
 * updateSession(...) method of that endpoint. After that, each endpoint will call updateSession(...)
 * method of their appropriate child endpoint, so that all the sending endpoints for the session will
 * be updated.
 *
 * This endpoint gets the target endpoint first from the dispatch manager, which will ask all listed
 * dispatchers for a matching session. If a matching session is found it will just invoke the send(...)
 * method of that endpoint. If not it will find an endpoint using the loadbalance policy and send to
 * that endpoint.
 */
public class SALoadbalanceEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(SALoadbalanceEndpoint.class);

    private static final String FIRST_MESSAGE_IN_SESSION = ""first_message_in_session"";

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the first request of sessions.
     * Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

     /**
     * Determine whether this endpoint is active or not. This is always loaded from the memory as it
     * could be accessed from multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Although any endpoint
     * can be the parent, only SALoadbalanceEndpoint should be used here. Use of any other endpoint
     * would invalidate the session.
     */
    private Endpoint parentEndpoint = null;

    /**
     * Dispatcher used for session affinity.
     */
    private Dispatcher dispatcher = null;

    public void send(MessageContext synMessageContext) {

        Endpoint endpoint = null;

        // first check if this session is associated with a session. if so, get the endpoint
        // associated for that session.
        endpoint = dispatcher.getEndpoint(synMessageContext);
        if (endpoint == null) {

            // there is no endpoint associated with this session. get a new endpoint using the
            // load balance policy.
            endpoint = algorithm.getNextEndpoint(synMessageContext);

            // this is a start of a new session. so update session map.
            if (dispatcher.isServerInitiatedSession()) {

                // add this endpoint to the endpoint sequence of operation context.
                Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synMessageContext;
                OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
                Object o = opCtx.getProperty(""endpointList"");

                if (o != null) {
                    List endpointList = (List) o;
                    endpointList.add(this);

                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
                        endpointList.add(endpoint);
                    }

                } else {

                    // this is the first endpoint in the heirachy. so create the queue and insert
                    // this as the first element.
                    List endpointList = new ArrayList();
                    endpointList.add(this);

                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
                        endpointList.add(endpoint);
                    }

                    opCtx.setProperty(""endpointList"", endpointList);
                }

            } else {
                dispatcher.updateSession(synMessageContext, endpoint);
            }

            // this is the first request. so an endpoint has not been bound to this session and we
            // are free to failover if the currently selected endpoint is not working. but for
            // failover to work, we have to build the soap envelope.
            synMessageContext.getEnvelope().build();

            // we should also indicate that this is the first message in the session. so that
            // onFault(...) method can resend only the failed attempts for the first message.
            synMessageContext.setProperty(FIRST_MESSAGE_IN_SESSION, Boolean.TRUE);
        }

        if (endpoint != null) {

            // endpoints given by session dispatchers may not be active. therefore, we have check
            // it here.
            if (endpoint.isActive(synMessageContext)) {                
                endpoint.send(synMessageContext);
            } else {
                informFailure(synMessageContext);
            }

        } else {

            // all child endpoints have failed. so mark this also as failed.
            setActive(false, synMessageContext);
            informFailure(synMessageContext);
        }
    }

    /**
     * This will be called for the response of the first message of each server initiated session.
     *
     * @param responseMsgCtx
     * @param endpointList
     */
    public void updateSession(MessageContext responseMsgCtx, List endpointList) {

        Endpoint endpoint = (Endpoint) endpointList.remove(0);
        dispatcher.updateSession(responseMsgCtx, endpoint);
        if (endpoint instanceof SALoadbalanceEndpoint) {
            ((SALoadbalanceEndpoint) endpoint).updateSession(responseMsgCtx, endpointList);
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * This is active in below conditions:
     * If a session is not started AND at least one child endpoint is active.
     * If a session is started AND the binding endpoint is active.
     *
     * This is not active for all other conditions.
     *
     * @param synMessageContext MessageContext of the current message. This is used to determine the
     * session.
     *
     * @return true is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        // todo: implement above

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        this.active = active;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public Dispatcher getDispatcher() {
        return dispatcher;
    }

    public void setDispatcher(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    /**
     * It is logically incorrect to failover a session affinity endpoint after the session has started.
     * If we redirect a message belonging to a particular session, new endpoint is not aware of the
     * session. So we can't handle anything more at the endpoint level. Therefore, this method just
     * deactivate the failed endpoint and give the fault to the next fault handler.
     *
     * But if the session has not started (i.e. first message), the message will be resend by binding
     * it to a different endpoint.
     *
     * @param endpoint Failed endpoint.
     * @param synMessageContext MessageContext of the failed message.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        Object o = synMessageContext.getProperty(FIRST_MESSAGE_IN_SESSION);

        if (o != null && Boolean.TRUE.equals(o)) {

            // this is the first message. so unbind the sesion with failed endpoint and start
            // new one by resending.
            dispatcher.unbind(synMessageContext);
            send(synMessageContext);

        } else {

            // session has already started. we can't failover.
            informFailure(synMessageContext);
        }
    }

    private void informFailure(MessageContext synMessageContext) {

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);

        } else {

            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/IndirectEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Creates an IndirectEndpoint using a XML configuration. Key can be a name of an endpoint defined
 * in the same Synapse configuration or a registry key pointing to an endpoint configuration in the
 * registry (e.g. <endpoint key=""registry/endpoint1.xml"" />).
 *
 * <endpoint key=""key"" />
 */
public class IndirectEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(IndirectEndpointFactory.class);

    private static IndirectEndpointFactory instance = new IndirectEndpointFactory();

    private IndirectEndpointFactory() {}

    public static IndirectEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        IndirectEndpoint indirectEndpoint = new IndirectEndpoint();
        String ref = epConfig.getAttributeValue(new QName(""key""));
        indirectEndpoint.setKey(ref);
        return indirectEndpoint;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
			return createEndpoint((OMElement) om, false);
		} else {
			handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
		}
		return null;
    }

     private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/XMLConfigurationBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.*;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.Util;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.builtin.LogMediator;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;


/**
 * Builds a Synapse Configuration from an XML input stream
 */
public class XMLConfigurationBuilder {

    private static Log log = LogFactory.getLog(XMLConfigurationBuilder.class);

    public static SynapseConfiguration getConfiguration(InputStream is) {

        log.info(""Generating the Synapse configuration model by parsing the XML configuration"");
        SynapseConfiguration config = new SynapseConfiguration();

        SequenceMediator rootSequence = new SequenceMediator();
        rootSequence.setName(org.apache.synapse.Constants.MAIN_SEQUENCE_KEY);

        OMElement definitions = null;
        try {
            definitions = new StAXOMBuilder(is).getDocumentElement();
            definitions.build();

            OMNamespace namespace = definitions.getNamespace();
            if(namespace == null){
                handleException(""No namespace is defined for definitions element"");
            }

            if (Constants.SYNAPSE_NAMESPACE.equals(namespace.getNamespaceURI())
                && Constants.DEFINITIONS_ELT.getLocalPart()
                    .equals(definitions.getQName().getLocalPart())) {

                Iterator iter = definitions.getChildren();

                while (iter.hasNext()) {
                    Object o = iter.next();
                    if (o instanceof OMElement) {
                        OMElement elt = (OMElement) o;
                        if (Constants.SEQUENCE_ELT.equals(elt.getQName())) {
                            String key = elt.getAttributeValue(
                                new QName(Constants.NULL_NAMESPACE, ""key""));
                            // this could be a sequence def or a mediator of the main sequence
                            if (key != null) {
                                Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                                rootSequence.addChild(m);
                            } else {
                                defineSequence(config, elt);
                            }
                        } else if (Constants.ENDPOINT_ELT.equals(elt.getQName())) {
                            defineEndpoint(config, elt);
                        } else if (Constants.ENTRY_ELT.equals(elt.getQName())) {
                            defineEntry(config, elt);
                        } else if (Constants.PROXY_ELT.equals(elt.getQName())) {
                            defineProxy(config, elt);
                        } else if (Constants.REGISTRY_ELT.equals(elt.getQName())) {
                            defineRegistry(config, elt);
                        } else {
                            Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                            rootSequence.addChild(m);
                        }
                    }
                }
            } else {
                handleException(""Invalid Synapse Configuration : No definition element found"");
            }

        } catch (XMLStreamException e) {
            handleException(""Error parsing Synapse configuration : "" + e.getMessage(), e);
        }

        if (is != null) {
            try {
                is.close();
            } catch (IOException ignore) {}
        }

        if (config.getLocalRegistry().isEmpty() && config.getProxyServices().isEmpty() &&
                rootSequence.getList().isEmpty() && config.getRegistry() != null) {
            OMNode remoteConfigNode = config.getRegistry().lookup(""synapse.xml"");
            config = getConfiguration(Util.getStreamSource(remoteConfigNode).getInputStream());
        }

        if (config.getMainSequence() == null) {
            if (rootSequence.getList().isEmpty()) {
                setDefaultMainSequence(config);
            } else {
                config.addSequence(rootSequence.getName(), rootSequence);
            }
        } else if (!rootSequence.getList().isEmpty()) {
            handleException(""Invalid Synapse Configuration : Conflict in resolving the \""main\"" "" +
                    ""mediator\n\tSynapse Configuration cannot have sequence named \""main\"" and "" +
                    ""toplevel mediators simultaniously"");
        }

        if (config.getFaultSequence() == null) {
            setDefaultFaultSequence(config);
        }

        return config;
    }

    private static void defineRegistry(SynapseConfiguration config, OMElement elem) {
        if (config.getRegistry() != null) {
            handleException(""Only one remote registry can be defined within a configuration"");
        }
        config.setRegistry(RegistryFactory.createRegistry(elem));
    }

    private static void defineProxy(SynapseConfiguration config, OMElement elem) {
        ProxyService proxy = ProxyServiceFactory.createProxy(elem);
        if (config.getProxyService(proxy.getName()) != null) {
            handleException(""Duplicate proxy service with name : "" + proxy.getName());
        }
        config.addProxyService(proxy.getName(), proxy);
    }

    private static void defineEntry(SynapseConfiguration config, OMElement elem) {
        Entry entry = EntryFactory.createEntry(elem);
        if (config.getLocalRegistry().get(entry.getKey()) != null) {
            handleException(""Duplicate registry entry definition for key : "" + entry.getKey());
        }
        config.addEntry(entry.getKey(), entry);
    }

    public static void defineSequence(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(Constants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name) != null) {
                handleException(""Duplicate sequence definition : "" + name);
            }
            config.addSequence(name, MediatorFactoryFinder.getInstance().getMediator(ele));
        } else {
            handleException(""Invalid sequence definition without a name"");
        }
    }

    public static void defineEndpoint(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(Constants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name.trim()) != null) {
                handleException(""Duplicate endpoint definition : "" + name);
            }
            Endpoint endpoint =
                    EndpointAbstractFactory.getEndpointFactroy(ele).createEndpoint(ele, false);
            config.addEndpoint(name.trim(), endpoint);
        } else {
            handleException(""Invalid endpoint definition without a name"");
        }
    }

    /**
     * Return the main sequence if one is not defined. This implementation defaults to
     * a simple sequence with a <send/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultMainSequence(SynapseConfiguration config) {
        SequenceMediator main = new SequenceMediator();
        main.setName(org.apache.synapse.Constants.MAIN_SEQUENCE_KEY);
        main.addChild(new SendMediator());
        config.addSequence(org.apache.synapse.Constants.MAIN_SEQUENCE_KEY, main);
    }

    /**
     * Return the fault sequence if one is not defined. This implementation defaults to
     * a simple sequence with a <log level=""full""/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultFaultSequence(SynapseConfiguration config) {
        SequenceMediator fault = new SequenceMediator();
        fault.setName(org.apache.synapse.Constants.FAULT_SEQUENCE_KEY);
        LogMediator log = new LogMediator();
        log.setLogLevel(LogMediator.FULL);
        fault.addChild(log);
        config.addSequence(org.apache.synapse.Constants.FAULT_SEQUENCE_KEY, fault);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/SendMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

import javax.xml.namespace.QName;

/**
 * The Send mediator factory parses a Send element and creates an instance of the mediator
 *
 * //TODO document endpoints, failover and loadbalacing
 *
 * The &lt;send&gt; element is used to send messages out of Synapse to some endpoint. In the simplest case,
 * the place to send the message to is implicit in the message (via a property of the message itself)-
 * that is indicated by the following
 * <pre>
 *  &lt;send/&gt;
 * </pre>
 *
 * If the message is to be sent to one or more endpoints, then the following is used:
 * <pre>
 *  &lt;send&gt;
 *   (endpointref | endpoint)+
 *  &lt;/send&gt;
 * </pre>
 * where the endpointref token refers to the following:
 * <pre>
 * &lt;endpoint ref=""name""/&gt;
 * </pre>
 * and the endpoint token refers to an anonymous endpoint defined inline:
 * <pre>
 *  &lt;endpoint address=""url""/&gt;
 * </pre>
 * If the message is to be sent to an endpoint selected by load balancing across a set of endpoints,
 * then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;load-balance algorithm=""uri""&gt;
 *     (endpointref | endpoint)+
 *   &lt;/load-balance&gt;
 * &lt;/send&gt;
 * </pre>
 * Similarly, if the message is to be sent to an endpoint with failover semantics, then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;failover&gt;
 *     (endpointref | endpoint)+
 *   &lt;/failover&gt;
 * &lt;/send&gt;
 * </pre>
 */
public class SendMediatorFactory extends AbstractMediatorFactory  {

    private static final Log log = LogFactory.getLog(SendMediatorFactory.class);

    private static final QName SEND_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""send"");

    public Mediator createMediator(OMElement elem) {

        SendMediator sm =  new SendMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(sm,elem);

        OMElement epElement = elem.getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""endpoint""));
        if (epElement != null) {
            // get the factory for the element
            // create the endpoint and set it in the send medaitor

            EndpointFactory fac = EndpointAbstractFactory.getEndpointFactroy(epElement);
            if (fac != null) {
                Endpoint endpoint = fac.createEndpoint(epElement, true);
                if (endpoint != null) {
                    sm.setEndpoint(endpoint);
                }
            } else {
                throw new SynapseException(""Invalid endpoint fromat."");
            }
        }

        return sm;
    }

    public QName getTagQName() {
        return SEND_Q;
    }
}
"
org/apache/synapse/config/xml/InMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

import javax.xml.namespace.QName;

/**
 * Creates an In mediator instance
 *
 * <pre>
 * &lt;in&gt;
 *    mediator+
 * &lt;/in&gt;
 * </pre>
 */
public class InMediatorFactory extends AbstractListMediatorFactory {

    private static final QName IN_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""in"");

    public Mediator createMediator(OMElement elem) {
        InMediator filter = new InMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(filter,elem);
        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return IN_Q;
    }
}
"
org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;

import java.util.HashMap;
import java.util.Map;
import java.util.Collections;

/**
 * Dispatches sessions based on HTTP cookies. Session is initiated by the server in the first response
 * when it sends ""Set-Cookie"" HTTP header with the session ID. For all successive messages client
 * should send ""Cookie"" HTTP header with session ID send by the server.
 */
public class HttpSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    Map sessionMap = Collections.synchronizedMap(new HashMap());

    /**
     * Check if ""Cookie"" HTTP header is available. If so, check if that cookie is in the session map.
     * If cookie is available, there is a session for this cookie. return the (server) endpoint for
     * that session.
     *
     * @param synCtx MessageContext possibly containing a ""Cookie"" HTTP header.
     *
     * @return Endpoint Server endpoint for the given HTTP session.
     */
    public Endpoint getEndpoint(MessageContext synCtx) {

        Endpoint endpoint = null;

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Cookie"");

            if (cookie != null) {
                Object e = sessionMap.get(cookie);
                if (e != null) {
                    endpoint = (Endpoint) e;
                }
            }
        }

        return endpoint;
    }

    /**
     * Searches for ""Set-Cookie"" HTTP header in the message context. If found and that given
     * session ID is not already in the session map update the session map by mapping the cookie
     * to the endpoint.
     *
     * @param synCtx MessageContext possibly containing the ""Set-Cookie"" HTTP header.
     * @param endpoint Endpoint to be mapped to the session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint) {

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Set-Cookie"");

            if (cookie != null) {
                // synchronized to avoid possible replacement of sessions
                synchronized(sessionMap) {
                    if (!sessionMap.containsKey(cookie)) {
                        sessionMap.put(cookie, endpoint);
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Cookie"");

            if (cookie != null) {
                sessionMap.remove(cookie);
            }
        }
    }

    /**
     * HTTP sessions are initiated by the server.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/Constants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMAbstractFactory;

import javax.xml.namespace.QName;

/**
 * Global constants for the Synapse project
 */
public interface Constants {

    /** The Synapse namespace */
    public static final String SYNAPSE_NAMESPACE = ""http://ws.apache.org/ns/synapse"";

    public static final String MAIN_SEQUENCE_KEY  = ""main"";
    public static final String FAULT_SEQUENCE_KEY = ""fault"";

    public static final OMNamespace SYNAPSE_OMNAMESPACE =
            OMAbstractFactory.getOMFactory().createOMNamespace(SYNAPSE_NAMESPACE, ""syn"");

    // -- keys related to Axis2 configuration and Synapse initialization --
    /** The key name used to store the Synapse configuration into the Axis2 config */
    String SYNAPSE_CONFIG = ""synapse.config"";

    /** The key name used to store the Synapse environment into the Axis2 config */
    String SYNAPSE_ENV = ""synapse.env"";

    /** The system property used to specify/override the synapse configuration XML location */
    String SYNAPSE_XML = ""synapse.xml"";

    /** a message context property set to hold the relates to for POX responses */
    String RELATES_TO_FOR_POX = ""RelatesToForPox"";

    /** If the message context contains a Boolean.TRUE with this key, WS-A would be turned on send */
    String OUTFLOW_ADDRESSING_ON = ""OUTFLOW_ADDRESSING_ON"";

    /** If the message context contains a Boolean.TRUE with this key, RM would be turned on send */
    String OUTFLOW_RM_ON = ""OUTFLOW_RM_ON"";

    /** The message context property name which holds the RM 'Policy' object for outgoing messages */
    String OUTFLOW_RM_POLICY = ""OUTFLOW_RM_POLICY"";

    /** If the message context contains a Boolean.TRUE with this key, Rampart would be engaged on send */
    String OUTFLOW_SECURITY_ON = ""OUTFLOW_SECURITY_ON"";

    /** The message context property name which holds the Security 'Policy' object for outgoing messages */
    String OUTFLOW_SEC_POLICY = ""OUTFLOW_SEC_POLICY"";
    

    // -- Synapse message context property keys --
    /** The scope for the synapse message context properties */
    String SCOPE_DEFAULT = ""default"";
    
    /**
     * The scope for a set-property mediator, when the property should be set
     *  on the underlying Axis2 message context
     */
    String SCOPE_AXIS2 = ""axis2"";

    /**
     * The scope for a set-property mediator, when the property should be set
     *  on the underlying transport 
     */
    String SCOPE_TRANSPORT = ""transport"";

    /** An string name which holds the out sequence property in the MessageContext */
    String PROXY_SERVICE = ""proxy.name"";

    /** A key with this name on the message context set to Boolean.TRUE, indicates that this is a response */
    String ISRESPONSE_PROPERTY = ""synapse.isresponse"";

    /** If message context property contains Boolean.TRUE then Axis2 will send this with a separate listener engaged **/
    public static final String OUTFLOW_USE_SEPARATE_LISTENER = ""OUTFLOW_USE_SEPARATE_LISTENER"";
    
    /** The message context property name which holds the error code for the last encountered exception */
    String ERROR_CODE = ""ERROR_CODE"";

    /** The message context property name which holds the error message for the last encountered exception */
    String ERROR_MESSAGE = ""ERROR_MESSAGE"";

    /** The message context property name which holds the error detail (stack trace) for the last encountered exception */
    String ERROR_DETAIL = ""ERROR_DETAIL"";

    // -- names of modules to be engaged at runtime --
    /** The Name of the WS-RM Sandesha module */
    String SANDESHA2_MODULE_NAME = ""sandesha2"";

    /** The Name of the WS-A Addressing module */
    String ADDRESSING_MODULE_NAME = ""addressing"";

    /** The Name of the WS-Security Rampart module */
    String RAMPART_MODULE_NAME = ""rampart"";

    /** Refers the To header */
    String HEADER_TO = ""To"";
    /** Refers the From header */
    String HEADER_FROM = ""From"";
    /** Refers the FaultTo header */
    String HEADER_FAULT = ""FaultTo"";
    /** Refers the Action header */
    String HEADER_ACTION = ""Action"";
    /** Refers the ReplyTo header */
    String HEADER_REPLY_TO = ""ReplyTo"";
    /** Refers the MessageID header */
    String HEADER_MESSAGE_ID = ""MessageID"";

    String RESPONSE = ""RESPONSE"";

    /** The tracing state -off */
    int TRACING_OFF =0;
    /** The tracing state-on */
    int TRACING_ON =1;
    /** The tracing state-unset */
    int TRACING_UNSET=2;
    /** Tracing logger */
    String TRACE_LOGGER =""TRACE_LOGGER"";

    //  -- Synapse property values for WS-RM sequence handling --
    /** WS-RM version 1.0*/
    String SEQUENCE_VERSION_1_0 = ""1.0"";
    /** WS-RM version 1.1*/
    String SEQUENCE_VERSION_1_1 = ""1.1"";

    /** Sandesha last message property name */
    String SANDESHA_LAST_MESSAGE = ""Sandesha2LastMessage"";
    /** Sandesha last sequence key property name */
    String SANDESHA_SEQUENCE_KEY = ""Sandesha2SequenceKey"";
    /** Sandesha WS-RM specification version property name */
    String SANDESHA_SPEC_VERSION = ""Sandesha2RMSpecVersion"";

    /** The statistics state -off */
    int STATISTICS_OFF =0;
    /** The statistics state-on */
    int STATISTICS_ON =1;
    /** The statistics state-unset */
    int STATISTICS_UNSET=2;

    String SYNAPSE_ERROR =""syapse_error"" ;

    /** key for lookup sequence statistics stack */
    String SEQUENCE_STATISTICS_STACK =""sequence_statistics_stack"";

    /** key for lookup Proxy Service statistics stack */
    String PROXYSERVICE_STATISTICS_STACK =""proxyservice_statistics_stack"";

    /** key for lookup Proxy Service statistics stack */
    String SYNAPSESERVICE_STATISTICS_STACK =""synapseservice_statistics_stack"";      

    /** key for lookup Endpoint statistics stack */
    String ENDPOINT_STATISTICS_STACK =""endpoint_statistics_stack"";

    /** Sequence statistics category*/
    int  SEQUENCE_STATISTICS = 0;

    /** Proxy Service statistics category */
    int  PROXYSERVICE_STATISTICS = 1;

    /** Endpoint statistics category*/
    int ENDPOINT_STATISTICS = 2;

    /**
     * Interval for activating the timeout handler for cleaning up expired requests. Note that
     * there can be an error as large as the value of the interval. But for smaller intervals and
     * larger timeouts this error is negligable.
     */
    long TIMEOUT_HANDLER_INTERVAL = 1000;

    /**
     * don't do anything for response timeouts. this means infinite timeout. this is the default
     * action, if the timeout configuration is not explicitly set.
     */
    int NONE = 100;

    /** Discard the callback if the timeout for the response is expired */
    int DISCARD = 101;

    /**
     * Discard the callback and activate specified fault sequence if the timeout for the response
     * is expired
     */
    int DISCARD_AND_FAULT = 102;

    /**
     * Error codes for message sending. We go with closest HTTP fault codes.
     */
    String TIME_OUT = ""504"";
    String SENDING_FAULT = ""503"";

    /** Property name to store the last endpoint through which the message has flowed */
    String PROCESSED_ENDPOINT = ""processed_endpoint"";
    /**  Anonymous Endpoint key   */
    String ANONYMOUS_ENDPOINTS = ""AnonymousEndpoints"";
    /** Anonymous Sequence  key   */
    String ANONYMOUS_SEQUENCES = ""AnonymousSequences"";
    /** Anonymous ProxyServices key   */
    String ANONYMOUS_PROXYSERVICES = ""AnonymousProxyServices"";
}
"
org/apache/synapse/config/xml/XMLConfigurationSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.core.axis2.ProxyService;

import javax.xml.stream.XMLStreamException;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

/**
 * Serialize a SynapseConfiguration into an OutputStream
 */
public class XMLConfigurationSerializer {

    private static final Log log = LogFactory.getLog(XMLConfigurationSerializer.class);

    private static final OMFactory fac = OMAbstractFactory.getOMFactory();
    private static final OMNamespace synNS = fac.createOMNamespace(Constants.SYNAPSE_NAMESPACE, ""syn"");
    private static final OMNamespace nullNS = fac.createOMNamespace(Constants.NULL_NAMESPACE, """");

    /**
     * order of entries is irrelavant, however its nice to have some order
     * @param synCfg
     * @param outputStream
     * @throws XMLStreamException
     */
    public static void serializeConfiguration(SynapseConfiguration synCfg,
        OutputStream outputStream) throws XMLStreamException {

        OMElement definitions = fac.createOMElement(""definitions"", synNS);

        // first process a remote registry if present
        if (synCfg.getRegistry() != null) {
            RegistrySerializer.serializeRegistry(definitions, synCfg.getRegistry());
        }

        // add proxy services
        Iterator iter = synCfg.getProxyServices().iterator();
        while (iter.hasNext()) {
            ProxyService service = (ProxyService) iter.next();
            ProxyServiceSerializer.serializeProxy(definitions, service);
        }

        Map entries   = new HashMap();
        Map endpoints = new HashMap();
        Map sequences = new HashMap();

        iter = synCfg.getLocalRegistry().keySet().iterator();
        while (iter.hasNext()) {
            Object key = iter.next();
            Object o = synCfg.getLocalRegistry().get(key);
            if (o instanceof Mediator) {
                sequences.put(key, o);
            } else if (o instanceof Endpoint) {
                endpoints.put(key, o);
            } else if (o instanceof Entry) {
                entries.put(key, o);
            } else {
                handleException(""Unknown object : "" + o.getClass()
                    + "" for serialization into Synapse configuration"");
            }
        }

        // process entries
        serializeEntries(definitions, entries);

        // process endpoints
        serializeEndpoints(definitions, endpoints);

        // process sequences
        serializeSequences(definitions, sequences);

        definitions.serialize(outputStream);
    }

    private static void serializeEntries(OMElement definitions, Map entries) {
        Iterator iter = entries.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            EntrySerializer.serializeEntry((Entry) entries.get(key), definitions);
        }
    }

    private static void serializeEndpoints(OMElement definitions, Map endpoints) {
        Iterator iter = endpoints.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();            
            Object o = endpoints.get(key);
            if (o instanceof Endpoint) {
                Endpoint endpoint = (Endpoint) o;
                OMElement epElement = EndpointAbstractSerializer.
                        getEndpointSerializer(endpoint).serializeEndpoint(endpoint);
                definitions.addChild(epElement);
            }

        }
    }

    private static void serializeSequences(OMElement definitions, Map sequences) {
        Iterator iter = sequences.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            Mediator mediator = (Mediator) sequences.get(key);
            MediatorSerializerFinder.getInstance().getSerializer(mediator)
                .serializeMediator(definitions, mediator);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.axiom.om.OMElement;

/**
 * All endpoint factories should implement this interface. Use EndpointAbstractFactory to obtain the
 * correct endpoint fatory for particular endpoint configuration. As endpoints can be nested inside
 * each other, EndpointFactory implementations may call other EndpointFactory implementations recursively
 * to obtain the required endpoint hierachy.
 *
 * This also serves as the XMLToObjactMapper implementation for specific endpoint implementations.
 * If the endpoint type is not known use XMLToEndpointMapper as the generic XMLToObjectMapper for
 * all endpoints.
 */
public interface EndpointFactory extends XMLToObjectMapper {

    /**
     * Creates the Endpoint implementation for the given XML endpoint configuration. If the endpoint
     * configuration is an inline one, it should be anonymous endpoint. If it is defined as an immediate
     * child element of the <definitions> it should have a name, which is used as the key in local registry.
     *
     * @param epConfig OMElement conatining the endpoint configuration.
     * @param anonymousEndpoint false if the endpoint has a name. true otherwise.
     * @return Endpoint implementation for the given configuration.
     */
    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint);
}
"
org/apache/synapse/config/xml/SendMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

/**
 *
 * //TODO document endpoints, failover and loadbalacing
 *
 * The &lt;send&gt; element is used to send messages out of Synapse to some endpoint. In the simplest case,
 * the place to send the message to is implicit in the message (via a property of the message itself)-
 * that is indicated by the following
 * <pre>
 *  &lt;send/&gt;
 * </pre>
 *
 * If the message is to be sent to one or more endpoints, then the following is used:
 * <pre>
 *  &lt;send&gt;
 *   (endpointref | endpoint)+
 *  &lt;/send&gt;
 * </pre>
 * where the endpointref token refers to the following:
 * <pre>
 * &lt;endpoint ref=""name""/&gt;
 * </pre>
 * and the endpoint token refers to an anonymous endpoint defined inline:
 * <pre>
 *  &lt;endpoint address=""url""/&gt;
 * </pre>
 * If the message is to be sent to an endpoint selected by load balancing across a set of endpoints,
 * then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;load-balance algorithm=""uri""&gt;
 *     (endpointref | endpoint)+
 *   &lt;/load-balance&gt;
 * &lt;/send&gt;
 * </pre>
 * Similarly, if the message is to be sent to an endpoint with failover semantics, then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;failover&gt;
 *     (endpointref | endpoint)+
 *   &lt;/failover&gt;
 * &lt;/send&gt;
 * </pre>
 */
public class SendMediatorSerializer extends AbstractMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(SendMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SendMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SendMediator mediator = (SendMediator) m;
        OMElement send = fac.createOMElement(""send"", synNS);
        finalizeSerialization(send, mediator);

        Endpoint activeEndpoint = mediator.getEndpoint();
        if (activeEndpoint != null) {
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(activeEndpoint);

            OMElement endpointElement = serializer.serializeEndpoint(activeEndpoint);
            send.addChild(endpointElement);
        }

        if (parent != null) {
            parent.addChild(send);
        }
        return send;
    }

    public String getMediatorClassName() {
        return SendMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/SynapseConfiguration.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.Constants;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.config.xml.MediatorFactoryFinder;
import org.apache.synapse.config.xml.endpoints.XMLToEndpointMapper;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.registry.Registry;
import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import java.util.*;
import java.net.URLConnection;
import java.io.IOException;

/**
 * The SynapseConfiguration holds the global configuration for a Synapse
 * instance.
 */
public class SynapseConfiguration {

    private static final Log log = LogFactory.getLog(SynapseConfiguration.class);

    /** The remote registry made available to the Synapse configuration. Only one is supported */
    Registry registry = null;

    /** Holds Proxy services defined through Synapse */
    private Map proxyServices = new HashMap();

    /**
     * The local registry is a simple HashMap and provides the ability to override definitions
     * of a remote registry for entries defined locally with the same key
     */
    private Map localRegistry = new HashMap();

    /** Hold reference to the Axis2 ConfigurationContext */
    private AxisConfiguration axisConfiguration = null;

    /** Save the path to the configuration file loaded, to save it later if required */
    private String pathToConfigFile = null;

    /**
     * Add a named sequence into the local registry
     * @param key the name for the sequence
     * @param mediator a Sequence mediator
     */
    public void addSequence(String key, Mediator mediator) {
        localRegistry.put(key, mediator);
    }

    /**
     * Allow a dynamic sequence to be cached and made available through the local registry
     * @param key the key to lookup the sequence from the remote registry
     * @param entry the Entry object which holds meta information and the cached resource
     */
    public void addSequence(String key, Entry entry) {
        localRegistry.put(key, entry);
    }

    /**
     * Returns the map of defined sequences in the configuraiton excluding the fetched sequences
     * from remote registry
     * @return Map of SequenceMediators defined in the local configuraion
     */
    public Map getDefinedSequences() {
        Map definedSequences = new HashMap();
        Iterator itr = localRegistry.values().iterator();
        while(itr.hasNext()) {
            Object o = itr.next();
            if(o instanceof SequenceMediator) {
                definedSequences.put(((SequenceMediator) o).getName(), o);
            }
        }
        return definedSequences;
    }

    /**
     * Return the sequence specified with the given key
     * @param key the key being referenced
     * @return the sequence referenced by the key
     */
    public Mediator getSequence(String key) {
        Object o = localRegistry.get(key);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        }

        Entry entry = null;
        if (o != null && o instanceof Entry) {
            entry = (Entry) o;
        } else {
            entry = new Entry(key);
            entry.setType(Entry.REMOTE_ENTRY);
            entry.setMapper(MediatorFactoryFinder.getInstance());
        }

        if (registry != null) {
            o = registry.getResource(entry);
            if (o != null && o instanceof Mediator) {
                localRegistry.put(key, entry);
                return (Mediator) o;
            }
        }

        return null;
    }

    /**
     * Removes a sequence from the local registry
     * @param key of the sequence to be removed
     */
    public void removeSequence(String key) {
        localRegistry.remove(key);
    }

    /**
     * Return the main/default sequence to be executed. This is the sequence which
     * will execute for all messages when message mediation takes place
     * @return the main mediator sequence
     */
    public Mediator getMainSequence() {
        return getSequence(Constants.MAIN_SEQUENCE_KEY);
    }

    /**
     * Return the fault sequence to be executed when Synapse encounters a fault scenario
     * during processing
     * @return the fault sequence
     */
    public Mediator getFaultSequence() {
        return getSequence(Constants.FAULT_SEQUENCE_KEY);
    }

    /**
     * Define a resource to the local registry. All static resources (e.g. URL source)
     * are loaded during this definition phase, and the inability to load such a resource
     * will not allow the definition of the resource to the local registry
     *
     * @param key the key associated with the resource
     * @param entry the Entry that holds meta information about the resource and its
     * contents (or cached contents if the Entry refers to a dynamic resource off a
     * remote registry)
     */
    public void addEntry(String key, Entry entry) {

        if (entry.getType() == Entry.URL_SRC) {
            try {
                entry.setValue(Util.getOMElementFromURL(entry.getSrc().toString()));
                localRegistry.put(key, entry);
            } catch (IOException e) {
                handleException(""Can not read from source URL : "" + entry.getSrc());
            }
        } else {
            localRegistry.put(key, entry);
        }
    }

    /**
     * Returns the map of defined entries in the configuraiton excluding the fetched entries
     * from remote registry
     * @return Map of Entries defined in the local configuraion
     */
    public Map getDefinedEntries() {
        Map definedEntries = new HashMap();
        Iterator itr = localRegistry.values().iterator();
        while(itr.hasNext()) {
            Object o = itr.next();
            if(o instanceof Entry && ((Entry) o).getType() != Entry.REMOTE_ENTRY) {
                definedEntries.put(((Entry) o).getKey(), o);
            }
        }
        return definedEntries;
    }

    /**
    * Get the resource with the given key
    * @param key the key of the resource required
    * @return its value
    */
    public Object getEntry(String key) {
        Object o = localRegistry.get(key);
        if (o != null && o instanceof Entry) {
            Entry entry = (Entry) o;
            if (entry.isDynamic()) {
                if (entry.isCached() && !entry.isExpired()) {
                    return entry.getValue();
                } else if (registry != null) {
                    o = registry.getResource(entry);
                }
            } else {
                return entry.getValue();
            }
        }
        return o;
    }

    /**
     * Get the Entry object mapped to the given key
     * @param key the key for which the Entry is required
     * @return its value
     */
    public Entry getEntryDefinition(String key) {
        Object o = localRegistry.get(key);
        if (o == null || o instanceof Entry) {
            if (o == null) {
                // this is not a local definition
                Entry entry = new Entry(key);
                entry.setType(Entry.REMOTE_ENTRY);
                addEntry(key, entry);
                return entry;
            }
            return (Entry) o;
        } else {
            handleException(""Invalid local registry entry : "" + key);
            return null;
        }
    }

    /**
     * Deletes any reference mapped to the given key from the local registry
     * @param key the key of the reference to be removed
     */
    public void removeEntry(String key) {
        localRegistry.remove(key);
    }

    /**
     * Define a named endpoint with the given key
     * @param key the key for the endpoint
     * @param endpoint the endpoint definition
     */
    public void addEndpoint(String key, Endpoint endpoint) {
        localRegistry.put(key, endpoint);
    }

    /**
     * Add a dynamic endpoint definition to the local registry
     * @param key the key for the endpoint definition
     * @param entry the actual endpoint definition to be added
     */
    public void addEndpoint(String key, Entry entry) {
        localRegistry.put(key, entry);
    }

    /**
     * Returns the map of defined endpoints in the configuraiton excluding the fetched endpoints
     * from remote registry
     * @return Map of Endpoints defined in the local configuraion
     */
    public Map getDefinedEndpoints() {
        Map definedEndpoints = new HashMap();
        Iterator itr = localRegistry.values().iterator();
        while(itr.hasNext()) {
            Object o = itr.next();
            if(o instanceof Endpoint) {
                definedEndpoints.put(((Endpoint) o).getName(), o);
            }
        }
        return definedEndpoints;
    }

    /**
     * Get the definition of the endpoint with the given key
     * @param key the key of the endpoint
     * @return the endpoint definition
     */
    public Endpoint getEndpoint(String key) {
        Object o = localRegistry.get(key);
        if (o != null && o instanceof Endpoint) {
            return (Endpoint) o;
        }

        Entry entry = null;
        if (o != null && o instanceof Entry) {
            entry = (Entry) o;
        } else {
            entry = new Entry(key);
            entry.setType(Entry.REMOTE_ENTRY);
            entry.setMapper(XMLToEndpointMapper.getInstance());
        }

        if (registry != null) {
            o = registry.getResource(entry);
            if (o != null && o instanceof Endpoint) {
                localRegistry.put(key, entry);
                return (Endpoint) o;
            }
        }

        return null;
    }

    /**
     * Deletes the endpoint with the given key
     * @param key of the endpoint to be deleted
     */
    public void removeEndpoint(String key) {
        localRegistry.remove(key);
    }

    /**
     * Add a Proxy service to the configuration
     * @param name the name of the Proxy service
     * @param proxy the Proxy service instance
     */
    public void addProxyService(String name, ProxyService proxy) {
        proxyServices.put(name, proxy);
    }

    /**
     * Get the Proxy service with the given name
     * @param name the name being looked up
     * @return the Proxy service
     */
    public ProxyService getProxyService(String name) {
        return (ProxyService) proxyServices.get(name);
    }

    /**
     * Deletes the Proxy Service named with the given name
     * @param name of the Proxy Service to be deleted
     */
    public void removeProxyService(String name) {
        Object o = proxyServices.get(name);
        if (o == null) {
            handleException(""Unknown proxy service for name : "" + name);
        } else {
            try {
                if(getAxisConfiguration().getServiceForActivation(name) != null) {
                    if (getAxisConfiguration().getServiceForActivation(name).isActive()) {
                        getAxisConfiguration().getService(name).setActive(false);
                    }
                    getAxisConfiguration().removeService(name);
                }
                proxyServices.remove(name);
            } catch (AxisFault axisFault) {
                handleException(axisFault.getMessage());
            }
        }
    }

    /**
     * Return the list of defined proxy services
     * @return the proxy services defined
     */
    public Collection getProxyServices() {
        return proxyServices.values();
    }

    /**
     * Return an unmodifiable copy of the local registry
     * @return an unmodifiable copy of the local registry
     */
    public Map getLocalRegistry() {
        return Collections.unmodifiableMap(localRegistry);
    }

    /**
     * Get the remote registry defined (if any)
     * @return the currently defined remote registry
     */
    public Registry getRegistry() {
        return registry;
    }

    /**
     * Set the remote registry for the configuration
     * @param registry the remote registry for the configuration
     */
    public void setRegistry(Registry registry) {
        this.registry = registry;
    }

    /**
     * Set the Axis2 AxisConfiguration to the SynapseConfiguration
     * @param axisConfig
     */
    public void setAxisConfiguration(AxisConfiguration axisConfig) {
        this.axisConfiguration = axisConfig;
    }

    /**
     * Get the Axis2 AxisConfiguration for the SynapseConfiguration
     * @return AxisConfiguration of the Axis2
     */
    public AxisConfiguration getAxisConfiguration() {
        return axisConfiguration;
    }

    /**
     * The path to the currently loaded configuration file
     * @return file path to synapse.xml
     */
    public String getPathToConfigFile() {
        return pathToConfigFile;
    }

    /**
     * Set the path to the loaded synapse.xml
     * @param pathToConfigFile path to the synapse.xml loaded
     */
    public void setPathToConfigFile(String pathToConfigFile) {
        this.pathToConfigFile = pathToConfigFile;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/transform/HeaderMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.axis2.addressing.EndpointReference;

import javax.xml.namespace.QName;
import java.util.List;
import java.util.Iterator;

/**
 * The header mediator is able to set a given value as a SOAP header, or remove a given
 * header from the current message instance. This supports the headers currently
 * supported by the HeaderType class. If an expression is supplied, its runtime value
 * is evaluated using the current message. Unless the action is set to remove, the
 * default behaviour of this mediator is to set a header value.
 */
public class HeaderMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(HeaderMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;

    /** The qName of the header @see HeaderType */
    private QName qName = null;
    /** The literal value to be set as the header (if one was specified) */
    private String value = null;
    /** Set the header (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;
    /** An expression which should be evaluated, and the result set as the header value */
    private AXIOMXPath expression = null;

    /**
     * Sets/Removes a SOAP header on the current message
     *
     * @param synCtx the current message which is altered as necessary
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Header mediator <"" + (action == ACTION_SET ? ""Set"" : ""Remove"") + ""> :: mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if(shouldTrace) {
            trace.trace(""Start : Header mediator, action = "" +
                (action == ACTION_SET ? ""set"" : ""remove""));
        }
        if (action == ACTION_SET) {
            String value = (getValue() != null ? getValue() :
                Axis2MessageContext.getStringValue(getExpression(), synCtx));

            log.debug(""Setting header : "" + qName + "" to : "" + value);
            if(shouldTrace) {
                trace.trace(""Set Header : "" + qName + "" to : "" + value);
            }
            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {
                if (Constants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(new EndpointReference(value));
                } else if (Constants.HEADER_FROM.equals(qName.getLocalPart())){
                    synCtx.setFrom(new EndpointReference(value));
                } else if (Constants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(value);
                } else if (Constants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(new EndpointReference(value));
                } else if (Constants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(new EndpointReference(value));
                } else {
                    addCustomHeader(synCtx);
                }
            } else {
                addCustomHeader(synCtx);                
            }

        } else {
            log.debug(""Removing header : "" + qName + "" from current message"");

            if (shouldTrace) {
                trace.trace(""Remove Header : "" + qName);
            }

            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {
                if (Constants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(null);
                } else if (Constants.HEADER_FROM.equals(qName.getLocalPart())){
                    synCtx.setFrom(null);
                } else if (Constants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(null);
                } else if (Constants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(null);
                } else if (Constants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(null);
                } else {
                    removeFromHeaderList(synCtx.getEnvelope().getHeader().getHeaderBlocksWithNSURI(""""));
                }                
            } else {
                removeFromHeaderList(synCtx.getEnvelope().getHeader().
                    getHeaderBlocksWithNSURI(qName.getNamespaceURI()));
            }
        }
        if (shouldTrace) {
            trace.trace(""End : Header mediator"");
        }
        return true;
    }

    private void addCustomHeader(MessageContext synCtx) {
        SOAPEnvelope env = synCtx.getEnvelope();
            SOAPFactory fac = (SOAPFactory) env.getOMFactory();
            SOAPHeader header = env.getHeader();
            if (header == null) {
                header = fac.createSOAPHeader(env);
            }
            SOAPHeaderBlock hb = header.addHeaderBlock(qName.getLocalPart(),
                fac.createOMNamespace(qName.getNamespaceURI(), qName.getPrefix()));
            hb.setText(value);
    }

    private void removeFromHeaderList(List headersList) {
        if (headersList == null || headersList.isEmpty()) {
            return;
        }
        
        Iterator iter = headersList.iterator();
        while (iter.hasNext()) {
            Object o = iter.next();
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                if (header.getLocalName().equals(qName.getLocalPart())) {
                    header.detach();
                }
            } else if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                if (omElem.getLocalName().equals(qName.getLocalPart())) {
                    omElem.detach();
                }
            }
        }
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }

    public QName getQName() {
        return qName;
    }

    public void setQName(QName qName) {
        this.qName = qName;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/SequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

import javax.xml.namespace.QName;

/**
 * Builds an instance of a Sequence mediator through the Synapse configuration. It follows the following
 *
 * <pre>
 * &lt;sequence name=""string"" [onError=""string""]&gt;
 *   mediator+
 * &lt;/sequence&gt;
 * </pre>
 *
 * OR
 *
 * <pre>
 * &lt;sequence key=""name""/&gt;
 * </pre>
 */
public class SequenceMediatorFactory extends AbstractListMediatorFactory {

    private static final Log log = LogFactory.getLog(SequenceMediatorFactory.class);

    private static final QName SEQUENCE_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""sequence"");

    public QName getTagQName() {
        return SEQUENCE_Q;
    }

    public SequenceMediator createAnonymousSequence(OMElement elem) {
        SequenceMediator seqMediator = new SequenceMediator();
        OMAttribute e = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""onError""));
        if (e != null) {
            seqMediator.setErrorHandler(e.getAttributeValue());
        }
        initMediator(seqMediator, elem);
        addChildren(elem, seqMediator);
        OMAttribute statistics = elem.getAttribute(
                new QName(Constants.NULL_NAMESPACE, Constants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (Constants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_ON);
                } else if (Constants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_OFF);
                }
            }
        }
        return seqMediator;
    }
    
    public Mediator createMediator(OMElement elem) {

        SequenceMediator seqMediator = new SequenceMediator();

        OMAttribute n = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
        OMAttribute e = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""onError""));
        if (n != null) {
            seqMediator.setName(n.getAttributeValue());
            if (e != null) {
                seqMediator.setErrorHandler(e.getAttributeValue());
            }
            initMediator(seqMediator, elem);
            addChildren(elem, seqMediator);

        } else {
            n = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""key""));
            if (n != null) {
                seqMediator.setKey(n.getAttributeValue());
                if (e != null) {
                    String msg = ""A sequence mediator swhich a reference to another sequence can not have 'ErrorHandler'"";
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            } else {
                String msg = ""A sequence mediator should be a named sequence or a reference to another sequence "" +
                    ""(i.e. a name attribute or key attribute is required."";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMAttribute statistics = elem.getAttribute(
                new QName(Constants.NULL_NAMESPACE, Constants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (Constants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_ON);
                } else if (Constants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_OFF);
                }
            }
        }

        return seqMediator;
    }
}
"
org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

/**
 * All load balance algorithms must implement this interface. Implementations of this interface can
 * be registered in LoadbalanceManagers.
 */
public interface LoadbalanceAlgorithm {

    /**
     * This method returns the next node according to the algorithm implementation.
     *
     * @param synapseMessageContext SynapseMessageContext of the current message
     * @return Next node for directing the message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext);

    /**
     * Resets the algorithm to its initial position. Initial position depends on the implementation.
     */
    public void reset();
}
"
org/apache/synapse/config/xml/SwitchMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.SwitchMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Constructs a Switch mediator instance from the given XML configuration
 * <p/>
 * <pre>
 * &lt;switch source=""xpath""&gt;
 *   &lt;case regex=""string""&gt;
 *     mediator+
 *   &lt;/case&gt;+
 *   &lt;default&gt;
 *     mediator+
 *   &lt;/default&gt;?
 * &lt;/switch&gt;
 * </pre>
 */
public class SwitchMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(SwitchMediatorFactory.class);

    private static final QName SWITCH_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""switch"");
    private static final QName CASE_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""case"");
    private static final QName DEFAULT_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""default"");

    public Mediator createMediator(OMElement elem) {

        SwitchMediator switchMediator = new SwitchMediator();
        OMAttribute source = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""source""));
        if (source == null) {
            String msg = ""A 'source' XPath attribute is required for a switch mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            try {
                AXIOMXPath sourceXPath = new AXIOMXPath(source.getAttributeValue());
                org.apache.synapse.config.xml.OMElementUtils.addNameSpaces(sourceXPath, elem, log);
                switchMediator.setSource(sourceXPath);

            } catch (JaxenException e) {
                String msg = ""Invalid XPath for attribute 'source' : "" + source.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(switchMediator, elem);
        Iterator iter = elem.getChildrenWithName(CASE_Q);
        while (iter.hasNext()) {
            OMElement caseElem = (OMElement) iter.next();
            SwitchCase aCase = new SwitchCase();
            OMAttribute regex = caseElem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""regex""));
            if (regex == null) {
                String msg = ""The 'regex' attribute is required for a switch case definition"";
                log.error(msg);
                throw new SynapseException(msg);
            }
            try {
                aCase.setRegex(Pattern.compile(regex.getAttributeValue()));
            } catch (PatternSyntaxException pse) {
                String msg = ""Invalid Regular Expression for attribute 'regex' : "" + regex.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator(caseElem));
            switchMediator.addCase(aCase);
        }
        iter = elem.getChildrenWithName(DEFAULT_Q);
        while (iter.hasNext()) {
            SwitchCase aCase = new SwitchCase();
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator((OMElement) iter.next()));
            switchMediator.setDefaultCase(aCase);
            break; // add only the *first* default if multiple are specified, ignore rest if any
        }
        return switchMediator;
    }

    public QName getTagQName() {
        return SWITCH_Q;
    }
}
"
org/apache/synapse/config/xml/AbstractListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;

import java.util.Iterator;
import java.util.List;

public abstract class AbstractListMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(AbstractListMediatorSerializer.class);

    protected static void serializeChildren(OMElement parent, List list)
    {
        Iterator iter = list.iterator();
        while (iter.hasNext()) {
            Mediator child = (Mediator) iter.next();
            MediatorSerializer medSer = MediatorSerializerFinder.getInstance().getSerializer(child);
            if (medSer != null) {
                medSer.serializeMediator(parent, child);
            } else {
                handleException(""Unable to find a serializer for mediator : "" + child.getType());
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/core/axis2/SynapseDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.HandlerDescription;
import org.apache.axis2.engine.AbstractDispatcher;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * This is the Axis2 Dispatcher which is registered with the Axis2 engine. It dispatches
 * each and every message received to the SynapseMessageReceiver for processing.
 */
public class SynapseDispatcher extends AbstractDispatcher {

    private static final Log log = LogFactory.getLog(SynapseDispatcher.class);

    private static final long serialVersionUID = -6970206989111592645L;

    private static final String SYNAPSE_SERVICE_NAME = ""synapse"";

    private static final QName MEDIATE_OPERATION_NAME = new QName(""mediate"");

    public void initDispatcher() {
        QName qn = new QName(""http://synapse.apache.org"", ""SynapseDispatcher"");
        HandlerDescription hd = new HandlerDescription(qn.getLocalPart());
        super.init(hd);
    }

    public AxisService findService(MessageContext mc) throws AxisFault {
        AxisConfiguration ac = mc.getConfigurationContext().getAxisConfiguration();
        AxisService as = ac.getService(SYNAPSE_SERVICE_NAME);
        return as;
    }

    public AxisOperation findOperation(AxisService svc, MessageContext mc) throws AxisFault {
        AxisOperation ao = svc.getOperation(MEDIATE_OPERATION_NAME);
        return ao;
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;

import javax.xml.namespace.QName;

public abstract class AbstractMediatorFactory implements MediatorFactory {

    /**
     * This is to Initialize the mediator with the default attributes
     *
     * @param mediator
     * @param mediatorOmElement
     */
    protected void initMediator(Mediator mediator, OMElement mediatorOmElement) {

        OMAttribute trace = mediatorOmElement.getAttribute(
            new QName(Constants.NULL_NAMESPACE, Constants.TRACE_ATTRIB_NAME));

        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(Constants.TRACE_ENABLE)) {
                    mediator.setTraceState(org.apache.synapse.Constants.TRACING_ON);
                } else if (traceValue.equals(Constants.TRACE_DISABLE)) {
                    mediator.setTraceState(org.apache.synapse.Constants.TRACING_OFF);
                }
            }
        }
    }
}
"
org/apache/synapse/config/xml/endpoints/XMLToEndpointMapper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;

/**
 * This is a generic XMLToObjectMapper implementation for all endpoint types. Use this if the endpoint
 * type is not known at the time mapper is created. If the endpoint type is known use the EndpointFactory
 * implementation for that specific endpoint.
 */
public class XMLToEndpointMapper implements XMLToObjectMapper {

    private static XMLToEndpointMapper instance = new XMLToEndpointMapper();

    private XMLToEndpointMapper() {}

    public static XMLToEndpointMapper getInstance() {
        return instance;
    }

    /**
     * Constructs the Endpoint implementation for the given OMNode.
     *
     * @param om OMNode containig endpoint configuration. This should be an OMElement.
     * @return Endpoint implementaiotn for the given OMNode.
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            OMElement epElement = (OMElement) om;
            return EndpointAbstractFactory.
                    getEndpointFactroy(epElement).createEndpoint(epElement, false);
        } else {
            throw new SynapseException(""Configuration is not in proper format."");
        }
    }
}
"
org/apache/synapse/endpoints/dispatch/Dispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;

/**
 * Defines the behavior of session dispatchers. There can be two dispatcher types. Server intiated
 * session dispatchers and client initialted session dispatchers. In the former one, server generates
 * the session ID and sends it to the client in the first RESPONSE. In the later case, client should
 * generate the session ID and send it to the server in the first REQUEST. A dispatcher object will
 * be created for each session affinity load balance endpoint.
 */
public interface Dispatcher {

    /**
     * Dispatcher should check the session id pattern in the synapseMessageContext and return the
     * matching endpoint for that session id, if availabale. If the session id in the given
     * synapseMessageContext is not found it should return null.
     *
     * @param synCtx client -> esb message context.
     * @return Endpoint Endpoint associated with this session.
     */
    public Endpoint getEndpoint(MessageContext synCtx);
    
    /**
     * Updates the session maps. This will be called in the first client -> synapse -> server flow
     * for client initiated sessions. For server initiated sessions, this will be called in the first
     * server -> synapse -> client flow.
     *
     * @param synCtx SynapseMessageContext
     * @param endpoint Selected endpoint for this session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint);

    /**
     * Removes the session belonging to the given message context.
     *
     * @param synCtx MessageContext containing an session ID.         
     */
    public void unbind(MessageContext synCtx);

    /**
     * Determine whether the session supported by the implementing dispatcher is intiated by the
     * server (e.g. soap session) or by the client. This can be used for optimizing session updates.
     *
     * @return true, if the session is initiated by the server. false, otherwise.
     */
    public boolean isServerInitiatedSession();
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;

import java.util.ArrayList;
import java.util.List;

/**
 * Serializes FailoverEndpoint to XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <failover>
 *       <endpoint>+
 *    </failover>
 * </endpoint>
 */
public class FailoverEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof FailoverEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        FailoverEndpoint failoverEndpoint = (FailoverEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        OMElement failoverElement = fac.createOMElement(""failover"", Constants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(failoverElement);

        String name = failoverEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        List endpoints = failoverEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            failoverElement.addChild(aeElement);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/mediators/builtin/SendMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.axis2.context.OperationContext;

import java.util.List;

/**
 * SendMediator sends a message using specified semantics. If it contains an endpoint it will send the
 * message to that endpoint. Once a message is sent to the endpoint further sending behaviors are completely
 * governed by that endpoint. If there is no endpoint available, SendMediator will send the message to
 * the implicitly stated destination.
 * */
public class SendMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(SendMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    private Endpoint endpoint = null;

    /**
     * This is a leaf mediator. i.e. processing stops once send is invoked,
     * as it always returns false
     *
     * @param synCtx the current message to be sent
     * @return false always as this is a leaf mediator
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Send mediator :: mediate()"");

        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        try {
            if (shouldTrace) {
                trace.trace(""Start : Send mediator"");
                trace.trace(""Sending Message :: "" + synCtx.getEnvelope());
            }
            // if no endpoints are defined, send where implicitly stated
            if (endpoint == null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Sending message using implicit message properties.."");
                    log.debug(""Sending To: "" + (synCtx.getTo() != null ?
                            synCtx.getTo().getAddress() : ""null""));
                    log.debug(""SOAPAction: "" + (synCtx.getWSAAction() != null ?
                            synCtx.getWSAAction() : ""null""));
                    log.debug(""Body : \n"" + synCtx.getEnvelope());
                }

                if (synCtx.isResponse()) {
                    Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synCtx;
                    OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
                    Object o = opCtx.getProperty(""endpointList"");
                    if (o != null) {
                        // we are in the response of the first message of a server initiated session.
                        // so update all session maps.
                        List endpointList = (List) o;
                        Object e = endpointList.remove(0);
                        if (e != null && e instanceof SALoadbalanceEndpoint) {
                            SALoadbalanceEndpoint saLoadbalanceEndpoint = (SALoadbalanceEndpoint) e;
                            saLoadbalanceEndpoint.updateSession(synCtx, endpointList);
                        }
                    }
                }
                synCtx.getEnvironment().send(null, synCtx);

            } else {
                endpoint.send(synCtx);
            }

        } finally {
            if (shouldTrace) {
                trace.trace(""End : Send mediator"");
            }
        }
        return true;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.PropertyMediator;
import org.jaxen.JaxenException;

/**
 * Creates a property mediator through the supplied XML configuration
 * <p/>
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"")/&gt;
 * </pre>
 */
public class PropertyMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(LogMediatorFactory.class);

    private static final QName PROP_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""property"");

    public Mediator createMediator(OMElement elem) {

        PropertyMediator propMediator = new PropertyMediator();
        OMAttribute name = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
        OMAttribute value = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""value""));
        OMAttribute expression = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""expression""));
        OMAttribute scope = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""scope""));
        OMAttribute action = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""action""));
        if (name == null) {
            String msg = ""The 'name' attribute is required for the configuration of a property mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else if ((value == null && expression == null) && !(action != null && ""remove"".equals(action.getAttributeValue()))) {
            String msg = ""Either an 'value' or 'expression' attribute is required for a property mediator when action is SET"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        propMediator.setName(name.getAttributeValue());
        if (value != null) {
            propMediator.setValue(value.getAttributeValue());
        } else if (expression != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                propMediator.setExpression(xp);

            } catch (JaxenException e) {
                String msg = ""Invalid XPath expression for attribute 'expression' : "" + expression.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        if (scope != null) {
            String valueStr = scope.getAttributeValue();
            if (!Constants.SCOPE_AXIS2.equals(valueStr) && !Constants.SCOPE_TRANSPORT.equals(valueStr)
                    && !Constants.SCOPE_DEFAULT.equals(valueStr)) {
                String msg = ""Only '"" + Constants.SCOPE_AXIS2 + ""' or '"" + Constants.SCOPE_TRANSPORT
                        + ""' values are allowed for attribute scope for a property mediator""
                        + "", Unsupported scope "" + valueStr;
                log.error(msg);
                throw new SynapseException(msg);
            }
            propMediator.setScope(valueStr);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(propMediator, elem);
        // The action attribute is optional, if provided and equals to 'remove' the
        // property mediator will act as a property remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            propMediator.setAction(PropertyMediator.ACTION_REMOVE);
        }
        return propMediator;
    }

    public QName getTagQName() {
        return PROP_Q;
    }
}
"
org/apache/synapse/core/axis2/SynapseMessageReceiver.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.MessageReceiver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This message receiver should be configured in the Axis2 configuration as the
 * default message receiver, which will handle all incoming messages through the
 * synapse mediation
 */
public class SynapseMessageReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseMessageReceiver.class);

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        if (log.isDebugEnabled()) {
            log.debug(""Synapse received a new message for message mediation..."");
            log.debug(""Received To: "" + (mc.getTo() != null ? mc.getTo().getAddress() : ""null""));
            log.debug(""SOAPAction: "" + (mc.getSoapAction() != null ? mc.getSoapAction() : ""null""));
            log.debug(""WSA-Action: "" + (mc.getWSAAction() != null ? mc.getWSAAction() : ""null""));
            String[] cids = mc.getAttachmentMap().getAllContentIDs();
            if (cids != null && cids.length > 0) {
                for (int i=0; i<cids.length; i++) {
                    log.debug(""Attachment : "" + cids[i]);
                }
            }
            log.debug(""Body : \n"" + mc.getEnvelope());
        }

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);
        try {
            StatisticsStack synapseServiceStack =
                    (StatisticsStack) synCtx.getProperty(
                            org.apache.synapse.Constants.SYNAPSESERVICE_STATISTICS_STACK);
            if (synapseServiceStack == null) {
                synapseServiceStack = new ProxyServiceStatisticsStack();
                synCtx.setProperty(org.apache.synapse.Constants.SYNAPSESERVICE_STATISTICS_STACK,
                        synapseServiceStack);
            }
            String name = ""SynapseService"";
            boolean isFault = synCtx.getEnvelope().getBody().hasFault();
            synapseServiceStack.put(name, System.currentTimeMillis(), !synCtx.isResponse(),
                    true, isFault);

            // invoke synapse message mediation
            synCtx.getEnvironment().injectMessage(synCtx);
        } catch (SynapseException syne) {
            if (!synCtx.getFaultStack().isEmpty()) {
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);
            } else {
                log.error(""Synapse encountered an exception, "" +
                        ""No error handlers found - [Message Dropped]\n"" + syne.getMessage());
            }
        }
    }
}
"
org/apache/synapse/core/axis2/Axis2Sender.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.util.Utils;
import org.apache.axis2.transport.nhttp.NhttpConstants;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.AxisEngine;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.rampart.handler.WSSHandlerConstants;

/**
 * This class helps the Axis2SynapseEnvironment implement the send method
 */
public class Axis2Sender {

    private static final Log log = LogFactory.getLog(Axis2Sender.class);

    public static void sendOn(
            EndpointDefinition endpoint,
            org.apache.synapse.MessageContext synapseInMessageContext) {

        try {
                Axis2FlexibleMEPClient.send(
                    // The endpoint where we are sending to
                    endpoint,

                    // The Axis2 Message context of the Synapse MC
                    synapseInMessageContext);

        } catch (Exception e) {
            handleException(""Unexpected error during Sending message onwards"", e);
        }
    }

    public static void sendBack(org.apache.synapse.MessageContext smc) {

        MessageContext messageContext = ((Axis2MessageContext) smc).getAxis2MessageContext();

        // if this is a dummy 202 Accepted message meant only for the http/s transports
        // prevent it from going into any other transport sender
        if (Utils.isExplicitlyTrue(messageContext, NhttpConstants.SC_ACCEPTED) &&
            messageContext.getTransportOut() != null &&
            !messageContext.getTransportOut().getName().startsWith(""http"")) {
                return;
        }

        AxisEngine ae = new AxisEngine(messageContext.getConfigurationContext());

        try {
            messageContext.setProperty(Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            // check if addressing is already engaged for this message.
            // if engaged we should use the addressing enabled Configuraion context.
            if (smc.isResponse()) {
                //Process statistics
                StatisticsUtils.processEndPointStatistics(smc);
                StatisticsUtils.processProxyServiceStatistics(smc);
                StatisticsUtils.processAllSequenceStatistics(smc);
            }
            Axis2FlexibleMEPClient.removeAddressingHeaders(messageContext);
            messageContext.setMessageID(UUIDGenerator.getUUID());

            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (messageContext.isEngaged(WSSHandlerConstants.SECURITY_MODULE_NAME) &&
                messageContext.getEnvelope().getHeader() == null) {
                SOAPFactory fac = messageContext.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(messageContext.getEnvelope());
            }
            ae.send(messageContext);

        } catch (AxisFault e) {
            handleException(""Unexpected error during Sending message back"", e);
        }
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/mediators/base/SequenceMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;

import java.util.Stack;

/**
 * The Sequence mediator either refers to a named Sequence mediator instance
 * or is a *Named* list/sequence of other (child) Mediators
 * <p/>
 * If this instance defines a sequence mediator, then the name is required, and
 * an errorHandler sequence name optional. If this instance refers to another (defined)
 * sequence mediator, the errorHandler will not have a meaning, and if an error in
 * encountered in the reffered sequence, its errorHandler would execute.
 */
public class SequenceMediator extends AbstractListMediator {

    private static final Log log = LogFactory.getLog(SequenceMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    private String name = null;
    private String key = null;
    private String errorHandler = null;
    /** is this definition dynamic */
    private boolean dynamic = false;
    /** the registry key to load this definition if dynamic */
    private String registryKey = null;

    /** To decide to whether statistics should have collected or not  */
    private int statisticsEnable = Constants.STATISTICS_UNSET;

    /**
     * If this mediator refers to another named Sequence, execute that. Else
     * execute the list of mediators (children) contained within this. If a referenced
     * named sequence mediator instance cannot be found at runtime, an exception is
     * thrown. This may occur due to invalid configuration of an erroneous runtime
     * change of the synapse configuration. It is the responsibility of the
     * SynapseConfiguration builder to ensure that dead references are not present.
     *
     * @param synCtx the synapse message
     * @return as per standard mediator result
     */
    public boolean mediate(MessageContext synCtx) {
        
        log.debug(""Sequence mediator <"" + (name == null ? ""anonymous"" : name) + ""> :: mediate()"");
        
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (key == null) {
            // Setting Required property to collect the sequence statistics
            boolean isStatisticsEnable
                    = (org.apache.synapse.Constants.STATISTICS_ON == statisticsEnable);
            if (isStatisticsEnable) {
                StatisticsStack sequenceStack
                        = (StatisticsStack) synCtx.getProperty(Constants.SEQUENCE_STATISTICS_STACK);
                if (sequenceStack == null) {
                    sequenceStack = new SequenceStatisticsStack();
                    synCtx.setProperty(Constants.SEQUENCE_STATISTICS_STACK, sequenceStack);
                }
                String seqName = (name == null ? Constants.ANONYMOUS_SEQUENCES : name);
                boolean isFault =synCtx.getEnvelope().getBody().hasFault();
                sequenceStack.put(seqName,System.currentTimeMillis(),
                        !synCtx.isResponse(), isStatisticsEnable,isFault);
            }
            try {
                if (shouldTrace) {
                    trace.trace(""Start : Sequence <"" + (name == null ? ""anonymous"" : name) + "">"");
                }

                // push the errorHandler sequence into the current message as the fault handler
                if (errorHandler != null) {
                    log.debug(""Setting the onError handler for the sequence"");
                    synCtx.pushFaultHandler(
                        new MediatorFaultHandler(synCtx.getSequence(errorHandler)));
                }

                boolean ret = super.mediate(synCtx);

                // pop our error handler from the fault stack before we exit, if we have pushed it
                Stack faultStack = synCtx.getFaultStack();
                if (errorHandler != null && !faultStack.isEmpty()) {
                    Object o = faultStack.peek();
                    if (o instanceof MediatorFaultHandler &&
                        synCtx.getSequence(errorHandler).equals(
                            ((MediatorFaultHandler) o).getFaultMediator())) {
                        faultStack.pop();
                    }
                }

                return ret;

            } finally {

                //If this sequence is finished it's task normally
                if (isStatisticsEnable) {
                    StatisticsUtils.processSequenceStatistics(synCtx);
                }
                //If this sequence is a IN or OUT sequence of a proxy service
                StatisticsUtils.processProxyServiceStatistics(synCtx);
                if (shouldTrace) {
                    trace.trace(""End : Sequence <"" + (name == null ? ""anonymous"" : name) + "">"");
                }
            }

        } else {
            Mediator m = synCtx.getSequence(key);
            if (m == null) {
                if (shouldTrace) {
                    trace.trace(""Sequence named "" + key + "" cannot be found."");
                }
                handleException(""Sequence named "" + key + "" cannot be found."");
            } else {
                if (shouldTrace) {
                    trace.trace(""Executing sequence named "" + key);
                }
                return m.mediate(synCtx);
            }
        }
        return false;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getErrorHandler() {
        return errorHandler;
    }

    public void setErrorHandler(String errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsEnable() {
        return statisticsEnable;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsEnable
     */
    public void setStatisticsEnable(int statisticsEnable) {
        this.statisticsEnable = statisticsEnable;
    }

    /**
     * Is this a dynamic sequence?
     * @return true if dynamic
     */
    public boolean isDynamic() {
        return dynamic;
    }

    /**
     * Mark this as a dynamic sequence
     * @param dynamic true if this is a dynamic sequence
     */
    public void setDynamic(boolean dynamic) {
        this.dynamic = dynamic;
    }

    /**
     * Return the registry key used to load this sequence dynamically
     * @return  registry key
     */
    public String getRegistryKey() {
        return registryKey;
    }

    /**
     * get the registry key used to load this sequence dynamically
     * @param registryKey
     */
    public void setRegistryKey(String registryKey) {
        this.registryKey = registryKey;
    }
}
"
org/apache/synapse/config/xml/RegistryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Create an instance of the given registry, and sets properties on it.
 *
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistryFactory {

    private static final Log log = LogFactory.getLog(RegistryFactory.class);

    public static final QName PROVIDER_Q = new QName(Constants.NULL_NAMESPACE, ""provider"");
    public static final QName PARAMETER_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""parameter"");
    public static final QName NAME_Q     = new QName(Constants.NULL_NAMESPACE, ""name"");

    public static Registry createRegistry(OMElement elem) {

        OMAttribute prov = elem.getAttribute(PROVIDER_Q);
        if (prov != null) {
            try {
                Class provider = Class.forName(prov.getAttributeValue());
                Registry registry = (Registry) provider.newInstance();
                setProperties(registry, elem);
                return registry;

            } catch (ClassNotFoundException e) {
                handleException(""Cannot locate registry provider class : "" +
                    prov.getAttributeValue(), e);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            } catch (InstantiationException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            }
        } else {
            handleException(""The registry 'provider' attribute is required for a registry definition"");
        }

        return null;
    }

    private static void setProperties(Registry reg, OMElement elem) {
        Iterator params = elem.getChildrenWithName(PARAMETER_Q);
        while (params.hasNext()) {
            Object o = params.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(NAME_Q);
                String propertyValue = prop.getText();
                if (pname != null) {
                    if (propertyValue != null) {
                        reg.addConfigProperty(pname.getAttributeValue(), propertyValue.trim());
                    }
                } else {
                    handleException(""Invalid registry property - property should have a name "");
                }
            } else {
                handleException(""Invalid registry property"");
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/mediators/builtin/DropMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.mediators.AbstractMediator;

/**
 * Halts further processing/mediation of the current message. i.e. returns false
 */
public class DropMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(DropMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Halts further mediation of the current message by returning false.
     *
     * @param synCtx the current message
     * @return false always
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Drop mediator :: mediate()"");
        //If drop mediator is a child of a sequence
        // and if this sequence is a IN or OUT sequence of a proxy service
        StatisticsUtils.processProxyServiceStatistics(synCtx);
        //If this a sequence is not  a IN or OUT sequence of a proxy service
        StatisticsUtils.processAllSequenceStatistics(synCtx);
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Drop mediator"");
        }
        if (synCtx.getTo() == null) {
            if (shouldTrace) {
                trace.trace(""End : Drop mediator"");
            }
            return false;
        } else {
            synCtx.setTo(null);
            if (shouldTrace) {
                trace.trace(""End : Drop mediator"");
            }
            return false;
        }
    }
}
"
org/apache/synapse/config/xml/OutMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

public class OutMediatorSerializer extends AbstractListMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(OutMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof OutMediator)) {
            handleException(""Unsupported mediator passed out for serialization : "" + m.getType());
        }

        OutMediator mediator = (OutMediator) m;
        OMElement out = fac.createOMElement(""out"", synNS);
        finalizeSerialization(out,mediator);
        serializeChildren(out, mediator.getList());

        if (parent != null) {
            parent.addChild(out);
        }
        return out;
    }

    public String getMediatorClassName() {
        return OutMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/MessageContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;


import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;

import java.util.Set;
import java.util.Stack;


/**
 * The Synapse Message Context is available to all mediators through which it flows. It
 * allows one to call to the underlying SynapseEnvironment (i.e. the SOAP engine
 * - such as Axis2) where required. It also allows one to access the current
 * SynapseConfiguration. Additionally it holds per message properties (i.e. local
 * properties valid for the lifetime of the message), and the current SOAPEnvelope
 */
public interface MessageContext {

    /**
     * Get a reference to the current SynapseConfiguration
     *
     * @return the current synapse configuration
     */
    public SynapseConfiguration getConfiguration();

    /**
     * Set or replace the Synapse Configuration instance to be used. May be used to
     * programatically change the configuration at runtime etc.
     *
     * @param cfg The new synapse configuration instance
     */
    public void setConfiguration(SynapseConfiguration cfg);

    /**
     * Returns a reference to the host Synapse Environment
     * @return the Synapse Environment
     */
    public SynapseEnvironment getEnvironment();

    /**
     * Sets the SynapseEnvironment reference to this context
     * @param se the reference to the Synapse Environment
     */
    public void setEnvironment(SynapseEnvironment se);

    /**
     * Return the main sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.MAIN_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the main sequence if the main
     * sequence was dynamic and changed in between at the registry
     * @return the main sequence to be used for mediation
     */
    public Mediator getMainSequence();

    /**
     * Return the fault sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.FAULT_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the fault sequence if the fault
     * sequence was dynamic and changed in between at the registry
     * @return the fault sequence to be used for mediation
     */
    public Mediator getFaultSequence();

    /**
     * Return the sequence with the given key from the configuration, or the local message
     * context. This method looks up for the sequence with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said sequence if it was dynamic and
     * changed in between at the registry
     * @param key the sequence key to be looked up
     * @return the sequence mediator mapped to the key
     */
    public Mediator getSequence(String key);

    /**
     * Return the endpoint with the given key from the configuration, or the local message
     * context. This method looks up for the endpoint with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said endpoint if it was dynamic and
     * changed in between at the registry
     * @param key the endpoint key to be looked up
     * @return the endpoint mapped to the key
     */
    public Endpoint getEndpoint(String key);

    /**
     * Get the value of a custom (local) property set on the message instance
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getProperty(String key);

    /**
     * Get the value of a property set on the message instance, from the local registry
     * or the remote registry - by cascading through
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getEntry(String key);

    /**
     * Set a custom (local) property with the given name on the message instance
     * @param key key to be used
     * @param value value to be saved
     */
    public void setProperty(String key, Object value);

    /**
     * Returns the Set of keys over the properties on this message context
     * @return a Set of keys over message properties
     */
    public Set getPropertyKeySet();

    /**
     * Get the SOAP envelope of this message
     * @return the SOAP envelope of the message
     */
    public SOAPEnvelope getEnvelope();

    /**
     * Sets the given envelope as the current SOAPEnvelope for this message
     * @param envelope the envelope to be set
     * @throws org.apache.axis2.AxisFault on exception
     */
    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault;

    // --- SOAP Message related methods ------
    /** Get the faultTo EPR if available */
    public EndpointReference getFaultTo();

    /** Set the faultTo EPR */
    public void setFaultTo(EndpointReference reference);

    /** Get the from EPR if available */
    public EndpointReference getFrom();

    /** Set the from EPR */
    public void setFrom(EndpointReference reference);

    /** Get the message id if available */
    public String getMessageID();

    /** Set the message id */
    public void setMessageID(String string);

    /** Get the relatesTo of this message */
    public RelatesTo getRelatesTo();

    /**
     * Sets the relatesTo references for this message
     * @param reference the relatesTo references array
     */
    public void setRelatesTo(RelatesTo[] reference);

    /** Set the replyTo EPR */
    public EndpointReference getReplyTo();

    /** Get the replyTo EPR if available */
    public void setReplyTo(EndpointReference reference);

    /** Get the To EPR */
    public EndpointReference getTo();

     /**
     * Set the To EPR
     * @param reference the To EPR
     */
    public void setTo(EndpointReference reference);

    /**
     * Sets the WSAAction
     * @param actionURI the WSAAction
     */
    public void setWSAAction(String actionURI);

    /**
     * Returns the WSAAction
     * @return the WSAAction
     */
    public String getWSAAction();

    /**
     * Returns the SOAPAction of the message
     * @return the SOAPAction
     */
    public String getSoapAction();

    /**
     * Set the SOAPAction
     * @param string the SOAP Action
     */
    public void setSoapAction(String string);

    /**
     * Set the message if
     * @param messageID
     */
    public void setWSAMessageID(String messageID);

    /**
     * Gets the message id
     * @return the WSA MessageID
     */
    public String getWSAMessageID();

    /**
     * If this message using MTOM?
     * @return true if using MTOM
     */
    public boolean isDoingMTOM();

    /**
     * If this message using SWA?
     * @return true if using SWA
     */
    public boolean isDoingSWA();

    /**
     * Marks as using MTOM
     * @param b true to mark as using MTOM
     */
    public void setDoingMTOM(boolean b);

    /**
     * Marks as using SWA
     * @param b true to mark as using SWA
     */
    public void setDoingSWA(boolean b);

    /**
     * Is this message over POX?
     * @return true if over POX
     */
    public boolean isDoingPOX();

    /**
     * Marks this message as over REST
     * @param b true to mark as REST
     */
    public void setDoingPOX(boolean b);

    /**
     * Is this message a SOAP 1.1 message?
     * @return true if this is a SOAP 1.1 message
     */
    public boolean isSOAP11();

    /**
     * Mark this message as a response or not.
     * @see org.apache.synapse.MessageContext#isResponse()
     * @param b true to set this as a response
     */
    public void setResponse(boolean b);

    /**
     * Is this message a response to a synchronous message sent out through Synapse?
     * @return true if this message is a response message
     */
    public boolean isResponse();

    /**
     * Marks this message as a fault response
     * @see org.apache.synapse.MessageContext#isFaultResponse()
     * @param b true to mark this as a fault response
     */
    public void setFaultResponse(boolean b);

    /**
     * Is this message a response to a fault message?
     * @return true if this is a response to a fault message
     */
    public boolean isFaultResponse();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return indicate whether tracing is on, off or unset
     */
    public int getTracingState();

    /**
     * This is used to set the value of tracing enable variable
     * @param tracingState Set whether the tracing is enabled or not
     */
    public void setTracingState(int tracingState);

    public Stack getFaultStack();

    public void pushFaultHandler(FaultHandler fault);

}
"
org/apache/synapse/mediators/AbstractListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * This class implements the base functionality of a List mediator
 *
 * @see ListMediator
 */
public abstract class AbstractListMediator extends AbstractMediator implements ListMediator {

    private static final Log log = LogFactory.getLog(AbstractListMediator.class);

    protected List mediators = new ArrayList();

    public boolean mediate(MessageContext synCtx) {
        try {
            log.debug(""Implicit Sequence <"" + getType() + ""> :: mediate()"");
            saveAndSetTraceState(synCtx);
            Iterator it = mediators.iterator();            
            while (it.hasNext()) {
                Mediator m = (Mediator) it.next();
                if (!m.mediate(synCtx)) {
                    return false;
                }
            }
        }
        finally {
            restoreTracingState(synCtx);
        }
        return true;
    }

    public List getList() {
        return mediators;
    }

    public boolean addChild(Mediator m) {
        return mediators.add(m);
    }

    public boolean addAll(List c) {
        return mediators.addAll(c);
    }

    public Mediator getChild(int pos) {
        return (Mediator) mediators.get(pos);
    }

    public boolean removeChild(Mediator m) {
        return mediators.remove(m);
    }

    public Mediator removeChild(int pos) {
        return (Mediator) mediators.remove(pos);
    }
}
"
org/apache/synapse/endpoints/AddressEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Stack;

/**
 * This class represents an actual endpoint to send the message. It is resposible for sending the
 * message, performing reries if a failure occured and informing the parent endpoint if a failure
 * couldn't be recovered.
 */
public class AddressEndpoint extends FaultHandler implements Endpoint {

    private static final Log log = LogFactory.getLog(AddressEndpoint.class);

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * Determines if this endpoint is active or not. This variable have to be loaded always from the
     * memory as multiple threads could access it.
     */
    private volatile boolean active = true;

    /**
     * Stores the endpoint details for this endpoint. Details include EPR, WS-Addressing information,
     * WS-Security information, etc.
     */
    private EndpointDefinition endpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    /**
     * Leaf level endpoints will be suspended for the specified time by this variable, after a
     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to suspended forever.
     */
    private long suspendOnFailDuration = -1;

    /**
     * Time to recover a failed endpoint. Value of this is calculated when endpoint is set as
     * failed by adding suspendOnFailDuration to current time.
     */
    private long recoverOn = Long.MAX_VALUE;

    public EndpointDefinition getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(EndpointDefinition endpoint) {
        this.endpoint = endpoint;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
                recoverOn = 0;
            }
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public synchronized void setActive(boolean active, MessageContext synMessageContext) {

        // this is synchronized as recoverOn can be set to unpredictable values if two threads call
        // this method simultaneously.

        if (!active) {
            if (suspendOnFailDuration != -1) {
                recoverOn = System.currentTimeMillis() + suspendOnFailDuration;
            } else {
                recoverOn = Long.MAX_VALUE;
            }
        }

        this.active = active;
    }

    /**
     * Sends the message through this endpoint. This method just handles statistics related functions
     * and gives the message to the Synapse environment to send. It does not add any endpoint
     * specific details to the message context. These details are added only to the cloned message
     * context by the Axis2FlexibleMepClient. So that we can reuse the original message context for
     * resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        String endPointName = this.getName();
        if(endPointName ==null) {
            endPointName = Constants.ANONYMOUS_ENDPOINTS;
        }
        // Setting Required property to collect the End Point statistics
        boolean statisticsEnable =
                (org.apache.synapse.Constants.STATISTICS_ON == endpoint.getStatisticsEnable());
        if (statisticsEnable) {
            EndPointStatisticsStack endPointStatisticsStack = null;
            Object statisticsStackObj =
                    synCtx.getProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK);
            if (statisticsStackObj == null) {
                endPointStatisticsStack = new EndPointStatisticsStack();
                synCtx.setProperty(org.apache.synapse.Constants.ENDPOINT_STATISTICS_STACK,
                        endPointStatisticsStack);
            } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
            }
            if (endPointStatisticsStack != null) {
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statisticsEnable, isFault);
            }
        }

        if (endpoint.getAddress() != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Sending message to endpoint :: name = "" +
                        endPointName + "" resolved address = "" + endpoint.getAddress());
                log.debug(""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                        synCtx.getSoapAction() : ""null""));
                log.debug(""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));
                log.debug(""Body : \n"" + synCtx.getEnvelope());
            }
        }

        // register this as the immediate fault handler for this message.
        synCtx.pushFaultHandler(this);

        // add this as the last endpoint to process this message. it is used by statistics code.
        synCtx.setProperty(Constants.PROCESSED_ENDPOINT, this);

        synCtx.getEnvironment().send(endpoint, synCtx);
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // nothing to do as this is a leaf level endpoint
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public long getSuspendOnFailDuration() {
        return suspendOnFailDuration;
    }

    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
        this.suspendOnFailDuration = suspendOnFailDuration;
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        setActive(false, synCtx);

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }
}
"
org/apache/synapse/mediators/MediatorFaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This implements the FaultHandler interface as a mediator fault handler. That is the fault handler is
 * specified by a sequence and this handler implements the logic of handling the fault through the set
 * of mediators present in the sequence.
 *
 * @see org.apache.synapse.FaultHandler
 */
public class MediatorFaultHandler extends FaultHandler {

    private static final Log log = LogFactory.getLog(MediatorFaultHandler.class);

    /**
     * Thsi holds the fault sequence for the mediator fault handler
     */
    private Mediator faultMediator = null;

    /**
     * Constructs the FaultHandler object for handling mediator faults
     *
     * @param faultMediator Mediator in which fault sequence is specified
     */
    public MediatorFaultHandler(Mediator faultMediator) {

        this.faultMediator = faultMediator;
    }

    /**
     * Implements the fault handling method for the mediators (basically sequences)
     *
     * @param synCtx Synapse Message Context of which mediation occurs
     * @throws SynapseException in case there is a failure in the fault execution
     * @see org.apache.synapse.FaultHandler#handleFault(org.apache.synapse.MessageContext)
     */
    public void onFault(MessageContext synCtx) throws SynapseException {

        log.debug(""MediatorFaultHandler :: handleFault"");
        this.faultMediator.mediate(synCtx);
    }

    /**
     * Getter for the mediator describing the fault sequence
     *
     * @return Mediator specifying the fault sequence for mediator fault handler
     */
    public Mediator getFaultMediator() {

        return faultMediator;
    }

    /**
     * Setter of the mediator describing the fault sequence
     *
     * @param faultMediator Mediator specifying the fault sequence to be used by the handler
     */
    public void setFaultMediator(Mediator faultMediator) {

        this.faultMediator = faultMediator;
    }
}
"
org/apache/synapse/core/axis2/SynapseModule.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.MDC;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.SynapseConfigurationBuilder;

import javax.xml.namespace.QName;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;

/**
 * This is the Synapse Module implementation class, which would initialize Synapse when it is
 * deployed onto an Axis2 configuration.
 */
public class SynapseModule implements Module {

    private static final Log log = LogFactory.getLog(SynapseModule.class);

    private static final String SYNAPSE_SERVICE_NAME = ""synapse"";
    private static final QName MEDIATE_OPERATION_Q_NAME = new QName(""mediate"");

    public void init(ConfigurationContext configurationContext,
        AxisModule axisModule) throws AxisFault {

        try {
            InetAddress addr = InetAddress.getLocalHost();
            if (addr != null) {
                // Get IP Address
                String ipAddr = addr.getHostAddress();
                if (ipAddr != null) {
                    MDC.put(""ip"", ipAddr);
                }

                // Get hostname
                String hostname = addr.getHostName();
                if (hostname == null) {
                    hostname = ipAddr;
                }
                MDC.put(""host"", hostname);
            }
        } catch (UnknownHostException e) {
            log.warn(""Unable to report hostname or IP address for tracing"", e);
        }   
        // Initializing the SynapseEnvironment and SynapseConfiguration
        log.info(""Initializing the Synapse configuration ..."");
        SynapseConfiguration synCfg = initializeSynapse(configurationContext);

        log.info(""Deploying the Synapse service.."");
        // Dynamically initialize the Synapse Service and deploy it into Axis2
        AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();
        AxisService synapseService = new AxisService(SYNAPSE_SERVICE_NAME);
        AxisOperation mediateOperation = new InOutAxisOperation(MEDIATE_OPERATION_Q_NAME);
        mediateOperation.setMessageReceiver(new SynapseMessageReceiver());
        synapseService.addOperation(mediateOperation);
        List transports = new ArrayList();
        transports.add(org.apache.axis2.Constants.TRANSPORT_HTTP);
        transports.add(""https"");
        synapseService.setExposedTransports(transports);
        axisCfg.addService(synapseService);

        log.info(""Initializing Sandesha 2..."");
        AxisModule sandeshaAxisModule = configurationContext.getAxisConfiguration().
            getModule(Constants.SANDESHA2_MODULE_NAME);
        if (sandeshaAxisModule != null) {
            Module sandesha2 = sandeshaAxisModule.getModule();
            sandesha2.init(configurationContext, sandeshaAxisModule);
        }

        log.info(""Deploying Proxy services..."");
        Iterator iter = synCfg.getProxyServices().iterator();
        while (iter.hasNext()) {
            ProxyService proxy = (ProxyService) iter.next();
            proxy.buildAxisService(synCfg, axisCfg);
            log.debug(""Deployed Proxy service : "" + proxy.getName());
            if (!proxy.isStartOnLoad()) {
                proxy.stop(synCfg);
            }
        }

        log.info(""Synapse initialized successfully...!"");
    }

    private static SynapseConfiguration initializeSynapse(
        ConfigurationContext cfgCtx) {

        cfgCtx.setProperty(""addressing.validateAction"", Boolean.FALSE);
        AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();
        SynapseConfiguration synapseConfiguration;

        String config = System.getProperty(Constants.SYNAPSE_XML);

        if (config != null) {
            log.debug(""System property '"" + Constants.SYNAPSE_XML +
                ""' specifies synapse configuration as "" + config);
            synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);
        } else {
            log.warn(""System property '"" + Constants.SYNAPSE_XML +
                ""' is not specified. Using default configuration.."");
            synapseConfiguration = SynapseConfigurationBuilder.getDefaultConfiguration();
        }

        // Set the Axis2 ConfigurationContext to the SynapseConfiguration
        synapseConfiguration.setAxisConfiguration(cfgCtx.getAxisConfiguration());

        // set the Synapse configuration and environment into the Axis2 configuration
        Parameter synapseCtxParam = new Parameter(Constants.SYNAPSE_CONFIG, null);
        synapseCtxParam.setValue(synapseConfiguration);
        MessageContextCreatorForAxis2.setSynConfig(synapseConfiguration);

        Parameter synapseEnvParam = new Parameter(Constants.SYNAPSE_ENV, null);
        Axis2SynapseEnvironment synEnv = new Axis2SynapseEnvironment(cfgCtx, synapseConfiguration);
        synapseEnvParam.setValue(synEnv);
        MessageContextCreatorForAxis2.setSynEnv(synEnv);

        try {
            axisConfiguration.addParameter(synapseCtxParam);
            axisConfiguration.addParameter(synapseEnvParam);

        } catch (AxisFault e) {
            String msg =
                ""Could not set parameters '"" + Constants.SYNAPSE_CONFIG +
                    ""' and/or '"" + Constants.SYNAPSE_ENV +
                    ""'to the Axis2 configuration : "" + e.getMessage();
            log.fatal(msg, e);
            throw new SynapseException(msg, e);
        }
        
        return synapseConfiguration;
    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {
        // ignore
    }

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation
    }

    public void shutdown(ConfigurationContext configurationContext)
        throws AxisFault {
        // ignore
    }
}
"
org/apache/synapse/core/axis2/DynamicAxisOperation.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.transport.TransportUtils;
import org.apache.axis2.i18n.Messages;
import org.apache.axis2.util.TargetResolver;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.async.Callback;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisEngine;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.synapse.Constants;

import javax.xml.namespace.QName;

/**
 * DynamicAxisOperation which switch dynamically between MEPs
 */
public class DynamicAxisOperation extends OutInAxisOperation {

	public DynamicAxisOperation() {
		super();
	}

	public DynamicAxisOperation(QName name) {
		super(name);
	}

	public OperationClient createClient(ServiceContext sc, Options options) {
		return new DynamicOperationClient(this, sc, options);
	}

	class DynamicOperationClient extends OperationClient {

		DynamicOperationClient(OutInAxisOperation axisOp, ServiceContext sc, Options options) {
            super(axisOp, sc, options);
		}

		/**
         * same as OutInAxisOperationClient
		 */
		public void addMessageContext(MessageContext mc) throws AxisFault {
			mc.setServiceContext(sc);
			if (mc.getMessageID() == null) {
				setMessageID(mc);
			}
			axisOp.registerOperationContext(mc, oc);
		}

		/**
		 * same as OutInAxisOperationClient
		 */
		public MessageContext getMessageContext(String messageLabel) throws AxisFault {
			return oc.getMessageContext(messageLabel);
		}

        /**
         * same as OutInAxisOperationClient
         */
        public void setCallback(Callback callback) {
			this.callback = callback;
		}

		public void execute(boolean block) throws AxisFault {

            // if the MEP is completed, throw a fault
            if (completed) {
				throw new AxisFault(Messages.getMessage(""mepiscomplted""));
			}

            // if the OUT message is not set on the operation context, throw a fault
            MessageContext outMsgCtx = oc.getMessageContext(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
			if (outMsgCtx == null) {
				throw new AxisFault(Messages.getMessage(""outmsgctxnull""));
			}

            ConfigurationContext cfgCtx = sc.getConfigurationContext();

            // set ClientOptions to the current outgoing message
            outMsgCtx.setOptions(options);

			// do Target Resolution
			TargetResolver tr = cfgCtx.getAxisConfiguration().getTargetResolverChain();
            if (tr != null) {
                tr.resolveTarget(outMsgCtx);
            }

            // if the transport to use for sending is not specified, try to find it from the URL
			TransportOutDescription transportOut = options.getTransportOut();
			if (transportOut == null) {
				EndpointReference toEPR =
                    (options.getTo() != null) ? options.getTo() : outMsgCtx.getTo();
				transportOut =
                    ClientUtils.inferOutTransport(cfgCtx.getAxisConfiguration(), toEPR, outMsgCtx);
			}
			outMsgCtx.setTransportOut(transportOut);

			if (options.getTransportIn() == null && outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(
                    ClientUtils.inferInTransport(cfgCtx.getAxisConfiguration(), options, outMsgCtx));
			} else if (outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(options.getTransportIn());
			}

            // add reference parameters to To EPR
            addReferenceParameters(outMsgCtx);

            if (options.isUseSeparateListener()) {

                /* TODO - review and finalise this - asankha 22 feb 2007
				// options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
				options.setTransportIn(outMsgCtx.getConfigurationContext()
						.getAxisConfiguration().getTransportIn(
								new QName(Constants.TRANSPORT_HTTP)));

				SynapseCallbackReceiver callbackReceiver = (SynapseCallbackReceiver) axisOp
						.getMessageReceiver();
				callbackReceiver.addCallback(outMsgCtx.getMessageID(), callback);
				EndpointReference replyToFromTransport = outMsgCtx
						.getConfigurationContext().getListenerManager()
						.getEPRforService(sc.getAxisService().getKey(),
								axisOp.getKey().getLocalPart(),
								outMsgCtx.getTransportOut().getKey().getLocalPart());

				if (outMsgCtx.getReplyTo() == null) {
					outMsgCtx.setReplyTo(replyToFromTransport);
				} else {
					outMsgCtx.getReplyTo().setAddress(
							replyToFromTransport.getAddress());
				}
				// if dont do this , this guy will wait till its gets HTTP 202
				// in the case
				// HTTP
				outMsgCtx.setProperty(MessageContext.TRANSPORT_NON_BLOCKING,
						Boolean.TRUE);
				AxisEngine engine = new AxisEngine(cfgCtx);
				outMsgCtx.getConfigurationContext().registerOperationContext(
						outMsgCtx.getMessageID(), oc);
				engine.send(outMsgCtx);

				// Options object reused so soapAction needs to be removed so
				// that soapAction+wsa:Action on response don't conflict
				options.setAction("""");
                */

			} else {

                SynapseCallbackReceiver callbackReceiver =
                    (SynapseCallbackReceiver) axisOp.getMessageReceiver();
                callbackReceiver.addCallback(outMsgCtx.getMessageID(), callback);
                send(outMsgCtx);
			}
		}

		private void send(MessageContext msgctx) throws AxisFault {

			// create the responseMessageContext and set that its related to the current outgoing
            // message, so that it could be tied back to the original request even if the response
            // envelope does not contain addressing headers
            MessageContext responseMessageContext = new MessageContext();
            responseMessageContext.setMessageID(msgctx.getMessageID());
            responseMessageContext.setProperty(Constants.RELATES_TO_FOR_POX, msgctx.getMessageID());
            responseMessageContext.setOptions(options);
			addMessageContext(responseMessageContext);

            AxisEngine engine = new AxisEngine(msgctx.getConfigurationContext());
			engine.send(msgctx);

            // did the engine receive a immediate synchronous response?
            // e.g. sometimes the transport sender may listen for a syncronous reply
			if (msgctx.getProperty(MessageContext.TRANSPORT_IN) != null) {

                responseMessageContext.setOperationContext(msgctx.getOperationContext());                
                responseMessageContext.setAxisMessage(
                    msgctx.getOperationContext().getAxisOperation().
                    getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));
                responseMessageContext.setAxisService(msgctx.getAxisService());

                // set properties on responseMessageContext
                responseMessageContext.setServerSide(true);
                responseMessageContext.setProperty(MessageContext.TRANSPORT_OUT,
                    msgctx.getProperty(MessageContext.TRANSPORT_OUT));
                responseMessageContext.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    msgctx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));

                responseMessageContext.setProperty(
                    org.apache.synapse.Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // If request is REST assume that the responseMessageContext is REST too
                responseMessageContext.setDoingREST(msgctx.isDoingREST());

                responseMessageContext.setProperty(MessageContext.TRANSPORT_IN,
                    msgctx.getProperty(MessageContext.TRANSPORT_IN));
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // Options object reused above so soapAction needs to be removed so
                // that soapAction+wsa:Action on response don't conflict
                responseMessageContext.setSoapAction("""");

                if (responseMessageContext.getEnvelope() == null) {
                    // If request is REST we assume the responseMessageContext is
                    // REST, so set the variable

                    SOAPEnvelope resenvelope =
                        TransportUtils.createSOAPMessage(responseMessageContext);

                    if (resenvelope != null) {
                        responseMessageContext.setEnvelope(resenvelope);
                        engine = new AxisEngine(msgctx.getConfigurationContext());
                        engine.receive(responseMessageContext);
                        if (responseMessageContext.getReplyTo() != null) {
                            sc.setTargetEPR(responseMessageContext.getReplyTo());
                        }
                    } else {
                        throw new AxisFault(Messages.getMessage(""blockingInvocationExpectsResponse""));
                    }
                }
            }
        }
	}
}
"
org/apache/synapse/config/xml/MediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

/**
 * Interface which should be implemented by mediator serializers. Does the
 * reverse of the MediatorFactory
 */
public interface MediatorSerializer {

    /**
     * Return the XML representation of this mediator
     * @param m mediator to be serialized
     * @param parent the OMElement to which the serialization should be attached
     * @return the serialized mediator XML
     */
    public OMElement serializeMediator(OMElement parent, Mediator m);

    /**
     * Return the class name of the mediator which can be serialized
     * @return the class name 
     */
    public String getMediatorClassName();
}
"
org/apache/synapse/statistics/impl/EndPointStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;

/**
 * The data structure to hold statistics related to the endpoints
 *
 */

public class EndPointStatisticsStack implements StatisticsStack {

    /** list of endpoint statistics */
    private List endpointStatistics;
    /** To decide whether the reporting of the in flow statistics have been completed*/
    private boolean isCompleteInFlowStatisicsReport = false;

    /**
     * To put statistics
     * @param key                   - The name of the End Point
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (endpointStatistics == null) {
            endpointStatistics = new ArrayList();
        }
        endpointStatistics.add(
                new EndPointStatistics(key, initTime, isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            EndPointStatistics statistics =
                    (EndPointStatistics) endpointStatistics.get(
                            endpointStatistics.size() - 1);
            if (statistics != null && statistics.isStatisticsEnable &&
                    statistics.endPointName != null) {
                if (statistics.inTimeForInFlow != -1) {
                    long initTimeForOutFlow = System.currentTimeMillis();
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            false, statistics.inTimeForInFlow,
                            initTimeForOutFlow, isFault);
                    statistics.inTimeForInFlow = -1;
                    statistics.inTimeForOutFlow = initTimeForOutFlow;
                } else if (statistics.inTimeForOutFlow != -1 &&
                        isCompleteInFlowStatisicsReport) {
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            true, statistics.inTimeForOutFlow,
                            System.currentTimeMillis(), isFault);
                    endpointStatistics.remove(statistics);
                }
            }
        }
    }

    /**
     * Report a particular statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null &&
                            statistics.endPointName.equals(name)) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
        isCompleteInFlowStatisicsReport = true;
    }

    class EndPointStatistics {

        /** The name of the endpoint    */
        private String endPointName;
         /** To check whether IN message flow or not   */
        private boolean isStatisticsEnable;
        /** To indicate whether this is fault or not  */
        private boolean isFault;
        /** The time which starts to collect statistics for IN flow */
        private long inTimeForInFlow = -1;
        /** The time which starts to collect statistics for OUT flow */
        private long inTimeForOutFlow = -1;

        public EndPointStatistics(String endPointName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean fault) {
            if (inFlow) {
                this.endPointName = endPointName;
                this.inTimeForInFlow = initTime;
                isStatisticsEnable = statisticsEnable;
                isFault = fault;
            }
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            EndPointStatistics that = (EndPointStatistics) o;

            if (endPointName != null ? !endPointName.equals(that.endPointName) : that.endPointName != null)
                return false;

            return true;
        }

        public int hashCode() {
            return (endPointName != null ? endPointName.hashCode() : 0);
        }
    }
}
"
org/apache/synapse/config/xml/ClassMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.ClassMediator;

import javax.xml.namespace.QName;

/**
 * Creates an instance of a Class mediator using XML configuration specified
 *
 * <pre>
 * &lt;class name=""class-name""&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(LogMediatorFactory.class);

    private static final QName CLASS_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""class"");

    public Mediator createMediator(OMElement elem) {

        ClassMediator classMediator = new ClassMediator();

        OMAttribute name = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
        if (name == null) {
            String msg = ""The name of the actual mediator class is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            Class clazz = getClass().getClassLoader().loadClass(name.getAttributeValue());
            classMediator.setClazz(clazz);
        } catch (ClassNotFoundException e) {
            String msg = ""Cannot find class : "" + name.getAttributeValue();
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(classMediator,elem);
        classMediator.addAllProperties(MediatorPropertyFactory.getMediatorProperties(elem));

        return classMediator;
    }


    public QName getTagQName() {
        return CLASS_Q;
    }
}
"
org/apache/synapse/config/xml/SwitchMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.SwitchMediator;

import java.util.Iterator;

/**
 * <pre>
 * &lt;switch source=""xpath""&gt;
 *   &lt;case regex=""string""&gt;
 *     mediator+
 *   &lt;/case&gt;+
 *   &lt;default&gt;
 *     mediator+
 *   &lt;/default&gt;?
 * &lt;/switch&gt;
 * </pre>
 */
public class SwitchMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(SwitchMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SwitchMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SwitchMediator mediator = (SwitchMediator) m;
        OMElement switchMed = fac.createOMElement(""switch"", synNS);
        finalizeSerialization(switchMed, mediator);

        if (mediator.getSource() != null) {
            switchMed.addAttribute(fac.createOMAttribute(
                    ""source"", nullNS, mediator.getSource().toString()));
            super.serializeNamespaces(switchMed, mediator.getSource());

        } else {
            handleException(""Invalid switch mediator. Source required"");
        }

        Iterator iter = mediator.getCases().iterator();
        while (iter.hasNext()) {
            OMElement caseElem = fac.createOMElement(""case"", synNS);
            SwitchCase aCase = ((SwitchCase) iter.next());
            if (aCase.getRegex() != null) {
                caseElem.addAttribute(fac.createOMAttribute(
                        ""regex"", nullNS, aCase.getRegex().pattern()));
            } else {
                handleException(""Invalid switch case. Regex required"");
            }
            AnonymousListMediator caseMediator = aCase.getCaseMediator();
            if (caseMediator != null) {
                AnonymousListMediatorSerializer.serializeAnonymousListMediator(
                        caseElem, caseMediator);
                switchMed.addChild(caseElem);
            }
        }
        SwitchCase defaultCase = mediator.getDefaultCase();
        if (defaultCase != null) {
            OMElement caseDefaultElem = fac.createOMElement(""default"", synNS);
            AnonymousListMediator caseDefaultMediator = defaultCase.getCaseMediator();
            if (caseDefaultMediator != null) {
                AnonymousListMediatorSerializer.serializeAnonymousListMediator(
                        caseDefaultElem, caseDefaultMediator);
                switchMed.addChild(caseDefaultElem);
            }
        }
        if (parent != null) {
            parent.addChild(switchMed);
        }
        return switchMed;
    }

    public String getMediatorClassName() {
        return SwitchMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/LogMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

/**
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""] [separator=""string""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorSerializer extends AbstractMediatorSerializer
    {

    private static final Log log = LogFactory.getLog(LogMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof LogMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        LogMediator mediator = (LogMediator) m;
        OMElement log = fac.createOMElement(""log"", synNS);
        finalizeSerialization(log,mediator);

        if (mediator.getLogLevel() != LogMediator.SIMPLE) {
            log.addAttribute(fac.createOMAttribute(
                ""level"", nullNS,
                    mediator.getLogLevel() == LogMediator.HEADERS ? ""headers"" :
                    mediator.getLogLevel() == LogMediator.FULL ? ""full"" :
                    mediator.getLogLevel() == LogMediator.CUSTOM ? ""custom"" : ""simple""
                ));
        }

        if (mediator.getSeparator() != LogMediator.DEFAULT_SEP) {
            log.addAttribute(fac.createOMAttribute(
                ""separator"", nullNS, mediator.getSeparator()));
        }

        super.serializeProperties(log, mediator.getProperties());

        if (parent != null) {
            parent.addChild(log);
        }
        return log;
    }

    public String getMediatorClassName() {
        return LogMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/mediators/transform/FaultMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMDocument;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.*;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import javax.xml.namespace.QName;
import java.net.URI;
import java.util.Iterator;

/**
 * This transforms the current message instance into a SOAP Fault message. The
 * SOAP version for the fault message could be explicitly specified. Else if the
 * original message was SOAP 1.1 the fault will also be SOAP 1.1 else, SOAP 1.2
 *
 * This class exposes methods to set SOAP 1.1 and 1.2 fault elements and uses
 * these as required.
 */
public class FaultMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(FaultMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    public static final String WSA_ACTION = ""Action"";
    /** Make a SOAP 1.1 fault */
    public static final int SOAP11 = 1;
    /** Make a SOAP 1.2 fault */
    public static final int SOAP12 = 2;
    /** Holds the SOAP version to be used to make the fault, if specified */
    private int soapVersion;

    // -- fault elements --
    /** The fault code QName to be used */
    private QName faultCodeValue = null;
    /** An XPath expression that will give the fault code QName at runtime */
    private AXIOMXPath faultCodeExpr = null;
    /** The fault reason to be used */
    private String faultReasonValue = null;
    /** An XPath expression that will give the fault reason string at runtime */
    private AXIOMXPath faultReasonExpr = null;
    /** The fault node URI to be used */
    private URI faultNode = null;
    /** The fault role URI to be used - if applicable */
    private URI faultRole = null;
    /** The fault detail to be used */
    private String faultDetail = null;

    public boolean mediate(MessageContext synCtx) {
        log.debug(""Fault mediator mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        SOAPEnvelope envelop = synCtx.getEnvelope();
        if(shouldTrace) {
            trace.trace(""Start : Fault mediator"");
        }
        switch (soapVersion) {
            case SOAP11:
                return makeSOAPFault(synCtx, SOAP11,shouldTrace);
            case SOAP12:
                return makeSOAPFault(synCtx, SOAP12,shouldTrace);
            default : {
                if (envelop != null) {
                    if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                        envelop.getNamespace().getNamespaceURI())) {
                        soapVersion = SOAP12;
                        return makeSOAPFault(synCtx, SOAP12,shouldTrace);
                    } else {
                        soapVersion = SOAP11;
                        return makeSOAPFault(synCtx, SOAP11,shouldTrace);
                    }
                } else {
                    return makeSOAPFault(synCtx, SOAP11,shouldTrace);
                }
            }
        }
    }

    private boolean makeSOAPFault(MessageContext synCtx, int soapVersion,boolean shouldTrace) {

        log.debug(""Creating a SOAP fault using SOAP "" + (soapVersion == SOAP11 ? ""1.1"" : ""1.2""));
        // get the correct SOAP factory to be used
        SOAPFactory factory = (
            soapVersion == SOAP11 ? OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory());

        // create the SOAP fault document and envelope
        OMDocument soapFaultDocument = factory.createOMDocument();
        SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();
        soapFaultDocument.addChild(faultEnvelope);

        // create the fault element  if it is need 
        SOAPFault fault = faultEnvelope.getBody().getFault();
        if(fault == null){
            fault = factory.createSOAPFault();
        }

        // populate it
        setFaultCode(synCtx, factory, fault);
        setFaultResaon(synCtx, factory, fault);
        setFaultNode(factory, fault);
        setFaultRole(factory, fault);
        setFaultDetail(factory, fault);

        // set the all headers of griginal SOAP Envelope to the Fault Envelope
        Iterator iter = synCtx.getEnvelope().getHeader().examineAllHeaderBlocks();
        if (iter.hasNext()) {
            while (iter.hasNext()) {
                Object o = iter.next();
                if (o instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                    faultEnvelope.getHeader().addChild(header);
                } else if (o instanceof OMElement) {
                    faultEnvelope.getHeader().addChild((OMElement) o);
                }
            }
        }
        log.debug(""The fault message as : "" + fault);
        // overwrite current message envelope with new fault envelope
        try {
            if (shouldTrace) {
                trace.trace(""Original SOAP Message : "" + synCtx.getEnvelope().toString());
                trace.trace(""Fault Message created : "" + faultEnvelope.toString());
            }
            synCtx.setEnvelope(faultEnvelope);
        } catch (AxisFault af) {
            String msg = ""Error replacing SOAP envelope with a fault envelope "" + af.getMessage();
            log.error(msg);
            throw new SynapseException(af);
        }

        if (synCtx.getFaultTo() != null) {
            synCtx.setTo(synCtx.getFaultTo());
        } else if (synCtx.getReplyTo() != null) {
            synCtx.setTo(synCtx.getReplyTo());
        } else {
            synCtx.setTo(null);
        }

        if (shouldTrace) {
            trace.trace(""End : Fault mediator"");
        }
        return true;
    }

    private void setFaultCode(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {

        QName fault_code = null;

        if (faultCodeValue == null && faultCodeExpr == null) {
            handleException(""A valid fault code QName value or expression is required"");
        } else if (faultCodeValue != null) {
            fault_code = faultCodeValue;
        } else {
            fault_code = QName.valueOf(Axis2MessageContext.getStringValue(faultCodeExpr, synCtx));
        }

        SOAPFaultCode code = factory.createSOAPFaultCode();
        switch(soapVersion){
            case SOAP11:
                code.setText(fault_code);
                break;
            case SOAP12:
                SOAPFaultValue value = factory.createSOAPFaultValue(code);
                value.setText(fault_code);
                break;
        }
        fault.setCode(code);
    }

    private void setFaultResaon(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {
        String reasonString = null;

        if (faultReasonValue == null && faultReasonExpr == null) {
            handleException(""A valid fault reason value or expression is required"");
        } else if (faultReasonValue != null) {
            reasonString = faultReasonValue;
        } else {
            reasonString = Axis2MessageContext.getStringValue(faultReasonExpr, synCtx);
        }

        SOAPFaultReason reason = factory.createSOAPFaultReason();
        switch(soapVersion){
            case SOAP11:
                reason.setText(reasonString);
                break;
            case SOAP12:
                SOAPFaultText text = factory.createSOAPFaultText();
                text.setText(reasonString);
                reason.addSOAPText(text);
                break;
        }
        fault.setReason(reason);
    }

    private void setFaultNode(SOAPFactory factory, SOAPFault fault) {
        if (faultNode != null) {
            SOAPFaultNode soapfaultNode = factory.createSOAPFaultNode();
            soapfaultNode.setNodeValue(faultNode.toString());
            fault.setNode(soapfaultNode);
        }
    }

    private void setFaultRole(SOAPFactory factory, SOAPFault fault) {
        if (faultRole != null) {
            SOAPFaultRole soapFaultRole = factory.createSOAPFaultRole();
            soapFaultRole.setRoleValue(faultRole.toString());
            fault.setRole(soapFaultRole);
        }
    }

    private void setFaultDetail(SOAPFactory factory, SOAPFault fault) {
        if (faultDetail != null) {
            SOAPFaultDetail soapFaultDetail = factory.createSOAPFaultDetail();
            soapFaultDetail.setText(faultDetail);
            fault.setDetail(soapFaultDetail);
        }
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public int getSoapVersion() {
        return soapVersion;
    }

    public void setSoapVersion(int soapVersion) {
        this.soapVersion = soapVersion;
    }

    public QName getFaultCodeValue() {
        return faultCodeValue;
    }

    public void setFaultCodeValue(QName faultCodeValue) {

        if (soapVersion == SOAP11) {
            this.faultCodeValue = faultCodeValue;

        } else {
            if (
                SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(faultCodeValue.getNamespaceURI()) &&

                (SOAP12Constants.FAULT_CODE_DATA_ENCODING_UNKNOWN.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_MUST_UNDERSTAND.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_RECEIVER.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_SENDER.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_VERSION_MISMATCH.equals(faultCodeValue.getLocalPart())) ){

                this.faultCodeValue = faultCodeValue;

            } else {
                String msg = ""Invalid Fault code value for a SOAP 1.2 fault : "" + faultCodeValue;
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }

    public AXIOMXPath getFaultCodeExpr() {
        return faultCodeExpr;
    }

    public void setFaultCodeExpr(AXIOMXPath faultCodeExpr) {
        this.faultCodeExpr = faultCodeExpr;
    }

    public String getFaultReasonValue() {
        return faultReasonValue;
    }

    public void setFaultReasonValue(String faultReasonValue) {
        this.faultReasonValue = faultReasonValue;
    }

    public AXIOMXPath getFaultReasonExpr() {
        return faultReasonExpr;
    }

    public void setFaultReasonExpr(AXIOMXPath faultReasonExpr) {
        this.faultReasonExpr = faultReasonExpr;
    }

    public URI getFaultNode() {
        return faultNode;
    }

    public void setFaultNode(URI faultNode) {
        if (soapVersion == SOAP11) {
            handleException(""A fault node does not apply to a SOAP 1.1 fault"");
        }
        this.faultNode = faultNode;
    }

    public URI getFaultRole() {
        return faultRole;
    }

    public void setFaultRole(URI faultRole) {
        this.faultRole = faultRole;
    }

    public String getFaultDetail() {
        return faultDetail;
    }

    public void setFaultDetail(String faultDetail) {
        this.faultDetail = faultDetail;
    }
}
"
org/apache/synapse/mediators/base/SynapseMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The SynapseMediator is the ""mainmediator"" of the synapse engine. It is
 * given each message on arrival at the synapse engine. The synapse configuration
 * holds a reference to this special mediator instance. The SynapseMediator
 * holds the list of mediators supplied within the <rules> element of an XML
 * based Synapse configuration
 *
 * @see org.apache.synapse.config.SynapseConfiguration#getMainSequence()
 */
public class SynapseMediator extends AbstractListMediator {

    private static final Log log = LogFactory.getLog(SynapseMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Perform the mediation specified by the rule set
     *
     * @param synCtx the message context
     * @return as per standard mediate() semantics
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Synapse main mediator :: mediate()"");
        if(synCtx.isResponse()) {
            StatisticsUtils.processAllSequenceStatistics(synCtx);
        }
        StatisticsStack sequenceStack = (StatisticsStack) synCtx.getProperty(
                Constants.SEQUENCE_STATISTICS_STACK);
        if (sequenceStack == null) {
            sequenceStack = new SequenceStatisticsStack();
            synCtx.setProperty(Constants.SEQUENCE_STATISTICS_STACK, sequenceStack);
        }
        String seqName = ""MainSequence"";
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        sequenceStack.put(seqName, System.currentTimeMillis(), !synCtx.isResponse(), true, isFault);
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
         try {
            if (shouldTrace) {
                trace.trace(""Start : Synapse main mediator"");
            }
            return super.mediate(synCtx);
        } finally {
            if (shouldTrace) {
                trace.trace(""End : Synapse main mediator"");
            }
        }
    }
}
"
org/apache/synapse/statistics/StatisticsUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * A utils to process statistics
 *
 */

public class StatisticsUtils {

    /**
     * To process statistics related to the proxy services
     *
     * @param synCtx
     */
    public static void processProxyServiceStatistics(MessageContext synCtx) {

        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        ProxyServiceStatisticsStack proxyServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(Constants.PROXYSERVICE_STATISTICS_STACK);
        if (proxyServiceStatisticsStack != null) {
            proxyServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
        ProxyServiceStatisticsStack synapseServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(Constants.SYNAPSESERVICE_STATISTICS_STACK);
        if (synapseServiceStatisticsStack != null) {
            synapseServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

    /**
     * To process statistics related to the End Points
     *
     * @param synCtx
     */
    public static void processEndPointStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        EndPointStatisticsStack endPointStatisticsStack = (EndPointStatisticsStack)
                synCtx.getProperty(Constants.ENDPOINT_STATISTICS_STACK);
        if (endPointStatisticsStack != null) {
            Object endpointObj = synCtx.getProperty(Constants.PROCESSED_ENDPOINT);
            if (endpointObj instanceof Endpoint) {
                Endpoint endpoint = (Endpoint) endpointObj;
                String name = endpoint.getName();
                if (name == null) {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault);
                } else {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault, name);
                }
                endPointStatisticsStack.reportAllToStatisticsCollector(statisticsCollector, true);
            }
        }
    }

    /**
     * To process statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(Constants.SEQUENCE_STATISTICS_STACK);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

     /**
     * To process all statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processAllSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(Constants.SEQUENCE_STATISTICS_STACK);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportAllToStatisticsCollector(statisticsCollector,isFault);
        }
    }
    /**
     * A helper method to get StatisticsCollector from the Synapse Message Context
     *
     * @param synCtx
     * @return StatisticsCollector
     */
    private static StatisticsCollector getStatisticsCollector(MessageContext synCtx) {
        SynapseEnvironment synEnv = synCtx.getEnvironment();
        StatisticsCollector statisticsCollector = null;
        if (synEnv != null) {
            statisticsCollector = synEnv.getStatisticsCollector();
            if (statisticsCollector == null) {
                statisticsCollector = new StatisticsCollector();
                synEnv.setStatisticsCollector(statisticsCollector);
            }
        }
        return statisticsCollector;
    }
}
"
org/apache/synapse/config/Entry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.net.URL;

/**
 * Represents an Entry contained in the local registry used by Synapse
 *
 * @see org.apache.synapse.config.SynapseConfiguration#localRegistry
 */
public class Entry {

    private static final Log log = LogFactory.getLog(Entry.class);

    /** The key of the entry */
    private String key;
    /** The type of the entry */
    private int type;
    /** Source URL of the entry if it is a URL_SRC */
    private URL src;
    /** The value of the entry. This can be either an OMElement or an String */
    private Object value;
    /** An XML to Object mapper - if one is available */
    private XMLToObjectMapper mapper;
    /** The version of the cached resource */
    private long version;
    /** The local expiry time for the cached resource */
    private long expiryTime;

    public Entry() {}
    
    public Entry(String key) {
        this.key = key;
    }

    public int getType() {
        return type;
    }

    public boolean isRemote() {
        return type == REMOTE_ENTRY;
    }

    public boolean isURLSource() {
        return type == URL_SRC;
    }

    public boolean isInlineXML() {
        return type == INLINE_XML;
    }

    public boolean isInlineText() {
        return type == INLINE_TEXT;
    }

    public void setType(int type) {
        if (type <= 4 && type >= 0)
            this.type = type;
        else
            handleException(""Invalid entry type for the static entry"");
    }

    public URL getSrc() {
        return src;
    }

    public void setSrc(URL src) {
        this.src = src;
    }

    public String getKey() {
        return this.key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * Gets the value of the entry. String if the type is INLINE_TEXT or VALUE_TYPE,
     * OMElement otherwise.
     * @return Either an OMElement or a String
     */
    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    /**
     *
     * @return mapper
     */
    public XMLToObjectMapper getMapper() {
        return mapper;
    }

    /**
     *
     * @param mapper
     */
    public void setMapper(XMLToObjectMapper mapper) {
        this.mapper = mapper;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public long getExpiryTime() {
        return expiryTime;
    }

    public void setExpiryTime(long expiryTime) {
        this.expiryTime = expiryTime;
    }

    public boolean isExpired() {
        if(getType() == REMOTE_ENTRY) {
            return System.currentTimeMillis() > expiryTime;
        } else {
            return false;
        }
    }

    public boolean isCached() {
        return value != null;
    }

    public boolean isDynamic() {
        return type == REMOTE_ENTRY;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public static final int INLINE_TEXT = 0;
    public static final int INLINE_XML = 1;
    public static final int URL_SRC = 2;
    public static final int REMOTE_ENTRY = 3;
}
"
org/apache/synapse/config/xml/ValidateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.apache.synapse.config.xml.MediatorSerializer;
import org.apache.synapse.config.xml.AbstractListMediatorSerializer;

import java.util.Iterator;

/**
 * <validate [source=""xpath""]>
 *   <schema key=""string"">+
 *   <property name=""<validation-feature-id>"" value=""true|false""/> *
 *   <on-fail>
 *     mediator+
 *   </on-fail>
 * </validate>
 */
public class ValidateMediatorSerializer extends AbstractListMediatorSerializer
    implements MediatorSerializer {

    private static final Log log = LogFactory.getLog(ValidateMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ValidateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        ValidateMediator mediator = (ValidateMediator) m;
        OMElement validate = fac.createOMElement(""validate"", synNS);
        finalizeSerialization(validate,mediator);

        if (mediator.getSource() != null) {
            validate.addAttribute(fac.createOMAttribute(
                ""source"", nullNS, mediator.getSource().toString()));
            serializeNamespaces(validate, mediator.getSource());
        }

        Iterator iter = mediator.getSchemaKeys().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            OMElement schema = fac.createOMElement(""schema"", synNS, validate);
            schema.addAttribute(fac.createOMAttribute(""key"", nullNS, key));
        }

        serializeProperties(validate, mediator.getProperties());

        OMElement onFail = fac.createOMElement(""on-fail"", synNS, validate);
        serializeChildren(onFail, mediator.getList());        

        if (parent != null) {
            parent.addChild(validate);
        }
        return validate;
    }

    public String getMediatorClassName() {
        return ValidateMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/AbstractMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.Constants;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;

/**
 * This class is an abstract Mediator, that defines the logging and debugging
 * elements of a mediator class.
 */
public abstract class AbstractMediator implements Mediator {

    /** The parent tracing state */
     protected  int parentTraceState = Constants.TRACING_UNSET;

    /** State of tracing for the current mediator */
     protected int traceState = Constants.TRACING_UNSET;

    /**
     * Returns the class name of the mediator
     *
     * @return the class name of the mediator
     */
    public String getType() {
        String cls = getClass().getName();
        int p = cls.lastIndexOf(""."");
        if (p == -1)
            return cls;
        else
            return cls.substring(p + 1);
    }

    /**
     * Returns the tracing state
     *
     * @return int
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing state variable
     *
     * @param traceState
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    /**
     * This method is used to save previous tracing state and set next the tracing state for a child
     * mediator
     *
     * @param synCtx current message
     */
    public void saveAndSetTraceState(MessageContext synCtx) {
        parentTraceState = synCtx.getTracingState();
        synCtx.setTracingState(traceState);
    }

    /**
     * This method is used to restore parent tracing state back
     * @param synCtx the current message
     */
    public void restoreTracingState(MessageContext synCtx){
        synCtx.setTracingState(parentTraceState);
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param parentTraceState parents trace state
     * @return true if tracing should be performed
     */
    public boolean shouldTrace(int parentTraceState){
        return (traceState == Constants.TRACING_ON) ||
                (traceState == Constants.TRACING_UNSET &&
                parentTraceState == Constants.TRACING_ON);
    }
}
"
org/apache/synapse/endpoints/utils/EndpointDefinition.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.utils;

import org.apache.synapse.Constants;


/**
 * Endpoint definition contains the information about an web services endpoint. It is used by leaf
 * level endpoints to keep these information (e.g. AddressEndpoint and WSDLEndpoint). An EndpointDefinition
 * object is used by only one endpoint and they cannot be looked up in the registry.
 */
public class EndpointDefinition {

    /** The simple address this endpoint resolves to - if explicitly specified */
    private String address = null;
    /** Should messages be sent in an WS-RM Sequence ? */
    private boolean reliableMessagingOn = false;
    /** Should messages be sent using WS-A? */
    private boolean addressingOn = false;
    /** Should messages be sent using WS-Security? */
    private boolean securityOn = false;
    /** The ""key"" for any WS-RM Policy overrides to be used */
    private String wsRMPolicyKey = null;
    /** The ""key"" for any Rampart Security Policy to be used */
    private String wsSecPolicyKey = null;
    /** use a separate listener - implies addressing is on **/
	private boolean useSeparateListener = false;
	/** force REST on **/
	private boolean forcePOX = false;
	/** force SOAP on **/
	private boolean forceSOAP = false;
    /** use MTOM **/
    private boolean useMTOM = false;
    /** use SWA **/
    private boolean useSwa = false;

    /**
     * timeout duration for waiting for a response. if the user has set some timeout action and
     * the timeout duration is not set, default is set to 0 seconds. note that if the user has
     * not set any timeout configuration, default timeout action is set to NONE, which won't do
     * anything for timeouts.
    */
    private long timeoutDuration = 0;

    /** action to perform when a timeout occurs (NONE | DISCARD | DISCARD_AND_FAULT) **/
    private int timeoutAction = Constants.NONE;

    /** To decide to whether statistics should have collected or not */
    private int statisticsEnable = Constants.STATISTICS_UNSET;

    /**
     * This should return the absolute EPR address referenced by the named endpoint. This may be possibly computed.
     * @return an absolute address to be used to reference the named endpoint
     */
    public String getAddress() {
        return address;
    }

    /**
     * Set an absolute URL as the address for this named endpoint
     * @param address the absolute address to be used
     */
    public void setAddress(String address) {
        this.address = address;
    }

    /**
     * Is RM turned on on this endpoint?
     * @return true if on
     */
    public boolean isReliableMessagingOn() {
        return reliableMessagingOn;
    }

    /**
     * Request that RM be turned on/off on this endpoint
     * @param reliableMessagingOn
     */
    public void setReliableMessagingOn(boolean reliableMessagingOn) {
        this.reliableMessagingOn = reliableMessagingOn;
    }

    /**
     * Is WS-A turned on on this endpoint?
     * @return true if on
     */
    public boolean isAddressingOn() {
        return addressingOn;
    }

    /**
     * Request that WS-A be turned on/off on this endpoint
     * @param addressingOn
     */
    public void setAddressingOn(boolean addressingOn) {
        this.addressingOn = addressingOn;
    }

    /**
     * Is WS-Security turned on on this endpoint?
     * @return true if on
     */
    public boolean isSecurityOn() {
        return securityOn;
    }

    /**
     * Request that WS-Sec be turned on/off on this endpoint
     * @param securityOn
     */
    public void setSecurityOn(boolean securityOn) {
        this.securityOn = securityOn;
    }

    /**
     * Return the Rampart Security configuration policys' 'key' to be used (See Rampart)
     * @return the ORampart Security configuration policys' 'key' to be used (See Rampart)
     */
    public String getWsSecPolicyKey() {
        return wsSecPolicyKey;
    }

    /**
     * Set the Rampart Security configuration policys' 'key' to be used (See Rampart)
     * @param wsSecPolicyKey the Rampart Security configuration policys' 'key' to be used (See Rampart)
     */
    public void setWsSecPolicyKey(String wsSecPolicyKey) {
        this.wsSecPolicyKey = wsSecPolicyKey;
    }

    /**
     * Get the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     * @return the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     */
    public String getWsRMPolicyKey() {
        return wsRMPolicyKey;
    }

    /**
     * Set the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     * @param wsRMPolicyKey the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     */
    public void setWsRMPolicyKey(String wsRMPolicyKey) {
        this.wsRMPolicyKey = wsRMPolicyKey;
    }

	public void setUseSeparateListener(boolean b) {
		this.useSeparateListener = b;
	}
	public boolean isUseSeparateListener() {
		return useSeparateListener;
	}

	public void setForcePOX(boolean forcePOX) {
		this.forcePOX = forcePOX;
	}

	public boolean isForcePOX() {
		return forcePOX;
	}

	public void setForceSOAP(boolean forceSOAP) {
		this.forceSOAP = forceSOAP;
	}

	public boolean isForceSOAP() {
		return forceSOAP;
	}

    public boolean isUseMTOM() {
        return useMTOM;
    }

    public void setUseMTOM(boolean useMTOM) {
        this.useMTOM = useMTOM;
    }

    public boolean isUseSwa() {
        return useSwa;
    }

    public void setUseSwa(boolean useSwa) {
        this.useSwa = useSwa;
    }

    public long getTimeoutDuration() {
        return timeoutDuration;
    }

    public void setTimeoutDuration(long timeoutDuration) {
        this.timeoutDuration = timeoutDuration;
    }

    public int getTimeoutAction() {
        return timeoutAction;
    }

    public void setTimeoutAction(int timeoutAction) {
        this.timeoutAction = timeoutAction;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsEnable() {
        return statisticsEnable;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsEnable
     */
    public void setStatisticsEnable(int statisticsEnable) {
        this.statisticsEnable = statisticsEnable;
    }
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Serializes AddressEndpoint to XML.
 *
 * <endpoint [name=""name""]>
 *  <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *  <address uri=""url"">
 *
 *    .. extensibility ..
 *
 *    <!-- Axis2 Rampart configurations : may be obsolete soon -->
 *    <parameter name=""OutflowSecurity"">
 *      ...
 *    </parameter>+
 *
 *    <!-- Apache Sandesha configurations : may be obsolete soon -->
 *    <wsp:Policy xmlns:wsp=""http://schemas.xmlsoap.org/ws/2004/09/policy""..
 *      xmlns:wsrm=""http://ws.apache.org/sandesha2/policy"" wsu:Id=""RMPolicy"">
 *      ...
 *    </Policy>+
 *
 *    <enableRM/>+
 *    <enableSec/>+
 *    <enableAddressing/>+
 *
 *    <timeout>
 *      <duration>duration in milliseconds</duration>
 *      <action>discard | fault</action>
 *    </timeout>
 *
 *  </address>
 * </endpoint>
 */
public class AddressEndpointSerializer implements EndpointSerializer {

    private static Log log = LogFactory.getLog(AddressEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof AddressEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        AddressEndpoint addressEndpoint = (AddressEndpoint) endpoint;
        String name = addressEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        EndpointDefinition epAddress = addressEndpoint.getEndpoint();
        OMElement addressElement = serializeEndpointDefinition(epAddress);
        endpointElement.addChild(addressElement);

        long suspendDuration = addressEndpoint.getSuspendOnFailDuration();
        if (suspendDuration != -1) {
            // user has set some value for this. let's serialize it.

            OMElement suspendElement = fac.createOMElement(
                    org.apache.synapse.config.xml.Constants.SUSPEND_DURATION_ON_FAILURE,
                    Constants.SYNAPSE_OMNAMESPACE);

            suspendElement.setText(Long.toString(suspendDuration / 1000));
            addressElement.addChild(suspendElement);
        }

        return endpointElement;
    }

    public OMElement serializeEndpointDefinition(EndpointDefinition endpt) {

        OMElement address = fac.createOMElement(""address"", Constants.SYNAPSE_OMNAMESPACE);

        if (endpt.isForcePOX()) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
        } else if (endpt.isForceSOAP()) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""soap""));
        }
        if (endpt.isUseSwa()) {
            address.addAttribute(fac.createOMAttribute(""optimize"", null, ""swa""));
        } else if (endpt.isUseMTOM()) {
            address.addAttribute(fac.createOMAttribute(""optimize"", null, ""mtom""));
        }
        if (endpt.getAddress() != null) {
            address.addAttribute(fac.createOMAttribute(
                    ""uri"", null, endpt.getAddress()));
        } else {
            handleException(""Invalid Endpoint. Address is required"");
        }

        int isEnableStatistics = endpt.getStatisticsEnable();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_ON) {
            statisticsValue = org.apache.synapse.config.xml.Constants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_OFF) {
            statisticsValue = org.apache.synapse.config.xml.Constants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            address.addAttribute(fac.createOMAttribute(
                    org.apache.synapse.config.xml.Constants.STATISTICS_ATTRIB_NAME, null, statisticsValue));
        }
        if (endpt.isAddressingOn()) {
            OMElement addressing = fac.createOMElement(""enableAddressing"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpt.isUseSeparateListener()) {
                addressing.addAttribute(fac.createOMAttribute(
                        ""separateListener"", null, ""true""));
            }
            address.addChild(addressing);
        }

        if (endpt.isReliableMessagingOn()) {
            OMElement rm = fac.createOMElement(""enableRM"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpt.getWsRMPolicyKey() != null) {
                rm.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpt.getWsRMPolicyKey()));
            }
            address.addChild(rm);
        }

        if (endpt.isSecurityOn()) {
            OMElement sec = fac.createOMElement(""enableSec"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpt.getWsSecPolicyKey() != null) {
                sec.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpt.getWsSecPolicyKey()));
            }
            address.addChild(sec);
        }

        if (endpt.getTimeoutAction() != Constants.NONE) {
            OMElement timeout = fac.createOMElement(""timeout"", Constants.SYNAPSE_OMNAMESPACE);
            address.addChild(timeout);

            OMElement duration = fac.createOMElement(""duration"", Constants.SYNAPSE_OMNAMESPACE);
            duration.setText(Long.toString(endpt.getTimeoutDuration() / 1000));
            timeout.addChild(duration);

            OMElement action = fac.createOMElement(""action"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpt.getTimeoutAction() == Constants.DISCARD) {
                action.setText(""discard"");
            } else if (endpt.getTimeoutAction() == Constants.DISCARD_AND_FAULT) {
                action.setText(""fault"");
            }
            timeout.addChild(action);
        }

        return address;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/SequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

/**
 * <pre>
 * &lt;sequence name=""string"" [onError=""string""]&gt;
 *   mediator+
 * &lt;/sequence&gt;
 * </pre>
 * <p/>
 * OR
 * <p/>
 * <pre>
 * &lt;sequence key=""name""/&gt;
 * </pre>
 */
public class SequenceMediatorSerializer extends AbstractListMediatorSerializer {

    private static final Log log = LogFactory.getLog(SequenceMediatorSerializer.class);

    public OMElement serializeAnonymousSequence(OMElement parent, SequenceMediator mediator) {
        OMElement sequence = fac.createOMElement(""sequence"", synNS);
        int isEnableStatistics = mediator.getStatisticsEnable();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_ON) {
            statisticsValue = Constants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_OFF) {
            statisticsValue = Constants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    Constants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }
        if (mediator.getErrorHandler() != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""onError"", nullNS, mediator.getErrorHandler()));
        }
        finalizeSerialization(sequence, mediator);
        serializeChildren(sequence, mediator.getList());
        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SequenceMediator mediator = (SequenceMediator) m;
        OMElement sequence = fac.createOMElement(""sequence"", synNS);

        // is this a dynamic sequence we loaded from a registry? if so we have no work to here
        // except make sure that we refer back to the registry key used when we loaded ourself
        if (mediator.isDynamic()) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
            sequence.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, mediator.getRegistryKey()));

        } else {

            int isEnableStatistics = mediator.getStatisticsEnable();
            String statisticsValue = null;
            if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_ON) {
                statisticsValue = Constants.STATISTICS_ENABLE;
            } else if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_OFF) {
                statisticsValue = Constants.STATISTICS_DISABLE;
            }
            if (statisticsValue != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        Constants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
            }

            if (mediator.getKey() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""key"", nullNS, mediator.getKey()));
            } else if (mediator.getName() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""name"", nullNS, mediator.getName()));

                if (mediator.getErrorHandler() != null) {
                    sequence.addAttribute(fac.createOMAttribute(
                            ""onError"", nullNS, mediator.getErrorHandler()));
                }
                finalizeSerialization(sequence, mediator);
                serializeChildren(sequence, mediator.getList());
            }
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return SequenceMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/mediators/FilterMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.MessageContext;

/**
 * The filter mediator is a list mediator, which executes the given (sub) list of mediators
 * if the specified condition is satisfied
 *
 * @see FilterMediator#test(org.apache.synapse.MessageContext)
 */
public interface FilterMediator extends ListMediator {

    /**
     * Should return true if the sub/child mediators should execute. i.e. if the filter
     * condition is satisfied
     * @param synCtx
     * @return true if the configured filter condition evaluates to true
     */
    public boolean test(MessageContext synCtx);
}
"
org/apache/synapse/config/xml/LogMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import javax.xml.namespace.QName;

/**
 * Created a Log mediator that logs messages using commons-logging.
 *
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorFactory extends AbstractMediatorFactory  {

    private static final Log log = LogFactory.getLog(LogMediatorFactory.class);

    private static final QName LOG_Q    = new QName(Constants.SYNAPSE_NAMESPACE, ""log"");
    private static final String SIMPLE  = ""simple"";
    private static final String HEADERS = ""headers"";
    private static final String FULL    = ""full"";
    private static final String CUSTOM  = ""custom"";

    public QName getTagQName() {
        return LOG_Q;
    }

    public Mediator createMediator(OMElement elem) {

        LogMediator logMediator = new LogMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(logMediator,elem);
        
        // Set the high level set of properties to be logged (i.e. log level)
        OMAttribute level = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""level""));
        if (level != null) {
            String levelstr = level.getAttributeValue();
            if (SIMPLE.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.SIMPLE);
            } else if (HEADERS.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.HEADERS);
            } else if (FULL.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.FULL);
            } else if (CUSTOM.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.CUSTOM);
            }
        }

        // check if a custom separator has been supplied, if so use it
        OMAttribute separator = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""separator""));
        if (separator != null) {
            logMediator.setSeparator(separator.getAttributeValue());
        }

        logMediator.addAllProperties(MediatorPropertyFactory.getMediatorProperties(elem));

        return logMediator;
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.config.xml.endpoints.utils.WSDL11EndpointBuilder;
import org.apache.synapse.config.xml.endpoints.utils.WSDL20EndpointBuilder;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axis2.description.WSDL2Constants;
import org.apache.synapse.config.Util;

import javax.xml.namespace.QName;
import java.net.URL;
import java.net.URLConnection;
import java.io.InputStream;
import java.io.IOException;

/**
 * Creates an WSDL based endpoint from a XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *    <wsdl uri=""wsdl uri"" service=""service name"" port=""port name"">
 *       .. extensibility ..
 *    </wsdl>
 * </endpoint>
 */
public class WSDLEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(WSDLEndpointFactory.class);

    private static WSDLEndpointFactory instance = new WSDLEndpointFactory();

    private WSDLEndpointFactory() {}

    public static WSDLEndpointFactory getInstance() {
        return instance;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        WSDLEndpoint wsdlEndpoint = new WSDLEndpoint();

        if (!anonymousEndpoint) {
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                wsdlEndpoint.setName(name.getAttributeValue());
            }
        }

        OMElement wsdlElement = epConfig.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""wsdl""));

        if (wsdlElement != null) {

            // set the suspend on fail duration.
            OMElement suspendElement = wsdlElement.getFirstChildWithName(new QName(
                    Constants.SYNAPSE_NAMESPACE,
                    org.apache.synapse.config.xml.Constants.SUSPEND_DURATION_ON_FAILURE));

            if (suspendElement != null) {
                String suspend = suspendElement.getText();

                try {
                    if (suspend != null) {
                        long suspendDuration = Long.parseLong(suspend.trim());
                        wsdlEndpoint.setSuspendOnFailDuration(suspendDuration * 1000);
                    }

                } catch (NumberFormatException e) {
                    handleException(""suspendDurationOnFailure should be valid number."");
                }
            }

            EndpointDefinition endpoint = null;

            // get the service name and port name. at this point we should not worry about the presence
            // of those parameters. they are handled by corresponding WSDL builders.
            String serviceName = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.Constants.NULL_NAMESPACE,""service""));

            String portName = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.Constants.NULL_NAMESPACE,""port""));

            // check if wsdl is supplied as a URI
            String wsdlURI = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.Constants.NULL_NAMESPACE,""uri""));

            // set serviceName and portName in the endpoint. it does not matter if these are
            // null at this point. we are setting them only for serialization purpose.
            wsdlEndpoint.setServiceName(serviceName);
            wsdlEndpoint.setPortName(portName);

            if (wsdlURI != null) {
                wsdlEndpoint.setWsdlURI(wsdlURI.trim());

                try {
                    String ns = Util.getOMElementFromURL(new URL(wsdlURI).toString())
                        .getNamespace().getNamespaceURI();

                    if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.equals(ns)) {
                        endpoint = new WSDL11EndpointBuilder().
                                createEndpointDefinitionFromWSDL(wsdlURI, serviceName, portName);

                    } else if (WSDL2Constants.WSDL_NAMESPACE.equals(ns)) {
                        //endpoint = new WSDL20EndpointBuilder().
                        //        createEndpointDefinitionFromWSDL(wsdlURI, serviceName, portName);

                        handleException(""WSDL 2.0 Endpoints are currently not supported"");
                    }

                } catch (Exception e) {
                    handleException(""Couldn't create endpoint from the given WSDL URI : ""
                        + e.getMessage(), e);
                }
            }

            // check if the wsdl 1.1 document is suppled inline
            OMElement definitionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""definitions""));
            if (endpoint == null && definitionElement != null) {
                wsdlEndpoint.setWsdlDoc(definitionElement);

                endpoint = new WSDL11EndpointBuilder().
                        createEndpointDefinitionFromWSDL(definitionElement, serviceName, portName);
            }

            // check if a wsdl 2.0 document is supplied inline
            OMElement descriptionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""description""));
            if (endpoint == null && descriptionElement != null) {
                wsdlEndpoint.setWsdlDoc(descriptionElement);
                handleException(""WSDL 2.0 Endpoints are currently not supported."");
            }
            if (endpoint != null) {
                // for now, QOS information has to be provided explicitly.
                extractQOSInformation(endpoint, wsdlElement);
                OMAttribute statistics = epConfig.getAttribute(
                        new QName(org.apache.synapse.config.xml.Constants.NULL_NAMESPACE,
                                org.apache.synapse.config.xml.Constants.STATISTICS_ATTRIB_NAME));
                if (statistics != null) {
                    String statisticsValue = statistics.getAttributeValue();
                    if (statisticsValue != null) {
                        if (org.apache.synapse.config.xml.Constants.STATISTICS_ENABLE.equals(
                                statisticsValue)) {
                            endpoint.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_ON);
                        } else if (org.apache.synapse.config.xml.Constants.STATISTICS_DISABLE.equals(
                                statisticsValue)) {
                            endpoint.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_OFF);
                        }
                    }
                }
                wsdlEndpoint.setEndpointDefinition(endpoint);
            } else {
                handleException(""WSDL is not specified for WSDL endpoint."");
            }
        }

        return wsdlEndpoint;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void extractQOSInformation(EndpointDefinition endpointDefinition, OMElement wsdlElement) {

        OMAttribute format = wsdlElement.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""format""));
        OMAttribute optimize = wsdlElement.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""optimize""));

        if (format != null)
        {
            String forceValue = format.getAttributeValue().trim().toLowerCase();
            if (forceValue.equals(""pox"")) {
                endpointDefinition.setForcePOX(true);
            } else if (forceValue.equals(""soap"")) {
                endpointDefinition.setForceSOAP(true);
            } else {
                handleException(""force value -\""""+forceValue+""\"" not yet implemented"");
            }
        }

        if (optimize != null && optimize.getAttributeValue().length() > 0) {
            String method = optimize.getAttributeValue().trim();
            if (""mtom"".equalsIgnoreCase(method)) {
                endpointDefinition.setUseMTOM(true);
            } else if (""swa"".equalsIgnoreCase(method)) {
                endpointDefinition.setUseSwa(true);
            }
        }

        OMElement wsAddr = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableAddressing""));
        if (wsAddr != null) {
            endpointDefinition.setAddressingOn(true);
            String useSepList = wsAddr.getAttributeValue(new QName(
                    ""separateListener""));
            if (useSepList != null) {
                if (useSepList.trim().toLowerCase().startsWith(""tr"")
                        || useSepList.trim().startsWith(""1"")) {
                    endpointDefinition.setUseSeparateListener(true);
                }
            }
        }

        OMElement wsSec = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableSec""));
        if (wsSec != null) {
            endpointDefinition.setSecurityOn(true);
            OMAttribute policy = wsSec.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpointDefinition.setWsSecPolicyKey(policy.getAttributeValue());
            }
        }
        OMElement wsRm = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableRM""));
        if (wsRm != null) {
            endpointDefinition.setReliableMessagingOn(true);
            OMAttribute policy = wsRm.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpointDefinition.setWsRMPolicyKey(policy.getAttributeValue());
            }
        }

        // set the timeout configuration
        OMElement timeout = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""timeout""));
        if (timeout != null) {
            OMElement duration = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""duration""));
            if (duration != null) {
                String d = duration.getText();
                if (d != null) {
                    long timeoutSeconds = new Long(d.trim()).longValue();
                    endpointDefinition.setTimeoutDuration(timeoutSeconds * 1000);
                }
            }

            OMElement action = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""action""));
            if (action != null) {
                String a = action.getText();
                if (a != null) {
                    if ((a.trim()).equalsIgnoreCase(""discard"")) {
                        endpointDefinition.setTimeoutAction(Constants.DISCARD);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpointDefinition.getTimeoutDuration() == 0) {
                            endpointDefinition.setTimeoutDuration(30000);
                        }
                    } else if ((a.trim()).equalsIgnoreCase(""fault"")) {
                        endpointDefinition.setTimeoutAction(Constants.DISCARD_AND_FAULT);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpointDefinition.getTimeoutDuration() == 0) {
                            endpointDefinition.setTimeoutDuration(30000);
                        }
                    }
                }
            }
        }
    }
}
"
org/apache/synapse/config/xml/AbstractListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ListMediator;
import org.apache.synapse.Mediator;

import java.util.Iterator;

/**
 * This implements the basic logic to build a list mediator from a given XML
 * configuration. It recursively builds the child mediators of the list.
 */
public abstract class AbstractListMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(AbstractListMediatorFactory.class);

    protected static void addChildren(OMElement el, ListMediator m) {
        Iterator it = el.getChildElements();
        while (it.hasNext()) {
            OMElement child = (OMElement) it.next();
            Mediator med = MediatorFactoryFinder.getInstance().getMediator(child);
            if (med != null) {
                m.addChild(med);
            } else {
                String msg = ""Unknown mediator : "" + child.getLocalName();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }
}
"
org/apache/synapse/config/Util.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URI;
import java.net.MalformedURLException;

public class Util {

    private static final Log log = LogFactory.getLog(Util.class);

    /**
     * Return a StreamSource for the given Object
     * @param o the object
     * @return the StreamSource
     */
    public static StreamSource getStreamSource(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMNode) {
            OMNode omNode = (OMNode) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omNode.serialize(baos);
                return new StreamSource(new ByteArrayInputStream(baos.toByteArray()));
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else {
            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    public static InputStream getInputStream(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMElement) {
            OMElement omElement = (OMElement) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omElement.serialize(baos);
                return new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else if (o instanceof URI){
            try {
                return ((URI)(o)).toURL().openStream();                   
            } catch (IOException e) {
                handleException(""Error opening stream form URI"",e);
            }
        }
        else {
            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    /**
     * Get an object from a given URL. Will first fetch the content from the
     * URL and depending on the content-type, a suitable XMLToObjectMapper
     * (if available) would be used to transform this content into an Object.
     * If a suitable XMLToObjectMapper cannot be found, the content would be
     * treated as XML and an OMNode would be returned
     * @param url the URL to the resource
     * @return an Object created from the given URL
     */
    public static Object getObject(URL url) {
        try {
            URLConnection urlc = url.openConnection();
            XMLToObjectMapper xmlToObject =
                getXmlToObjectMapper(urlc.getContentType());

            try {
                XMLStreamReader parser = XMLInputFactory.newInstance().
                    createXMLStreamReader(urlc.getInputStream());
                StAXOMBuilder builder = new StAXOMBuilder(parser);
                OMElement omElem =  builder.getDocumentElement();

                // detach from URL connection and keep in memory
                // TODO remove this 
                omElem.build();

                if (xmlToObject != null) {
                    return xmlToObject.getObjectFromOMNode(omElem);
                } else {
                    return omElem;
                }

            } catch (XMLStreamException e) {
                log.warn(""Content at URL : "" + url + "" is non XML.."");
                return urlc.getContent();
            }

        } catch (IOException e) {
            handleException(""Error connecting to URL : "" + url, e);
        }
        return null;
    }

    /**
     * Return an OMElement from a URL source
     * @param url a URL string
     * @return an OMElement of the resource
     * @throws IOException for invalid URL's or IO errors
     */
    public static OMElement getOMElementFromURL(String url) throws IOException {
        URLConnection conn = new URL(url).openConnection();
        conn.setReadTimeout(10000);
        conn.setConnectTimeout(2000);
        conn.setRequestProperty(""Connection"", ""close""); // if http is being used
        InputStream urlInStream = conn.getInputStream();

        if (urlInStream != null) {
            try {
                StAXOMBuilder builder = new StAXOMBuilder(urlInStream);
                OMElement doc = builder.getDocumentElement();
                doc.build();
                return doc;
            } catch (Exception e) {
                handleException(""Error parsing resource at URL : "" + url +
                    "" as XML"", e);
            } finally {
                try {
                    urlInStream.close();
                } catch (IOException ignore) {}
            }
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Return a suitable XMLToObjectMapper for the given content type if one
     * is available, else return null;
     * @param contentType the content type for which a mapper is required
     * @return a suitable XMLToObjectMapper or null if none can be found
     */
    public static XMLToObjectMapper getXmlToObjectMapper(String contentType) {
        return null;
    }
}
"
org/apache/synapse/config/xml/RMSequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;
import org.jaxen.JaxenException;

/**
 * Creates a RMSequence mediator through the supplied XML configuration
 * <p/>
 * <pre>
 * &lt;RMSequence (correlation=""xpath"" [last-message=""xpath""]) | single=""true"" [version=""1.0|1.1""]/&gt;
 * </pre>
 */
public class RMSequenceMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(LogMediatorFactory.class);

    private static final QName SEQUENCE_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""RMSequence"");

    public Mediator createMediator(OMElement elem) {

        RMSequenceMediator sequenceMediator = new RMSequenceMediator();
        OMAttribute correlation =
            elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""correlation""));
        OMAttribute lastMessage =
            elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""last-message""));
        OMAttribute single = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""single""));
        OMAttribute version = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""version""));

        if (single == null && correlation == null) {
            String msg = ""The 'single' attribute value of true or a 'correlation' attribute is "" +
                ""required for the configuration of a RMSequence mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (correlation != null) {
            if (correlation.getAttributeValue() != null &&
                correlation.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for correlation"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setCorrelation(new AXIOMXPath(correlation.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute correlation : ""
                        + correlation.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(sequenceMediator.getCorrelation(), elem, log);
        }

        if (single != null) {
            sequenceMediator.setSingle(Boolean.valueOf(single.getAttributeValue()));
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getCorrelation() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);

        } else if (!sequenceMediator.isSingle() && sequenceMediator.getCorrelation() == null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence must have a ""
                + ""single attribute value of true or a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (lastMessage != null) {
            if (lastMessage.getAttributeValue() != null &&
                lastMessage.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for last-message"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setLastMessage(new AXIOMXPath(lastMessage.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute last-message : ""
                        + lastMessage.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(sequenceMediator.getLastMessage(), elem, log);
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getLastMessage() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a last-message attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (version != null) {
            if (!Constants.SEQUENCE_VERSION_1_0.equals(version.getAttributeValue()) &&
                !Constants.SEQUENCE_VERSION_1_1.equals(version.getAttributeValue())) {
                String msg = ""Only '"" + Constants.SEQUENCE_VERSION_1_0 + ""' or '"" +
                    Constants.SEQUENCE_VERSION_1_1
                    + ""' values are allowed for attribute version for a RMSequence mediator""
                    + "", Unsupported version "" + version.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            sequenceMediator.setVersion(version.getAttributeValue());
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(sequenceMediator, elem);

        return sequenceMediator;
    }

    public QName getTagQName() {
        return SEQUENCE_Q;
    }
}
"
org/apache/synapse/statistics/impl/ProxyServiceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * The data structure to hold statistics related to the Proxy Services
 *
 */

public class ProxyServiceStatisticsStack implements StatisticsStack {

    private static final Log log = LogFactory.getLog(ProxyServiceStatisticsStack.class);
    /** The name of the proxy service*/
    private String proxyServiceName;
    /** To check whether statistics is enabled or not */
    private boolean isStatisticsEnable = false;
    /** The time which starts to collect statistics for IN flow */
    private long inTimeForInFlow = -1;
    /** The time which starts to collect statistics for OUT flow */
    private long inTimeForOutFlow = -1;
    /** To indicate whether IN Flow is fault or not*/
    private boolean isINFault;
    /** To indicate whether OUT Flow is fault or not*/
    private boolean isOUTFault;

    /**
     * To put a statistics
     * @param key                   - The Name of the proxy service
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (isInFlow) {
            this.proxyServiceName = key;
            this.isStatisticsEnable = isStatisticsEnable;
            this.inTimeForInFlow = initTime;
            this.isINFault = isFault;
        }
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        if (proxyServiceName != null && isStatisticsEnable && inTimeForInFlow != -1) {
            inTimeForOutFlow = System.currentTimeMillis();
            isOUTFault = isFault;
            statisticsCollector.reportForProxyService(proxyServiceName, false,
                    inTimeForInFlow, inTimeForOutFlow, isINFault);
            inTimeForInFlow = -1;
        } else if (inTimeForOutFlow != -1) {
            statisticsCollector.reportForProxyService(proxyServiceName, true,
                    inTimeForOutFlow, System.currentTimeMillis(), isFault);
            inTimeForOutFlow = -1;
        }
    }

    /**
     * Report a particular statistics to the StatisticsReporter
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (name != null && proxyServiceName != null && proxyServiceName.equals(name)) {
            reportToStatisticsCollector(statisticsCollector, isFault);
        } else {
            handleException(""Invalid ProxyService Name "" + name + "" expected "" + proxyServiceName);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        reportToStatisticsCollector(statisticsCollector, isFault);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/XSLTMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.apache.synapse.config.xml.AbstractMediatorSerializer;

/**
 * <pre>
 * &lt;xslt key=""property-key"" [source=""xpath""]&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/transform&gt;
 * </pre>
 */
public class XSLTMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(XSLTMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof XSLTMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        XSLTMediator mediator = (XSLTMediator) m;
        OMElement xslt = fac.createOMElement(""xslt"", synNS);

        if (mediator.getXsltKey() != null) {
            xslt.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, mediator.getXsltKey()));
        } else {
            handleException(""Invalid XSLT mediator. XSLT registry key is required"");
        }
        finalizeSerialization(xslt,mediator);

        if (mediator.getSource() != null &&
            !XSLTMediator.DEFAULT_XPATH.toString().equals(mediator.getSource().toString())) {
            xslt.addAttribute(fac.createOMAttribute(
                ""source"", nullNS, mediator.getSource().toString()));
            serializeNamespaces(xslt, mediator.getSource());
        }

        serializeProperties(xslt, mediator.getProperties());

        if (parent != null) {
            parent.addChild(xslt);
        }
        return xslt;
    }

    public String getMediatorClassName() {
        return XSLTMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/MediatorProperty.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.config.xml.Constants;

import javax.xml.namespace.QName;

/**
 * A mediator property is a name-value or name-expression pair which could be supplied
 * for certain mediators. If expressions are supplied they are evaluated at the runtime
 * against the current message into literal String values.
 */
public class MediatorProperty {

    public static final QName PROPERTY_Q  = new QName(Constants.SYNAPSE_NAMESPACE, ""property"");
    public static final QName ATT_NAME_Q  = new QName(Constants.NULL_NAMESPACE, ""name"");
    public static final QName ATT_VALUE_Q = new QName(Constants.NULL_NAMESPACE, ""value"");
    public static final QName ATT_EXPR_Q  = new QName(Constants.NULL_NAMESPACE, ""expression"");

    private String name;
    private String value;
    private AXIOMXPath expression;

    public MediatorProperty() {}

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    public String getEvaluatedExpression(MessageContext synCtx) {
        return Axis2MessageContext.getStringValue(expression, synCtx);
    }

}
"
org/apache/synapse/registry/url/URLRegistryEntry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry.url;

import org.apache.synapse.registry.RegistryEntry;

import java.net.URI;
import java.util.Date;

public class URLRegistryEntry implements RegistryEntry {

    private String key = null;
    private String name = null;
    private long version = Long.MIN_VALUE;
    private URI type = null;
    private String description;
    private long created;
    private long lastModified;
    private long cachableDuration;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public URI getType() {
        return type;
    }

    public void setType(URI type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getCreated() {
        return created;
    }

    public void setCreated(long created) {
        this.created = created;
    }

    public long getLastModified() {
        return lastModified;
    }

    public void setLastModified(long lastModified) {
        this.lastModified = lastModified;
    }

    public long getCachableDuration() {
        return cachableDuration;
    }

    public void setCachableDuration(long cachableDuration) {
        this.cachableDuration = cachableDuration;
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(""RegistryEntry {"")
            .append("" Key : "" + key)
            .append("" Name : "" + name)
            .append("" Ver : "" + version)
            .append("" Type : "" + type)
            .append("" Desc : "" + description)
            .append("" Created : "" + new Date(created))
            .append("" Modified : "" + new Date(lastModified))
            .append("" Cacheable for : "" + (cachableDuration / 1000) + ""sec"")
            .append(""}"");
        return sb.toString();
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointAbstractSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.*;
import org.apache.synapse.SynapseException;

/**
 * Abstract serialier for endpoint serializers. Use this class to obtain the EndpointSerializer
 * implementation for particular endpoint type.
 */
public class EndpointAbstractSerializer {

    /**
     * Returns the EndpointSerializer implementation for the given endpoint. Throws a SynapseException,
     * if there is no serializer for the given endpoint type.
     *
     * @param endpoint Endpoint implementaion.
     * @return EndpointSerializer implementation.
     */
    public static EndpointSerializer getEndpointSerializer(Endpoint endpoint) {

        if (endpoint instanceof AddressEndpoint) {
            return new AddressEndpointSerializer();
        } else if (endpoint instanceof WSDLEndpoint) {
            return new WSDLEndpointSerializer();
        } else if (endpoint instanceof IndirectEndpoint) {
            return new IndirectEndpointSerializer();
        } else if (endpoint instanceof LoadbalanceEndpoint) {
            return new LoadbalanceEndpointSerializer();
        } else if (endpoint instanceof SALoadbalanceEndpoint) {
            return new SALoadbalanceEndpointSerializer();
        } else if (endpoint instanceof FailoverEndpoint) {
            return new FailoverEndpointSerializer();
        }

        throw new SynapseException(""Serializer for endpoint "" +
                endpoint.getClass().toString() + "" is not defined."");
    }
}
"
org/apache/synapse/core/axis2/ProxyServiceMessageReceiver.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This is the MessageReceiver set to act on behalf of Proxy services.
 */
public class ProxyServiceMessageReceiver extends SynapseMessageReceiver {

    private static final Log log = LogFactory.getLog(ProxyServiceMessageReceiver.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * The name of the Proxy Service
     */
    private String name = null;

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        if (log.isDebugEnabled()) {
            log.debug(""Proxy Service "" + name + "" received a new message..."");
            log.debug(""Message To: "" + (mc.getTo() != null ? mc.getTo().getAddress() : ""null""));
            log.debug(""SOAPAction: "" + (mc.getSoapAction() != null ? mc.getSoapAction() : ""null""));
            log.debug(""WSA-Action: "" + (mc.getWSAAction() != null ? mc.getWSAAction() : ""null""));
            String[] cids = mc.getAttachmentMap().getAllContentIDs();
            if (cids != null && cids.length > 0) {
                for (int i = 0; i < cids.length; i++) {
                    log.debug(""Attachment : "" + cids[i]);
                }
            }
            log.debug(""Body : \n"" + mc.getEnvelope());
        }

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);

        try {
            synCtx.setProperty(org.apache.synapse.Constants.PROXY_SERVICE, name);
            ProxyService proxy = synCtx.getConfiguration().getProxyService(name);

            // Setting Required property to collect the proxy service statistics
            boolean statisticsEnable;
            if (proxy != null) {
                statisticsEnable = (
                        org.apache.synapse.Constants.STATISTICS_ON == proxy.getStatisticsEnable());
                if (statisticsEnable) {
                    ProxyServiceStatisticsStack proxyServiceStatisticsStack
                            = new ProxyServiceStatisticsStack();
                    boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                    proxyServiceStatisticsStack.put(name, System.currentTimeMillis(),
                            !synCtx.isResponse(), statisticsEnable, isFault);
                    synCtx.setProperty(org.apache.synapse.Constants.PROXYSERVICE_STATISTICS_STACK,
                            proxyServiceStatisticsStack);
                }
                boolean shouldTrace = (proxy.getTraceState() == Constants.TRACING_ON);
                if (shouldTrace) {
                    trace.trace(""Proxy Service "" + name + "" received a new message..."");
                    trace.trace(""Received Message :: "" + mc.getEnvelope());
                }
                if (proxy.getTargetFaultSequence() != null) {

                    Mediator faultSequence = synCtx.getSequence(proxy.getTargetFaultSequence());
                    if (faultSequence != null) {
                        log.debug(""Setting the fault-sequence of the "" +
                                ""proxy service to MessageContext"");
                        synCtx.pushFaultHandler(new MediatorFaultHandler(
                                synCtx.getSequence(proxy.getTargetFaultSequence())));
                    } else {
                        // when we can not find the reference to the fault sequence of the proxy
                        // service we should not throw an exception because still we have the global
                        // fault sequence and the message mediation can still continue
                        log.warn(""Unable to find the fault-sequence for the proxy service "" +
                                ""specified by the name "" + proxy.getTargetFaultSequence());
                    }
                } else if (proxy.getTargetInLineFaultSequence() != null) {
                    log.debug(""Setting the anonymous fault-sequence of the proxy to context"");
                    synCtx.pushFaultHandler(
                            new MediatorFaultHandler(proxy.getTargetInLineFaultSequence()));
                }

                // Using inSequence for the incoming message mediation
                if (proxy.getTargetInSequence() != null) {
                    Mediator inSequence = synCtx.getSequence(proxy.getTargetInSequence());
                    if (inSequence != null) {
                        String msg = ""Using the sequence named ""
                                + proxy.getTargetInSequence() + "" for message mediation"";
                        if (shouldTrace) {
                            trace.trace(msg);
                        }
                        log.debug(msg);
                        inSequence.mediate(synCtx);
                    } else {

                        log.error(""Unable to find the in-sequence for the proxy service "" +
                                ""specified by the name "" + proxy.getTargetInSequence());
                        throw new SynapseException(""Unable to find the in-sequence for the proxy "" +
                                ""service specified by the name "" + proxy.getTargetInSequence());
                    }
                } else if (proxy.getTargetInLineInSequence() != null) {
                    String msg = ""Using the anonymous "" +
                            ""in-sequence of the proxy service for message mediation"";
                    if (shouldTrace) {
                        trace.trace(msg);
                    }
                    log.debug(msg);
                    proxy.getTargetInLineInSequence().mediate(synCtx);
                }

                if (proxy.getTargetEndpoint() != null) {
                    Endpoint endpoint = synCtx.getEndpoint(proxy.getTargetEndpoint());
                    if (endpoint != null) {
                        String msg = ""Forwarding message to the endpoint named ""
                                + proxy.getTargetEndpoint() + "" after message mediation"";
                        if (shouldTrace) {
                            trace.trace(msg);
                        }
                        log.debug(msg);
                        endpoint.send(synCtx);
                    } else {

                        log.error(""Unable to find the endpoint for the proxy service "" +
                                ""specified by the name "" + proxy.getTargetEndpoint());
                        throw new SynapseException(""Unable to find the endpoint for the "" +
                                ""proxy service specified by the name "" + proxy.getTargetEndpoint());
                    }
                } else if (proxy.getTargetInLineEndpoint() != null) {
                    String msg = ""Forwarding the message to the anonymous "" +
                            ""endpoint of the proxy service after message mediation"";
                    if (shouldTrace) {
                        trace.trace(msg);
                    }
                    log.debug(msg);
                    proxy.getTargetInLineEndpoint().send(synCtx);
                }

            } else {
                log.error(""Proxy Service with the name "" + name + "" does not exists"");
                throw new SynapseException(
                        ""Proxy Service with the name "" + name + "" does not exists"");
            }
        } catch (SynapseException syne) {
            if (!synCtx.getFaultStack().isEmpty()) {
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);
            } else {
                log.error(""Synapse encountered an exception, "" +
                        ""No error handlers found - [Message Dropped]\n"" + syne.getMessage());
            }
        }

    }

    /**
     * Set the name of the corresponding proxy service
     *
     * @param name the proxy service name
     */
    public void setName(String name) {
        this.name = name;
    }

}
"
org/apache/synapse/endpoints/IndirectEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.FaultHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class represents the endpoints referred by keys. It does not store the actual referred
 * endpoint as a private variable as it could expire. Therefore, it only stores the key and gets the
 * actual endpoint from the synapse configuration.
 *
 * As this is also an instance of endpoint, this can be used any place, where a normal endpoint is used.
 */
public class IndirectEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(IndirectEndpoint.class);

    private String name = null;
    private String key = null;
    private boolean active = true;
    private Endpoint parentEndpoint = null;

    /**
     * This should have a reference to the current message context as it gets the referred endpoint
     * from it.
     */
    private MessageContext currentMsgCtx = null;

    public void send(MessageContext synMessageContext) {
        // get the actual endpoint and send
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        if (endpoint.isActive(synMessageContext)) {
            endpoint.send(synMessageContext);
        } else {

            // if this is a child of some other endpoint, inform parent about the failure.
            // if not, inform to the next fault handler.
            if (parentEndpoint != null) {
                parentEndpoint.onChildEndpointFail(this, synMessageContext);
            } else {
                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * IndirectEndpoints are active if its referref endpoint is active and vise versa. Therefore,
     * this returns if its referred endpoint is active or not.
     *
     * @param synMessageContext MessageContext of the current message.
     *
     * @return true if the referred endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        return endpoint.isActive(synMessageContext);
    }

    /**
     * Activating or deactivating an IndirectEndpoint is the activating or deactivating its
     * referref endpoint. Therefore, this sets the active state of its referred endpoint.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext of the current message.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        endpoint.setActive(active, synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {        

        // if this is a child of some other endpoint, inform parent about the failure.
        // if not, inform to the next fault handler.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);
        } else {
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/metrics/Constants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;
/*
 * 
 */

public final class Constants {
    public static String GLOBAL_REQUEST_COUNTER = ""__GLOBAL_REQUEST_COUNTER__"";
    public static String REQUEST_RECEIVED_TIME = ""__REQUEST_RECEIVED_TIME__"";
}
"
org/apache/synapse/config/xml/MediatorFactoryFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.xml.XSLTMediatorFactory;
import org.apache.synapse.config.xml.ValidateMediatorFactory;
import org.apache.synapse.config.XMLToObjectMapper;
import sun.misc.Service;

import javax.xml.namespace.QName;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 *
 * 
 * This class is based on J2SE Service Provider model
 * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
 */

public  class MediatorFactoryFinder implements XMLToObjectMapper {

	private static final Log log = LogFactory.getLog(MediatorFactoryFinder.class);

	private static final Class[] mediatorFactories = {
        SequenceMediatorFactory.class,
        LogMediatorFactory.class,
        SendMediatorFactory.class,         
        FilterMediatorFactory.class,
        SynapseMediatorFactory.class,
        DropMediatorFactory.class,
        HeaderMediatorFactory.class,
        FaultMediatorFactory.class,
        PropertyMediatorFactory.class,
        SwitchMediatorFactory.class,
        InMediatorFactory.class,
        OutMediatorFactory.class,
        RMSequenceMediatorFactory.class,          
        ClassMediatorFactory.class,
        ValidateMediatorFactory.class,
        XSLTMediatorFactory.class
    };

    private static MediatorFactoryFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap();

    public static synchronized MediatorFactoryFinder getInstance() {
        if (instance == null) {
            instance = new MediatorFactoryFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private MediatorFactoryFinder() {

        factoryMap = new HashMap();

        for (int i = 0; i < mediatorFactories.length; i++) {
			Class c = mediatorFactories[i];
			try {
                MediatorFactory fac = (MediatorFactory) c.newInstance();
                factoryMap.put(fac.getTagQName(), c);
            } catch (Exception e) {
				throw new SynapseException(""Error instantiating "" + c.getName(), e);
			}
		}
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        //log.debug(""Registering mediator extensions found in the classpath : "" + System.getResource(""java.class.path""));

        // register MediatorFactory extensions
        Iterator it = Service.providers(MediatorFactory.class);
        while (it.hasNext()) {
            MediatorFactory mf = (MediatorFactory) it.next();
            QName tag = mf.getTagQName();
            factoryMap.put(tag, mf.getClass());
            log.debug(""Added MediatorFactory "" + mf.getClass() + "" to handle "" + tag);
        }
    }

    /**
	 * This method returns a Processor given an OMElement. This will be used
	 * recursively by the elements which contain processor elements themselves
	 * (e.g. rules)
	 * 
	 * @param element
     * @return Processor
	 */
	public Mediator getMediator(OMElement element) {

        String localName = element.getLocalName();
        QName qName = null;
        if (element.getNamespace() != null) {
            qName = new QName(element.getNamespace().getNamespaceURI(), localName);
        } else {
            qName = new QName(localName);
        }
        log.debug(""getMediator("" + qName + "")"");
        Class cls = (Class) factoryMap.get(qName);

        if (cls == null && localName.indexOf('.') > -1) {
            String newLocalName = localName.substring(0, localName.indexOf('.'));
            qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);
            log.debug(""getMediator.2("" + qName + "")"");
            cls = (Class) factoryMap.get(qName);
        }

        if (cls == null) {
            String msg = ""Unknown mediator referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
			MediatorFactory mf = (MediatorFactory) cls.newInstance();
			return mf.createMediator(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
		}
	}
    /*
    This method exposes all the MediatorFactories and its Extensions 
    */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /**
     * Allow the mediator factory finder to act as an XMLToObjectMapper for Mediators
     * (i.e. Sequence Mediator) loaded dynamically from a Registry 
     * @param om
     * @return
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getMediator((OMElement) om);
        } else {
            handleException(""Invalid mediator configuration XML : "" + om);
        }
        return null;
    }
}
"
org/apache/synapse/SynapseServer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.axis2.util.OptionsParser;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.axis2.engine.ListenerManager;
import org.apache.axis2.description.TransportInDescription;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.io.File;
import java.util.Iterator;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * Starts all transports as specified on the axis2.xml
 */
public class SynapseServer {

    private static final Log log = LogFactory.getLog(SynapseServer.class);

    public static void printUsage() {
        System.out.println(""Usage: SynapseServer <repository>"");
        System.out.println("" Opts: -? this message"");
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {

        // first check if we should print usage
        if (args.length != 1 || !new File(args[0]).exists()) {
            printUsage();
        }

        System.out.println(""[SynapseServer] Using the Axis2 Repository ""
                + new File(args[0]).getAbsolutePath());

        try {
            ConfigurationContext configctx = ConfigurationContextFactory.
                createConfigurationContextFromFileSystem(args[0], null);

            ListenerManager listenerManager = configctx.getListenerManager();
            if (listenerManager == null) {
                listenerManager = new ListenerManager();
                listenerManager.init(configctx);
            }

            // decide on HTTP port to execute
            selectPort(configctx);

            Iterator iter = configctx.getAxisConfiguration().
                getTransportsIn().keySet().iterator();
            while (iter.hasNext()) {
                String trp = (String) iter.next();
                TransportInDescription trsIn = (TransportInDescription)
                    configctx.getAxisConfiguration().getTransportsIn().get(trp);
                listenerManager.addListener(trsIn, false);
                String msg = ""[SynapseServer] Starting transport "" + trsIn.getName();
                if (trsIn.getParameter(""port"") != null) {
                    msg += "" on port "" + trsIn.getParameter(""port"").getValue();
                }
                System.out.println(msg);
            }
            System.out.println(""[SynapseServer] Ready"");

        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println(""[SynapseServer] Startup failed..."");
        }
    }

    private static void selectPort(ConfigurationContext configCtx) {
        // check if configured port is available
        TransportInDescription trsIn = (TransportInDescription)
            configCtx.getAxisConfiguration().getTransportsIn().get(""http"");

        if (trsIn != null) {

            int port = 8080;

            String strPort = System.getProperty(""port"");
            if(strPort != null) {
                // port is specified as a VM parameter
                try {
                    port = new Integer(strPort).intValue();
                } catch (NumberFormatException e) {
                    // user supplied parameter is not a valid integer. so use the port in configuration.
                    log.error(""Given port is not a valid integer. Port specified in the configuration is used for the server."");
                    port = Integer.parseInt(trsIn.getParameter(""port"").getValue().toString());
                }

            } else {
                port = Integer.parseInt(trsIn.getParameter(""port"").getValue().toString());
            }

            while (true) {
                ServerSocket sock = null;
                try {
                    sock = new ServerSocket(port);
                    trsIn.getParameter(""port"").setValue(Integer.toString(port));
                    break;
                } catch (Exception e) {
                	System.out.println(""[SynapseServer] Port ""+port+"" already in use. Trying alternate"");
                    if (port == 8080) {
                        port = 8008;
                    } else {
                        port++;
                    }
                } finally {
                    if (sock != null) {
                        try {
                            sock.close();
                        } catch (Exception e) {}
                    }
                }
            }
        }
    }

}
"
org/apache/synapse/mediators/GetPropertyFunction.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.jaxen.Context;
import org.jaxen.Function;
import org.jaxen.FunctionCallException;
import org.jaxen.Navigator;
import org.jaxen.function.StringFunction;

import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * Implements the XPath extension function synapse:get-property(scope,prop-name)
 */
public class GetPropertyFunction implements Function {

    private static final Log log = LogFactory.getLog(GetPropertyFunction.class);

    /** Synapse Message context*/
    private MessageContext synCtx = null;

    public MessageContext getSynCtx() {
        return synCtx;
    }

    public void setSynCtx(MessageContext synCtx) {
        this.synCtx = synCtx;
    }

    /**
     * Returns the string value of the property which is get from the corresponding context to the provided scope .
     * The default scope is used to get property from the synapse message context
     *
     * @param context
     * @param args
     * @return The string value of a property
     * @throws FunctionCallException
     */
    public Object call(Context context, List args) throws FunctionCallException {

        int size = args.size();
        if (size == 0) {
            log.warn(""Property key value for lookup was not specified"");
            return null;
        } else if (size == 1) {
            return evaluate(Constants.SCOPE_DEFAULT, args.get(0), context.getNavigator());
        } else if (size == 2) {
            return evaluate(args.get(0), args.get(1), context.getNavigator());
        } else {
            String msg = ""Invalid arguments for synapse:get-property(prop-name) 0r  "" +
                    ""synapse:get-property(scope,prop-name) XPath function "";
            log.warn(msg);
            throw new FunctionCallException(msg);
        }
    }

    /**
     * Returns the string value of the property using arg. one as key and arg. two as scope
     *
     * @param scopeObject
     * @param keyObject
     * @param navigator
     * @return The String value of property using arg. one as key and arg. two as scope
     */
    public Object evaluate(Object scopeObject, Object keyObject, Navigator navigator) {
        if (synCtx == null) {
            log.warn(""Synapse context has not been set for the XPath extension function"" +
                    ""'synapse:get-property(prop-name)'"");
            return null;

        }
        String scope = StringFunction.evaluate(scopeObject, navigator);
        String key = StringFunction.evaluate(keyObject, navigator);

        if (key == null || """".equals(key)) {
            log.warn(""property-name should be provided when executing "" +
                    ""synapse:get-property(scope,prop-name)"" +
                    "" or synapse:get-property(prop-name) Xpath function"");
            return null;
        }
        if (Constants.SCOPE_DEFAULT.equals(scope)) {

            if (Constants.HEADER_TO.equals(key) && synCtx.getTo() != null) {
                return synCtx.getTo().getAddress();
            } else if (Constants.HEADER_FROM.equals(key) && synCtx.getFrom() != null) {
                return synCtx.getFrom().getAddress();
            } else if (Constants.HEADER_ACTION.equals(key) && synCtx.getWSAAction() != null) {
                return synCtx.getWSAAction();
            } else if (Constants.HEADER_FAULT.equals(key) && synCtx.getFaultTo() != null) {
                return synCtx.getFaultTo().getAddress();
            } else if (Constants.HEADER_REPLY_TO.equals(key) && synCtx.getReplyTo() != null) {
                return synCtx.getReplyTo().getAddress();
            } else if (Constants.HEADER_MESSAGE_ID.equals(key) && synCtx.getMessageID() != null) {
                return synCtx.getMessageID();
            } else {
                Object result = synCtx.getProperty(key);
                if (result != null) {
                    return result;
                } else {
                    return synCtx.getEntry(key);       
                }
            }

        } else if (Constants.SCOPE_AXIS2.equals(scope) && synCtx instanceof Axis2MessageContext) {
            org.apache.axis2.context.MessageContext axis2MessageContext
                    = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            return axis2MessageContext.getConfigurationContext().getProperty(key);
        } else if (Constants.SCOPE_TRANSPORT.equals(scope)
                && synCtx instanceof Axis2MessageContext) {
            org.apache.axis2.context.MessageContext axis2MessageContext
                    = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            Object headers = axis2MessageContext.getProperty(
                    org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
            if (headers != null && headers instanceof Map) {
                Map headersMap = (HashMap) headers;
                return headersMap.get(key);
            }
        } else {
            log.warn(""Invalid scope : '"" + scope + ""' has been set for the "" +
                    ""synapse:get-property(scope,prop-name) XPath function"");
        }
        return null;
    }
}

"
org/apache/synapse/mediators/filters/FilterMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;
import org.jaxen.JaxenException;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * The filter mediator combines the regex and xpath filtering functionality. If an xpath
 * is set, it is evaluated; else the given regex is evaluated against the source xpath.
 */
public class FilterMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    private static final Log log = LogFactory.getLog(FilterMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    private AXIOMXPath source = null;
    private Pattern regex = null;
    private AXIOMXPath xpath = null;

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""Filter mediator mediate()"");

        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        try {
            if (shouldTrace) {
                trace.trace(""Start : Filter mediator "");
            }
            if (test(synCtx)) {
                log.debug(""Filter condition satisfied.. executing child mediators"");
                return super.mediate(synCtx);
            } else {
                log.debug(""Filter condition failed.. will skip executing child mediators"");
                return true;
            }
        } finally {
            if (shouldTrace) {
                trace.trace(""End : Filter mediator "");
            }
        }
    }

    /**
     * Tests the supplied condition after evaluation against the given XPath
     * or Regex (against a source XPath). When a regular expression is supplied
     * the source XPath is evaluated into a String value, and matched against
     * the given regex
     *
     * @param synCtx the current message for evaluation of the test condition
     * @return true if evaluation of the XPath/Regex results in true
     */
    public boolean test(MessageContext synCtx) {
        try {
            if (xpath != null) {
                log.debug(""Evaluating XPath expression : "" + xpath);
                if (shouldTrace(synCtx.getTracingState())) {
                    trace.trace(""XPath expression : "" + xpath + "" evaluates to : "" +
                        xpath.booleanValueOf(synCtx.getEnvelope()));
                }
                return xpath.booleanValueOf(synCtx.getEnvelope());

            } else if (source != null && regex != null) {
                log.debug(""Evaluating regular expression : "" + regex.pattern() + "" against source : "" + source);
                String sourceString = Axis2MessageContext.getStringValue(source, synCtx);
                if (sourceString == null) {
                    log.debug(""Source String has been evaluated to Null"");
                    return false;
                }
                if (shouldTrace(synCtx.getTracingState())) {
                    trace.trace(""Regular expression : "" + regex.pattern() + "" and Source "" +
                            sourceString + "" matches : "" + regex.matcher(sourceString).matches());
                }
                Matcher matcher = regex.matcher(sourceString);
                if (matcher == null) {
                    log.warn(""Can not find a Regex Pattren Matcher"");
                    return false;
                }
                return matcher.matches();

            } else {
                log.error(""Invalid configuration specified"");
                return false;
            }

        } catch (JaxenException e) {
            log.error(""XPath error : "" + e.getMessage());
            return false;
        }
    }


    public AXIOMXPath getSource() {
        return source;
    }

    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    public Pattern getRegex() {
        return regex;
    }

    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    public AXIOMXPath getXpath() {
        return xpath;
    }

    public void setXpath(AXIOMXPath xpath) {
        this.xpath = xpath;
    }

}
"
org/apache/synapse/config/xml/MediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

import javax.xml.namespace.QName;

/**
 * A mediator factory capable of creating an instance of a mediator through a given
 * XML should implement this interface
 */
public interface MediatorFactory {
    /**
     * Creates an instance of the mediator using the OMElement
     * @param elem
     * @return the created mediator
     */
    public Mediator createMediator(OMElement elem);

    /**
     * The QName of this mediator element in the XML config
     * @return QName of the mediator element
     */
    public QName getTagQName();
}
"
org/apache/synapse/mediators/ListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.Mediator;

import java.util.List;

/**
 * The List mediator executes a given sequence/list of child mediators
 */
public interface ListMediator extends Mediator {

    /**
     * Appends the specified mediator to the end of this mediator's (children) list
     * @param m the mediator to be added
     * @return true (as per the general contract of the Collection.add method)
     */
    public boolean addChild(Mediator m);

    /**
     * Appends all of the mediators in the specified collection to the end of this mediator's (children)
     * list, in the order that they are returned by the specified collection's iterator
     * @param c the list of mediators to be added
     * @return true if this list changed as a result of the call
     */
    public boolean addAll(List c);

    /**
     * Returns the mediator at the specified position
     * @param pos index of mediator to return
     * @return the mediator at the specified position in this list
     */
    public Mediator getChild(int pos);

    /**
     * Removes the first occurrence in this list of the specified mediator
     * @param m mediator to be removed from this list, if present
     * @return true if this list contained the specified mediator
     */
    public boolean removeChild(Mediator m);

    /**
     * Removes the mediator at the specified position in this list
     * @param pos the index of the mediator to remove
     * @return the mediator previously at the specified position
     */
    public Mediator removeChild(int pos);

    /**
     * Return the list of mediators of this List mediator instance
     * @return the child/sub mediator list
     */
    public List getList();
}
"
org/apache/synapse/config/xml/DropMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

public class DropMediatorSerializer extends AbstractMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(DropMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DropMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DropMediator mediator = (DropMediator) m;
        OMElement drop = fac.createOMElement(""drop"", synNS);
        finalizeSerialization(drop,mediator);

        if (parent != null) {
            parent.addChild(drop);
        }
        return drop;
    }

    public String getMediatorClassName() {
        return DropMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/metrics/Counter.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;
/*
 * This is the basic unit to get Global, Proxy Service or
 * Proxy Opertaion Level hit count. 
 */

public class Counter {

    private long count = 0;

    public synchronized void increment(){
        count++;
    }

    public long getCount() {
        return count;
    }
}
"
org/apache/synapse/SynapseException.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

/**
 * <p>Runtime exception for Synapse code to throw
 */
public class SynapseException extends RuntimeException {

    private static final long serialVersionUID = -7244032125641596311L;

    public SynapseException(String string) {
        super(string);
    }

    public SynapseException(String msg, Throwable e) {
        super(msg, e);
    }

    public SynapseException(Throwable t) {
        super(t);
    }

}
"
org/apache/synapse/core/axis2/MessageContextCreatorForAxis2.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;

/**
 * The MessageContext needs to be set up and then is used by the SynapseMessageReceiver to inject messages.
 * This class is used by the SynapseMessageReceiver to find the environment. The env is stored in a Parameter to the Axis2 config
 */
public class MessageContextCreatorForAxis2 implements Constants {

    private static Log log = LogFactory.getLog(MessageContextCreatorForAxis2.class);

    private static SynapseConfiguration synCfg = null;
    private static SynapseEnvironment   synEnv = null;

    public static MessageContext getSynapseMessageContext(
            org.apache.axis2.context.MessageContext axisMsgCtx) throws AxisFault {

        if (synCfg == null || synEnv == null) {
            String msg = ""Synapse environment has not initialized properly.."";
            log.fatal(msg);
            throw new SynapseException(msg);
        }

        return new Axis2MessageContext(axisMsgCtx, synCfg, synEnv);
    }

    public static void setSynConfig(SynapseConfiguration synCfg) {
        MessageContextCreatorForAxis2.synCfg = synCfg;
    }

    public static void setSynEnv(SynapseEnvironment synEnv) {
        MessageContextCreatorForAxis2.synEnv = synEnv;
    }
}
"
org/apache/synapse/FaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import java.util.Stack;
import java.io.StringWriter;
import java.io.Writer;
import java.io.PrintWriter;

/**
 * This is an abstract class that handles an unexpected error during Synapse mediation, but looking
 * at the stack of registered FaultHanders and invoking on them as appropriate. Sequences and
 * Endpoints would be Synapse entities that handles faults. If such an entity is unable to handle
 * an error condition, then a SynapseException should be thrown, which triggers this fault
 * handling logic.
 */
public abstract class FaultHandler {

    public void handleFault(MessageContext synCtx) {

        try {
            onFault(synCtx);

        } catch (SynapseException e) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    public void handleFault(MessageContext synCtx, Exception e) {

        if (synCtx.getProperty(Constants.ERROR_CODE) == null) {
            synCtx.setProperty(Constants.ERROR_CODE, ""00000"");
        }
        if (synCtx.getProperty(Constants.ERROR_MESSAGE) == null) {
            // use only the first line as the message for multiline exception messages (Axis2 has these)
            synCtx.setProperty(Constants.ERROR_MESSAGE, e.getMessage().split(""\n"")[0]);
        }
        synCtx.setProperty(Constants.ERROR_DETAIL, getStackTrace(e));

        try {
            onFault(synCtx);

        } catch (SynapseException se) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx, se);
            }
        }
    }

    /**
     * This will be executed to handle any Exceptions occured within the Synapse environment.
     * @param synCtx SynapseMessageContext of which the fault occured message comprises
     * @throws SynapseException in case there is a failure in the fault execution
     */
    public abstract void onFault(MessageContext synCtx);

    private static String getStackTrace(Throwable aThrowable) {
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        aThrowable.printStackTrace(printWriter);
        return result.toString();
    }
}
"
org/apache/synapse/statistics/StatisticsCollector.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.Constants;

import java.util.*;

/**
 * To collect statistics
 */

public class StatisticsCollector {

    /**  A synchronized map for holding sequence statistics  */
    private Map sequenceStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding end point statistics */
    private Map endpointStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding proxy services statistics */
    private Map proxyServicesStatistics = Collections.synchronizedMap(new HashMap());

    /**
     * To report the statistics related to a  EndPonit
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForEndPoint(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) endpointStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(Constants.ENDPOINT_STATISTICS);
            endpointStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);

    }

    /**
     * To report the statistics related to a  ProxyService
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForProxyService(String keyOfStatistic, boolean isResponse, long inTime,
                                      long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) proxyServicesStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(Constants.PROXYSERVICE_STATISTICS);
            proxyServicesStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To report the statistics related to a  Sequence
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForSequence(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) sequenceStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(Constants.SEQUENCE_STATISTICS);
            sequenceStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To access all sequence statistics
     *
     * @return all sequence statistics
     */
    public Map getSequenceStatistics() {
        return sequenceStatistics;
    }

    /**
     * To access all proxy services statistics
     *
     * @return all proxy services statistics
     */
    public Map getProxyServiceStatistics() {
        return proxyServicesStatistics;
    }

    /**
     * To access all endpoint statistics
     *
     * @return all endpoint statistics
     */
    public Map getEndPointStatistics() {
        return endpointStatistics;
    }

    /**
     * To reset the sequence statistics
     */
    public void resetSequenceStatistics() {
        this.sequenceStatistics = Collections.synchronizedMap(new HashMap());
    }

    /**
     * To reset the proxy service statistics
     */
    public void resetProxyServiceStatistics() {
        this.proxyServicesStatistics = Collections.synchronizedMap(new HashMap());
    }

    /**
     * To reset the endpoint statistics
     */
    public void resetEndPointStatistics() {
        this.endpointStatistics = Collections.synchronizedMap(new HashMap());
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointAbstractFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;

import javax.xml.namespace.QName;

/**
 * Abstract factory for endpoint factories. Use this class to obtain the EndpointFactory implementation
 * for the required endpoint configuration.
 */
public class EndpointAbstractFactory {

    /**
     * Returns the EndpointFactory implementation for given endpoint configuration. Throws a SynapseException,
     * if there is no EndpointFactory for given configuration.
     *
     * @param configElement Endpoint configuration.
     * @return EndpointFactory implementation.
     */
    public static EndpointFactory getEndpointFactroy(OMElement configElement) {

        if (configElement.getAttribute(new QName(""key"")) != null) {
            IndirectEndpointFactory endpointFactory = IndirectEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement addressElement = configElement.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""address""));
        if (addressElement != null) {
            EndpointFactory endpointFactory = AddressEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement wsdlElement = configElement.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""wsdl""));
        if (wsdlElement != null) {
            EndpointFactory endpointFactory = WSDLEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement lbElement = configElement.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""loadbalance""));
        if (lbElement != null) {
            OMElement sessionElement = configElement.
                    getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""session""));
            if (sessionElement != null) {
                EndpointFactory endpointFactory = SALoadbalanceEndpointFactory.getInstance();
                return endpointFactory;
            } else {
                EndpointFactory endpointFactory = LoadbalanceEndpointFactory.getInstance();
                return endpointFactory;
            }            
        }

        OMElement foElement = configElement.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""failover""));
        if (foElement != null) {
            EndpointFactory endpointFactory = FailoverEndpointFactory.getInstance();
            return endpointFactory;
        }

        throw new SynapseException(""Invalid endpoint configuration."");
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.PropertyMediator;

/**
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"")/&gt;
 * </pre>
 */
public class PropertyMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(PropertyMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof PropertyMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        PropertyMediator mediator = (PropertyMediator) m;
        OMElement property = fac.createOMElement(""property"", synNS);
        finalizeSerialization(property, mediator);

        if (mediator.getName() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
        } else {
            handleException(""Invalid property mediator. Name is required"");
        }

        if (mediator.getValue() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

        } else if (mediator.getExpression() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""expression"", nullNS, mediator.getExpression().toString()));
            super.serializeNamespaces(property, mediator.getExpression());

        } else if (mediator.getAction() == PropertyMediator.ACTION_SET) {
            handleException(""Invalid property mediator. Value or expression is required if action is SET"");
        }
        if (mediator.getScope() != null) {
            // if we have already built a mediator with scope, scope should be valid, now save it
            property.addAttribute(fac.createOMAttribute(""scope"", nullNS, mediator.getScope()));
        }
        if (mediator.getAction() == PropertyMediator.ACTION_REMOVE) {
            property.addAttribute(fac.createOMAttribute(
                    ""action"", nullNS, ""remove""));
        }
        if (parent != null) {
            parent.addChild(property);
        }
        return property;
    }

    public String getMediatorClassName() {
        return PropertyMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/Constants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

/**
 * Constants used in the XML processing
 */
public interface Constants {
    public static final QName DEFINITIONS_ELT
            = new QName(Constants.SYNAPSE_NAMESPACE, ""definitions"");
    public static final QName SEQUENCE_ELT      
            = new QName(Constants.SYNAPSE_NAMESPACE, ""sequence"");
    public static final QName ENDPOINT_ELT
            = new QName(Constants.SYNAPSE_NAMESPACE, ""endpoint"");
    public static final QName ENTRY_ELT
            = new QName(Constants.SYNAPSE_NAMESPACE, ""localEntry"");
    public static final QName REGISTRY_ELT
            = new QName(Constants.SYNAPSE_NAMESPACE, ""registry"");
    public static final QName PROXY_ELT
            = new QName(Constants.SYNAPSE_NAMESPACE, ""proxy"");

    public static final String SYNAPSE_NAMESPACE
            = org.apache.synapse.Constants.SYNAPSE_NAMESPACE;
    public static final String NULL_NAMESPACE    = """";
    public static final String RAMPART_POLICY    = ""rampartPolicy"";
    public static final String SANDESHA_POLICY   = ""sandeshaPolicy"";

    /** The Trace attribute name */
    public static final String TRACE_ATTRIB_NAME =""trace"";
    /** The Trace value 'enable' */
    public static final String TRACE_ENABLE =""enable"";
    /** The Trace value 'disable' */
    public static final  String TRACE_DISABLE =""disable"";        
    /** The statistics attribute name */
    public static final String STATISTICS_ATTRIB_NAME =""statistics"";
    /** The statistics  value 'enable' */
    public static final String STATISTICS_ENABLE =""enable"";
    /** The statistics  value 'disable' */
    public static final  String STATISTICS_DISABLE =""disable"";
    
    // -- variables for the scoping of a property mediator --
    /** The String value for an Axis2 messagecontext property */
    public static final String SCOPE_AXIS2 = org.apache.synapse.Constants.SCOPE_AXIS2;
    /**
     * The scope for a set-property mediator, when the property should be set
     * on the underlying transport
     */
    String SCOPE_TRANSPORT = org.apache.synapse.Constants.SCOPE_TRANSPORT;

    // -- Synapse message context property keys --
       /** The scope for the synapse message context properties */
    String SCOPE_DEFAULT = org.apache.synapse.Constants.SCOPE_DEFAULT;


    //  -- Synapse property values for WS-RM sequence handling --
    /** The String value for a WS-RM version 1.0*/
    public static final String SEQUENCE_VERSION_1_0
            = org.apache.synapse.Constants.SEQUENCE_VERSION_1_0;
    /** The String value for a WS-RM version 1.1*/
    public static final String SEQUENCE_VERSION_1_1
            = org.apache.synapse.Constants.SEQUENCE_VERSION_1_1;

    // -- Synapse Send mediator releated constants -- //
    String SEND_ELEMENT = ""send"";
    String LOADBALANCE_ELEMENT      = ""loadbalance"";
    /** failover only element */
    String FAILOVER_ELEMENT         = ""failover"";
    String SUSPEND_DURATION_ON_FAILURE = ""suspendDurationOnFailure"";
    String MAXIMUM_RETRIES          = ""maximumRetries"";
    String RETRY_INTERVAL           = ""retryInterval"";
    /** failover attribute in the loadbalance element */
    String FAILOVER                 = ""failover"";
    String SESSION_AFFINITY         = ""sessionAffinity"";
    String ALGORITHM_NAME           = ""policy"";
    /** failover group element inside the loadbalance element */
    String FAILOVER_GROUP_ELEMENT   = ""failover"";
    String DISPATCH_MANAGER         = ""DISPATCH_MANAGER"";
    String DISPATCHERS_ELEMENT      = ""dispatchers"";
    String DISPATCHER_ELEMENT       = ""dispatcher"";
    QName ATT_KEY_Q = new QName(NULL_NAMESPACE, ""key"");
    QName ATT_ADDRESS_Q = new QName(NULL_NAMESPACE, ""address"");
    String ONREJECT = ""onReject"";
    String ONACCEPT = ""onAccept"";
}
"
org/apache/synapse/metrics/GlobalRequestCountHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.handlers.AbstractHandler;

/*
 * This information is published using WS-Management.
 * Access from any location with XXContext.getParameter(Constants.GLOBAL_REQUEST_COUNTER);
 */

public class GlobalRequestCountHandler extends AbstractHandler {

    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
        msgContext
                .setProperty(Constants.REQUEST_RECEIVED_TIME, new Long(System.currentTimeMillis()));
        // global increment
        ((Counter) msgContext.getParameter(Constants.GLOBAL_REQUEST_COUNTER).getValue())
                .increment();
        return InvocationResponse.CONTINUE;
    }
}
"
org/apache/synapse/config/xml/endpoints/IndirectEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;

/**
 * Serializes an IndirectEndpoint to an XML configuration.
 *
 * <endpoint key=""key"" />
 */
public class IndirectEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof IndirectEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        IndirectEndpoint indirectEndpoint = (IndirectEndpoint) endpoint;
        String ref = indirectEndpoint.getKey();
        if (ref != null) {
            endpointElement.addAttribute(""key"", ref, null);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/config/xml/SynapseMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SynapseMediator;

import javax.xml.namespace.QName;

/**
 * Builds the main mediator (@see SynapseConfiguration) of the Synapse instance
 *
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorFactory extends AbstractListMediatorFactory {

    private final static QName RULES_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""rules"");

    public QName getTagQName() {
        return RULES_Q;
    }

    public Mediator createMediator(OMElement elem) {
        SynapseMediator sm = new SynapseMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(sm,elem);

        addChildren(elem, sm);
        return sm;
    }

}
"
org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.statistics.StatisticsUtils;


/**
 * <p> This is the Axis2 implementation of the MessageContext
 */
public class Axis2SynapseEnvironment implements SynapseEnvironment {

    private static final Log log = LogFactory.getLog(Axis2SynapseEnvironment.class);

    private SynapseConfiguration synapseConfig;
    /**
     * The StatisticsCollector object
     */
    private StatisticsCollector statisticsCollector;

    public Axis2SynapseEnvironment() {
    }

    public Axis2SynapseEnvironment(ConfigurationContext cfgCtx,
                                   SynapseConfiguration synapseConfig) {
        this.synapseConfig = synapseConfig;
    }

    public void injectMessage(final MessageContext synCtx) {
        synCtx.setEnvironment(this);
        if (synCtx.isResponse()) {
            //Process statistics related to a sequence which has send mediator as a child,end point
            StatisticsUtils.processEndPointStatistics(synCtx);
            StatisticsUtils.processProxyServiceStatistics(synCtx);
            StatisticsUtils.processSequenceStatistics(synCtx);
        }

        // if this is a response to a proxy service 
        if (synCtx.getProperty(Constants.PROXY_SERVICE) != null) {

            if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    Constants.PROXY_SERVICE)).getTargetOutSequence() != null) {

                String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx.
                        getProperty(Constants.PROXY_SERVICE)).getTargetOutSequence();
                Mediator outSequence = synCtx.getSequence(sequenceName);

                if (outSequence != null) {
                    log.debug(""Using the sequence named "" + sequenceName
                            + "" for the outgoing message mediation of the proxy service ""
                            + synCtx.getProperty(Constants.PROXY_SERVICE));
                    outSequence.mediate(synCtx);
                } else {
                    log.error(""Unable to find the out-sequence "" +
                            ""specified by the name "" + sequenceName);
                    throw new SynapseException(""Unable to find the "" +
                            ""out-sequence specified by the name "" + sequenceName);
                }

            } else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    Constants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {

                log.debug(""Using the anonymous out-sequence specified in the proxy service ""
                        + synCtx.getProperty(Constants.PROXY_SERVICE)
                        + "" for outgoing message mediation"");
                synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                        Constants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);
            } else {

                log.debug(""Proxy service "" + synCtx.getProperty(Constants.PROXY_SERVICE)
                        + "" does not specifies an out-sequence - sending the response back"");
                Axis2Sender.sendBack(synCtx);
            }

        } else {
            synCtx.getMainSequence().mediate(synCtx);
        }
    }

    public void send(EndpointDefinition endpoint, MessageContext synCtx) {
        if (synCtx.isResponse())
            Axis2Sender.sendBack(synCtx);
        else
            Axis2Sender.sendOn(endpoint, synCtx);
    }

    public MessageContext createMessageContext() {
        org.apache.axis2.context.MessageContext axis2MC
                = new org.apache.axis2.context.MessageContext();
        MessageContext mc = new Axis2MessageContext(axis2MC, synapseConfig, this);
        return mc;
    }

    /**
     * This method returns the StatisticsCollector
     *
     * @return Retruns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector() {
        return statisticsCollector;
    }

    /**
     * To set the StatisticsCollector
     *
     * @param collector
     */
    public void setStatisticsCollector(StatisticsCollector collector) {
        this.statisticsCollector = collector;
    }

}
"
org/apache/synapse/statistics/StatisticsHolder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.Constants;

/**
 * To hold statistics that will collected during both of in and out message mediation
 */

public class StatisticsHolder {

    private int statisticsCategory ;

    private String key ;

    /**  The statistics that will collect during in coming message mediation  */
    private Statistics inFlowStatistics;

    /**  The statistics that will collect during out going message mediation  */
    private Statistics outFlowStatistics;

    /**
     * To update the statistics
     *
     * @param isResponse - A boolean value that indicate whether message flow is in or out
     * @param inTime     - The processing start time
     * @param outTime    - The processing end time
     * @param isFault    - A boolean value that indicate whether falut has occured or not
     */
    public synchronized void update(boolean isResponse, long inTime, long outTime,
                                    boolean isFault) {
        if (isResponse) {
            if (outFlowStatistics == null) {
                outFlowStatistics = new Statistics();
            }
            outFlowStatistics.update(inTime, outTime, isFault);
        } else {
            if (inFlowStatistics == null) {
                inFlowStatistics = new Statistics();
            }
            inFlowStatistics.update(inTime, outTime, isFault);
        }

    }

    /**
     * To get Statistics related to the In Flow
     * @return  Statistics related to the In Flow
     */
    public synchronized Statistics getInFlowStatistics() {
        return inFlowStatistics;
    }

    /**
     * To get Statistics related to the Out Flow
     * @return  Statistics related to the Out Flow
     */
    public synchronized Statistics getOutFlowStatistics() {
        return outFlowStatistics;
    }

    /**
     * To get statistics category
     * @return  Statistics Category
     */
    public int getStatisticsCategory() {
        return statisticsCategory;
    }

    /**
     * To set statistics category
     * @param statisticsCategory
     */
    public void setStatisticsCategory(int statisticsCategory) {
        this.statisticsCategory = statisticsCategory;
    }

    /**
     * To get key of statistics
     * @return   key of statistics
     */
    public String getKey() {
        return key;
    }

    /**
     * To set key of statistics
     * @param key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * To clear stored statistics
     */
    public synchronized void clearStatistics(){
        this.inFlowStatistics =null;
        this.outFlowStatistics=null;
    }
}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates SALoadbalanceEndpoint from a XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <session type=""soap | ..other session types.."" />
 *    <loadbalance policy=""policy"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class SALoadbalanceEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(LoadbalanceEndpointFactory.class);

    private static SALoadbalanceEndpointFactory instance = new SALoadbalanceEndpointFactory();

    private SALoadbalanceEndpointFactory() {}

    public static SALoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms
        SALoadbalanceEndpoint loadbalanceEndpoint = new SALoadbalanceEndpoint();

        // get the session for this endpoint
        OMElement sessionElement = epConfig.
                getFirstChildWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""session""));
        if (sessionElement != null) {

            String type = sessionElement.getAttributeValue(new QName(""type""));

            if (type.equalsIgnoreCase(""soap"")) {
                Dispatcher soapDispatcher = new SoapSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(soapDispatcher);

            } else if (type.equalsIgnoreCase(""http"")) {
                Dispatcher httpDispatcher = new HttpSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(httpDispatcher);

            } else if (type.equalsIgnoreCase(""simpleClientSession"")) {
                Dispatcher csDispatcher = new SimpleClientSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(csDispatcher);
            }
        } else {
            handleException(""Session affinity endpoints should have a session element in the configuration."");
        }

        // set endpoint name
        OMAttribute name = epConfig.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            loadbalanceEndpoint.setName(name.getAttributeValue());
        }

        OMElement loadbalanceElement =  null;
        loadbalanceElement = epConfig.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            // set endpoints
            ArrayList endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set abandon time
            //long abandonTime = 0;
            //OMAttribute atAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, org.apache.synapse.config.xml.Constants.RETRY_AFTER_FAILURE_TIME));
            //if(atAttribute != null) {
            //    String at = atAttribute.getAttributeValue();
            //    abandonTime = Long.parseLong(at);
            //    loadbalanceEndpoint.setAbandonTime(abandonTime);
            //}

            //long retryInterval = 30000;
            //OMAttribute riAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.RETRY_INTERVAL));
            //
            //if(riAttribute != null) {
            //    String ri = riAttribute.getAttributeValue();
            //    retryInterval = Long.parseLong(ri);
            //}

            //int maximumRetries = 0;
            //OMAttribute mrAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.MAXIMUM_RETRIES));
            //
            //if(mrAttribute != null) {
            //    String mr = mrAttribute.getAttributeValue();
            //    maximumRetries = Integer.parseInt(mr);
            //}

            return loadbalanceEndpoint;
        }

        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement loadbalanceElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = loadbalanceElement.getChildrenWithName
                (org.apache.synapse.config.xml.Constants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/SwitchCase.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * A SwitchCase define a case element of Switch Mediator and It has a list mediator and
 * a regex that is matched by its owning SwitchMediator for selection.
 * If any SwitchCase has selected ,Then the list mediator of it, will responsible
 * for message mediation
 */

public class SwitchCase {

    private static final Log log = LogFactory.getLog(SwitchCase.class);
    /** The regular expression pattern to be used */
    private Pattern regex = null;
    /** The list mediator for which responsible message mediation  */
    private AnonymousListMediator caseMediator;

    public SwitchCase() {
    }

    /**
     * To delegate message mediation to list mediator
     *
     * @param synCtx
     * @return boolean value
     */
    public boolean mediate(MessageContext synCtx) {
        if (caseMediator != null) {
            return caseMediator.mediate(synCtx);
        }
        return true;
    }

    /**
     * To get list mediator of this case element
     *
     * @return List mediator of  switch case
     */
    public AnonymousListMediator getCaseMediator() {
        return caseMediator;
    }

    /**
     * To set the list mediator
     *
     * @param caseMediator
     */
    public void setCaseMediator(AnonymousListMediator caseMediator) {
        this.caseMediator = caseMediator;
    }

    /**
     * To get the regular expression pattern
     *
     * @return Pattern
     */
    public Pattern getRegex() {
        return regex;
    }

    /**
     * To set the regular expression pattern
     *
     * @param regex
     */
    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    /**
     * To evaluate regular expression pattern to a get switch case
     *
     * @param value
     * @return boolean value
     */
    public boolean matches(String value) {
        Matcher matcher = regex.matcher(value);
        if(matcher == null){
            return false;
        }
        boolean retVal = matcher.matches();
        log.debug(""Case : "" + regex.pattern() + "" evaluated to : "" + retVal);
        return retVal;
    }
}
"
org/apache/synapse/config/xml/FilterMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.FilterMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Creates a filter mediator instance
 *
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorFactory extends AbstractListMediatorFactory {

    private static final Log log = LogFactory.getLog(FaultMediatorFactory.class);

    private static final QName FILTER_Q    = new QName(Constants.SYNAPSE_NAMESPACE, ""filter"");

    public Mediator createMediator(OMElement elem) {
        FilterMediator filter = new FilterMediator();

        OMAttribute attXpath  = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""xpath""));
        OMAttribute attSource = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""source""));
        OMAttribute attRegex  = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""regex""));

        if (attXpath != null) {
            if (attXpath.getAttributeValue() != null && attXpath.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for xpath"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    filter.setXpath(new AXIOMXPath(attXpath.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute xpath : "" + attXpath.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(filter.getXpath(), elem, log);

        } else if (attSource != null && attRegex != null) {

            if (
                (attSource.getAttributeValue() != null && attSource.getAttributeValue().trim().length() == 0) ||
                (attRegex.getAttributeValue()  != null && attRegex.getAttributeValue().trim().length() == 0) ){
                String msg = ""Invalid attribute values for source and/or regex specified"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    filter.setSource(new AXIOMXPath(attSource.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute source : "" + attSource.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
                try {
                    filter.setRegex(Pattern.compile(attRegex.getAttributeValue()));
                } catch (PatternSyntaxException pse) {
                    String msg = ""Invalid Regular Expression for attribute regex : "" + attRegex.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(filter.getSource(), elem, log);

        } else {
            String msg = ""An xpath or (source, regex) attributes are required for a filter"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(filter,elem);
        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return FILTER_Q;
    }
}
"
org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;

import javax.xml.namespace.QName;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;

/**
 * This dispatcher is implemented to demonstrate a sample client session. It will detect sessions
 * based on the <syn:ClientID xmlns:syn=""http://ws.apache.org/namespaces/synapse""> soap header of the
 * request message. Therefore, above header has to be included in the request soap messages by the
 * client who wants to initiate and maintain a session.
 */
public class SimpleClientSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    private Map sessionMap = Collections.synchronizedMap(new HashMap());

    public Endpoint getEndpoint(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                Object o = sessionMap.get(csID.getText());
                if (o != null) {
                    return (Endpoint) o;
                }
            }
        }

        return null;
    }

    public void updateSession(MessageContext synCtx, Endpoint endpoint) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                // synchronized to avoid possible replacement of sessions
                synchronized(sessionMap) {
                    if (!sessionMap.containsKey(csID.getText())) {
                        sessionMap.put(csID.getText(), endpoint);
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                sessionMap.remove(csID.getText());
            }
        }
    }

    public boolean isServerInitiatedSession() {
        return false;
    }
}
"
org/apache/synapse/config/xml/FaultMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.FaultMediator;

import javax.xml.namespace.QName;

/**
 * <pre>
 * &lt;makefault [version=""soap11|soap12""]&gt;
 *   &lt;code (value=""literal"" | expression=""xpath"")/&gt;
 *   &lt;reason (value=""literal"" | expression=""xpath"")&gt;
 *   &lt;node&gt;?
 *   &lt;role&gt;?
 *   &lt;detail&gt;?
 * &lt;/makefault&gt;
 * </pre>
 */
public class FaultMediatorSerializer extends AbstractMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(FaultMediatorSerializer.class);

    private static final String SOAP11 = ""soap11"";

    private static final String SOAP12 = ""soap12"";

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FaultMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FaultMediator mediator = (FaultMediator) m;
        OMElement fault = fac.createOMElement(""makefault"", synNS);
        finalizeSerialization(fault,mediator);

        if(mediator.getSoapVersion()==FaultMediator.SOAP11) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP11));
        }else if(mediator.getSoapVersion()==FaultMediator.SOAP12) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP12));
        }

        OMElement code = fac.createOMElement(""code"", synNS, fault);
        if (mediator.getFaultCodeValue() != null) {
            code.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultCodeValue().getPrefix() + "":""
                    + mediator.getFaultCodeValue().getLocalPart()));
            code.declareNamespace(mediator.getFaultCodeValue().getNamespaceURI(),
                    mediator.getFaultCodeValue().getPrefix());

        } else if (mediator.getFaultCodeExpr() != null) {
            code.addAttribute(fac.createOMAttribute(
                ""expression"", nullNS, mediator.getFaultCodeExpr().toString()));
            super.serializeNamespaces(code, mediator.getFaultCodeExpr());

        } else {
            handleException(""Fault code is required for a fault mediator"");
        }

        OMElement reason = fac.createOMElement(""reason"", synNS, fault);
        if (mediator.getFaultReasonValue() != null) {
            reason.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultReasonValue()));

        } else if (mediator.getFaultReasonExpr() != null) {
            reason.addAttribute(fac.createOMAttribute(
                ""expression"", nullNS, mediator.getFaultReasonExpr().toString()));
            super.serializeNamespaces(code, mediator.getFaultReasonExpr());

        } else {
            handleException(""Fault reason is required for a fault mediator"");
        }


        if (mediator.getFaultNode() != null) {
            OMElement node = fac.createOMElement(""node"", synNS, fault);
            node.setText(mediator.getFaultNode().toString());
        }

        if (mediator.getFaultRole() != null) {
            OMElement role = fac.createOMElement(""role"", synNS, fault);
            role.setText(mediator.getFaultRole().toString());
        }

        if (mediator.getFaultDetail() != null) {
            OMElement detail = fac.createOMElement(""detail"", synNS, fault);
            detail.setText(mediator.getFaultDetail());
        }

        if (parent != null) {
            parent.addChild(fault);
        }
        return fault;
    }

    public String getMediatorClassName() {
        return FaultMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/ProxyServiceSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.core.axis2.ProxyService;

import java.util.Iterator;
import java.util.ArrayList;
import java.net.URI;

/**
 * <proxyService name=""string"" [transports=""(http |https |jms )+|all""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <policy key=""string"">
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxyService>
 */
public class ProxyServiceSerializer {

    private static final Log log = LogFactory.getLog(PropertyMediatorSerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(Constants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(Constants.NULL_NAMESPACE, """");

    public static OMElement serializeProxy(OMElement parent, ProxyService service) {

        OMElement proxy = fac.createOMElement(""proxy"", synNS);
        if (service.getName() != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, service.getName()));
        } else {
            handleException(""Invalid proxy service. Service name is required"");
        }
        String descriptionStr = service.getDescription();
        if (descriptionStr != null) {
            OMElement description = fac.createOMElement(""description"", synNS);
            description.addChild(fac.createOMText(descriptionStr));
            proxy.addChild(description);
        }
        ArrayList transports = service.getTransports();
        if (transports != null && !transports.isEmpty()) {
            String transportStr = """" + transports.get(0);
            for (int i = 1; i < transports.size(); i++) {
                transportStr = transportStr + "" "" + transports.get(i);
            }
            proxy.addAttribute(fac.createOMAttribute(""transports"", nullNS, transportStr));
        }

        if (service.isStartOnLoad()) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""true""));
        } else {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""false""));
        }
        String endpoint = service.getTargetEndpoint();

        OMElement target = fac.createOMElement(""target"", synNS);
        Endpoint inLineEndpoint = service.getTargetInLineEndpoint();
        if (endpoint != null) {
            target.addAttribute(fac.createOMAttribute(
                    ""endpoint"", nullNS, endpoint));
            proxy.addChild(target);
        } else if (inLineEndpoint != null) {
            EndpointSerializer serializer
                    = EndpointAbstractSerializer.getEndpointSerializer(inLineEndpoint);
            OMElement epElement = serializer.serializeEndpoint(inLineEndpoint);
            target.addChild(epElement);            
            proxy.addChild(target);
        }
            String inSeq = service.getTargetInSequence();
            String outSeq = service.getTargetOutSequence();
            String faultSeq = service.getTargetFaultSequence();
            SequenceMediatorSerializer serializer = new SequenceMediatorSerializer();
            if (inSeq != null) {
                target.addAttribute(fac.createOMAttribute(""inSequence"", nullNS, inSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineInSeq = service.getTargetInLineInSequence();
                if (inLineInSeq != null) {
                    OMElement inSeqElement = serializer.serializeAnonymousSequence(null, inLineInSeq);
                    inSeqElement.setLocalName(""inSequence"");
                    target.addChild(inSeqElement);
                    proxy.addChild(target);
                }
            }
            if (outSeq != null) {
                target.addAttribute(fac.createOMAttribute(""outSequence"", nullNS, outSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineOutSeq = service.getTargetInLineOutSequence();
                if (inLineOutSeq != null) {
                    OMElement outSeqElement = serializer.serializeAnonymousSequence(null, inLineOutSeq);
                    outSeqElement.setLocalName(""outSequence"");
                    target.addChild(outSeqElement);
                    proxy.addChild(target);
                }
            }
            if (faultSeq != null) {
                target.addAttribute(fac.createOMAttribute(""faultSequence"", nullNS, faultSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineFaultSeq = service.getTargetInLineFaultSequence();
                if (inLineFaultSeq != null) {
                    OMElement faultSeqElement = serializer.serializeAnonymousSequence(null, inLineFaultSeq);
                    faultSeqElement.setLocalName(""faultSequence"");
                    target.addChild(faultSeqElement);
                    proxy.addChild(target);
                }
            }

        

        String wsdlKey = service.getWSDLKey();
        URI wsdlUri = service.getWsdlURI();
        Object inLineWSDL = service.getInLineWSDL();
        OMElement wsdl = fac.createOMElement(""publishWSDL"", synNS);
        if (wsdlKey != null) {
            wsdl.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, wsdlKey));
            proxy.addChild(wsdl);
        } else if (inLineWSDL != null) {
            wsdl.addChild((OMNode) inLineWSDL);
            proxy.addChild(wsdl);
        } else if (wsdlUri != null) {
            wsdl.addAttribute(fac.createOMAttribute(
                    ""uri"", nullNS, wsdlUri.toString()));
            proxy.addChild(wsdl);
        }

        // TODO still schemas are not used
        // Iterator iter = service.getSchemas();
        // ....

        Iterator iter = service.getServiceLevelPolicies().iterator();
        while (iter.hasNext()) {
            String policyKey = (String) iter.next();
            OMElement policy = fac.createOMElement(""policy"", synNS);
            policy.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, policyKey));
            proxy.addChild(policy);
        }

        iter = service.getParameterMap().keySet().iterator();
        while (iter.hasNext()) {
            String propertyName = (String) iter.next();
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, propertyName));
            Object value = service.getParameterMap().get(propertyName);
            if (value != null) {
                if (value instanceof String) {
                    property.setText(((String) value).trim());
                    proxy.addChild(property);
                } else if (value instanceof OMNode) {
                    property.addChild((OMNode) value);
                    proxy.addChild(property);
                }
            }
        }

        if (service.isWsRMEnabled()) {
            proxy.addChild(fac.createOMElement(""enableRM"", synNS));
        }
        if (service.isWsSecEnabled()) {
            proxy.addChild(fac.createOMElement(""enableSec"", synNS));
        }

        int isEnableStatistics = service.getStatisticsEnable();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_ON) {
            statisticsValue = Constants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_OFF) {
            statisticsValue = Constants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    Constants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }

        int traceState = service.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.Constants.TRACING_ON) {
            traceValue = Constants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.Constants.TRACING_OFF) {
            traceValue = Constants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    Constants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }
        if (parent != null) {
            parent.addChild(proxy);
        }
        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;
import org.apache.axis2.context.OperationContext;
import org.apache.axis2.AxisFault;

import javax.xml.namespace.QName;
import java.util.HashMap;
import java.util.Map;
import java.util.Collections;

public class SoapSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    private Map sessionMap = Collections.synchronizedMap(new HashMap());

    /**
     * Gives the endpoint based on the service group context ID of the request message.
     *
     * @param synCtx Request MessageContext, possibly containing a service group context ID.
     *
     * @return Endpoint associated with the soap session, if current message is a soap session
     * message and if current message is not the first message of the session. Returns null, if
     * an Endpoint could not be found for the session.
     */
    public Endpoint getEndpoint(MessageContext synCtx) {
        Endpoint endpoint = null;

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement sgcID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));

            if(sgcID != null && sgcID.getText() != null) {

                Object e = sessionMap.get(sgcID.getText());

                if (e != null) {
                    endpoint = (Endpoint) e;
                }
            }
        }

        return endpoint;
    }

    /**
     * As this is a server initiated session, this method will only be called for response messages.
     * It extracts the service group context ID (if available) from the message and updates the
     * session (service group context ID) -> endpoint map.
     *
     * @param synCtx MessageContext of the response message.
     * @param endpoint Endpoint to associate with the session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint) {
        // get the service group context id
        // check if service group context id is a key of any entry
        // if not, add an entry <service group context id, endpoint>


        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement replyTo = header.getFirstChildWithName
                    (new QName(""http://www.w3.org/2005/08/addressing"", ""ReplyTo"", ""wsa""));

            if(replyTo != null) {
                OMElement referenceParameters = replyTo.getFirstChildWithName(new QName(
                        ""http://www.w3.org/2005/08/addressing"", ""ReferenceParameters"", ""wsa""));

                if(referenceParameters != null) {
                    OMElement sgcID = referenceParameters.getFirstChildWithName(new QName(
                            ""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));

                    // synchronized to avoid possible replacement of sessions
                    synchronized(sessionMap) {
                        if(!sessionMap.containsKey(sgcID.getText())) {
                            sessionMap.put(sgcID.getText(), endpoint);
                        }
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement sgcID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));
            if(sgcID != null && sgcID.getText() != null) {
                sessionMap.remove(sgcID.getText());
            }
        }
    }

    /**
     * Soap session is initiated by the server. So this method always returns true.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.InputSource;

import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.WSDLException;
import javax.wsdl.Definition;
import javax.wsdl.Service;
import javax.wsdl.Port;
import javax.wsdl.extensions.soap.SOAPAddress;
import javax.wsdl.extensions.soap12.SOAP12Address;
import javax.wsdl.xml.WSDLReader;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.util.List;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStream;

/**
 * Builds the EndpointDefinition containing the details for an epr using a WSDL 1.1 document.
 */
public class WSDL11EndpointBuilder {

    private static Log log = LogFactory.getLog(WSDL11EndpointBuilder.class);

    /**
     * Creates an EndpointDefinition for WSDL endpoint from an inline WSDL supplied in the WSDL
     * endpoint configuration.
     *
     * @param wsdl OMElement representing the inline WSDL
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    public EndpointDefinition createEndpointDefinitionFromWSDL
            (OMElement wsdl, String service, String port) {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            wsdl.serialize(baos);
            InputStream in = new ByteArrayInputStream(baos.toByteArray());
            InputSource inputSource = new InputSource(in);
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            Definition definition = reader.readWSDL(null, inputSource);

            return createEndpointDefinitionFromWSDL(definition, service, port);

        } catch (XMLStreamException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        }

        return null;
    }

    /**
     * Creates an EndpointDefinition for WSDL endpoint from a WSDL document residing in the given URI.
     *
     * @param wsdlURI URI of the WSDL document
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String service, String port) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            Definition definition = reader.readWSDL(wsdlURI);

            return createEndpointDefinitionFromWSDL(definition, service, port);

        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the WSDL URI."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (Definition definition, String serviceName, String portName) {

        if (definition == null) {
            handleException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            handleException(""Service of the WSDL document is not specified."");
        }

        if (portName == null) {
            handleException(""Port of the WSDL document is not specified."");
        }


        String serviceURL = null;
        String tns = definition.getTargetNamespace();
        Service service = definition.getService(new QName(tns, serviceName));
        if (service != null) {
            Port port = service.getPort(portName);
            if (port != null) {
                List ext = port.getExtensibilityElements();
                for (int i = 0; i < ext.size(); i++) {
                    Object o = ext.get(i);
                    if (o instanceof SOAPAddress) {
                        SOAPAddress address = (SOAPAddress) o;
                        serviceURL = address.getLocationURI();
                        break;
                    } else if (o instanceof SOAP12Address) {
                        SOAP12Address address = (SOAP12Address) o;
                        serviceURL = address.getLocationURI();
                        break;
                    }
                }
            }
        }

        if (serviceURL != null) {
            EndpointDefinition endpointDefinition = new EndpointDefinition();
            endpointDefinition.setAddress(serviceURL);

            // todo: determine this using wsdl and policy                                    

            return endpointDefinition;

        } else {
            handleException(""Couldn't retrieve endpoint information from the WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/filters/SwitchMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.SwitchCase;
import org.apache.synapse.config.xml.AnonymousListMediator;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The switch mediator implements the functionality of the ""switch"" contruct. It first
 * evaluates the given XPath expression into a String value, and performs a match against
 * the given list of cases. This is actually a list of sequences, and depending on the
 * selected case, the selected sequence gets executed.
 */
public class SwitchMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(SwitchMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /** The XPath expression specifying the source element to apply the switch case expressions against   */
    private AXIOMXPath source = null;
    /** The list of switch cases    */
    private List cases = new ArrayList();
    /** The default switch case, if any */
    private SwitchCase defaultCase = null;

    /**
     * Iterate over switch cases and find match and execute selected sequence
     *
     * @param synCtx current context
     * @return as per standard semantics
     */
    public boolean mediate(MessageContext synCtx) {

        log.debug(""Switch mediator :: mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Switch mediator"");
        }
        String sourceText = Axis2MessageContext.getStringValue(source, synCtx);
        log.debug(""Applying switch case regex patterns against evaluated source value : "" + sourceText);
        try {
            saveAndSetTraceState(synCtx);
            if (shouldTrace) {
                trace.trace(""Source Value : "" + sourceText);
                trace.trace(""Start Case mediator list"");
            }
            if (sourceText != null) {
                Iterator iter = cases.iterator();
                while (iter.hasNext()) {
                    SwitchCase swCase = (SwitchCase) iter.next();
                    if (swCase != null) {
                        if (swCase.matches(sourceText)) {
                            if (shouldTrace) {
                                trace.trace(""Executing case for : "" + swCase.getRegex());
                            }
                            return swCase.mediate(synCtx);
                        }
                    }
                }
                if (shouldTrace) {
                    trace.trace(""End Case mediator list"");
                }
            } else {
                log.warn(""Source has been evaluated to Null...Default Case will be run"");
            }
            if (defaultCase != null) {
                log.debug(""Executing default case"");
                if (shouldTrace) {
                    trace.trace(""Executing default case"");
                }
                return defaultCase.mediate(synCtx);
            }
        } finally {
            restoreTracingState(synCtx);
            if (shouldTrace) {
                trace.trace(""End : Switch mediator"");
            }
        }
        return true;
    }

    /**
     * Adds the given mediator (Should be a SwitchCaseMediator) to the list of cases
     * of this Switch mediator
     *
     * @param m the SwitchCaseMediator instance to be added
     */
    public void addCase(SwitchCase m) {
        cases.add(m);
    }

    /**
     * Get the list of cases
     *
     * @return the cases list
     */
    public List getCases() {
        return cases;
    }

    /**
     * Return the source XPath expression set
     *
     * @return thje source XPath expression
     */
    public AXIOMXPath getSource() {
        return source;
    }

    /**
     * Sets the source XPath expression
     *
     * @param source the XPath expression to be used as the source
     */
    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    /**
     * Get default case
     *
     * @return the default csae
     */
    public SwitchCase getDefaultCase() {
        return defaultCase;
    }

    public void setDefaultCase(SwitchCase defaultCase) {
        this.defaultCase = defaultCase;
    }
}
"
org/apache/synapse/mediators/builtin/RMSequenceMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Collections;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.sandesha2.client.SandeshaClientConstants;
import org.jaxen.JaxenException;

public class RMSequenceMediator extends AbstractMediator {

    private static Log log = LogFactory.getLog(RMSequenceMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    private AXIOMXPath correlation = null;
    private AXIOMXPath lastMessage = null;
    private Boolean single = null;
    private String version = null;

    private static final String WSRM_SpecVersion_1_0 = ""Spec_2005_02"";
    private static final String WSRM_SpecVersion_1_1 = ""Spec_2007_02"";
    // set sequence expiry time to 5 minutes
    private static final long SEQUENCE_EXPIRY_TIME = 300000;
    private static Map sequenceMap = Collections.synchronizedMap(new HashMap());

    public boolean mediate(MessageContext smc) {
        if (log.isDebugEnabled()) {
            log.debug(""RMSequence Mediator  ::  mediate() "");
        }
        boolean shouldTrace = shouldTrace(smc.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : RMSequence mediator"");
        }
        if (!(smc instanceof Axis2MessageContext)) {
            if (log.isDebugEnabled()) {
                log.debug(""RMSequence Mediator  ::  only axis2 message context is supported "");
            }
            return true;
        }
        Axis2MessageContext axis2MessageCtx = (Axis2MessageContext) smc;
        org.apache.axis2.context.MessageContext orgMessageCtx =
            axis2MessageCtx.getAxis2MessageContext();

        cleanupSequenceMap();

        String version = getVersionValue();
        orgMessageCtx.getOptions().setProperty(
            Constants.SANDESHA_SPEC_VERSION, version);
        if (log.isDebugEnabled()) {
            log.debug(""using WS-RM version "" + version);
        }

        if (isSingle()) {
            String sequenceID = UUIDGenerator.getUUID();
            orgMessageCtx.getOptions().setProperty(
                Constants.SANDESHA_SEQUENCE_KEY, sequenceID);
            orgMessageCtx.getOptions().setProperty(
                SandeshaClientConstants.OFFERED_SEQUENCE_ID, UUIDGenerator.getUUID());
            orgMessageCtx.getOptions().setProperty(
                Constants.SANDESHA_LAST_MESSAGE, ""true"");
            return true;
        }

        String correlationValue = getCorrelationValue(smc);
        if (log.isDebugEnabled()) {
            log.debug(""correlation value is "" + correlationValue);
        }

        boolean lastMessage = isLastMessage(smc);
        if (log.isDebugEnabled()) {
            log.debug(""Is this message the last message in sequence: "" + lastMessage);
        }

        if (!sequenceMap.containsKey(correlationValue)) {
            orgMessageCtx.getOptions().setProperty(
                SandeshaClientConstants.OFFERED_SEQUENCE_ID, UUIDGenerator.getUUID());       
        }

        String sequenceID = retrieveSequenceID(correlationValue);
        orgMessageCtx.getOptions().setProperty(
            Constants.SANDESHA_SEQUENCE_KEY, sequenceID);
        if (log.isDebugEnabled()) {
            log.debug(""RMSequence Mediator  ::  using sequence "" + sequenceID);
        }

        if (lastMessage) {
            orgMessageCtx.getOptions().setProperty(
                Constants.SANDESHA_LAST_MESSAGE, ""true"");
            sequenceMap.remove(correlationValue);
        }

        if (shouldTrace) {
            trace.trace(""End : RMSequence mediator"");
        }
        return true;
    }

    private String retrieveSequenceID(String correlationValue) {
        String sequenceID = null;
        if (!sequenceMap.containsKey(correlationValue)) {
            sequenceID = UUIDGenerator.getUUID();
            if (log.isDebugEnabled()) {
                log.debug(""setting sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
            Entry sequenceEntry = new Entry();
            sequenceEntry.setValue(sequenceID);
            sequenceEntry.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);
            sequenceMap.put(correlationValue, sequenceEntry);
        } else {
            sequenceID = (String) ((Entry) sequenceMap.get(correlationValue)).getValue();
            if (log.isDebugEnabled()) {
                log.debug(""got sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
        }
        return sequenceID;
    }

    private String getCorrelationValue(MessageContext smc) {
        OMElement node = null;
        try {
            node = (OMElement) getCorrelation().selectSingleNode(smc.getEnvelope());
        } catch (JaxenException e) {
            log.error(""XPath error : "" + e.getMessage());
            throw new SynapseException(""XPath error : "" + e.getMessage());
        }
        if (node == null) {
            log.debug(""XPath expression did not return any node"");
            throw new SynapseException(""XPath expression did not return any node"");
        }
        return node.getText();
    }

    private String getVersionValue() {
        if (Constants.SEQUENCE_VERSION_1_1.equals(getVersion())) {
            return WSRM_SpecVersion_1_1;
        } else {
            return WSRM_SpecVersion_1_0;
        }
    }

    private boolean isLastMessage(MessageContext smc) {
        if (getLastMessage() == null) {
            return false;
        }
        try {
            return getLastMessage().booleanValueOf(smc.getEnvelope());
        } catch (JaxenException e) {
            log.error(""XPath error : "" + e.getMessage());
            throw new SynapseException(""XPath error : "" + e.getMessage());
        }
    }

    private synchronized void cleanupSequenceMap() {
        Iterator itKey = sequenceMap.keySet().iterator();
        while (itKey.hasNext()) {
            Object key = itKey.next();
            Entry sequenceEntry = (Entry) sequenceMap.get(key);
            if (sequenceEntry.isExpired()) {
                sequenceMap.remove(key);
            }
        }
    }

    public boolean isSingle() {
        if (getSingle() != null && getSingle().booleanValue()) {
            return true;

        } else {
            return false;
        }
    }

    public AXIOMXPath getCorrelation() {
        return correlation;
    }

    public void setCorrelation(AXIOMXPath correlation) {
        this.correlation = correlation;
    }

    public AXIOMXPath getLastMessage() {
        return lastMessage;
    }

    public void setLastMessage(AXIOMXPath lastMessage) {
        this.lastMessage = lastMessage;
    }

    public Boolean getSingle() {
        return single;
    }

    public void setSingle(Boolean single) {
        this.single = single;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
}
"
org/apache/synapse/config/xml/EntryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMText;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.net.URL;
import java.net.MalformedURLException;

public class EntryFactory implements XMLToObjectMapper {

    private static Log log = LogFactory.getLog(EntryFactory.class);

    public static Entry createEntry(OMElement elem) {

        OMAttribute key = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""key""));
        if (key == null) {
            handleException(""The 'key' attribute is required for a local registry entry"");
            return null;

        } else {

            Entry entry = new Entry(key.getAttributeValue());
            String src  = elem.getAttributeValue(new QName(Constants.NULL_NAMESPACE, ""src""));

            // if a src attribute is present, this is a URL source resource,
            // it would now be loaded from the URL source, as all static properties
            // are initialized at startup
            if (src != null) {
                try {
                    entry.setSrc(new URL(src.trim()));
                    entry.setType(Entry.URL_SRC);
                    entry.setValue(
                        org.apache.synapse.config.Util.getObject(entry.getSrc()));
                } catch (MalformedURLException e) {
                    handleException(""The entry with key : "" + key + "" refers to an invalid URL"");
                }

            } else {
                OMNode    nodeValue = elem.getFirstOMChild();
                OMElement elemValue = elem.getFirstElement();

                if (elemValue != null) {
                    entry.setType(Entry.INLINE_XML);
                    entry.setValue(elemValue);
                } else if (nodeValue != null && nodeValue instanceof OMText) {
                    entry.setType(Entry.INLINE_TEXT);
                    entry.setValue(((OMText) nodeValue).getText().trim());
                }
            }
            return entry;
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEntry((OMElement) om);
        } else {
            handleException(""Invalid XML configuration for an Entry. OMElement expected"");
        }
        return null;
    }
}
"
org/apache/synapse/config/xml/MediatorSerializerFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.xml.ValidateMediatorSerializer;
import org.apache.synapse.config.xml.XSLTMediatorSerializer;
import sun.misc.Service;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class MediatorSerializerFinder {

    private static final Log log = LogFactory.getLog(MediatorSerializerFinder.class);

    private static final Class[] mediatorSerializers = {
        SequenceMediatorSerializer.class,
        LogMediatorSerializer.class,
        SendMediatorSerializer.class,
        FilterMediatorSerializer.class,
        SynapseMediatorSerializer.class,
        DropMediatorSerializer.class,
        HeaderMediatorSerializer.class,
        FaultMediatorSerializer.class,
        PropertyMediatorSerializer.class,
        SwitchMediatorSerializer.class,
        InMediatorSerializer.class,
        OutMediatorSerializer.class,
        RMSequenceMediatorSerializer.class,     
        ClassMediatorSerializer.class,
        ValidateMediatorSerializer.class,
        XSLTMediatorSerializer.class        
    };

    private static MediatorSerializerFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map serializerMap = new HashMap();

    public static synchronized MediatorSerializerFinder getInstance() {
        if (instance == null) {
            instance = new MediatorSerializerFinder();
        }
        return instance;
    }

    public MediatorSerializer getSerializer(Mediator mediator) {
        return (MediatorSerializer) serializerMap.get(mediator.getClass().getName());
    }

    private MediatorSerializerFinder() {

        serializerMap = new HashMap();

        for (int i = 0; i < mediatorSerializers.length; i++) {
            Class c = mediatorSerializers[i];
            try {
                MediatorSerializer ser = (MediatorSerializer) c.newInstance();
                serializerMap.put(ser.getMediatorClassName(), ser);
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    /**
     * Register pluggable mediator serializers from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        log.debug(""Registering mediator extensions found in the classpath : "" + System.getProperty(""java.class.path""));

        // register MediatorSerializer extensions
        Iterator it = Service.providers(MediatorSerializer.class);
        while (it.hasNext()) {
            MediatorSerializer ms = (MediatorSerializer) it.next();
            String name = ms.getMediatorClassName();
            try {
                serializerMap.put(name, ms.getClass().newInstance());
            } catch (InstantiationException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            }
            log.debug(""Added MediatorSerializer "" + ms.getClass().getName() + "" to handle "" + name);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/registry/url/SimpleURLRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry.url;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.AbstractRegistry;
import org.apache.synapse.registry.Registry;
import org.apache.synapse.registry.RegistryEntry;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.*;
import java.net.*;
import java.util.ArrayList;

/**
 * A Simple HTTP GET based registry which will work with a Web Server / WebDAV
 *
 * This saves the root server URL, and appends the a given key to construct the
 * full URL to locate resources
 */
public class SimpleURLRegistry extends AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(SimpleURLRegistry.class);

    private static final int MAX_KEYS = 200;

    public OMNode lookup(String key) {

        log.info(""==> Repository fetch of resource with key : "" + key);
        URLConnection urlc = null;
        try {
            URL url = new URL(getRoot() + key);
            urlc = url.openConnection();
            urlc.connect();
        } catch (IOException e) {
            return null;
        }

        try {
            XMLStreamReader parser = XMLInputFactory.newInstance().
                createXMLStreamReader(urlc.getInputStream());
            StAXOMBuilder builder = new StAXOMBuilder(parser);
            return builder.getDocumentElement();

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + getRoot() + key, e);
        } catch (FileNotFoundException fnf) {
            return null;
        } catch (IOException e) {
            handleException(""IO Error reading from URL "" + getRoot() + key, e);
        } catch (XMLStreamException e) {
            handleException(""XML Error reading from URL "" + getRoot() + key, e);
        }
        return null;
    }

    public RegistryEntry getRegistryEntry(String key) {

        log.debug(""Perform RegistryEntry lookup for key : "" + key);
        try {
            URL url = new URL(getRoot() + key);
            URLConnection urlc = url.openConnection();
            urlc.setReadTimeout(30000);
            urlc.setRequestProperty(""Connection"", ""Close"");

            URLRegistryEntry wre = new URLRegistryEntry();
            wre.setKey(key);
            wre.setName(url.getFile());
            wre.setType(new URI(urlc.getContentType()));
            wre.setDescription(""Resource at : "" + url.toString());
            wre.setLastModified(urlc.getLastModified());
            wre.setVersion(urlc.getLastModified());
            if (urlc.getExpiration() > 0) {
                wre.setCachableDuration(
                    urlc.getExpiration() - System.currentTimeMillis());
            } else {
                wre.setCachableDuration(getCachableDuration());
            }
            return wre;

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + getRoot() + key, e);
        } catch (IOException e) {
            handleException(""IO Error reading from URL "" + getRoot() + key, e);
        } catch (URISyntaxException e) {
            handleException(""URI Syntax error reading from URL "" + getRoot() + key, e);
        }
        return null;
    }

    public void addConfigProperty(String name, String value) {

        if(name.equals(""root"")) {

            // if the root is folder, it should always end with '/'
            // therefore, property keys do not have to begin with '/', which could be misleading
            try {
                URL url = new URL(value);
                if(url.getProtocol().equals(""file"")) {
                    if(!value.endsWith(""/"")) {
                        value = value + ""/"";
                    }
                }
            } catch (MalformedURLException e) {
                // don't do any thing if this is not a valid URL
            }
        }

        super.addConfigProperty(name, value);
    }

    public String getRoot() {
        String root = (String) properties.get(""root"");
        if (root == null) {
            return """";
        } else {
            return root;
        }
    }

    public long getCachableDuration() {
        String cachableDuration = (String) properties.get(""cachableDuration"");
        return cachableDuration == null ? 1500 : Long.parseLong(cachableDuration);
    }

    public RegistryEntry[] getChildren(RegistryEntry entry) {

        try {
            URL url;
            if(entry == null) {
                URLRegistryEntry urlEntry = new URLRegistryEntry();
                urlEntry.setKey("""");
                entry = urlEntry;
            }

            url = new URL(getRoot() + entry.getKey());

            if(url.getProtocol().equals(""file"")) {

                File file = new File(url.getFile());
                if(file.isDirectory() == false) {
                    return null;
                }

                InputStream inStream = null;
                try {
                    inStream = (InputStream) url.getContent();

                    BufferedReader reader = new BufferedReader(new InputStreamReader(inStream));
                    ArrayList entryList = new ArrayList();
                    String key = """";
                    while((key=reader.readLine()) != null) {
                        URLRegistryEntry registryEntry = new URLRegistryEntry();
                        if(entry.getKey().equals("""")) {
                            registryEntry.setKey(key);
                        } else {
                            if(entry.getKey().endsWith(""/"")) {
                                  registryEntry.setKey(entry.getKey() + key);
                            } else {
                                  registryEntry.setKey(entry.getKey() + ""/"" + key);
                            }
                        }

                        entryList.add(registryEntry);
                    }

                    RegistryEntry[] entries = new RegistryEntry[entryList.size()];
                    for(int i=0; i<entryList.size(); i++) {
                        entries[i] = (RegistryEntry) entryList.get(i);
                    }
                    return entries;

                } catch(Exception e) {
                    throw new SynapseException(""Error in reading the URL."");
                }

            } else {
                throw new SynapseException(""Invalid protocol."");
            }

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + getRoot() + entry.getKey(), e);
        }

        return null;
    }

    public RegistryEntry[] getDescendants(RegistryEntry entry) {

        ArrayList list = new ArrayList();
        RegistryEntry[] entries = getChildren(entry);
        if(entries != null) {
            for(int i=0; i<entries.length; i++) {

                if(list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        }

        RegistryEntry[] descendants = new RegistryEntry[list.size()];
        for(int i=0; i<list.size(); i++) {
            descendants[i] = (RegistryEntry) list.get(i);
        }

        return descendants;
    }

    private void fillDescendants(RegistryEntry parent, ArrayList list) {

        RegistryEntry[] entries = getChildren(parent);
        if(entries != null) {
            for(int i=0; i<entries.length; i++) {

                if(list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        } else {
            list.add(parent);
        }
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Serializes an WSDL based endpoint to an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *    <wsdl uri=""wsdl uri"" service=""service name"" port=""port name"">
 *       .. extensibility ..
 *    </wsdl>
 * </endpoint>
 */
public class WSDLEndpointSerializer implements EndpointSerializer {

    private static Log log = LogFactory.getLog(WSDLEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof WSDLEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        WSDLEndpoint wsdlEndpoint = (WSDLEndpoint) endpoint;
        String name = wsdlEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement wsdlElement = fac.createOMElement(""wsdl"", Constants.SYNAPSE_OMNAMESPACE);
        String serviceName = wsdlEndpoint.getServiceName();
        if (serviceName != null) {
            wsdlElement.addAttribute(""service"", serviceName, null);
        }

        String portName = wsdlEndpoint.getPortName();
        if (portName != null) {
            wsdlElement.addAttribute(""port"", portName, null);
        }

        String uri = wsdlEndpoint.getWsdlURI();
        if (uri != null) {
            wsdlElement.addAttribute(""uri"", uri, null);
        }

        OMElement wsdlDoc = wsdlEndpoint.getWsdlDoc();
        if (wsdlDoc != null) {
            wsdlElement.addChild(wsdlDoc);
        }

        long suspendDuration = wsdlEndpoint.getSuspendOnFailDuration();
        if (suspendDuration != -1) {
            // user has set some value for this. let's serialize it.

            OMElement suspendElement = fac.createOMElement(
                    org.apache.synapse.config.xml.Constants.SUSPEND_DURATION_ON_FAILURE,
                    Constants.SYNAPSE_OMNAMESPACE);

            suspendElement.setText(Long.toString(suspendDuration / 1000));
            wsdlElement.addChild(suspendElement);
        }

        // currently, we have to get QOS information from the endpoint definition and set them as
        // special elements under the wsdl element. in future, these information should be
        // extracted from the wsdl.
        EndpointDefinition epAddress = wsdlEndpoint.getEndpointDefinition();
        serializeQOSInformation(epAddress, wsdlElement);

        endpointElement.addChild(wsdlElement);

        return endpointElement;
    }

    public void serializeQOSInformation
            (EndpointDefinition endpointDefinition, OMElement wsdlElement) {

        if (endpointDefinition.isForcePOX()) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
        } else if (endpointDefinition.isForceSOAP()) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""soap""));
        }

        int isEnableStatistics = endpointDefinition.getStatisticsEnable();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_ON) {
            statisticsValue = org.apache.synapse.config.xml.Constants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.Constants.STATISTICS_OFF) {
            statisticsValue = org.apache.synapse.config.xml.Constants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            wsdlElement.addAttribute(fac.createOMAttribute(
                    org.apache.synapse.config.xml.Constants.STATISTICS_ATTRIB_NAME, null, statisticsValue));
        }
        if (endpointDefinition.isAddressingOn()) {
            OMElement addressing = fac.createOMElement(""enableAddressing"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.isUseSeparateListener()) {
                addressing.addAttribute(fac.createOMAttribute(
                        ""separateListener"", null, ""true""));
            }
            wsdlElement.addChild(addressing);
        }

        if (endpointDefinition.isReliableMessagingOn()) {
            OMElement rm = fac.createOMElement(""enableRM"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getWsRMPolicyKey() != null) {
                rm.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsRMPolicyKey()));
            }
            wsdlElement.addChild(rm);
        }

        if (endpointDefinition.isSecurityOn()) {
            OMElement sec = fac.createOMElement(""enableSec"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getWsSecPolicyKey() != null) {
                sec.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsSecPolicyKey()));
            }
            wsdlElement.addChild(sec);
        }

        if (endpointDefinition.getTimeoutAction() != Constants.NONE) {
            OMElement timeout = fac.createOMElement(""timeout"", Constants.SYNAPSE_OMNAMESPACE);
            wsdlElement.addChild(timeout);

            OMElement duration = fac.createOMElement(""duration"", Constants.SYNAPSE_OMNAMESPACE);
            duration.setText(Long.toString(endpointDefinition.getTimeoutDuration() / 1000));
            timeout.addChild(duration);

            OMElement action = fac.createOMElement(""action"", Constants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getTimeoutAction() == Constants.DISCARD) {
                action.setText(""discard"");
            } else if (endpointDefinition.getTimeoutAction() == Constants.DISCARD_AND_FAULT) {
                action.setText(""fault"");
            }
            timeout.addChild(action);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/SynapseConfigurationBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.XMLConfigurationBuilder;
import org.apache.synapse.mediators.base.SynapseMediator;
import org.apache.synapse.mediators.builtin.SendMediator;


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.File;

/**
 * Builds a Synapse Configuration model with a given input (e.g. XML, programmatic creation, default etc)
 */
public class SynapseConfigurationBuilder implements Constants {

    private static Log log = LogFactory.getLog(SynapseConfigurationBuilder.class);

    /**
     * Return the default Synapse Configuration
     * @return the default configuration to be used
     */
    public static SynapseConfiguration getDefaultConfiguration() {
        // programatically create an empty configuration which just sends messages to thier implicit destinations
        SynapseConfiguration config = new SynapseConfiguration();
        SynapseMediator mainmediator = new SynapseMediator();
        mainmediator.addChild(new SendMediator());
        config.addSequence(""main"", mainmediator);
        return config;
    }

    /**
     * Build a Synapse configuration from a given XML configuration file
     *
     * @param configFile the XML configuration
     * @return the Synapse configuration model
     */
    public static SynapseConfiguration getConfiguration(String configFile) {

        // build the Synapse configuration parsing the XML config file
        try {
            SynapseConfiguration synCfg = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));
            log.info(""Loaded Synapse configuration from : "" + configFile);
            synCfg.setPathToConfigFile(new File(configFile).getAbsolutePath());
            return synCfg;

        } catch (FileNotFoundException fnf) {
            handleException(""Cannot load Synapse configuration from : "" + configFile, fnf);
        } catch (Exception e) {
            handleException(""Could not initialize Synapse : "" + e.getMessage(), e);
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/metrics/MetricsAggregatorModule.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.AxisDescription;
import org.apache.axis2.description.AxisModule;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
/*
 * 
 */

public class MetricsAggregatorModule implements Module {
    // initialize the module
    public void init(ConfigurationContext configContext, AxisModule module) throws AxisFault {
        AxisConfiguration axiConfiguration = configContext.getAxisConfiguration();

        Counter globalRequestCounter = new Counter();
        Parameter globalRequestCounterParameter = new Parameter();
        globalRequestCounterParameter.setName(Constants.GLOBAL_REQUEST_COUNTER);
        globalRequestCounterParameter.setValue(globalRequestCounter);
        axiConfiguration.addParameter(globalRequestCounterParameter);

    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {}

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation 
    }

    // shutdown the module
    public void shutdown(ConfigurationContext configurationContext) throws AxisFault {}
}
"
org/apache/synapse/config/xml/HeaderMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.HeaderMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * This builds a Header Mediator parsing the XML configuration supplied
 *
 * Set header
 *   <pre>
 *      &lt;header name=""qname"" (value=""literal"" | expression=""xpath"")/&gt;
 *   </pre>
 *
 * Remove header
 *   <pre>
 *      &lt;header name=""qname"" action=""remove""/&gt;
 *   </pre>
 */
public class HeaderMediatorFactory extends AbstractMediatorFactory  {

    private static final Log log = LogFactory.getLog(HeaderMediatorFactory.class);

    private static final QName HEADER_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""header"");

    public Mediator createMediator(OMElement elem) {

        HeaderMediator headerMediator = new HeaderMediator();
        OMAttribute name   = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""name""));
        OMAttribute value  = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""value""));
        OMAttribute exprn  = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""expression""));
        OMAttribute action = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""action""));

        if (name == null || name.getAttributeValue() == null) {
            String msg = ""A valid name attribute is required for the header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            String nameAtt = name.getAttributeValue();
            int colonPos = nameAtt.indexOf("":"");
            if (colonPos != -1) {
                // has a NS prefix.. find it and the NS it maps into
                String prefix = nameAtt.substring(0, colonPos);
                Iterator it = elem.getAllDeclaredNamespaces();
                while (it.hasNext()) {
                    OMNamespace n = (OMNamespace) it.next();
                    if (prefix.equals(n.getPrefix())) {
                        headerMediator.setQName(
                            new QName(n.getNamespaceURI(), nameAtt.substring(colonPos+1), prefix));
                    }
                }
            } else {
                // no prefix
                headerMediator.setQName(new QName(nameAtt));
            }
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(headerMediator,elem);

        // The action attribute is optional, if provided and equals to 'remove' the
        // header mediator will act as a header remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            headerMediator.setAction(HeaderMediator.ACTION_REMOVE);
        }

        if (headerMediator.getAction() == HeaderMediator.ACTION_SET &&
            value == null && exprn == null) {
            String msg = ""A 'value' or 'expression' attribute is required for a [set] header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (value != null && value.getAttributeValue() != null) {
            headerMediator.setValue(value.getAttributeValue());

        } else if (exprn != null && exprn.getAttributeValue() != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(exprn.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                headerMediator.setExpression(xp);
            } catch (JaxenException je) {
                String msg = ""Invalid XPath expression : "" + exprn.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg, je);
            }
        }

        return headerMediator;
    }

    public QName getTagQName() {
        return HEADER_Q;
    }
}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.List;

public class SALoadbalanceEndpointSerializer implements EndpointSerializer {

    private static final Log log = LogFactory.getLog(SALoadbalanceEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof SALoadbalanceEndpoint)) {
            handleException(""Invalid endpoint type for serializing. "" +
                    ""Expected: SALoadbalanceEndpoint Found: "" + endpoint.getClass().getName());
        }

        SALoadbalanceEndpoint loadbalanceEndpoint = (SALoadbalanceEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        Dispatcher dispatcher = loadbalanceEndpoint.getDispatcher();

        if (dispatcher instanceof SoapSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", Constants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""soap"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof HttpSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", Constants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""http"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof SimpleClientSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", Constants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""simpleClientSession"", null);
            endpointElement.addChild(sessionElement);
        }

        OMElement loadbalanceElement = fac.createOMElement(""loadbalance"", Constants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute(""algorithm"", algorithmName, null);

        List endpoints = loadbalanceEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            loadbalanceElement.addChild(aeElement);
        }

        return endpointElement;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/ext/ClassMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The class mediator delegates the mediation to a new instance of a specified class. The specified class
 * must implement the Mediator interface
 *
 * @see Mediator
 */
public class ClassMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(ClassMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    private Class clazz = null;
    private List properties = new ArrayList();

    /**
     * Delegate mediation to a new instance of the specified class
     *
     * @param synCtx the message context
     * @return as per standard semantics
     */
    public boolean mediate(MessageContext synCtx) {

        log.debug(""Class mediator <"" + clazz.getName() + "">:: mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Class mediator"");
        }
        Mediator m ;
        try {
            try {
                m = (Mediator) clazz.newInstance();
            } catch (Exception e) {
                String msg = ""Error while creating an instance of the specified mediator class : "" + clazz.getName();
                if (shouldTrace)
                    trace.trace(msg);
                log.error(msg, e);
                throw new SynapseException(msg, e);
            }

            setProperties(m, synCtx, shouldTrace);
            if (shouldTrace) {
                trace.trace(""Executing an instance of the specified class : "" + clazz.getName());
            }
            return m.mediate(synCtx);
        } finally {
            if (shouldTrace) {
                trace.trace(""End : Class mediator"");
            }
        }
    }

    /**
     * Only String properties are supported
     *
     * @param m the mediator
     */
    private void setProperties(Mediator m, MessageContext synCtx, boolean shouldTrace) {

        Iterator iter = properties.iterator();
        while (iter.hasNext()) {

            MediatorProperty mProp = (MediatorProperty) iter.next();

            String mName = ""set"" + Character.toUpperCase(mProp.getName().charAt(0)) + mProp.getName().substring(1);
            String value = (mProp.getValue() != null ?
                mProp.getValue() :
                Axis2MessageContext.getStringValue(mProp.getExpression(), synCtx));

            try {
                if (value != null) {
                    Method method = m.getClass().getMethod(mName, new Class[]{String.class});
                    log.debug(""Setting property :: invoking method "" + mName + ""("" + value + "")"");
                    if (shouldTrace) {
                        trace.trace(""Setting property :: invoking method "" + mName + ""("" + value + "")"");
                    }
                    method.invoke(m, new Object[]{value});
                }
            } catch (Exception e) {
                String msg = ""Error setting property : "" + mProp.getName() + "" as a String property into class"" +
                    "" mediator : "" + m.getClass() + "" : "" + e.getMessage();
                log.error(msg);
                if (shouldTrace) {
                    trace.trace(msg);
                }
                throw new SynapseException(msg, e);
            }
        }
    }

    public void setClazz(Class clazz) {
        this.clazz = clazz;
    }

    public Class getClazz() {
        return clazz;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }

}
"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.ArrayList;

/**
 * Creates LoadbalanceEndpoint using an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <loadbalance policy=""load balance algorithm"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class LoadbalanceEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(LoadbalanceEndpointFactory.class);

    private static LoadbalanceEndpointFactory instance = new LoadbalanceEndpointFactory();

    private LoadbalanceEndpointFactory() {}

    public static LoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms

        OMElement loadbalanceElement =  null;
        loadbalanceElement = epConfig.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            LoadbalanceEndpoint loadbalanceEndpoint = new LoadbalanceEndpoint();

            // set endpoint name
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                loadbalanceEndpoint.setName(name.getAttributeValue());
            }

            // set endpoints
            ArrayList endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set if failover is turned off
            String failover = loadbalanceElement.getAttributeValue(new QName(""failover""));
            if (failover != null && failover.equalsIgnoreCase(""false"")) {
                loadbalanceEndpoint.setFailover(false);
            }

            return loadbalanceEndpoint;
        }

        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement loadbalanceElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = loadbalanceElement.getChildrenWithName
                (org.apache.synapse.config.xml.Constants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/statistics/StatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 *  This interface need to be implemented by each of the entry that
 *  need to collect statistics
 *
 */

public interface StatisticsStack {

    /**
     * This method is used to put current statistics
     * @param key
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key,long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault);

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault);

    /**
     * Report the particular statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name);

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault);

}
"
org/apache/synapse/config/xml/OMElementUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.jaxen.JaxenException;

import java.util.Iterator;

/**
 * Holds Axiom utility methods used by Synapse
 */
public class OMElementUtils {

    private static final Log log = LogFactory.getLog(OMElementUtils.class);

    /**
     * Return the namespace with the given prefix, using the given element
     * @param prefix the prefix looked up
     * @param elem the source element to use
     * @return the namespace which maps to the prefix or null
     */
    public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {
        if (prefix == null || elem == null) {
            log.warn(""Searching for null NS prefix and/or using null OMElement"");
            return null;
        }

        Iterator iter = elem.getAllDeclaredNamespaces();
        while (iter.hasNext()) {
            OMNamespace ns = (OMNamespace) iter.next();
            if (prefix.equals(ns.getPrefix())) {
                return ns.getNamespaceURI();     
            }
        }
        return null;
    }

    /**
     * Add xmlns NS declarations of element 'elem' into XPath expression
     * @param xpath
     * @param elem
     * @param log
     */
    public static void addNameSpaces(AXIOMXPath xpath, OMElement elem, Log log) {
        try {
            Iterator it = elem.getAllDeclaredNamespaces();
            while (it.hasNext()) {
                OMNamespace n = (OMNamespace) it.next();
                xpath.addNamespace(n.getPrefix(), n.getNamespaceURI());
            }
        } catch (JaxenException je) {
            String msg = ""Error adding declared name spaces of "" + elem + "" to the XPath : "" + xpath;
            log.error(msg);
            throw new SynapseException(msg, je);
        }
    }

}
"
org/apache/synapse/config/xml/XSLTMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.OMElementUtils;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.apache.synapse.config.xml.Constants;
import org.apache.synapse.config.xml.AbstractMediatorFactory;
import org.apache.synapse.config.xml.MediatorPropertyFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Creates a XSLT mediator from the given XML
 *
 * <pre>
 * &lt;xslt key=""property-key"" [source=""xpath""]&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/transform&gt;
 * </pre>
 */
public class XSLTMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(XSLTMediatorFactory.class);
    private static final QName TAG_NAME    = new QName(Constants.SYNAPSE_NAMESPACE, ""xslt"");

    public QName getTagQName() {
        return TAG_NAME;
    }

    public Mediator createMediator(OMElement elem) {

        XSLTMediator transformMediator = new XSLTMediator();

        OMAttribute attXslt   = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""key""));
        OMAttribute attSource = elem.getAttribute(new QName(Constants.NULL_NAMESPACE, ""source""));

        if (attXslt != null) {
            transformMediator.setXsltKey(attXslt.getAttributeValue());
        } else {
            handleException(""The 'key' attribute is required for the XSLT mediator"");
        }

        if (attSource != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(attSource.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                transformMediator.setSource(xp);

            } catch (JaxenException e) {
                handleException(""Invalid XPath specified for the source attribute : "" +
                    attSource.getAttributeValue());
            }
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(transformMediator,elem);

        transformMediator.addAllProperties(
            MediatorPropertyFactory.getMediatorProperties(elem));

        return transformMediator;
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/EntrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import javax.xml.stream.XMLStreamConstants;
import java.net.URL;

public class EntrySerializer {

    private static Log log = LogFactory.getLog(EntrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(
            Constants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(Constants.NULL_NAMESPACE, """");

    /**
     * Serialize the Entry object to an OMElement representing the entry
     * @param entry
     * @param parent
     * @return OMElement representing the entry
     */
    public static OMElement serializeEntry(Entry entry, OMElement parent) {
        OMElement propertyElement = fac.createOMElement(""localEntry"", synNS);
        propertyElement.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, entry.getKey().trim()));
        int type = entry.getType();
        if (type == Entry.URL_SRC) {
            URL srcUrl = entry.getSrc();
            if (srcUrl != null) {
                propertyElement.addAttribute(fac.createOMAttribute(
                        ""src"", nullNS, srcUrl.toString().trim()));
            }
        } else if (type == Entry.INLINE_XML) {
            Object value = entry.getValue();
            if (value != null && value instanceof OMElement) {
                propertyElement.addChild((OMElement) value);
            }
        } else if (type == Entry.INLINE_TEXT) {
            Object value = entry.getValue();
            if (value != null && value instanceof String) {
                OMTextImpl textData = (OMTextImpl) fac.createOMText(((String) value).trim());
                textData.setType(XMLStreamConstants.CDATA);
                propertyElement.addChild(textData);
            }
        } else if (type == Entry.REMOTE_ENTRY) {
            // nothing to serialize
            return null;
        } else {
            handleException(""Entry type undefined"");
        }
        if (parent != null) {
            parent.addChild(propertyElement);
        }
        return propertyElement;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/core/SynapseEnvironment.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.StatisticsCollector;

/**
 * The SynapseEnvironment allows access into the the host SOAP engine. It allows
 * the sending of messages, classloader access etc.
 */
public interface SynapseEnvironment {

    /**
     * This method injects a new message into the Synapse engine. This is used by
     * the underlying SOAP engine to inject messages into Synapse for mediation.
     * e.g. The SynapseMessageReceiver used by Axis2 invokes this to inject new messages
     */
    public void injectMessage(MessageContext smc);

    /**
     * This method allows a message to be sent through the underlying SOAP engine.
     * <p/>
     * This will send request messages on (forward), and send the response messages back to the client
     */
    public void send(EndpointDefinition endpoint, MessageContext smc);

    /**
     * Creates a new Synapse <code>MessageContext</code> instance.
     * @return a MessageContext
     */
    public MessageContext createMessageContext();

    /**
     * This method returns the StatisticsCollector
     *
     * @return Retruns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector();

    /**
     * To set the StatisticsCollector
     *
     * @param statisticsCollector
     */
    public void setStatisticsCollector(StatisticsCollector statisticsCollector);
}
"
org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import java.util.ArrayList;
import java.util.Iterator;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axis2.AxisFault;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.context.ServiceGroupContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisServiceGroup;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.axiom.attachments.Attachments;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.rampart.handler.WSSHandlerConstants;
import org.apache.sandesha2.client.SandeshaClientConstants;

/**
 * This is a simple client that handles both in only and in out
 */
public class Axis2FlexibleMEPClient {

    private static final Log log = LogFactory.getLog(Axis2FlexibleMEPClient.class);

    /**
     * Based on the Axis2 client code. Sends the Axis2 Message context out and returns
     * the Axis2 message context for the response.
     *
     * Here Synapse works as a Client to the service. It would expect 200 ok, 202 ok and
     * 500 internal server error as possible responses. Currently the code expects
     * Synchronus operation
     *
     * @param endpoint
     * @param synapseOutMessageContext
     * @return The Axis2 reponse message context
     */
    public static void send(

        EndpointDefinition endpoint,
        org.apache.synapse.MessageContext synapseOutMessageContext) throws AxisFault {

        boolean separateListener    = false;
        boolean wsSecurityEnabled   = false;
        String wsSecPolicyKey       = null;
        boolean wsRMEnabled         = false;
        String wsRMPolicyKey        = null;
        boolean wsAddressingEnabled = false;

        if (endpoint != null) {
            separateListener    = endpoint.isUseSeparateListener();
            wsSecurityEnabled   = endpoint.isSecurityOn();
            wsSecPolicyKey      = endpoint.getWsSecPolicyKey();
            wsRMEnabled         = endpoint.isReliableMessagingOn();
            wsRMPolicyKey       = endpoint.getWsRMPolicyKey();
            wsAddressingEnabled = endpoint.isAddressingOn() || wsSecurityEnabled || wsRMEnabled;
        }

        if (log.isDebugEnabled()) {
            log.debug(
                ""sending [add = "" + wsAddressingEnabled +
                ""] [sec = "" + wsSecurityEnabled +
                ""] [rm = "" + wsRMEnabled +
                (endpoint != null ?
                    ""] [ mtom = "" + endpoint.isUseMTOM() +
                    ""] [ swa = "" + endpoint.isUseSwa() +
                    ""] [ force soap="" + endpoint.isForceSOAP() +
                    ""; pox="" + endpoint.isForcePOX() : """") +
                ""] [ to "" + synapseOutMessageContext.getTo() + ""]"");
        }

        // save the original message context wihout altering it, so we can tie the response
        MessageContext originalInMsgCtx = ((Axis2MessageContext) synapseOutMessageContext).getAxis2MessageContext();

        // create a new MessageContext to be sent out as this should not corrupt the original
        // we need to create the response to the original message later on
        MessageContext axisOutMsgCtx = cloneForSend(originalInMsgCtx);

        // set all the details of the endpoint only to the cloned message context
        // so that we can use the original message context for resending through different endpoints
        String eprAddress = null;
        if (endpoint != null && endpoint.getAddress() != null) {

            eprAddress = endpoint.getAddress().toString();

            if (endpoint.isForcePOX()) {
                axisOutMsgCtx.setDoingREST(true);
            } else if (endpoint.isForceSOAP()) {
                axisOutMsgCtx.setDoingREST(false);
                if (axisOutMsgCtx.getSoapAction() == null && axisOutMsgCtx.getWSAAction() != null) {
                    axisOutMsgCtx.setSoapAction(axisOutMsgCtx.getWSAAction());
                }
            }

            if (endpoint.isUseMTOM()) {
                axisOutMsgCtx.setDoingMTOM(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingMTOM(true);

            } else if (endpoint.isUseSwa()) {
                axisOutMsgCtx.setDoingSwA(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingSwA(true);
            }

            if (endpoint.isUseSeparateListener()) {
                axisOutMsgCtx.setProperty(Constants.OUTFLOW_USE_SEPARATE_LISTENER, Boolean.TRUE);
            }

            axisOutMsgCtx.setTo(new EndpointReference(eprAddress));
        }

        if (wsAddressingEnabled) {
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.FALSE);

        } else {
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);
        }

        ConfigurationContext axisCfgCtx = axisOutMsgCtx.getConfigurationContext();
        AxisConfiguration axisCfg       = axisCfgCtx.getAxisConfiguration();

        AxisService anoymousService =
            AnonymousServiceFactory.getAnonymousService(
            axisCfg, wsAddressingEnabled, wsRMEnabled, wsSecurityEnabled);
        ServiceGroupContext sgc = new ServiceGroupContext(
            axisCfgCtx, (AxisServiceGroup) anoymousService.getParent());
        ServiceContext serviceCtx = sgc.getServiceContext(anoymousService);

        // get a reference to the DYNAMIC operation of the Anonymous Axis2 service
        AxisOperation axisAnonymousOperation = anoymousService.getOperation(
            new QName(AnonymousServiceFactory.DYNAMIC_OPERATION));

        Options clientOptions = new Options();
        clientOptions.setUseSeparateListener(separateListener);
        // if RM is requested,
        if (wsRMEnabled) {
            // if a WS-RM policy is specified, use it
            if (wsRMPolicyKey != null) {
                clientOptions.setProperty(
                    org.apache.synapse.config.xml.Constants.SANDESHA_POLICY,
                    getPolicy(synapseOutMessageContext, wsRMPolicyKey));
            }
            copyRMOptions(originalInMsgCtx, clientOptions);

            // always send each and every message in a new sequence and terminate sequence
            //clientOptions.setProperty(""Sandesha2LastMessage"", ""true"");
        }

        // if security is enabled,
        if (wsSecurityEnabled) {
            // if a WS-Sec policy is specified, use it
            if (wsSecPolicyKey != null) {
                clientOptions.setProperty(
                    org.apache.synapse.config.xml.Constants.RAMPART_POLICY,
                    getPolicy(synapseOutMessageContext, wsSecPolicyKey));
            }
            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (axisOutMsgCtx.getEnvelope().getHeader() == null) {
                SOAPFactory fac = axisOutMsgCtx.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(axisOutMsgCtx.getEnvelope());
            }
        }
        OperationClient mepClient = axisAnonymousOperation.createClient(
            serviceCtx, clientOptions);
        mepClient.addMessageContext(axisOutMsgCtx);
        axisOutMsgCtx.setAxisMessage(
            axisAnonymousOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));

        // always set a callback as we decide if the send it blocking or non blocking within
        // the MEP client. This does not cause an overhead, as we simply create a 'holder'
        // object with a reference to the outgoing synapse message context synapseOutMessageContext
        AsyncCallback callback = new AsyncCallback(synapseOutMessageContext);
        if (endpoint != null) {
            // set the timeout time and the timeout action to the callback, so that the TimeoutHandler
            // can detect timed out callbacks and take approprite action.
            callback.setTimeOutOn(System.currentTimeMillis() + endpoint.getTimeoutDuration());
            callback.setTimeOutAction(endpoint.getTimeoutAction());
        }
        mepClient.setCallback(callback);
        
        mepClient.execute(false);

        // with the nio transport, this causes the listener not to write a 202
        // Accepted response, as this implies that Synapse does not yet know if
        // a 202 or 200 response would be written back.
        originalInMsgCtx.getOperationContext().setProperty(
            org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");
   }

    private static MessageContext cloneForSend(MessageContext ori) throws AxisFault {
        MessageContext newMC = new MessageContext();

        // do not copy options from the original
        newMC.setConfigurationContext(ori.getConfigurationContext());
        newMC.setMessageID(UUIDGenerator.getUUID());
        newMC.setTo(ori.getTo());
        newMC.setSoapAction(ori.getSoapAction());

        newMC.setProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING,
                ori.getProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA));

        newMC.setDoingREST(ori.isDoingREST());
        newMC.setDoingMTOM(ori.isDoingMTOM());
        newMC.setDoingSwA(ori.isDoingSwA());

        // if the original request carries any attachments, copy them to the clone
        // as well, except for the soap part if any
        Attachments attachments = ori.getAttachmentMap();
        if (attachments != null && attachments.getAllContentIDs().length > 0) {
            String[] cIDs = attachments.getAllContentIDs();
            String soapPart = attachments.getSOAPPartContentID();
            for (int i=0; i<cIDs.length; i++) {
                if (!cIDs[i].equals(soapPart)) {
                    newMC.addAttachment(cIDs[i], attachments.getDataHandler(cIDs[i]));
                }
            }
        }

        newMC.setServerSide(false);

        // set SOAP envelope on the message context, removing WS-A headers
        newMC.setEnvelope(ori.getEnvelope());
        removeAddressingHeaders(newMC);

        // pass any transport headers on the original request
        newMC.setProperty(MessageContext.TRANSPORT_HEADERS,
            ori.getProperty(MessageContext.TRANSPORT_HEADERS));

        return newMC;
    }
    
    private static void copyRMOptions(MessageContext oriContext, Options targetOptions) {
        Options oriOptions = oriContext.getOptions();
        if(oriOptions.getProperty(Constants.SANDESHA_LAST_MESSAGE) != null) {
            targetOptions.setProperty(Constants.SANDESHA_LAST_MESSAGE, 
                    oriOptions.getProperty(Constants.SANDESHA_LAST_MESSAGE));
        }
        if(oriOptions.getProperty(Constants.SANDESHA_SPEC_VERSION) != null) {
            targetOptions.setProperty(Constants.SANDESHA_SPEC_VERSION, 
                    oriOptions.getProperty(Constants.SANDESHA_SPEC_VERSION));
        }
        if(oriOptions.getProperty(Constants.SANDESHA_SEQUENCE_KEY) != null) {
            targetOptions.setProperty(Constants.SANDESHA_SEQUENCE_KEY, 
                    oriOptions.getProperty(Constants.SANDESHA_SEQUENCE_KEY));
        }
        if(oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID) != null) {
            targetOptions.setProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID,
                    oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID));
        }
    }
    
    /**
     * Get the Policy object for the given name from the Synapse configuration at runtime
     * @param synCtx the current synapse configuration to get to the synapse configuration
     * @param propertyKey the name of the property which holds the Policy required
     * @return the Policy object with the given name, from the configuration
     */
    private static Policy getPolicy(org.apache.synapse.MessageContext synCtx, String propertyKey) {
        Object property = synCtx.getEntry(propertyKey);
        if (property != null && property instanceof OMElement) {
            return PolicyEngine.getPolicy((OMElement) property);
        } else {
            handleException(""Cannot locate Policy from the property : "" + propertyKey);
        }
        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Removes Submission and Final WS-Addressing headers and return the SOAPEnvelope
     * from the given message context
     * @param axisMsgCtx the Axis2 Message context
     * @return the resulting SOAPEnvelope
     */
    public static SOAPEnvelope removeAddressingHeaders(MessageContext axisMsgCtx) {

        SOAPEnvelope env = axisMsgCtx.getEnvelope();
        SOAPHeader soapHeader = env.getHeader();
        ArrayList addressingHeaders;

        if (soapHeader != null) {
            addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                AddressingConstants.Submission.WSA_NAMESPACE);

            if (addressingHeaders != null && addressingHeaders.size() != 0) {
                detachAddressingInformation(addressingHeaders);

            } else {
                addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                    AddressingConstants.Final.WSA_NAMESPACE);
                if (addressingHeaders != null && addressingHeaders.size() != 0) {
                    detachAddressingInformation(addressingHeaders);
                }
            }
        }
        return env;
    }

    /**
     * Remove WS-A headers
     * @param headerInformation headers to be removed
     */
    private static void detachAddressingInformation(ArrayList headerInformation) {
       Iterator iterator = headerInformation.iterator();
       while (iterator.hasNext()) {
           Object o = iterator.next();
           if (o instanceof SOAPHeaderBlock) {
               SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
               headerBlock.detach();
           } else if (o instanceof OMElement) {
               // work around for a known addressing bug which sends non SOAPHeaderBlock objects
               OMElement om = (OMElement) o;
               OMNamespace ns = om.getNamespace();
               if (ns != null &&
                       (AddressingConstants.Submission.WSA_NAMESPACE.equals(ns.getNamespaceURI())
                       || AddressingConstants.Final.WSA_NAMESPACE.equals(ns.getNamespaceURI()))) {
                   om.detach();
               }
           }
       }
   }
}
"
org/apache/synapse/mediators/filters/InMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The In Mediator acts only on ""incoming"" messages into synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class InMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    private static final Log log = LogFactory.getLog(InMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {
        log.debug(""In mediator mediate()"");
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        try {
            if (shouldTrace) {
                trace.trace(""Start : In mediator"");
            }
            if (test(synCtx)) {
                log.debug(""Current message is incoming.. executing child mediators"");
                return super.mediate(synCtx);
            } else {
                log.debug(""Current message is not incoming.. skipping child mediators"");
                return true;
            }
        } finally {
            if (shouldTrace) {
                trace.trace(""End : In mediator"");
            }
        }
    }

    /**
     * Apply mediation only on request messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return !synCtx.isResponse();
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.config.xml.Constants;

import javax.xml.namespace.QName;
import java.util.ArrayList;

/**
 * Factroy of all load balance algorithms. ESBSendMediatorFactroy will use this to create the
 * appropriate algorithm implementation.
 */
public class LoadbalanceAlgorithmFactory {

    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement, ArrayList endpoints) {

        LoadbalanceAlgorithm algorithm = null;

        String algorithmName = ""roundRobin"";
        OMAttribute algoAttribute = loadbalanceElement.getAttribute(new QName(null, Constants.ALGORITHM_NAME));
        if(algoAttribute != null) {
            algorithmName = algoAttribute.getAttributeValue();
        }

        if(algorithmName.equalsIgnoreCase(""roundRobin"")) {
                algorithm = new RoundRobin(endpoints);
        }

        return algorithm;
    }
}
"
org/apache/synapse/endpoints/FailoverEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;

import java.util.List;

/**
 * FailoverEndpoint can have multiple child endpoints. It will always try to send messages to current
 * endpoint. If the current endpoint is failing, it gets another active endpoint from the list and
 * make it the current endpoint. Then the message is sent to the current endpoint and if it fails, above
 * procedure repeats until there are no active endpoints. If all endpoints are failing and parent
 * endpoint is available, this will delegate the problem to the parent endpoint. If parent endpoint
 * is not available it will pop the next FaultHandler and delegate the problem to that.
 */
public class FailoverEndpoint implements Endpoint {

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * Determine whether this endpoint is active or not. This is active iff all child endpoints of
     * this endpoint is active. This is always loaded from the memory as it could be accessed from
     * multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * List of child endpoints. Failover sending is done among these. Any object implementing the
     * Endpoint interface can be a child.
     */
    private List endpoints = null;

    /**
     * Endpoint for which currently sending the SOAP traffic.
     */
    private Endpoint currentEndpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects. But use of
     * SALoadbalanceEndpoint as the parent is the logical scenario.
     */
    private Endpoint parentEndpoint = null;

    public void send(MessageContext synMessageContext) {

        // We have to build the envelop if we are supporting failover.
        // Failover should sent the original message multiple times if failures occur. So we have to
        // access the envelop multiple times.        
        synMessageContext.getEnvelope().build();

        if (currentEndpoint.isActive(synMessageContext)) {
            currentEndpoint.send(synMessageContext);
        } else {

            Endpoint liveEndpoint = null;
            boolean foundEndpoint = false;
            for (int i = 0; i < endpoints.size(); i++) {
                liveEndpoint = (Endpoint) endpoints.get(i);
                if (liveEndpoint.isActive(synMessageContext)) {
                    foundEndpoint = true;
                    currentEndpoint = liveEndpoint;
                    currentEndpoint.send(synMessageContext);
                    break;
                }
            }

            if (!foundEndpoint) {
                // there are no active child endpoints. so mark this endpoint as failed.
                setActive(false, synMessageContext);

                if (parentEndpoint != null) {
                    parentEndpoint.onChildEndpointFail(this, synMessageContext);
                } else {
                    Object o = synMessageContext.getFaultStack().pop();
                    if (o != null) {
                        ((FaultHandler) o).handleFault(synMessageContext);
                    }
                }
            }
        }
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            for (int i = 0; i < endpoints.size(); i++) {
                Endpoint endpoint = (Endpoint) endpoints.get(i);
                if (endpoint.isActive(synMessageContext)) {
                    active = true;

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean value is thread safe.
        this.active = active;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
        if (endpoints.size() > 0) {
            currentEndpoint = (Endpoint) endpoints.get(0);
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        send(synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This is Serializer  for serialization of an anonymous list mediator(an unnamed list of mediators )
 */

public abstract class AnonymousListMediatorSerializer extends AbstractListMediatorSerializer {

    private static final Log log = LogFactory.getLog(AnonymousListMediatorSerializer.class);

    /**
     * To serialize an  anonymous list mediator
     *
     * @param parent
     * @param m
     * @return OMElement
     */
    public static OMElement serializeAnonymousListMediator(OMElement parent, Mediator m) {
        if (!(m instanceof AnonymousListMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        AnonymousListMediator mediator = (AnonymousListMediator) m;
        serializeChildren(parent, mediator.getList());
        return parent;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/registry/RegistryEntry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import java.net.URI;

/**
 * This interface defines the core information to be returned by a Registry implementation
 * about a resource being managed by it. Every Registry implementation *must* provide valid
 * information for the methods marked below as 'required'
 */
public interface RegistryEntry {

    /** The key for the resource - required */
    public String getKey();

    /** A name for the resource - optional */
    public String getName();

    /** The version of the resource - required */
    public long getVersion();

    /** The type of the resource - optional */
    public URI getType();

    /** A description for the resource - optional */
    public String getDescription();

    /** The created time for the resource - optional */
    public long getCreated();

    /** The last updated time for the resource - optional */
    public long getLastModified();

    /** The number of milliseconds this resource could be cached */
    public long getCachableDuration();
}
"
org/apache/synapse/config/xml/ValidateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.OMElementUtils;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.apache.synapse.config.xml.AbstractListMediatorFactory;
import org.apache.synapse.config.xml.Constants;
import org.apache.synapse.config.xml.MediatorPropertyFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Creates a validation mediator from the XML configuration
 * <p/>
 * <validate [source=""xpath""]>
 *   <schema key=""string"">+
 *   <property name=""<validation-feature-id>"" value=""true|false""/> *
 *   <on-fail>
 *     mediator+
 *   </on-fail>
 * </validate>
 */
public class ValidateMediatorFactory extends AbstractListMediatorFactory {

    private static final Log log = LogFactory.getLog(ValidateMediatorFactory.class);

    private static final QName VALIDATE_Q = new QName(Constants.SYNAPSE_NAMESPACE, ""validate"");
    private static final QName ON_FAIL_Q  = new QName(Constants.SYNAPSE_NAMESPACE, ""on-fail"");
    private static final QName SCHEMA_Q   = new QName(Constants.SYNAPSE_NAMESPACE, ""schema"");
    private static final QName KEY_Q      = new QName(Constants.NULL_NAMESPACE, ""key"");
    private static final QName SOURCE_Q   = new QName(Constants.NULL_NAMESPACE, ""source"");

    public Mediator createMediator(OMElement elem) {

        ValidateMediator validateMediator = new ValidateMediator();

        // process schema element definitions and create DynamicProperties
        List schemaKeys = new ArrayList();
        Iterator schemas = elem.getChildrenWithName(SCHEMA_Q);

        while (schemas.hasNext()) {
            Object o = schemas.next();
            if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                OMAttribute keyAtt = omElem.getAttribute(KEY_Q);
                if (keyAtt != null) {
                    schemaKeys.add(keyAtt.getAttributeValue());
                } else {
                    handleException(""A 'schema' definition must contain a local property 'key'"");
                }
            } else {
                handleException(""Invalid 'schema' declaration for validate mediator"");
            }
        }

        if (schemaKeys.size() == 0) {
            handleException(""No schemas specified for the validate mediator"");
        } else {
            validateMediator.setSchemaKeys(schemaKeys);
        }

        // process source XPath attribute if present
        OMAttribute attSource = elem.getAttribute(SOURCE_Q);

        if (attSource != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(attSource.getAttributeValue());
                validateMediator.setSource(xp);
                OMElementUtils.addNameSpaces(xp, elem, log);
            } catch (JaxenException e) {
                handleException(""Invalid XPath expression specified for attribute 'source'"", e);
            }
        }

        // process on-fail
        OMElement onFail = null;
        Iterator iter = elem.getChildrenWithName(ON_FAIL_Q);
        if (iter.hasNext()) {
            onFail = (OMElement)iter.next();
        }

        if (onFail != null && onFail.getChildElements().hasNext()) {
            addChildren(onFail, validateMediator);
        } else {
            handleException(""A non-empty <on-fail> child element is required for "" +
                ""the <validate> mediator"");
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        initMediator(validateMediator,elem);

        // process properties
        validateMediator.addAllProperties(
            MediatorPropertyFactory.getMediatorProperties(elem));

        return validateMediator;
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public QName getTagQName() {
        return VALIDATE_Q;
    }
}
"
org/apache/synapse/config/xml/FilterMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.FilterMediator;

/**
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorSerializer extends AbstractListMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(FilterMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FilterMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FilterMediator mediator = (FilterMediator) m;
        OMElement filter = fac.createOMElement(""filter"", synNS);

        if (mediator.getSource() != null && mediator.getRegex() != null) {
            filter.addAttribute(fac.createOMAttribute(
                ""source"", nullNS, mediator.getSource().toString()));
            super.serializeNamespaces(filter, mediator.getSource());

            filter.addAttribute(fac.createOMAttribute(
                ""regex"", nullNS, mediator.getRegex().pattern()));

        } else if (mediator.getXpath() != null) {
            filter.addAttribute(fac.createOMAttribute(
                ""xpath"", nullNS, mediator.getXpath().toString()));
            super.serializeNamespaces(filter, mediator.getXpath());

        } else {
            handleException(""Invalid filter mediator. "" +
                ""Should have either a 'source' and a 'regex' OR an 'xpath' "");
        }

        finalizeSerialization(filter, mediator);
        serializeChildren(filter, mediator.getList());

        if (parent != null) {
            parent.addChild(filter);
        }
        return filter;
    }

    public String getMediatorClassName() {
        return FilterMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/builtin/PropertyMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;

/**
 * The property mediator would save(or remove) a named property as a local property of the Synapse Message Context
 * or as a property of the Axis2 Message Context or as a Transport Header.
 * Properties set this way could be extracted through the XPath extension function ""synapse:get-property(scope,prop-name)""
 */

public class PropertyMediator extends AbstractMediator {

    /** The Name of the property  */
    private String name = null;
    /** The Value to be set*/
    private String value = null;
    /** The XPath expr. to get value  */
    private AXIOMXPath expression = null;
    /** The scope for which decide properties where to go*/
    private String scope = null;
    /** The Action - set or remove */
    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;
    /** Set the property (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;
    private static final Log log = LogFactory.getLog(PropertyMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Sets or  a property into the current (local) Synapse Context or into the Axis Message Context
     * or into Transports Header
     * And Removes above properties from the corresspounding locations
     *
     * @param smc the message context
     * @return true always
     */
    public boolean mediate(MessageContext smc) {
        log.debug(""Property mediator :: mediate()"");
        boolean shouldTrace = shouldTrace(smc.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Property mediator"");
        }
        if (action == ACTION_SET) {
            String resultValue = (this.value != null ? this.value : Axis2MessageContext.getStringValue(
                    expression, smc));
            log.debug(""Setting : "" + name +
                    "" property (scope:"" + (scope == null ? ""default"" : scope) + "") = "" + resultValue);
            if (shouldTrace) {
                trace.trace(""Property Name : "" + name +
                        "" (scope:"" + (scope == null ? ""default"" : scope) + "") set to "" +
                        (value != null ? "" resultValue = "" + value :
                                "" result of expression "" + expression + "" = "" + resultValue));
            }
            if (scope == null) {
                //Setting property into the  Synapse Context
                smc.setProperty(name, resultValue);
            } else if (Constants.SCOPE_DEFAULT.equals(scope)) {
                //Setting property into the  Synapse Context
                smc.setProperty(name, resultValue);
            } else if (Constants.SCOPE_AXIS2.equals(scope)
                    && smc instanceof Axis2MessageContext) {
                //Setting property into the  Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) smc;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.setProperty(name, resultValue);

            } else if (Constants.SCOPE_TRANSPORT.equals(scope)
                    && smc instanceof Axis2MessageContext) {
                //Setting Transport Headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) smc;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.put(name, resultValue);
                }
                if (headers == null) {
                    Map headersMap = new HashMap();
                    headersMap.put(name, resultValue);
                    axis2MessageCtx.setProperty(
                            org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
                            headersMap);
                }
            } else {
                String msg = ""Unsupported scope : "" + scope + "" for property mediator"";
                handleException(msg);
            }
        } else {
            log.debug(""Removing : "" + name +
                    "" property (scope:"" + (scope == null ? ""default"" : scope) + "") "");
            trace.trace(""Remove - Property Name : "" + name +
                    "" (scope:"" + (scope == null ? ""default"" : scope) + "")"");
            if (scope == null) {
                //Removing property from the  Synapse Context
                Set pros = smc.getPropertyKeySet();
                if (pros != null) {
                    pros.remove(name);
                }
            } else if (Constants.SCOPE_DEFAULT.equals(scope)) {
                //Removing property from the  Synapse Context
                Set pros = smc.getPropertyKeySet();
                if (pros != null) {
                    pros.remove(name);
                }
            } else if (Constants.SCOPE_AXIS2.equals(scope)
                    && smc instanceof Axis2MessageContext) {
                //Removing property from the  Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) smc;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Map pros = axis2MessageCtx.getProperties();
                if (pros != null) {
                    pros.remove(name);
                }
            } else if (Constants.SCOPE_TRANSPORT.equals(scope)
                    && smc instanceof Axis2MessageContext) {
                // Removing transport headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) smc;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.remove(name);
                }
                if (headers == null) {
                    log.info(""No Headers found "");
                }

            } else {
                String msg = ""Unsupported scope : "" + scope + "" for property mediator"";
                handleException(msg);
            }
        }
        if (shouldTrace) {
            trace.trace(""End : Property mediator"");
        }
        return true;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    public String getScope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }
}
"
org/apache/synapse/config/xml/MediatorPropertyFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * A utility class capable of creating instances of MediatorProperty objects by reading
 * through a given XML configuration
 *
 * <pre>
 * &lt;element&gt;
 *    &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/element&gt;
 * </pre>
 */
public class MediatorPropertyFactory {

    private static final Log log = LogFactory.getLog(MediatorPropertyFactory.class);

    public static List getMediatorProperties(OMElement elem) {

        List propertyList = new ArrayList();

        Iterator iter = elem.getChildrenWithName(new QName(Constants.SYNAPSE_NAMESPACE, ""property""));
        while (iter.hasNext()) {

            OMElement propEle = (OMElement) iter.next();
            OMAttribute attName  = propEle.getAttribute(MediatorProperty.ATT_NAME_Q);
            OMAttribute attValue = propEle.getAttribute(MediatorProperty.ATT_VALUE_Q);
            OMAttribute attExpr  = propEle.getAttribute(MediatorProperty.ATT_EXPR_Q);

            MediatorProperty prop = new MediatorProperty();

            if (attName == null || attName.getAttributeValue() == null ||
                attName.getAttributeValue().trim().length() == 0) {
                String msg = ""Entry name is a required attribute for a Log property"";
                log.error(msg);
                throw new SynapseException(msg);
            } else {
                prop.setName(attName.getAttributeValue());
            }

            // if a value is specified, use it, else look for an expression
            if (attValue != null) {
                if (attValue.getAttributeValue() == null || attValue.getAttributeValue().trim().length() == 0) {
                    String msg = ""Entry attribute value (if specified) is required for a Log property"";
                    log.error(msg);
                    throw new SynapseException(msg);
                } else {
                    prop.setValue(attValue.getAttributeValue());
                }

            } else if (attExpr != null) {

                if (attExpr.getAttributeValue() == null || attExpr.getAttributeValue().trim().length() == 0) {
                    String msg = ""Entry attribute expression (if specified) is required for a mediator property"";
                    log.error(msg);
                    throw new SynapseException(msg);

                } else {
                    try {
                        AXIOMXPath xp = new AXIOMXPath(attExpr.getAttributeValue());
                        OMElementUtils.addNameSpaces(xp, propEle, log);
                        prop.setExpression(xp);

                    } catch (JaxenException e) {
                        String msg = ""Invalid XPapth expression : "" + attExpr.getAttributeValue();
                        log.error(msg);
                        throw new SynapseException(msg, e);
                    }
                }

            } else {
                String msg = ""Entry attribute value OR expression must be specified for a mediator property"";
                log.error(msg);
                throw new SynapseException(msg);
            }

            propertyList.add(prop);
        }

        return propertyList;
    }
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Creates AddressEndpoint using a XML configuration.
 *
 * <endpoint [name=""name""]>
 *   <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *   <address uri=""url"" [format=""soap|pox""] [optimize=""mtom|swa""]>
 *      .. extensibility ..
 *
 *      <timeout>
 *          <duration>duration in milliseconds</duration>
 *          <action>discard | fault</action>
 *      </timeout>
 *
 *      <enableRM [policy=""key""]/>+ <enableSec [policy=""key""]/>+ <enableAddressing
 *      separateListener=""true|false""/>+
 *   </address>
 * </endpoint>
 */
public class AddressEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(AddressEndpointFactory.class);

    private static AddressEndpointFactory instance = new AddressEndpointFactory();

    private AddressEndpointFactory() {}

    public static AddressEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        AddressEndpoint addressEndpoint = new AddressEndpoint();

        if (!anonymousEndpoint) {
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                addressEndpoint.setName(name.getAttributeValue());
            }
        }

        OMElement addressElement = epConfig.getFirstChildWithName
                (new QName(Constants.SYNAPSE_NAMESPACE, ""address""));

        if (addressElement != null) {
            EndpointDefinition endpoint = createEndpointDefinition(addressElement);
            addressEndpoint.setEndpoint(endpoint);

            // set the suspend on fail duration.
            OMElement suspendElement = addressElement.getFirstChildWithName(new QName(
                    Constants.SYNAPSE_NAMESPACE,
                    org.apache.synapse.config.xml.Constants.SUSPEND_DURATION_ON_FAILURE));

            if (suspendElement != null) {
                String suspend = suspendElement.getText();

                try {
                    if (suspend != null) {
                        long suspendDuration = Long.parseLong(suspend.trim());
                        addressEndpoint.setSuspendOnFailDuration(suspendDuration * 1000);
                    }

                } catch (NumberFormatException e) {
                    handleException(""The suspend duration should be specified as a valid number :: ""
                        + e.getMessage(), e);
                }
            }
        }

        return addressEndpoint;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    /**
     * Creates an EndpointDefinition instance using the XML fragment specification. Configuration for
     * EndpointDefinition always resides inside a configuration of an AddressEndpoint. This factory
     * extracts the details related to the EPR provided for address endpoint.
     *
     * @param elem XML configuration element
     * @return EndpointDefinition object containing the endpoint details.
     */
    public EndpointDefinition createEndpointDefinition(OMElement elem) {

        OMAttribute address = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""uri""));
        OMAttribute format = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""format""));
        OMAttribute optimize = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""optimize""));

        EndpointDefinition endpoint = new EndpointDefinition();
        OMAttribute statistics = elem.getAttribute(
                new QName(org.apache.synapse.config.xml.Constants.NULL_NAMESPACE,
                        org.apache.synapse.config.xml.Constants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (org.apache.synapse.config.xml.Constants.STATISTICS_ENABLE.equals(
                        statisticsValue)) {
                    endpoint.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_ON);
                } else if (org.apache.synapse.config.xml.Constants.STATISTICS_DISABLE.equals(
                        statisticsValue)) {
                    endpoint.setStatisticsEnable(org.apache.synapse.Constants.STATISTICS_OFF);
                }
            }
        }
        if (address != null) {
            endpoint.setAddress(address.getAttributeValue());
        } else {
            handleException(""One of the 'address' or 'ref' attributes are required in an ""
                    + ""anonymous endpoint"");
        }
        if (format != null)
        {
            String forceValue = format.getAttributeValue().trim().toLowerCase();
            if (forceValue.equals(""pox"")) {
                endpoint.setForcePOX(true);
            } else if (forceValue.equals(""soap"")) {
                endpoint.setForceSOAP(true);
            } else {
                handleException(""force value -\""""+forceValue+""\"" not yet implemented"");
            }
        }

        if (optimize != null && optimize.getAttributeValue().length() > 0) {
            String method = optimize.getAttributeValue().trim();
            if (""mtom"".equalsIgnoreCase(method)) {
                endpoint.setUseMTOM(true);
            } else if (""swa"".equalsIgnoreCase(method)) {
                endpoint.setUseSwa(true);
            }
        }

        OMElement wsAddr = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableAddressing""));
        if (wsAddr != null) {
            endpoint.setAddressingOn(true);
            String useSepList = wsAddr.getAttributeValue(new QName(
                    ""separateListener""));
            if (useSepList != null) {
                if (useSepList.trim().toLowerCase().startsWith(""tr"")
                        || useSepList.trim().startsWith(""1"")) {
                    endpoint.setUseSeparateListener(true);
                }
            }
        }
        OMElement wsSec = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableSec""));
        if (wsSec != null) {
            endpoint.setSecurityOn(true);
            OMAttribute policy = wsSec.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpoint.setWsSecPolicyKey(policy.getAttributeValue());
            }
        }
        OMElement wsRm = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""enableRM""));
        if (wsRm != null) {
            endpoint.setReliableMessagingOn(true);
            OMAttribute policy = wsRm.getAttribute(new QName(
                    org.apache.synapse.config.xml.Constants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpoint.setWsRMPolicyKey(policy.getAttributeValue());
            }
        }
        // set the timeout configuration
        OMElement timeout = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""timeout""));
        if (timeout != null) {
            OMElement duration = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""duration""));
            if (duration != null) {
                String d = duration.getText();
                if (d != null) {
                    try {
                        long timeoutSeconds = new Long(d.trim()).longValue();
                        endpoint.setTimeoutDuration(timeoutSeconds * 1000);
                        
                    } catch (NumberFormatException e) {
                        handleException(
                            ""The timeout seconds should be specified as a valid number :: ""
                            + e.getMessage(), e);
                    }
                }
            }

            OMElement action = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.Constants.SYNAPSE_NAMESPACE, ""action""));
            if (action != null) {
                String a = action.getText();
                if (a != null) {
                    if ((a.trim()).equalsIgnoreCase(""discard"")) {
                        endpoint.setTimeoutAction(Constants.DISCARD);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpoint.getTimeoutDuration() == 0) {
                            endpoint.setTimeoutDuration(30000);
                        }
                    } else if ((a.trim()).equalsIgnoreCase(""fault"")) {
                        endpoint.setTimeoutAction(Constants.DISCARD_AND_FAULT);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpoint.getTimeoutDuration() == 0) {
                            endpoint.setTimeoutDuration(30000);
                        }
                    }
                }
            }
        }

        return endpoint;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/endpoints/Endpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;

/**
 * Endpoint defines the bahavior common to all synapse endpoints. Synapse endpoints should be able
 * to send the given synapse message context, rather than just providing the information for sending
 * the message. The task a particuler endpoint does in its send(...) methis is specific to the endpoint.
 * For example a loadbalance endpoint may choose another endpoint using its loadbalance policy and
 * call its send(...) method while an address endpoint (leaf level) may send the message to a actual
 * endpoint url. Endpoints may contain zero or more endpoints in them and build up a heirachycal
 * structure of endpoints.
 */
public interface Endpoint {

    /**
     * Sends the message context according to an endpoint specific behavior.
     *
     * @param synMessageContext MessageContext to be sent.
     */
    public void send(MessageContext synMessageContext);

    /**
     * Endpoints that contain other endpoints should implement this method. It will be called if a
     * child endpoint causes an exception. Action to be taken on such failure is upto the implementation.
     * But it is good practice to first try addressing the issue. If it can't be addressed propagate the
     * exception to parent endpoint by calling parent endpoint's onChildEndpointFail(...) method.
     *
     * @param endpoint The child endpoint which caused the exception.
     * @param synMessageContext MessageContext that was used in the failed attempt.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext);

    /**
     * Sets the parent endpoint for the current endpoint.
     *
     * @param parentEndpoint parent endpoint containing this endpoint. It should handle the onChildEndpointFail(...)
     * callback.
     */
    public void setParentEndpoint(Endpoint parentEndpoint);

    /**
     * Returns the name of the endpoint.
     *
     * @return Endpoint name.
     */
    public String getName();

    /**
     * Sets the name of the endpoint. Local registry use this name as the key for storing the
     * endpoint.
     *
     * @param name Name for the endpoint.
     */
    public void setName(String name);

    /**
     * Returns if the endpoint is currently active or not. Messages should not be sent to inactive
     * endpoints.
     *
     * @param synMessageContext MessageContext for the current message. This is required for
     * IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     * Endpoint implementations may ignore this parameter.
     *
     * @return true if the endpoint is in active state. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext);

    /**
     * Sets the endpoint as active or inactive. If an endpoint is detected as failed, it should be
     * set as inactive. But endpoints may be eventually set as active by the endpoint refresher to
     * avoid ignoring endpoints forever.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext for the current message. This is required for
     * IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     * Endpoint implementations may ignore this parameter.
     */
    public void setActive(boolean active, MessageContext synMessageContext);
}
"
org/apache/synapse/endpoints/LoadbalanceEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;

import java.util.ArrayList;
import java.util.List;

/**
 * Load balance endpoint can have multiple endpoints. It will route messages according to the
 * specified loadbalance algorithm. This will assume that all immediate child endpoints are identical
 * in state (state is replicated) or state is not maintained at those endpoints. If an endpoint is
 * failing, the failed endpoint is marked as inactive and the message to the next endpoint obtained
 * using the loadbalance algorithm. If all the endpoints have failed and the parent endpoint is
 * available, onChildEndpointFail(...) methos of parent endpoint is called. If parent is not
 * avialable, this will call next FaultHandler for the message context.
 */
public class LoadbalanceEndpoint implements Endpoint {

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the load. Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

    /**
     * Determine whether this endpoint is active or not. This is active iff all child endpoints of
     * this endpoint is active. This is always loaded from the memory as it could be accessed from
     * multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * If this supports load balancing with failover. If true, request will be directed to the next
     * endpoint if the current one is failing.
     */
    private boolean failover = true;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    public void send(MessageContext synMessageContext) {

        Endpoint endpoint = algorithm.getNextEndpoint(synMessageContext);
        if (endpoint != null) {

            // We have to build the envelop if we are supporting failover.
            // Failover should sent the original message multiple times if failures occur. So we have to
            // access the envelop multiple times.
            if (failover) {
                synMessageContext.getEnvelope().build();
            }

            endpoint.send(synMessageContext);

        } else {
            // there are no active child endpoints. so mark this endpoint as failed.
            setActive(false, synMessageContext);

            if (parentEndpoint != null) {
                parentEndpoint.onChildEndpointFail(this, synMessageContext);
            } else {
                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true. As this a sessionless load balancing endpoint
     * having one active child endpoint is enough to consider this as active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            for (int i = 0; i < endpoints.size(); i++) {
                Endpoint endpoint = (Endpoint) endpoints.get(i);
                if (endpoint.isActive(synMessageContext)) {
                    active = true;

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean variable is thread safe.
        this.active = active;
    }

    public boolean isFailover() {
        return failover;
    }

    public void setFailover(boolean failover) {
        this.failover = failover;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        // resend (to a different endpoint) only if we support failover
        if (failover) {
            send(synMessageContext);
        } else {
            // we are not informing this to the parent endpoint as the failure of this loadbalance
            // endpoint. there can be more active endpoints under this, and current request has
            // failed only because the currently selected child endpoint has failed AND failover is
            // turned off in this load balance endpoint. so just call the next fault handler.
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }
}
"
org/apache/synapse/config/xml/RegistrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import java.util.Iterator;

/**
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistrySerializer {

    private static final Log log = LogFactory.getLog(RegistrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(Constants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(Constants.NULL_NAMESPACE, """");

    public static OMElement serializeRegistry(OMElement parent, Registry registry) {

        OMElement reg = fac.createOMElement(""registry"", synNS);

        if (registry.getProviderClass() != null) {
            reg.addAttribute(fac.createOMAttribute(
                ""provider"", nullNS, registry.getProviderClass()));
        } else {
            handleException(""Invalid registry. Provider is required"");
        }

        Iterator iter = registry.getConfigProperties().keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            String value = (String) registry.getConfigProperties().get(name);
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, name));
            property.setText(value.trim());
            reg.addChild(property);
        }

        if (parent != null) {
            parent.addChild(reg);
        }
        return reg;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;

import java.util.ArrayList;
import java.util.List;

/**
 * Serializes LoadbalanceEndpoint to an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <loadbalance policy=""load balance algorithm"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class LoadbalanceEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof LoadbalanceEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", Constants.SYNAPSE_OMNAMESPACE);

        LoadbalanceEndpoint loadbalanceEndpoint = (LoadbalanceEndpoint) endpoint;

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement loadbalanceElement = fac.createOMElement(""loadbalance"", Constants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute
                (org.apache.synapse.config.xml.Constants.ALGORITHM_NAME, algorithmName, null);

        // set if failover is turned off in the endpoint
        if (!loadbalanceEndpoint.isFailover()) {
            loadbalanceElement.addAttribute(""failover"", ""false"", null);
        }

        List endpoints = loadbalanceEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            loadbalanceElement.addChild(aeElement);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/util/UUIDGenerator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

/**
 * This is a thread-safe version of the Axiom UUIDGenerator
 * to be used until it is fixed in the next Axiom release
 */
public class UUIDGenerator {
    /** This class will give UUIDs for axis2. */

    private static String baseUUID = null;
    private static long incrementingValue = 0;

    private static Random myRand = null;
    private static boolean useNano = false;

    /**
     * MD5 a random string with localhost/date etc will return 128 bits construct a string of 18
     * characters from those bits.
     *
     * @return string
     */
    public static String getUUID() {
        if (baseUUID == null) {
            baseUUID = getInitialUUID();
            baseUUID = ""urn:uuid:"" + baseUUID;
        }
        if (++incrementingValue >= Long.MAX_VALUE) {
            incrementingValue = 0;
        }

        if (useNano) {
            return baseUUID + (System.nanoTime() + incrementingValue) +
                Integer.toString(myRand.nextInt());
        } else {

            return baseUUID + (System.currentTimeMillis() + incrementingValue +
                Integer.toString(myRand.nextInt()));
        }

    }

    protected static String getInitialUUID() {

        try {
            if (System.class.getMethod(""nanoTime"", new Class[0]) != null) {
                useNano = true;
            }
        } catch (NoSuchMethodException ignore) {}

        if (myRand == null) {
            myRand = new Random();
        }
        long rand = myRand.nextLong();
        String sid;
        try {
            sid = InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            sid = Thread.currentThread().getName();
        }
        StringBuffer sb = new StringBuffer();
        sb.append(sid);
        sb.append("":"");
        sb.append(Long.toString(rand));
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            //System.out.println(""Error: "" + e);
            //todo heve to be properly handle
        }
        md5.update(sb.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb2 = new StringBuffer();
        for (int j = 0; j < array.length; ++j) {
            int b = array[j] & 0xFF;
            sb2.append(Integer.toHexString(b));
        }
        int begin = myRand.nextInt();
        if (begin < 0) begin = begin * -1;
        begin = begin % 8;
        return sb2.toString().substring(begin, begin + 18).toUpperCase();
    }
}
"
org/apache/synapse/core/axis2/Axis2MessageContext.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import org.apache.axiom.om.impl.llom.OMElementImpl;
import org.apache.axiom.om.OMElement;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.*;
import org.apache.synapse.mediators.GetPropertyFunction;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.Entry;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jaxen.SimpleFunctionContext;
import org.jaxen.XPathFunctionContext;
import org.jaxen.JaxenException;

import java.util.*;

/**
 * This is the MessageContext implementation that synapse uses almost all the time because Synapse
 * is implemented on top of the Axis2
 */
public class Axis2MessageContext implements MessageContext {

    private static final Log log = LogFactory.getLog(Axis2MessageContext.class);

    /** Holds the reference to the Synapse Message Context */
    private SynapseConfiguration synCfg = null;

    /** Holds the environment on which synapse operates */
    private SynapseEnvironment synEnv = null;

    /** Synapse Message Context properties */
    private Map properties = new HashMap();

    /**
     * Local entries fetched from the configuration or from the registry for the transactional
     * resource access
     */
    private Map localEntries = new HashMap();

    /** Fault Handler stack which will be popped and called the handleFault in error states */
    private Stack faultStack = new Stack();

    /** The Axis2 MessageContext reference */
    private org.apache.axis2.context.MessageContext axis2MessageContext = null;

    /** Attribute of the MC specifying whether this is a response or not */
    private boolean response = false;

    /** Attribute specifying whether this MC corresponds to fault response or not */
    private boolean faultResponse = false;

    /** Attribute of MC stating the tracing state of the message */
    private int tracingState = Constants.TRACING_UNSET;

    public SynapseConfiguration getConfiguration() {
        return synCfg;
    }

    public void setConfiguration(SynapseConfiguration synCfg) {
        this.synCfg = synCfg;
    }

    public SynapseEnvironment getEnvironment() {
        return synEnv;
    }

    public void setEnvironment(SynapseEnvironment synEnv) {
        this.synEnv = synEnv;
    }

    public Mediator getMainSequence() {
        Object o = localEntries.get(Constants.MAIN_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator main = getConfiguration().getMainSequence();
            localEntries.put(Constants.MAIN_SEQUENCE_KEY, main);
            return main;
        }
    }

    public Mediator getFaultSequence() {
        Object o = localEntries.get(Constants.FAULT_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator fault = getConfiguration().getFaultSequence();
            localEntries.put(Constants.FAULT_SEQUENCE_KEY, fault);
            return fault;
        }
    }

    public Mediator getSequence(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator m = getConfiguration().getSequence(key);
            localEntries.put(key, m);
            return m;
        }
    }

    public Endpoint getEndpoint(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Endpoint) {
            return (Endpoint) o;
        } else {
            Endpoint e = getConfiguration().getEndpoint(key);
            localEntries.put(key, e);
            return e;
        }
    }

    public Object getEntry(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Entry) {
            return ((Entry) o).getValue();
        } else {
            Object e = getConfiguration().getEntry(key);
            if (e != null) {
                localEntries.put(key, e);
                return e;
            } else {
                getConfiguration().getEntryDefinition(key);
                return getConfiguration().getEntry(key);
            }
        }
    }

    public Object getProperty(String key) {
        return properties.get(key);
    }

    public void setProperty(String key, Object value) {
        properties.put(key, value);

        // do not commit response by default in the server process
        if (Constants.RESPONSE.equals(key)) {
            getAxis2MessageContext().getOperationContext().setProperty(
                org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");
        }
    }

    public Set getPropertyKeySet() {
        return properties.keySet();
    }

    /**
     * Constructor for the Axis2MessageContext inside Synapse
     * 
     * @param axisMsgCtx MessageContext representing the relevant Axis MC
     * @param synCfg SynapseConfiguraion describing Synapse
     * @param synEnv SynapseEnvironment describing the environment of Synapse
     */
    public Axis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx,
                               SynapseConfiguration synCfg, SynapseEnvironment synEnv) {
        setAxis2MessageContext(axisMsgCtx);
        this.synCfg = synCfg;
        this.synEnv = synEnv;
        this.pushFaultHandler(new MediatorFaultHandler(synCfg.getFaultSequence()));
    }

    public EndpointReference getFaultTo() {
        return axis2MessageContext.getFaultTo();
    }

    public void setFaultTo(EndpointReference reference) {
        axis2MessageContext.setFaultTo(reference);
    }

    public EndpointReference getFrom() {
        return axis2MessageContext.getFrom();
    }

    public void setFrom(EndpointReference reference) {
        axis2MessageContext.setFrom(reference);
    }

    public SOAPEnvelope getEnvelope() {
        return axis2MessageContext.getEnvelope();
    }

    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault {
        axis2MessageContext.setEnvelope(envelope);
    }

    public String getMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public void setMessageID(String string) {
        axis2MessageContext.setMessageID(string);
    }

    public RelatesTo getRelatesTo() {
        return axis2MessageContext.getRelatesTo();
    }

    public void setRelatesTo(RelatesTo[] reference) {
        axis2MessageContext.setRelationships(reference);
    }

    public EndpointReference getReplyTo() {
        return axis2MessageContext.getReplyTo();
    }

    public void setReplyTo(EndpointReference reference) {
        axis2MessageContext.setReplyTo(reference);
    }

    public EndpointReference getTo() {
        return axis2MessageContext.getTo();
    }

    public void setTo(EndpointReference reference) {
        axis2MessageContext.setTo(reference);
    }

    public void setWSAAction(String actionURI) {
        axis2MessageContext.setWSAAction(actionURI);
    }

    public String getWSAAction() {
        return axis2MessageContext.getWSAAction();
    }

    public void setWSAMessageID(String messageID) {
        axis2MessageContext.setWSAMessageId(messageID);
    }

    public String getWSAMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public String getSoapAction() {
        return axis2MessageContext.getSoapAction();
    }

    public void setSoapAction(String string) {
        axis2MessageContext.setSoapAction(string);
    }

    public boolean isDoingMTOM() {
        return axis2MessageContext.isDoingMTOM();
    }

    public boolean isDoingSWA() {
        return axis2MessageContext.isDoingSwA();
    }

    public void setDoingMTOM(boolean b) {
        axis2MessageContext.setDoingMTOM(b);
    }

    public void setDoingSWA(boolean b) {
        axis2MessageContext.setDoingSwA(b);
    }

    public boolean isDoingPOX() {
        return axis2MessageContext.isDoingREST();
    }

    public void setDoingPOX(boolean b) {
        axis2MessageContext.setDoingREST(b);
    }

    public boolean isSOAP11() {
        return axis2MessageContext.isSOAP11();
    }

    public void setResponse(boolean b) {
        response = b;
        axis2MessageContext.setProperty(Constants.ISRESPONSE_PROPERTY, Boolean.valueOf(b));
    }

    public boolean isResponse() {
        Object o = properties.get(Constants.RESPONSE);
        if (o != null && o instanceof String && ((String) o).equalsIgnoreCase(""true"")) {
            return true;
        }
        return response;
    }

    public void setFaultResponse(boolean b) {
        this.faultResponse = b;
    }

    public boolean isFaultResponse() {
        return this.faultResponse;
    }

    public int getTracingState() {
        return tracingState;
    }

    public void setTracingState(int tracingState) {
        this.tracingState= tracingState;
    }

    public Stack getFaultStack() {
        return this.faultStack;
    }

    public void pushFaultHandler(FaultHandler fault) {
        this.faultStack.push(fault);
    }

    public org.apache.axis2.context.MessageContext getAxis2MessageContext() {
        return axis2MessageContext;
    }

    public void setAxis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx) {
        this.axis2MessageContext = axisMsgCtx;
        Boolean resp = (Boolean) axisMsgCtx.getProperty(Constants.ISRESPONSE_PROPERTY);
        if (resp != null)
            response = resp.booleanValue();
    }

    public void setPaused(boolean value) {
        axis2MessageContext.setPaused(value);
    }

    public boolean isPaused() {
        return axis2MessageContext.isPaused();
    }

    public boolean isServerSide() {
        return axis2MessageContext.isServerSide();
    }

    public void setServerSide(boolean value) {
        axis2MessageContext.setServerSide(value);
    }

    /**
     * Evaluates the given XPath expression against the SOAPEnvelope of the
     * current message and returns a String representation of the result
     * @param xpath the expression to evaluate
     * @param synCtx the source message which holds the SOAP envelope
     * @return a String representation of the result of evaluation
     */
    public static String getStringValue(AXIOMXPath xpath, MessageContext synCtx) {

        if (xpath != null) {
            try {
                // create an instance of a synapse:get-property() function and set it to the xpath
                GetPropertyFunction getPropertyFunc = new GetPropertyFunction();
                getPropertyFunc.setSynCtx(synCtx);

                // set function context into XPath
                SimpleFunctionContext fc = new XPathFunctionContext();
                fc.registerFunction(Constants.SYNAPSE_NAMESPACE, ""get-property"", getPropertyFunc);
                fc.registerFunction(null, ""get-property"", getPropertyFunc);
                xpath.setFunctionContext(fc);

                // register namespace for XPath extension function
                xpath.addNamespace(""synapse"", Constants.SYNAPSE_NAMESPACE);
                xpath.addNamespace(""syn"", Constants.SYNAPSE_NAMESPACE);

            } catch (JaxenException je) {
                handleException(""Error setting up the Synapse XPath "" +
                    ""extension function for XPath : "" + xpath, je);
            }
            try {
                Object result = xpath.evaluate(synCtx.getEnvelope());
                if (result == null) {
                    return null;
                }
                StringBuffer textValue = new StringBuffer();
                if (result instanceof List) {
                    Iterator iter = ((List) result).iterator();
                    while (iter.hasNext()) {
                        Object o = iter.next();
                        if (o == null) {
                            return null;
                        }
                        if (o instanceof OMTextImpl) {
                            textValue.append(((OMTextImpl) o).getText());
                        } else if (o instanceof OMElementImpl) {
                            textValue.append(((OMElementImpl) o).getText());
                        }
                    }
                } else {
                    textValue.append(result.toString());
                }
                return textValue.toString();

            } catch (JaxenException je) {
                handleException(""Evaluation of the XPath expression "" + xpath.toString() +
                    "" resulted in an error"", je);
            }
        } else {
            handleException(""Invalid (null) XPath expression"");
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        String separator = ""\n"";

        if (getTo() != null)
            sb.append(""To: "" + getTo().getAddress());
        else
            sb.append(""To: "");
        if (getFrom() != null)
            sb.append(separator + ""From: "" + getFrom().getAddress());
        if (getWSAAction() != null)
            sb.append(separator + ""WSAction: "" + getWSAAction());
        if (getSoapAction() != null)
            sb.append(separator + ""SOAPAction: "" + getSoapAction());
        if (getReplyTo() != null)
            sb.append(separator + ""ReplyTo: "" + getReplyTo().getAddress());
        if (getMessageID() != null)
            sb.append(separator + ""MessageID: "" + getMessageID());

        Iterator iter = getEnvelope().getHeader().examineAllHeaderBlocks();
        if (iter.hasNext()) {
            sb.append(separator + ""Headers : "");
            while (iter.hasNext()) {
                Object o = iter.next();
                if (o instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                    sb.append(separator + header.getLocalName() + "" : "" + header.getText());
                } else if (o instanceof OMElement) {
                    OMElement headerElem = (OMElement) o;
                    sb.append(separator + headerElem.getLocalName() + "" : "" + headerElem.getText());
                }
            }
        }

        return sb.toString();
    }
}
"
org/apache/synapse/mediators/builtin/ValidateMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Constants;
import org.apache.synapse.config.Util;
import org.apache.synapse.config.Entry;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Validate a message or an element against a schema
 * <p/>
 * This internally uses the Xerces2-j parser, which cautions a lot about thread-safety and
 * memory leaks. Hence this initial implementation will create a single parser instance
 * for each unique mediator instance, and re-use it to validate multiple messages - even
 * concurrently - by synchronizing access
 */
public class ValidateMediator extends AbstractListMediator {

    private static final Log log = LogFactory.getLog(ValidateMediator.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);

    /**
     * Default schema language (http://www.w3.org/2001/XMLSchema) and validator feature ids.
     */
    private static final String DEFAULT_SCHEMA_LANGUAGE = ""http://www.w3.org/2001/XMLSchema"";

    /**
     * A list of property keys, referring to the schemas to be used for the validation
     */
    private List schemaKeys = new ArrayList();

    /**
     * An XPath expression to be evaluated against the message to find the element to be validated.
     * If this is not specified, the validation will occur against the first child element of the
     * SOAP body
     */
    private AXIOMXPath source = null;

    /**
     * A Map containing properties for the validate mediator - such as
     * features to be passed to the actual validator (Xerces)
     */
    private List properties = new ArrayList();

    /**
     * This is the actual Validator instance used to validate messages - probably
     * by multiple threads. Always *USE* validatorLock to synchronize access to this
     */
    private Validator validator = null;

    /**
     * Lock used to ensure thread-safe creation and use of the above Validator
     */
    private final Object validatorLock = new Object();

    /**
     * This is the reference to the DefaultHandler instance
     */
    private final MyErrorHandler errorHandler = new MyErrorHandler();

    private static final String DEFAULT_XPATH = ""//s11:Envelope/s11:Body/child::*[position()=1] | "" +
        ""//s12:Envelope/s12:Body/child::*[position()=1]"";

    public ValidateMediator() {
        // create the default XPath
        try {
            this.source = new AXIOMXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            handleException(""Error creating source XPath expression"", e);
        }
    }

    /**
     * Return the OMNode to be validated. If a source XPath is not specified, this will
     * default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which validation should be performed
     */
    private OMNode getValidateSource(MessageContext synCtx) {

        try {
            Object o = source.evaluate(synCtx.getEnvelope());
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                    + source + "" must result in an OMNode"");
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath "" + source + "" on message"");
        }
        return null;
    }

    public boolean mediate(MessageContext synCtx) {

        log.debug(""ValidateMediator - Validate mediator mediate()"");
        ByteArrayInputStream baisFromSource = null;
        boolean shouldTrace = shouldTrace(synCtx.getTracingState());
        if (shouldTrace) {
            trace.trace(""Start : Validate mediator"");
        }
        try {
            // create a byte array output stream and serialize the source node into it
            ByteArrayOutputStream baosForSource = new ByteArrayOutputStream();
            XMLStreamWriter xsWriterForSource =
                XMLOutputFactory.newInstance().createXMLStreamWriter(baosForSource);

            // serialize the validation target and get an input stream into it
            OMNode validateSource = getValidateSource(synCtx);
            if (shouldTrace) {
                trace.trace(""Validate Source : "" + validateSource.toString());
            }
            validateSource.serialize(xsWriterForSource);
            baisFromSource = new ByteArrayInputStream(baosForSource.toByteArray());

        } catch (Exception e) {
            handleException(""Error accessing source element for validation : "" + source, e);
        }

        try {
            XMLReader reader = XMLReaderFactory.createXMLReader();
            SAXSource saxSrc = new SAXSource(reader, new InputSource(baisFromSource));

            synchronized (validatorLock) {

                // initialize schemas/Validator if required
                initialize(synCtx);

                // perform actual validation
                validator.validate(saxSrc);

                if (errorHandler.isValidationError()) {
                    if (log.isDebugEnabled()) {
                        log.debug(
                            ""Validation of element returned by XPath : "" + source +
                                "" failed against the given schemas with Message : "" +
                                errorHandler.getSaxParseException().getMessage() +
                                "" Executing 'on-fail' sequence"");
                        log.debug(""Failed message envelope : "" + synCtx.getEnvelope());
                    }
                    // super.mediate() invokes the ""on-fail"" sequence of mediators
                    if (shouldTrace) {
                        trace.trace(""Validation failed. Invoking the \""on-fail\"" "" +
                            ""sequence of mediators"");
                    }
                    return super.mediate(synCtx);
                }
            }
        } catch (SAXException e) {
            handleException(""Error validating "" + source + "" element"" + e.getMessage(), e);
        } catch (IOException e) {
            handleException(""Error validating "" + source + "" element"" + e.getMessage(), e);
        }

        log.debug(""validation of element returned by the XPath expression : "" + source +
            "" succeeded against the given schemas and the current message"");
        if (shouldTrace) {
            trace.trace(""End : Validate mediator"");
        }
        return true;
    }

    /**
     * Perform actual initialization of this validate mediator instance - if required
     */
    private void initialize(MessageContext msgCtx) {

        // flag to check if we need to initialize/re-initialize the schema Validator
        boolean reCreate = false;

        // if any of the schemas are not loaded or expired, load or re-load them
        Iterator iter = schemaKeys.iterator();
        while (iter.hasNext()) {
            String propKey = (String) iter.next();
            Entry dp = msgCtx.getConfiguration().getEntryDefinition(propKey);
            if (dp != null && dp.isDynamic()) {
                if (!dp.isCached() || dp.isExpired()) {
                    reCreate = true;       // request re-initialization of Validator
                }
            }
        }

        // do not re-initialize Validator unless required
        if (!reCreate && validator != null) {
            return;
        }

        try {
            // Create SchemaFactory and configure for the default schema language - XMLSchema
            SchemaFactory factory = SchemaFactory.newInstance(DEFAULT_SCHEMA_LANGUAGE);
            // Clear the previous state of the validation error
            errorHandler.setValidationError(false);
            factory.setErrorHandler(errorHandler);

            // set any features on/off as requested
            iter = properties.iterator();
            while (iter.hasNext()) {
                MediatorProperty prop = (MediatorProperty) iter.next();
                factory.setFeature(
                    prop.getName(), prop.getValue() != null && ""true"".equals(prop.getValue()));
            }

            Schema schema = null;

            StreamSource[] sources = new StreamSource[schemaKeys.size()];
            iter = schemaKeys.iterator();
            int i = 0;
            while (iter.hasNext()) {
                String propName = (String) iter.next();
                sources[i++] = Util.getStreamSource(msgCtx.getEntry(propName));
            }
            schema = factory.newSchema(sources);

            // Setup validator and input source
            // Features set for the SchemaFactory get propagated to Schema and Validator (JAXP 1.4)
            validator = schema.newValidator();
            validator.setErrorHandler(errorHandler);

        } catch (SAXException e) {
            handleException(""Error creating Validator"", e);
        }
    }

    /**
     * This class handles validation errors to be used for error reporting
     */
    private class MyErrorHandler extends DefaultHandler {

        private boolean validationError = false;
        private SAXParseException saxParseException = null;

        public void error(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void fatalError(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void warning(SAXParseException exception) throws SAXException {
        }

        public boolean isValidationError() {
            return validationError;
        }

        public SAXParseException getSaxParseException() {
            return saxParseException;
        }

        /**
         * To set explicitly validation error condition 
         * @param validationError
         */
        public void setValidationError(boolean validationError) {
            this.validationError = validationError;
        }
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    // setters and getters

    /**
     * Get a mediator property. The common use case is a feature for the
     * underlying Xerces validator
     *
     * @param key property key / feature name
     * @return property string value (usually true|false)
     */
    public Object getProperty(String key) {
        Iterator iter = properties.iterator();
        while (iter.hasNext()) {
            MediatorProperty prop = (MediatorProperty) iter.next();
            if (key.equals(prop.getName())) {
                return prop.getValue();
            }
        }
        return null;
    }

    /**
     * Set a property for this mediator
     *
     * @param key   the property key / feature name
     * @param value property string value (usually true|false)
     * @see #getProperty(String)
     */
    public void setProperty(String key, Object value) {
        MediatorProperty prop = new MediatorProperty();
        prop.setName(key);
        prop.setValue(value.toString());
        properties.add(prop);
    }

    /**
     * Add a list of 'MediatorProperty'ies to this mediator
     *
     * @param list a List of MediatorProperty objects
     */
    public void addAllProperties(List list) {
        Iterator iter = list.iterator();
        while (iter.hasNext()) {
            Object o = iter.next();
            if (o instanceof MediatorProperty) {
                MediatorProperty prop = (MediatorProperty) o;
                setProperty(prop.getName(), prop.getValue());
            } else {
                handleException(""Attempt to set invalid property type. "" +
                    ""Expected MediatorProperty type got "" + o.getClass().getName());
            }
        }
    }

    /**
     * Set a list of local property names which refer to a list of schemas to be
     * used for validation
     *
     * @param schemaKeys list of local property names
     */
    public void setSchemaKeys(List schemaKeys) {
        this.schemaKeys = schemaKeys;
    }

    /**
     * Set the given XPath as the source XPath
     * @param source an XPath to be set as the source
     */
    public void setSource(AXIOMXPath source) {
       this.source = source;
    }

    /**
     * Get the source XPath which yeilds the source element for validation
     * @return the XPath which yeilds the source element for validation
     */
    public AXIOMXPath getSource() {
        return source;
    }

    /**
     * The keys for the schema resources used for validation
     * @return schema registry keys
     */
    public List getSchemaKeys() {
        return schemaKeys;
    }

    /**
     * Properties for the actual Xerces validator
     * @return properties to be passed to the Xerces validator
     */
    public List getProperties() {
        return properties;
    }
}
"
org/apache/synapse/Mediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.synapse.MessageContext;

/**
 * All Synapse mediators must implement this Mediator interface. As a message passes
 * through the synapse system, each mediator's mediate() method is invoked in the
 * sequence/order defined in the SynapseConfiguration.
 */
public interface Mediator {

    /**
     * Invokes the mediator passing the current message for mediation. Each
     * mediator performs its mediation action, and returns true if mediation
     * should continue, or false if further mediation should be aborted.
     *
     * @param synCtx the current message for mediation
     * @return true if further mediation should continue
     */
    public boolean mediate(MessageContext synCtx);

    /**
     * This is used for debugging purposes and exposes the type of the current
     * mediator for logging and debugging purposes
     * @return a String representation of the mediator type
     */
    public String getType();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return value that indicate whether tracing is on, off or unset
     */
    public int getTraceState();

    /**
     * This is used to set the value of tracing enable variable
     * @param traceState Set whether the tracing is enabled or not
     */
    public void setTraceState(int traceState);
}
"
org/apache/synapse/config/xml/AnonymousListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


import java.util.Iterator;

/**
 * This is factory for creating an anonymous list mediator(an unnamed list of mediators )
 *
 */

public abstract class AnonymousListMediatorFactory extends AbstractListMediatorFactory {

    private static final Log log = LogFactory.getLog(AnonymousListMediator.class);

    /**
     * To create an anonymous list mediator form OMElement
     * @param el
     * @return List mediator
     */
    public static AnonymousListMediator createAnonymousListMediator(OMElement el) {
        AnonymousListMediator mediator = new AnonymousListMediator();
        {
            addChildren(el, mediator);
        }
        return mediator;
    }

}
"
org/apache/synapse/config/xml/InMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

public class InMediatorSerializer extends AbstractListMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(InMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof InMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        InMediator mediator = (InMediator) m;
        OMElement in = fac.createOMElement(""in"", synNS);
        finalizeSerialization(in,mediator);

        serializeChildren(in, mediator.getList());

        if (parent != null) {
            parent.addChild(in);
        }
        return in;
    }

    public String getMediatorClassName() {
        return InMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/RMSequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;

/**
 * <pre>
 * &lt;RMSequence (correlation=""xpath"" [last-message=""xpath""]) | single=""true"" [version=""1.0|1.1""]/&gt;
 * </pre>
 */
public class RMSequenceMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(RMSequenceMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof RMSequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        RMSequenceMediator mediator = (RMSequenceMediator) m;
        OMElement sequence = fac.createOMElement(""RMSequence"", synNS);
        finalizeSerialization(sequence, mediator);
        
        if(mediator.isSingle() && mediator.getCorrelation() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a correlation attribute specified."");
        }
        if(mediator.isSingle() && mediator.getLastMessage() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a last-message attribute specified."");
        }
        
        if (mediator.isSingle()) {
            sequence.addAttribute(fac.createOMAttribute(""single"", nullNS, String.valueOf(mediator.isSingle())));
        } else if (mediator.getCorrelation() != null) {
            sequence.addAttribute(fac.createOMAttribute(""correlation"", nullNS, 
                    mediator.getCorrelation().toString()));
            super.serializeNamespaces(sequence, mediator.getCorrelation());
        } else {
            handleException(""Invalid RMSequence mediator. Specify a single message sequence "" 
                    + ""or a correlation attribute."");
        }
        
        if (mediator.getLastMessage() != null) {
            sequence.addAttribute(fac.createOMAttribute(
                ""last-message"", nullNS, mediator.getLastMessage().toString()));
            super.serializeNamespaces(sequence, mediator.getLastMessage());
        }
        
        if (mediator.getVersion() != null) {
            sequence.addAttribute(fac.createOMAttribute(""version"", nullNS, mediator.getVersion()));
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return RMSequenceMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/registry/Registry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.synapse.config.Entry;

import java.util.Map;

/**
 * This is the interface to a Registry from Synapse.
 */
public interface Registry {

    /**
     * Perform an actual lookup for for an XML resource as an OMNode for the given key
     * @param key the key for the registry lookup
     * @return the XML content from the registry as an OMNode
     */
    public OMNode lookup(String key);

    /**
     * This is the publicly used interface to the registry. It will fetch
     * the content from the registry and cache if required.
     * @see AbstractRegistry
     *
     * @param entry the registry Entry
     * @return the value from the registry or local cache
     */
    public Object getResource(Entry entry);

    /**
     * Get the registry entry for the given key
     * @return the registry key
     */
    public RegistryEntry getRegistryEntry(String key);

    /**
     * Set a configuration property on the registry. Could be used to initialize a registry
     * @param name property name
     * @param value simple String value
     */
    public void addConfigProperty(String name, String value);

    /**
     * Returns the child elements of a given registry entry
     * @param entry - parent registry entry
     * @return Array of child registry entries of the given parent registry entry
     */
    public RegistryEntry[] getChildren(RegistryEntry entry);

    /**
     * Returns all decendant entries of the given registry entry
     * @param entry - parent registry entry
     * @return Array of decendant registry entries of the given registry entry
     */
    public RegistryEntry[] getDescendants(RegistryEntry entry);

    /**
     * Return the name of the implementation class
     * @return name of the registry provider implementation class name
     */
    public String getProviderClass();

    /**
     * Return the list of configuration properties set on this instance
     * @return a Map of configuration properties
     */
    public Map getConfigProperties();
}
"
org/apache/synapse/endpoints/algorithms/RoundRobin.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import java.util.ArrayList;

/**
 * This is the implementation of the round robin load balancing algorithm. It simply iterates through
 * the endpoint list one by one for until an active endpoint is found.
 */
public class RoundRobin implements LoadbalanceAlgorithm {

    private ArrayList endpoints = null;
    private int currentEPR = 0;

    public RoundRobin(ArrayList endpoints) {
        this.endpoints = endpoints;
    }

    /**
     * Choose an active endpoint using the round robin algorithm. If there are no active endpoints
     * available, returns null.
     *
     * @param synapseMessageContext
     * @return endpoint to send the next message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext) {

        Endpoint nextEndpoint = null;
        int attempts = 0;

        do {
            // two successive clients could get the same endpoint if not synchronized.
            synchronized(this) {
                nextEndpoint = (Endpoint) endpoints.get(currentEPR);

                if(currentEPR == endpoints.size() - 1) {
                    currentEPR = 0;
                } else {
                    currentEPR++;
                }
            }

            attempts++;
            if (attempts > endpoints.size()) {
                return null;
            }

        } while (!nextEndpoint.isActive(synapseMessageContext));

        return nextEndpoint;
    }

    public void reset() {
        currentEPR = 0;
    }
}
"
org/apache/synapse/core/axis2/ProxyService.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axis2.AxisFault;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.synapse.Constants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.Util;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLInputFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.util.*;
import java.net.URI;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.net.URL;

/**
 * <proxy-service name=""string"" [transports=""(http |https |jms )+|all""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <enableSec/>?
 *    <enableRM/>?
 *    <policy key=""string"">?
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxy-service>
 */
public class ProxyService {

    private static final Log log = LogFactory.getLog(ProxyService.class);
    private static final Log trace = LogFactory.getLog(Constants.TRACE_LOGGER);
    /**
     * The proxy service name
     */
    private String name;
    /**
     * The proxy service description
     */
    private String description;
    /**
     * The transport/s over which this service should be exposed
     */
    //private String transports;
    private ArrayList transports;
    /**
     * The target endpoint, if assigned
     */
    private String targetEndpoint = null;
    /**
     * The target inSequence, if assigned
     */
    private String targetInSequence = null;
    /**
     * The target outSequence, if assigned
     */
    private String targetOutSequence = null;
    /**
     * The target faultSequence, if assigned
     */
    private String targetFaultSequence = null;
    /**
     * The target endpoint, if assigned
     */
    private Endpoint targetInLineEndpoint = null;
    /**
     * The target inSequence, if assigned
     */
    private SequenceMediator targetInLineInSequence = null;
    /**
     * The target outSequence, if assigned
     */
    private SequenceMediator targetInLineOutSequence = null;
    /**
     * The target faultSequence, if assigned
     */
    private SequenceMediator targetInLineFaultSequence = null;
    // if a target endpoint or sequence is not specified,
    // the default Synapse main mediator will be used
    /**
     * A list parameters
     */
    private Map parameters = new HashMap();

    /**
     * The key for the base WSDL, if specified
     */
    private String wsdlKey;
    /**
     * The URI for the base WSDL, if specified
     */
    private URI wsdlURI;
    /**
     * Inline XML representation of wsdl
     */
    private Object inLineWSDL;
    /**
     * The keys for any supplied schemas
     */   // todo: do we need this
    private List schemaKeys = new ArrayList();
    /**
     * The keys for any supplied policies that would apply at the service level
     */
    private List serviceLevelPolicies = new ArrayList();
    /**
     * Should WS RM (default configuration) be engaged on this service
     */
    private boolean wsRMEnabled = false;
    /**
     * Should WS Sec (default configuration) be engaged on this service
     */
    private boolean wsSecEnabled = false;
    /**
     * This will say weather need to start the service at the load or not
     */
    private boolean startOnLoad = true;
    /**
     * This will hold the status of the proxy weather it is running or not
     */
    private boolean running = false;

    public static final String ALL_TRANSPORTS = ""all"";

    /**
     * To decide to whether statistics should have collected or not
     */
    private int statisticsEnable = Constants.STATISTICS_UNSET;
    /**
     * The variable that indicate tracing on or off for the current mediator
     */
    protected int traceState = Constants.TRACING_UNSET;

    public ProxyService() {
    }

    public AxisService buildAxisService(SynapseConfiguration synCfg, AxisConfiguration axisCfg) {

        AxisService proxyService = null;
        InputStream wsdlInputStream = null;
        OMElement wsdlElement = null;
        if (wsdlKey != null) {
            synCfg.getEntryDefinition(wsdlKey);
            Object keyObject = synCfg.getEntry(wsdlKey);
            if (keyObject instanceof OMElement) {
                wsdlElement = (OMElement) keyObject;
            }
        } else if (inLineWSDL != null) {
            wsdlElement = (OMElement) inLineWSDL;
        } else if (wsdlURI != null) {
            try {
                URL url = wsdlURI.toURL();
                wsdlElement = Util.getOMElementFromURL(url.toString());
            } catch (MalformedURLException e) {
                handleException(""Malformed URI for wsdl"", e);
            } catch (IOException e) {
                handleException(""Error reading from wsdl URI"", e);
            }
        }
        if (wsdlElement != null) {
            OMNamespace wsdlNamespace = wsdlElement.getNamespace();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                wsdlElement.serialize(baos);
                wsdlInputStream = new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }
            if (wsdlInputStream != null) {
                try {
                    // detect version of the WSDL 1.1 or 2.0
                    if (wsdlNamespace != null) {
                        boolean isWSDL11 = false;
                        WSDLToAxisServiceBuilder wsdlToAxisServiceBuilder = null;
                        if (WSDL2Constants.WSDL_NAMESPACE.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL20ToAxisServiceBuilder(wsdlInputStream, null, null);
                            wsdlToAxisServiceBuilder.setBaseUri(wsdlURI != null ? wsdlURI.toString() : """");

                        } else if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL11ToAxisServiceBuilder(wsdlInputStream, null, null);
                            isWSDL11 = true;
                        } else {
                            handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                        }

                        if (wsdlToAxisServiceBuilder == null) {
                            throw new SynapseException(
                                    ""Could not get the WSDL to Axis Service Builder"");
                        }
                        proxyService = wsdlToAxisServiceBuilder.populateService();
                        proxyService.setWsdlFound(true);

                        if (isWSDL11) {
                            // workaround to support WSDL 2.0 generation when only a WSDL 1.1
                            // is supplied
                            Collection endpoints = proxyService.getEndpoints().values();
                            Iterator iter = endpoints.iterator();
                            while (iter.hasNext()) {
                                AxisEndpoint endpoint = (AxisEndpoint) iter.next();
                                Iterator children = endpoint.getBinding().getChildren();
                                while (children.hasNext()) {
                                    AxisBindingOperation axisBindingOperation =
                                        (AxisBindingOperation) children.next();
                                    axisBindingOperation.setProperty(
                                        WSDL2Constants.ATTR_WHTTP_IGNORE_UNCITED, new Boolean(false));
                                }
                            }
                        }

                    } else {
                        handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                    }

                } catch (AxisFault af) {
                    handleException(""Error building service from WSDL"", af);
                } catch (IOException ioe) {
                    handleException(""Error reading WSDL"", ioe);
                }
            }
        } else {
            // this is for POX... create a dummy service and an operation for which
            // our SynapseDispatcher will properly dispatch to
            proxyService = new AxisService();
            AxisOperation mediateOperation =
                    new InOutAxisOperation(new QName(""mediate""));
            proxyService.addOperation(mediateOperation);
        }

        // Set the name and description. Currently Axis2 uses the name as the
        // default Service destination
        if (proxyService == null) {
            throw new SynapseException(""Could not create a proxy service"");
        }
        proxyService.setName(name);
        if (description != null) {
            proxyService.setServiceDescription(description);
        }

        // process transports and expose over requested transports. If none
        // is specified, default to all transports using service name as
        // destination
        if (transports == null || transports.size() == 0) {
            // default to all transports using service name as destination
        } else {
            proxyService.setExposedTransports(transports);
        }

        // process parameters
        Iterator iter = parameters.keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            Object value = parameters.get(name);

            Parameter p = new Parameter();
            p.setName(name);
            p.setValue(value);

            try {
                proxyService.addParameter(p);
            } catch (AxisFault af) {
                handleException(""Error setting parameter : "" + name + """" +
                        ""to proxy service as a Parameter"", af);
            }
        }

        // if service level policies are specified, apply them
        if (!serviceLevelPolicies.isEmpty()) {
            Policy svcEffectivePolicy = null;
            iter = serviceLevelPolicies.iterator();
            while (iter.hasNext()) {
                String policyKey = (String) iter.next();
                synCfg.getEntryDefinition(policyKey);
                Object policyProp = synCfg.getEntry(policyKey);
                if (policyProp != null) {
                    if (svcEffectivePolicy == null) {

                        svcEffectivePolicy = PolicyEngine.getPolicy(
                                Util.getStreamSource(policyProp).getInputStream());
                    } else {
                        svcEffectivePolicy = (Policy) svcEffectivePolicy.merge(
                                PolicyEngine.getPolicy(
                                        Util.getStreamSource(policyProp).getInputStream()));
                    }
                }
            }
            PolicyInclude pi = proxyService.getPolicyInclude();
            if (pi != null && svcEffectivePolicy != null) {
                pi.addPolicyElement(PolicyInclude.AXIS_SERVICE_POLICY, svcEffectivePolicy);
                // todo: check whether the rm or sec is enabled
            }
        }

        // create a custom message receiver for this proxy service 
        ProxyServiceMessageReceiver msgRcvr = new ProxyServiceMessageReceiver();
        msgRcvr.setName(name);

        iter = proxyService.getOperations();
        while (iter.hasNext()) {
            AxisOperation op = (AxisOperation) iter.next();
            op.setMessageReceiver(msgRcvr);
        }

        try {
            axisCfg.addService(proxyService);
            this.setRunning(true);
        } catch (AxisFault axisFault) {
            try {
                if (axisCfg.getService(proxyService.getName()) != null) {
                    axisCfg.removeService(proxyService.getName());
                }
            } catch (AxisFault ignore) {}
            handleException(""Error adding Proxy service to the Axis2 engine"", axisFault);
        }

        // todo: need to remove this and engage modules by looking at policies
        // should RM be engaged on this service?
        if (wsRMEnabled) {
            try {
                proxyService.engageModule(axisCfg.getModule(
                        Constants.SANDESHA2_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS RM module on proxy service : "" + name, axisFault);
            }
        }

        // should Security be engaged on this service?
        if (wsSecEnabled) {
            try {
                proxyService.engageModule(axisCfg.getModule(
                        Constants.RAMPART_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS Sec module on proxy service : ""
                        + name, axisFault);
            }
        }
        return proxyService;
    }

    public void start(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration();
        axisConfig.getServiceForActivation(this.getName()).setActive(true);
        this.setRunning(true);
    }

    public void stop(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration().getAxisConfiguration();
        try {
            axisConfig.getService(this.getName()).setActive(false);
            this.setRunning(false);
        } catch (AxisFault axisFault) {
            handleException(axisFault.getMessage());
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public ArrayList getTransports() {
        return transports;
    }

    public void addParameter(String name, Object value) {
        parameters.put(name, value);
    }

    public Map getParameterMap() {
        return this.parameters;
    }

    public void setTransports(ArrayList transports) {
        this.transports = transports;
    }

    public String getTargetEndpoint() {
        return targetEndpoint;
    }

    public void setTargetEndpoint(String targetEndpoint) {
        this.targetEndpoint = targetEndpoint;
    }

    public String getTargetInSequence() {
        return targetInSequence;
    }

    public void setTargetInSequence(String targetInSequence) {
        this.targetInSequence = targetInSequence;
    }

    public String getTargetOutSequence() {
        return targetOutSequence;
    }

    public void setTargetOutSequence(String targetOutSequence) {
        this.targetOutSequence = targetOutSequence;
    }

    public String getWSDLKey() {
        return wsdlKey;
    }

    public void setWSDLKey(String wsdlKey) {
        this.wsdlKey = wsdlKey;
    }

    public List getSchemas() {
        return schemaKeys;
    }

    public void setSchemas(List schemas) {
        this.schemaKeys = schemas;
    }

    public List getServiceLevelPolicies() {
        return serviceLevelPolicies;
    }

    public void addServiceLevelPolicy(String serviceLevelPolicy) {
        this.serviceLevelPolicies.add(serviceLevelPolicy);
    }

    public boolean isWsRMEnabled() {
        return wsRMEnabled;
    }

    public void setWsRMEnabled(boolean wsRMEnabled) {
        this.wsRMEnabled = wsRMEnabled;
    }

    public boolean isWsSecEnabled() {
        return wsSecEnabled;
    }

    public void setWsSecEnabled(boolean wsSecEnabled) {
        this.wsSecEnabled = wsSecEnabled;
    }

    public boolean isStartOnLoad() {
        return startOnLoad;
    }

    public void setStartOnLoad(boolean startOnLoad) {
        this.startOnLoad = startOnLoad;
    }

    public boolean isRunning() {
        return running;
    }

    public void setRunning(boolean running) {
        this.running = running;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsEnable() {
        return statisticsEnable;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsEnable
     */
    public void setStatisticsEnable(int statisticsEnable) {
        this.statisticsEnable = statisticsEnable;
    }

    /**
     * Returns the int value that indicate the tracing state
     *
     * @return Returns the int value that indicate the tracing state
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing State variable
     *
     * @param traceState
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    public String getTargetFaultSequence() {
        return targetFaultSequence;
    }

    public void setTargetFaultSequence(String targetFaultSequence) {
        this.targetFaultSequence = targetFaultSequence;
    }

    public Object getInLineWSDL() {
        return inLineWSDL;
    }

    public void setInLineWSDL(Object inLineWSDL) {
        this.inLineWSDL = inLineWSDL;
    }

    public URI getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(URI wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public Endpoint getTargetInLineEndpoint() {
        return targetInLineEndpoint;
    }

    public void setTargetInLineEndpoint(Endpoint targetInLineEndpoint) {
        this.targetInLineEndpoint = targetInLineEndpoint;
    }

    public SequenceMediator getTargetInLineInSequence() {
        return targetInLineInSequence;
    }

    public void setTargetInLineInSequence(SequenceMediator targetInLineInSequence) {
        this.targetInLineInSequence = targetInLineInSequence;
    }

    public SequenceMediator getTargetInLineOutSequence() {
        return targetInLineOutSequence;
    }

    public void setTargetInLineOutSequence(SequenceMediator targetInLineOutSequence) {
        this.targetInLineOutSequence = targetInLineOutSequence;
    }

    public SequenceMediator getTargetInLineFaultSequence() {
        return targetInLineFaultSequence;
    }

    public void setTargetInLineFaultSequence(SequenceMediator targetInLineFaultSequence) {
        this.targetInLineFaultSequence = targetInLineFaultSequence;
    }
}
"
org/apache/synapse/config/xml/SynapseMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SynapseMediator;

/**
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorSerializer extends AbstractListMediatorSerializer
     {

    private static final Log log = LogFactory.getLog(SynapseMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SynapseMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SynapseMediator mediator = (SynapseMediator) m;
        OMElement rules = fac.createOMElement(""rules"", synNS);
        finalizeSerialization(rules,mediator);

        serializeChildren(rules, mediator.getList());

        if (parent != null) {
            parent.addChild(rules);
        }
        return rules;
    }

    public String getMediatorClassName() {
        return SynapseMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/HeaderMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.HeaderMediator;

import javax.xml.namespace.QName;

/**
 * Set header
 *   <pre>
 *      &lt;header name=""qname"" (value=""literal"" | expression=""xpath"")/&gt;
 *   </pre>
 *
 * Remove header
 *   <pre>
 *      &lt;header name=""qname"" action=""remove""/&gt;
 *   </pre>
 */
public class HeaderMediatorSerializer extends AbstractMediatorSerializer
     {
    private static final Log log = LogFactory.getLog(FilterMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof HeaderMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        HeaderMediator mediator = (HeaderMediator) m;
        OMElement header = fac.createOMElement(""header"", synNS);
        finalizeSerialization(header,mediator);

        QName qName = mediator.getQName();
        if (qName != null) {
            if (qName.getNamespaceURI() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS,
                    (qName.getPrefix() != null && !"""".equals(qName.getPrefix())
                        ? qName.getPrefix() + "":"" : """") + 
                    qName.getLocalPart()));
                header.declareNamespace(qName.getNamespaceURI(), qName.getPrefix());
            } else {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, qName.getLocalPart()));
            }
        }

        if (mediator.getAction() == HeaderMediator.ACTION_REMOVE) {
            header.addAttribute(fac.createOMAttribute(
                ""action"", nullNS, ""remove""));
        } else {
            if (mediator.getValue() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

            } else if (mediator.getExpression() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""expression"", nullNS, mediator.getExpression().toString()));
                super.serializeNamespaces(header, mediator.getExpression());

            } else {
                handleException(""Value or expression required for a set header mediator"");
            }
        }

        if (parent != null) {
            parent.addChild(header);
        }
        return header;
    }

    public String getMediatorClassName() {
        return HeaderMediator.class.getName();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/core/axis2/SynapseCallbackReceiver.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.engine.MessageReceiver;
import org.apache.axis2.client.async.Callback;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.AxisFault;
import org.apache.axis2.util.Utils;
import org.apache.axis2.transport.nhttp.NhttpConstants;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Constants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.axiom.soap.SOAPFault;
import org.apache.sandesha2.client.SandeshaClientConstants;

import java.util.*;

public class SynapseCallbackReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseCallbackReceiver.class);

    private Map callbackStore;  // this will be made thread safe within the constructor

    /**
     * Timer to schedule the timeout task.
     */
    private Timer timeOutTimer = null;

    public SynapseCallbackReceiver() {
        callbackStore = Collections.synchronizedMap(new HashMap());

        // create the Timer object and a TimeoutHandler task. Schedule it to run every 10 seconds from here
        TimeoutHandler timeoutHandler = new TimeoutHandler(callbackStore);
        timeOutTimer = new Timer(true);
        timeOutTimer.schedule(timeoutHandler, 0, Constants.TIMEOUT_HANDLER_INTERVAL);
    }

    public void addCallback(String MsgID, Callback callback) {
        callbackStore.put(MsgID, callback);
    }

    public void receive(MessageContext messageCtx) throws AxisFault {

        String messageID = null;

        if (messageCtx.getOptions() != null && messageCtx.getOptions().getRelatesTo() != null) {
            messageID = messageCtx.getOptions().getRelatesTo().getValue();
        } else if (messageCtx.getProperty(SandeshaClientConstants.SEQUENCE_KEY) == null) {
            messageID = (String) messageCtx.getProperty(Constants.RELATES_TO_FOR_POX);
        }

        if (messageID != null) {
            Callback callback = (Callback) callbackStore.remove(messageID);

            RelatesTo[] relates = messageCtx.getRelationships();
            if (relates != null && relates.length > 1) {
                // we set a relates to to the response message so that if WSA is not used, we
                // could still link back to the original message. But if WSA was used, this
                // gets duplicated, and we should remove it
                removeDuplicateRelatesTo(messageCtx, relates);
            }
            
            if (callback != null) {
                handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());
            } else {
                // TODO invoke a generic synapse error handler for this message
                log.warn(""Synapse received a response for the request with message Id : "" +
                        messageID + "" But a callback has not been registered to process this response"");
            }

        } else if (!Utils.isExplicitlyTrue(messageCtx, NhttpConstants.SC_ACCEPTED)){
            // TODO invoke a generic synapse error handler for this message
            log.warn(""Synapse received a response message without a message Id"");
        }
    }

    /**
     * Handle the response or error (during a failed send) message received for an outgoing request
     *
     * @param response         the Axis2 MessageContext that has been received and has to be handled
     * @param synapseOutMsgCtx the corresponding (outgoing) Synapse MessageContext for the above
     *                         Axis2 MC, that holds Synapse specific information such as the error
     *                         handler stack and local properties etc.
     */
    private void handleMessage(MessageContext response,
                               org.apache.synapse.MessageContext synapseOutMsgCtx) {

        Object o = response.getProperty(NhttpConstants.SENDING_FAULT);
        if (o != null && Boolean.TRUE.equals(o)) {

            // there is a sending fault. propagate the fault to fault handlers.

            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                SOAPFault fault = response.getEnvelope().getBody().getFault();
                Exception e = fault.getException();
                if (e == null) {
                    e = new Exception(fault.toString());
                }
                // set an error code to the message context, so that error sequences can filter
                // using that property to determine the cause of error
                synapseOutMsgCtx.setProperty(Constants.ERROR_CODE, Constants.SENDING_FAULT);
                if (fault != null && fault.getReason() != null) {
                    synapseOutMsgCtx.setProperty(Constants.ERROR_MESSAGE, fault.getReason().getText());
                }

                ((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);
            }

        } else {

            // there can always be only one instance of an Endpoint in the faultStack of a message
            // if the send was successful, so remove it before we proceed any further
            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (!faultStack.isEmpty() && faultStack.peek() instanceof Endpoint) {
                faultStack.pop();
            }
            if (log.isDebugEnabled()) {
                log.debug(""Synapse received an asynchronous response message"");
                log.debug(""Received To: "" +
                        (response.getTo() != null ? response.getTo().getAddress() : ""null""));
                log.debug(""SOAPAction: "" +
                        (response.getSoapAction() != null ? response.getSoapAction() : ""null""));
                log.debug(""WSA-Action: "" +
                        (response.getWSAAction() != null ? response.getWSAAction() : ""null""));
                String[] cids = response.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (int i = 0; i < cids.length; i++) {
                        log.debug(""Attachment : "" + cids[i]);
                    }
                }
                log.debug(""Body : \n"" + response.getEnvelope());
            }
            MessageContext axisOutMsgCtx =
                    ((Axis2MessageContext) synapseOutMsgCtx).getAxis2MessageContext();

            response.setOperationContext(axisOutMsgCtx.getOperationContext());
            response.getAxisMessage().setParent(
                axisOutMsgCtx.getOperationContext().getAxisOperation());
            response.setAxisService(axisOutMsgCtx.getAxisService());

            // set properties on response
            response.setServerSide(true);
            response.setProperty(Constants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            response.setProperty(MessageContext.TRANSPORT_OUT,
                    axisOutMsgCtx.getProperty(MessageContext.TRANSPORT_OUT));
            response.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    axisOutMsgCtx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));
            response.setTransportIn(axisOutMsgCtx.getTransportIn());
            response.setTransportOut(axisOutMsgCtx.getTransportOut());

            // If request is REST assume that the response is REST too
            response.setDoingREST(axisOutMsgCtx.isDoingREST());
            if (axisOutMsgCtx.isDoingMTOM()) {
                response.setDoingMTOM(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }
            if (axisOutMsgCtx.isDoingSwA()) {
                response.setDoingSwA(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }

            if (axisOutMsgCtx.getMessageID() != null) {
                response.setRelationships(
                        new RelatesTo[]{new RelatesTo(axisOutMsgCtx.getMessageID())});
            }

            // create the synapse message context for the response
            Axis2MessageContext synapseInMessageContext =
                    new Axis2MessageContext(
                            response,
                            synapseOutMsgCtx.getConfiguration(),
                            synapseOutMsgCtx.getEnvironment());

            synapseInMessageContext.setResponse(true);
            synapseInMessageContext.setTo(
                new EndpointReference(AddressingConstants.Final.WSA_ANONYMOUS_URL));

            // set the properties of the original MC to the new MC
            Iterator iter = synapseOutMsgCtx.getPropertyKeySet().iterator();

            while (iter.hasNext()) {
                Object key = iter.next();
                synapseInMessageContext.setProperty(
                        (String) key, synapseOutMsgCtx.getProperty((String) key));
            }

            // send the response message through the synapse mediation flow
            try {
                synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);
            } catch (SynapseException syne) {
                if (!synapseInMessageContext.getFaultStack().isEmpty()) {
                    ((FaultHandler) synapseInMessageContext
                            .getFaultStack().pop()).handleFault(synapseInMessageContext, syne);
                } else {
                    log.error(""Synapse encountered an exception, "" +
                            ""No error handlers found - [Message Dropped]\n"" + syne.getMessage());
                }
            }
        }
    }

    private void removeDuplicateRelatesTo(MessageContext mc, RelatesTo[] relates) {

        int insertPos = 0;
        RelatesTo[] newRelates = new RelatesTo[relates.length];

        for (int i = 0; i < relates.length; i++) {
            RelatesTo current = relates[i];
            boolean found = false;
            for (int j = 0; j < newRelates.length && j < insertPos; j++) {
                if (newRelates[j].equals(current) ||
                        newRelates[j].getValue().equals(current.getValue())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newRelates[insertPos++] = current;
            }
        }

        RelatesTo[] trimmedRelates = new RelatesTo[insertPos];
        System.arraycopy(newRelates, 0, trimmedRelates, 0, insertPos);
        mc.setRelationships(trimmedRelates);
    }
}
"
