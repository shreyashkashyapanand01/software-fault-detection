File,Bug,SRC
org/apache/log4j/xml/examples/XCategory.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.xml.examples;


import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.helpers.LogLog;

import org.apache.log4j.xml.examples.XPriority;

/**
   A simple example showing Category sub-classing. It shows the
   minimum steps necessary to implement one's {@link CategoryFactory}.
   Note that sub-classes follow the hiearchy even if its categories
   belong to different classes.

   <p>See <b><a href=""doc-files/XCategory.java"">source code</a></b>
   for more details. See also <a
   href=""doc-files/extension1.xml"">extension1.xml</a> and <a
   href=""doc-files/extension2.xml"">extension2.xml</a> XML
   configuration files.

   <p>
   
 */
public class XCategory extends Category implements OptionHandler {

  final private static String FQCN = XCategory.class.getName();

  // It's enough to instantiate a factory once and for all.
  private static XFactory factory = new XFactory();
  
  public static final String SUFFIX_OPTION = ""Suffix"";

  String suffix = """";

  /**
     Just calls the parent constuctor.
   */
  protected XCategory(String name) {
    super(name);
  }

  /** 
     Nothing to activate.
   */
  public
  void activateOptions() {
  }

  /**
     Overrides the standard debug method by appending the value of
     suffix variable to each message.  
  */
  public 
  void debug(String message) {
    super.debug(message + "" "" + suffix);
  }

  /**
     This method overrides {@link Category#getInstance} by supplying
     its own factory type as a parameter.

   */
  public 
  static
  Category getInstance(String name) {
    return Category.getInstance(name, factory); 
  }


  /**
     This method overrides {@link Category#getInstance(Class)} by supplying
     its own factory type as a parameter.
   */
  public 
  static
  Category getInstance(Class clazz) {
    return getInstance(clazz.getName(), factory); 
  }

 /**
    Retuns the option names for this component, namely the string
    {@link #SUFFIX_OPTION}.
 */
  public
  String[] getOptionStrings() {
    return (new String[] {SUFFIX_OPTION});
  }


  /**
     We introduce a new printing method in order to support {@link
     XPriority#LETHAL}.  */
  public
  void lethal(String message, Throwable t) { 
    // disable is a static variable defined in Category class
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, t);
  }

  /**
     We introduce a new printing method in order to support {@link
     XPriority#LETHAL}.  */
  public
  void lethal(String message) { 
    // disable is a static variable defined in Category class
    if(hierarchy.isDisabled(XPriority.LETHAL_INT)) 
      return;
    if(XPriority.LETHAL.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.LETHAL, message, null);
  }


 /**
     Set XCategory specific options.

     <p>The <b>Suffix</b> option is the only recognized option. It
     takes a string value.
     */
  public
  void setOption(String option, String value) {
    if(option == null) {
      return;
    }
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      this.suffix = value;
      LogLog.debug(""Setting suffix to""+suffix);
    }
  }
  
  public
  String getOption(String option) {
    if(option.equalsIgnoreCase(SUFFIX_OPTION)) {
      return this.suffix;
    }
    return null;
  }

  /**
     We introduce a new printing method that takes the TRACE priority.
  */
  public
  void trace(String message, Throwable t) { 
    // disable is defined in Category
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      forcedLog(FQCN, XPriority.TRACE, message, t);
  }

  /**
     We introduce a new printing method that takes the TRACE priority.
  */
  public
  void trace(String message) { 
    // disable is defined in Category
    if(hierarchy.isDisabled(XPriority.TRACE_INT))
      return;   
    if(XPriority.TRACE.isGreaterOrEqual(this.getChainedPriority()))
      callAppenders(new LoggingEvent(FQCN, this, XPriority.TRACE, 
				     message, null));
  }



  // Any sub-class of Category must also have its own implementation of 
  // CategoryFactory.
  public static class XFactory implements CategoryFactory {
    
    public XFactory() {
    }

    public
    Category makeNewCategoryInstance(String name) {
      return new XCategory(name);
    }
  }
}


"
org/apache/log4j/helpers/DateLayout.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.RelativeTimeDateFormat;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.helpers.DateTimeDateFormat;
import org.apache.log4j.helpers.ISO8601DateFormat;
import org.apache.log4j.spi.LoggingEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.text.FieldPosition;


/**
   This abstract layout takes care of all the date related options and
   formatting work.
   

   @author Ceki G&uuml;lc&uuml;
 */
abstract public class DateLayout extends Layout {

  /**
     String constant designating no time information. Current value of
     this constant is <b>NULL</b>.
     
  */
  public final static String NULL_DATE_FORMAT = ""NULL"";

  /**
     String constant designating relative time. Current value of
     this constant is <b>RELATIVE</b>.
   */
  public final static String RELATIVE_TIME_DATE_FORMAT = ""RELATIVE"";

  protected FieldPosition pos = new FieldPosition(0);

  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String DATE_FORMAT_OPTION = ""DateFormat"";
  
  /**
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String TIMEZONE_OPTION = ""TimeZone"";  

  private String timeZoneID;
  private String dateFormatOption;  

  protected DateFormat dateFormat;
  protected Date date = new Date();

  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  String[] getOptionStrings() {
    return new String[] {DATE_FORMAT_OPTION, TIMEZONE_OPTION};
  }

  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String option, String value) {
    if(option.equalsIgnoreCase(DATE_FORMAT_OPTION)) {
      dateFormatOption = value.toUpperCase();
    } else if(option.equalsIgnoreCase(TIMEZONE_OPTION)) {
      timeZoneID = value;
    }
  }
  

  /**
    The value of the <b>DateFormat</b> option should be either an
    argument to the constructor of {@link SimpleDateFormat} or one of
    the srings ""NULL"", ""RELATIVE"", ""ABSOLUTE"", ""DATE"" or ""ISO8601.
   */
  public
  void setDateFormat(String dateFormat) {
    if (dateFormat != null) {
        dateFormatOption = dateFormat.toUpperCase();
    }
    setDateFormat(dateFormatOption, TimeZone.getDefault());
  }

  /**
     Returns value of the <b>DateFormat</b> option.
   */
  public
  String getDateFormat() {
    return dateFormatOption;
  }
  
  /**
    The <b>TimeZoneID</b> option is a time zone ID string in the format
    expected by the {@link TimeZone#getTimeZone} method.
   */
  public
  void setTimeZone(String timeZone) {
    this.timeZoneID = timeZone;
  }
  
  /**
     Returns value of the <b>TimeZone</b> option.
   */
  public
  String getTimeZone() {
    return timeZoneID;
  }
  
  public
  void activateOptions() {
    setDateFormat(dateFormatOption);
    if(timeZoneID != null && dateFormat != null) {
      dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneID));
    }
  }

  public
  void dateFormat(StringBuffer buf, LoggingEvent event) {
    if(dateFormat != null) {
      date.setTime(event.timeStamp);
      dateFormat.format(date, buf, this.pos);
      buf.append(' ');
    }
  }

  /**
     Sets the {@link DateFormat} used to format time and date in the
     zone determined by <code>timeZone</code>.
   */
  public
  void setDateFormat(DateFormat dateFormat, TimeZone timeZone) {
    this.dateFormat = dateFormat;    
    this.dateFormat.setTimeZone(timeZone);
  }
  
  /**
     Sets the DateFormat used to format date and time in the time zone
     determined by <code>timeZone</code> parameter. The {@link DateFormat} used
     will depend on the <code>dateFormatType</code>.

     <p>The recognized types are {@link #NULL_DATE_FORMAT}, {@link
     #RELATIVE_TIME_DATE_FORMAT} {@link
     AbsoluteTimeDateFormat#ABS_TIME_DATE_FORMAT}, {@link
     AbsoluteTimeDateFormat#DATE_AND_TIME_DATE_FORMAT} and {@link
     AbsoluteTimeDateFormat#ISO8601_DATE_FORMAT}. If the
     <code>dateFormatType</code> is not one of the above, then the
     argument is assumed to be a date pattern for {@link
     SimpleDateFormat}.
  */
  public
  void setDateFormat(String dateFormatType, TimeZone timeZone) {
    if(dateFormatType == null) {
      this.dateFormat = null;
      return;
    } 

    if(dateFormatType.equalsIgnoreCase(NULL_DATE_FORMAT)) {
      this.dateFormat = null;
    } else if (dateFormatType.equalsIgnoreCase(RELATIVE_TIME_DATE_FORMAT)) {
      this.dateFormat =  new RelativeTimeDateFormat();
    } else if(dateFormatType.equalsIgnoreCase(
                             AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT)) {
      this.dateFormat =  new AbsoluteTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                        AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT)) {
      this.dateFormat =  new DateTimeDateFormat(timeZone);
    } else if(dateFormatType.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) {
      this.dateFormat =  new ISO8601DateFormat(timeZone);
    } else {
      this.dateFormat = new SimpleDateFormat(dateFormatType);
      this.dateFormat.setTimeZone(timeZone);
    }
  }
}
"
org/apache/log4j/net/test/SocketMin.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net.test;

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;
import java.io.InputStreamReader;

public class SocketMin {
  
  static Category cat = Category.getInstance(SyslogMin.class.getName());
  static SocketAppender s;

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    
    NDC.push(""some context"");
    if(argv[2].equals(""true""))
      loop();
    else
      test();
    
    s.close();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SocketMin.class 
		       + "" host port true|false"");
    System.exit(1);
  }

  static
  void init(String host, String portStr) {
    Category root = Category.getRoot();
    BasicConfigurator.configure();
    try {
      int port   = Integer.parseInt(portStr);
      cat.info(""Creating socket appender (""+host+"",""+port+"")."");
      s = new SocketAppender(host, port);
      s.setName(""S"");
      root.addAppender(s);
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    catch(Exception e) {
      System.err.println(""Could not start!"");
      e.printStackTrace();
      System.exit(1);
    }
  }

  static
  void loop() {
    Category root = Category.getRoot();
    InputStreamReader in = new InputStreamReader(System.in);
    System.out.println(""Type 'q' to quit"");
    int i;
    int k = 0;
    while (true) {
      cat.debug(""Message "" + k++);
      cat.info(""Message "" + k++);
      cat.warn(""Message "" + k++);
      cat.error(""Message "" + k++, new Exception(""Just testing""));
      try {i = in.read(); }
      catch(Exception e) { return; }
      if(i == -1) break;
      if(i == 'q') break;
      if(i == 'r') {
	System.out.println(""Removing appender S"");
	root.removeAppender(""S"");
      }
    }
  }

  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org/apache/log4j/StressCategory.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;


import org.apache.log4j.Priority;
import org.apache.log4j.Category;
import java.util.Random;

/*
  Stress test the Category class.

*/

class StressCategory {

  static Priority[] priority = new Priority[] {Priority.DEBUG, 
					       Priority.INFO, 
					       Priority.WARN,
					       Priority.ERROR,
					       Priority.FATAL};

  static Priority defaultPriority = Category.getRoot().getPriority();
  
  static int LENGTH;
  static String[] names;
  static Category[] cat;
  static CT[] ct;

  static Random random = new Random(10);

  public static void main(String[] args) {
    
    LENGTH = args.length;

    if(LENGTH == 0) {
      System.err.println( ""Usage: java "" + StressCategory.class.getName() +
			  "" name1 ... nameN\n."");      
      System.exit(1);
    }
    if(LENGTH >= 7) {
      System.err.println(
        ""This stress test suffers from combinatorial explosion.\n""+
        ""Invoking with seven arguments takes about 90 minutes even on fast machines"");
    }

    names = new String[LENGTH];
    for(int i=0; i < LENGTH; i++) {
      names[i] = args[i];
    }    
    cat = new Category[LENGTH];
    ct = new CT[LENGTH]; 


    permute(0); 

    // If did not exit, then passed all tests.
  }

  // Loop through all permutations of names[].
  // On each possible permutation call createLoop
  static
  void permute(int n) {
    if(n == LENGTH)
      createLoop(0);
    else
      for(int i = n; i < LENGTH; i++) {
	swap(names, n, i);
	permute(n+1);
	swap(names, n, i);	
      }
  }

  static
  void swap(String[] names, int i, int j) {
    String t = names[i];
    names[i] = names[j];
    names[j] = t;
  }
  
  public
  static
  void permutationDump() {
    System.out.print(""Current permutation is - "");
    for(int i = 0; i < LENGTH; i++) {
      System.out.print(names[i] + "" "");
    }
    System.out.println();
  }


  // Loop through all possible 3^n combinations of not instantiating, 
  // instantiating and setting/not setting a priority.

  static
  void createLoop(int n) {
    if(n == LENGTH) {  
      //System.out.println(""..............Creating cat[]..........."");
      for(int i = 0; i < LENGTH; i++) {
	if(ct[i] == null)
	  cat[i] = null;
	else {
	  cat[i] = Category.getInstance(ct[i].catstr);
	  cat[i].setPriority(ct[i].priority);
	}
      }
      test();
      // Clear hash table for next round
      Category.defaultHierarchy.clear();
    }
    else {      
      ct[n]  = null;
      createLoop(n+1);  

      ct[n]  = new CT(names[n], null);
      createLoop(n+1);  
      
      int r = random.nextInt(); if(r < 0) r = -r;
      ct[n]  = new CT(names[n], priority[r%5]);
      createLoop(n+1);
    }
  }


  static
  void test() {    
    //System.out.println(""++++++++++++TEST called+++++++++++++"");
    //permutationDump();
    //catDump();

    for(int i = 0; i < LENGTH; i++) {
      if(!checkCorrectness(i)) {
	System.out.println(""Failed stress test."");
	permutationDump();
	
	//Hierarchy._default.fullDump();
	ctDump();
	catDump();
	System.exit(1);
      }
    }
  }
  
  static
  void ctDump() {
    for(int j = 0; j < LENGTH; j++) {
       if(ct[j] != null) 
	    System.out.println(""ct ["" + j + ""] = (""+ct[j].catstr+"","" + 
			       ct[j].priority + "")"");
       else 
	 System.out.println(""ct ["" + j + ""] = undefined"");
    }
  }
  
  static
  void catDump() {
    for(int j = 0; j < LENGTH; j++) {
      if(cat[j] != null)
	System.out.println(""cat["" + j + ""] = ("" + cat[j].name + "","" +
			   cat[j].getPriority() + "")"");
      else
	System.out.println(""cat["" + j + ""] = undefined""); 
    }
  }

  //  static
  //void provisionNodesDump() {
  //for (Enumeration e = CategoryFactory.ht.keys(); e.hasMoreElements() ;) {
  //  CategoryKey key = (CategoryKey) e.nextElement();
  //  Object c = CategoryFactory.ht.get(key);
  //  if(c instanceof  ProvisionNode) 
  //((ProvisionNode) c).dump(key.name);
  //}
  //}
  
  static
  boolean checkCorrectness(int i) {
    CT localCT = ct[i];

    // Can't perform test if category is not instantiated
    if(localCT == null) 
      return true;
    
    // find expected priority
    Priority expected = getExpectedPrioriy(localCT);

			    
    Priority purported = cat[i].getChainedPriority();

    if(expected != purported) {
      System.out.println(""Expected priority for "" + localCT.catstr + "" is "" +
		       expected);
      System.out.println(""Purported priority for ""+ cat[i].name + "" is ""+purported);
      return false;
    }
    return true;
      
  }

  static
  Priority getExpectedPrioriy(CT ctParam) {
    Priority priority = ctParam.priority;
    if(priority != null) 
      return priority;

    
    String catstr = ctParam.catstr;    
    
    for(int i = catstr.lastIndexOf('.', catstr.length()-1); i >= 0; 
	                              i = catstr.lastIndexOf('.', i-1))  {
      String substr = catstr.substring(0, i);

      // find the priority of ct corresponding to substr
      for(int j = 0; j < LENGTH; j++) {	
	if(ct[j] != null && substr.equals(ct[j].catstr)) {
	  Priority p = ct[j].priority;
	  if(p != null) 
	    return p;	  
	}
      }
    }
    return defaultPriority;
  }

  

  static class CT {
    public String   catstr;
    public Priority priority;

    CT(String catstr,  Priority priority) {
      this.catstr = catstr;
      this.priority = priority;
    }
  }
}
"
org/apache/log4j/test/DefaultInit.java,false,"
package org.apache.log4j.test;

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
	
public class DefaultInit {

  static Category cat = Category.getInstance(DefaultInit.class.getName());

  public static void main( String[] argv) {

    cat.debug(""Hello world"");
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.DefaultInit "");
    System.exit(1);
  }

}
"
org/apache/log4j/spi/Filter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.spi.LoggingEvent;


/**
   Users should extend this class to implement customized logging
   event filtering. Note that {@link org.apache.log4j.Category} and {@link
   org.apache.log4j.AppenderSkeleton}, the parent class of all standard
   appenders, have built-in filtering rules. It is suggested that you
   first use and understand the built-in rules before rushing to write
   your own custom filters.

   <p>This abstract class assumes and also imposes that filters be
   organized in a linear chain. The {@link #decide
   decide(LoggingEvent)} method of each filter is called sequentially,
   in the order of their addition to the chain.

   <p>The {@link #decide decide(LoggingEvent)} method must return one
   of the integer constants {@link #DENY}, {@link #NEUTRAL} or {@link
   #ACCEPT}.

   <p>If the value {@link #DENY} is returned, then the log event is
   dropped immediately without consulting with the remaining
   filters. 

   <p>If the value {@link #NEUTRAL} is returned, then the next filter
   in the chain is consulted. If there are no more filters in the
   chain, then the log event is logged. Thus, in the presence of no
   filters, the default behaviour is to log all logging events.

   <p>If the value {@link #ACCEPT} is returned, then the log
   event is logged without consulting the remaining filters. 

   <p>The philosophy of log4j filters is largely inspired from the
   Linux ipchains. 

   <p>Note that filtering is only supported by the {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}. The {@link
   org.apache.log4j.PropertyConfigurator PropertyConfigurator} does not
   support filters.

   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public abstract class Filter implements OptionHandler {

  /**
     Points to the next filter in the filter chain.
   */
  public Filter next;

  /**
     The log event must be dropped immediately without consulting
     with the remaining filters, if any, in the chain.  */
  public static final int DENY    = -1;
  
  /**
     This filter is neutral with respect to the log event. The
     remaining filters, if any, should be consulted for a final decision.
  */
  public static final int NEUTRAL = 0;

  /**
     The log event must be logged immediately without consulting with
     the remaining filters, if any, in the chain.  */
  public static final int ACCEPT  = 1;


  /**
     Usually filters options become active when set. We provide a
     default do-nothing implementation for convenience.
  */
  public
  void activateOptions() {
  }



  /**     
     <p>If the decision is <code>DENY</code>, then the event will be
     dropped. If the decision is <code>NEUTRAL</code>, then the next
     filter, if any, will be invoked. If the decision is ACCEPT then
     the event will be logged without consulting with other filters in
     the chain.

     @param event The LoggingEvent to decide upon.
     @param decision The decision of the filter.  */
  abstract
  public
  int decide(LoggingEvent event);

}
"
org/apache/log4j/helpers/FormattingInfo.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;


/**
   FormattingInfo instances contain the information obtained when parsing
   formatting modifiers in conversion modifiers.

   @author <a href=mailto:jim_cakalic@na.biomerieux.com>Jim Cakalic</a>
   @author Ceki G&uuml;lc&uuml;

   @since 0.8.2   
 */
public class FormattingInfo {
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  void reset() {
    min = -1;
    max = 0x7FFFFFFF;
    leftAlign = false;      
  }

  void dump() {
    LogLog.debug(""min=""+min+"", max=""+max+"", leftAlign=""+leftAlign);
  }
}
 
"
org/apache/log4j/spi/Configurator.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.Hierarchy;
import java.net.URL;

/**
   Implemented by classes capable of configuring log4j using a URL.
   
   @since 1.0
   @author Anders Kristensen
 */
public interface Configurator {
  /**
     Interpret a resource pointed by a URL and set up log4j accordingly.

     The configuration is done relative to the <code>hierarchy</code>
     parameter.

     @param url The URL to parse
     @param hierarchy The hierarchy to operation upon.
   */
  void doConfigure(URL url, Hierarchy hierarchy);
}
"
org/apache/log4j/or/DefaultRenderer.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.or;

/**
   The default Renderer renders objects by calling their
   <code>toString</code> method.

   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
class DefaultRenderer implements ObjectRenderer {
  
  DefaultRenderer() {
  }

  /**
     Render the object passed as parameter by calling its
     <code>toString</code> method.  */
  public
  String doRender(Object o) {
    return o.toString();
  }
}  
"
org/apache/log4j/test/StressNDC.java,false,"//      Copyright 1996-1999, International Business Machines 
//      Corporation and others. All Rights Reserved.

package org.apache.log4j.test;


import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;


import java.util.Random;
import java.util.Stack;

/**
   Stress test {@link NDC}.
   
 */
public class StressNDC extends Thread {

  static Category root = Category.getRoot();  

  static Random random = new Random(101);

  static final int LOOP_LENGTH = 24;
  static final int PUSH_MISS = LOOP_LENGTH/2;      
  static final int POP_MISS = PUSH_MISS*2;    

  static final int BRANCHING_FACTOR = 4 + 1; // add 1 to the number you want
  
  static int maxThreads;  
  static int msgCounter = 0;
  static int threadCounter = 0;  

  static double LOG_2 = Math.log(2);

  static Object lock = new Object();

  
  public 
  static 
  void main(String args[]) {
    root.setPriority(Priority.DEBUG);
    BasicConfigurator.configure();

    if(args.length != 1) {
      usage();
    }

    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    
    root.debug( ""push(IP=127.0.0.1)"");
    
    NDC.push(""IP=127.0.0.1"");

    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);

	// wait until all threads are finished
	try {
	  root.debug( ""About to wait for notification."");
	  lock.wait();
	  root.debug( ""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }

  static
  void usage() {
    System.err.println( ""Usage: java org.apache.log4j.test.StressNDC "" +
			""MAX_THREADS"");
    System.exit(1);
  }


  Stack parentDC;
  
  public
  StressNDC(Stack parentDC) {
    this.setName(randomID());
    this.parentDC = parentDC;
  }

  public
  void run() {
    NDC.inherit(parentDC);
    
    int loopLength = StressNDC.randomInt(LOOP_LENGTH);
    root.debug(""In run loop.debug( loopLength = ""+loopLength);

    int createIndex = loopLength/2;
      
    for(int i = 0; i <= loopLength; i++) {

      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      
      if(randomInt(PUSH_MISS) == 0) {
	String id = randomID();
	root.debug( ""push(""+id+"")""); 
	NDC.push(id);
      }      
      root.debug( ""Message number "" + StressNDC.msgCounter++);	
      if(randomInt(POP_MISS) == 0) {
	root.debug( ""pop()"");
	NDC.pop();
      }
    }    

    synchronized(lock) {
      StressNDC.threadCounter--;
      root.debug( ""Exiting run loop. "" + threadCounter);
      if(StressNDC.threadCounter <= 0) {
	root.debug( ""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }

    // We sometimes forget to remove references
    if((loopLength % 2) == 0) {
      root.debug(""Removing NDC for this thread."");
      NDC.remove();
    }
  }

  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;

    synchronized(lock) {
      n = maxThreadsConstained(n);    
      root.debug(""Creating "" + n+ "" child StressNDC threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressNDC, threadCounter = "" + (++threadCounter));
	new StressNDC(NDC.cloneStack()).start();
      }
    }
  }

  static
  public
  int maxThreadsConstained(int a) {
    int maxAllowed = StressNDC.maxThreads - StressNDC.threadCounter;      
    return a <= maxAllowed ? a : maxAllowed;
  }

  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }

  public
  static
  String randomID() {
    return Integer.toHexString(random.nextInt()& 0xFFFFFF);
  }
}
"
org/apache/log4j/CategoryKey.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

/**
   CategoryKey is heavily used internally to accelerate hash table searches.
   @author Ceki G&uuml;lc&uuml; 
*/
class CategoryKey {

  String   name;  
  int hashCache;

  CategoryKey(String name) {
    this.name = name.intern();
    hashCache = name.hashCode();
  }

  final
  public  
  int hashCode() {
    return hashCache;
  }

  final
  public
  boolean equals(Object rArg) {
    if(this == rArg)
      return true;
    
    if(rArg != null && CategoryKey.class == rArg.getClass()) 
      return  name == ((CategoryKey)rArg ).name;
    else 
      return false;
  }
}
"
org/apache/log4j/nt/NTEventLogAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.nt;

import org.apache.log4j.*;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;

import java.io.*;


/**
   Append to the NT event log system. 

   <p><b>WARNING</b> This appender can only be installed and used on a
   Windows system.

   <p>Do not forget to place the file NTEventLogAppender.dll in a
   directory that is on the PATH of the Windows system. Otherwise, you
   will get a java.lang.UnsatisfiedLinkError.

   @author <a href=""mailto:cstaylor@pacbell.net"">Chris Taylor</a>
   @author <a href=""mailto:jim_cakalic@na.biomerieux.com"">Jim Cakalic</a> */
public class NTEventLogAppender extends AppenderSkeleton {
  private int _handle = 0;

  /**
     The string constant used in naming the source of the event. The
     current value of this constant is <b>Source</b>.

     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

   */
  public static final String SOURCE_OPTION = ""Source"";
  
  private String source = null;
  private String server = null;

  private static final int FATAL  = Priority.FATAL.toInt();
  private static final int ERROR  = Priority.ERROR.toInt();
  private static final int WARN   = Priority.WARN.toInt();
  private static final int INFO   = Priority.INFO.toInt();
  private static final int DEBUG  = Priority.DEBUG.toInt();
  
  public NTEventLogAppender() {
    this(null, null, null);
  }
  
  public NTEventLogAppender(String source) {
    this(null, source, null);
  }
  
  public NTEventLogAppender(String server, String source) {
    this(server, source, null);
  }
  
  public NTEventLogAppender(Layout layout) {
    this(null, null, layout);
  }
  
  public NTEventLogAppender(String source, Layout layout) {
    this(null, source, layout);
  }
  
  public NTEventLogAppender(String server, String source, Layout layout) {
    if (source == null) {
      source = ""Log4j"";
    }
    if (layout == null) {
      this.layout = new TTCCLayout();
    } else {
      this.layout = layout;
    }
    
    try {
      _handle = registerEventSource(server, source);
    } catch (Exception e) {
      e.printStackTrace();
      _handle = 0;
    }
  }

  /**
     Returns the option names for this component.
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   **/
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {SOURCE_OPTION});
  }

  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    

    if(key.equalsIgnoreCase(SOURCE_OPTION)) {
      // Set the source for the NT Evetns
      source = value.trim();
    }
  }

  public
  void close() {
    // unregister ...
  }

  public
  void activateOptions() {    
    if (source != null) {
      try {
	_handle = registerEventSource(server, source);
      } catch (Exception e) {
	LogLog.error(""Could not register event source."", e);
	_handle = 0;
      }
    }
  }

  
  public void append(LoggingEvent event) {

    StringBuffer sbuf = new StringBuffer();    

    sbuf.append(layout.format(event));
    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {	
	  sbuf.append(s[0]);
	}	
      }
    }
    // Normalize the log message priority into the supported categories
    int nt_category = event.priority.toInt();

    // Anything above FATAL or below DEBUG is labeled as INFO.
    //if (nt_category > FATAL || nt_category < DEBUG) {
    //  nt_category = INFO;
    //}
    reportEvent(_handle, sbuf.toString(), nt_category);
  }
  
  
  public 
  void finalize() {
    deregisterEventSource(_handle);
    _handle = 0;
  }
  
  /**
     The <b>Source</b> option which names the source of the event. The
     current value of this constant is <b>Source</b>.
   */
  public
  void setSource(String source) {
    this.source = source.trim();
  }
  
  public
  String getSource() {
    return source;
  }
  
/**
     The <code>NTEventLogAppender</code> requires a layout. Hence,
     this method always returns <code>true</code>. */
  public
  boolean requiresLayout() {
    return true;
  }
  
  native private int registerEventSource(String server, String source);
  native private void reportEvent(int handle, String message, int priority);
  native private void deregisterEventSource(int handle);
  
  static {
    System.loadLibrary(""NTEventLogAppender"");
  }
}   
"
org/apache/log4j/performance/NotLogging.java,true,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.

package org.apache.log4j.performance;


import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Layout;

import org.apache.log4j.Priority;

/**
   Measure the performance of evaluating whether to log or not to log,
   but not actually logging.

   <p>This program takes two arguments, a string which should be
   ""true"" for testing shipped code performance and ""false"" for testing
   debug-enabled performance the second argument is the run length of
   the measurement loops.

   <p>The results of the measurement (should) show that

   <ul>

   <p>
   <li>Category evaluation is independent of the length of the category name.

   <p>
   <li>As expected, using the {@link Category#isDebugEnabled
   isDebugEnabled} and {@link Category#isInfoEnabled isInfoEnabled}
   methods eliminates the overhead of message argument construction.

   <p> <li>Message argument construction can be an important slowing
   factor while evaluating whether to log or not.

   </ul>

   @author Ceki G&uuml;lc&uuml;

*/
public class NotLogging {

  static int runLength;

  final static int INITIAL_HASH_SIZE = 101; 

  static String  SHORT_MSG = ""Hello World"";

  static Category SHORT_CAT = Category.getInstance(""A0123456789"");
  static Category MEDIUM_CAT= Category.getInstance(""A0123456789.B0123456789"");
  static Category LONG_CAT  = 
                   Category.getInstance(""A0123456789.B0123456789.C0123456789"");

  static Category INEXISTENT_SHORT_CAT = Category.getInstance(""I0123456789"");
  static Category INEXISTENT_MEDIUM_CAT=
                                Category.getInstance(""I0123456789.B0123456789"");
  static Category INEXISTENT_LONG_CAT= 
                     Category.getInstance(""I0123456789.B0123456789.C0123456789"");


  static Category[] CAT_ARRAY = new Category[] {SHORT_CAT, MEDIUM_CAT, 
						LONG_CAT, INEXISTENT_SHORT_CAT,
						INEXISTENT_MEDIUM_CAT,
						INEXISTENT_LONG_CAT};

  static
  void  Usage() {
    System.err.println(
      ""Usage: java org.apache.log4j.test.NotLogging true|false runLength\n"" +
      ""true indicates shipped code, false indicates code in development"" +
      ""  where runLength is an int representing the run length of loops\n""+
      ""We suggest that runLength be at least 100'000."");
    System.exit(1);
  }

  public static void main(String argv[]) {

    if(argv.length != 2) {
      Usage();
    }    
    ProgramInit(argv);
    double delta;

    
    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = SimpleMessage(CAT_ARRAY[i], SHORT_MSG, runLength);
      System.out.println(""Simple argument,          "" + delta 
			 + "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }

    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = FullyOptimizedComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Fully optimized complex,  "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }

    System.out.println();
    for(int i = 0; i < CAT_ARRAY.length; i++) {
      delta = ComplexMessage(CAT_ARRAY[i], runLength);
      System.out.println(""Complex message argument, "" + delta + 
			 "" micros. Cat: "" + CAT_ARRAY[i].getName());
    }
    
  }
  
  /**
    Program wide initialization method.  */
  static
  void ProgramInit(String[] args) {

    try {
      runLength = Integer.parseInt(args[1]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      

    
    ConsoleAppender appender = new ConsoleAppender(new SimpleLayout());
    
    if(""false"".equals(args[0]))
      ;       
    else if (""true"".equals(args[0])) {
      System.out.println(""Flagging as shipped code."");
      Category.getDefaultHierarchy().disableInfo();
    }
    else 
      Usage();

    SHORT_CAT.setPriority(Priority.INFO);      
    Category.getRoot().setPriority(Priority.INFO);

  }    
  

  static
  double SimpleMessage(Category category, String msg, long runLength) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(msg);
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }

  static
  double FullyOptimizedComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      if(category.isDebugEnabled())
	category.debug(""Message"" + i + 
		  "" bottles of beer standing on the wall."");
    }    
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }

  static
  double ComplexMessage(Category category, long runLength) {    
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.debug(""Message"" + i +
		"" bottles of beer standing on the wall."");
    }
    return (System.currentTimeMillis() - before)*1000.0/runLength;    
  }
}
"
org/apache/log4j/performance/NullAppender.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.performance;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;

/**
   A bogus appender which calls the format method of its layout object
   but does not write the result anywhere.   
 */
public class NullAppender extends AppenderSkeleton {

  public static String s;
  public String t;	

  public
  NullAppender() {}
  
  public
  NullAppender(Layout layout) {
    this.layout = layout;
  }

  public
  void close() {}
  
  public
  void doAppend(LoggingEvent event) {
    if(layout != null) {
      t = layout.format(event);
      s = t;
    }
  }

  public
  void append(LoggingEvent event) {
  }

  /**
     This is a bogus appender but it still uses a layout.
  */
  public
  boolean requiresLayout() {
    return true;
  }  
}
"
org/apache/log4j/test/ROFile.java,false,"package org.apache.log4j.test; 

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import java.io.IOException;

public class ROFile {

  static Category cat = Category.getInstance(ROFile.class.getName());
  
  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) 
      init(argv[0]);
    else 
      Usage(""Wrong number of arguments."");

    test();
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + ROFile.class.getName() +
			""configFile"");
    System.exit(1);
  }

  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }

  static
  void test() {
    int i = -1;
    cat.debug(""Message "" + ++i);
  }
}
"
org/apache/log4j/test/Shallow.java,true,"/* Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
// NOTICE: Some tests are sensitive to line numbers!
package org.apache.log4j.test; 
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;
import org.apache.log4j.Priority;
import java.io.IOException;
import java.util.Enumeration;
/** 
   This class is a shallow test of the various appenders and
   layouts. It also tests their reading of the configuration file.
   @author  Ceki G&uuml;lc&uuml;
*/
public class Shallow {
  
  static Category cat = Category.getInstance(Shallow.class);
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java ""+ Shallow.class.getName()+""configFile"");
    System.exit(1);
  }

  static 
  void init(String configFile) {
    if(configFile.endsWith("".xml""))
      DOMConfigurator.configure(configFile);
    else 
      PropertyConfigurator.configure(configFile);
  }

  static 
  void test() {
    int i = -1; 
    NDC.push(""NDC""); 
    Category root = Category.getRoot();
    cat.debug(""Message "" + ++i);
    root.debug(""Message "" + i);        

    cat.info (""Message "" + ++i);
    root.info(""Message "" + i);        

    cat.warn (""Message "" + ++i);
    root.warn(""Message "" + i);        

    cat.error(""Message "" + ++i);
    root.error(""Message "" + i);
    
    cat.log(Priority.FATAL, ""Message "" + ++i);
    root.log(Priority.FATAL, ""Message "" + i);    
    
    Exception e = new Exception(""Just testing"");
    cat.debug(""Message "" + ++i, e);
    root.debug(""Message "" + i, e);
    
    cat.info(""Message "" + ++i, e);
    root.info(""Message "" + i, e);    

    cat.warn(""Message "" + ++i , e);
    root.warn(""Message "" + i , e);    

    cat.error(""Message "" + ++i, e);
    root.error(""Message "" + i, e);    

    cat.log(Priority.FATAL, ""Message "" + ++i, e);
    root.log(Priority.FATAL, ""Message "" + i, e);    


    // It is always a good idea to call this method when exiting an
    // application.
    Category.shutdown();
  }


  static
  void delay(int amount) {
    try {
      Thread.currentThread().sleep(amount);
    }
    catch(Exception e) {}
  }
}
"
org/apache/log4j/ProvisionNode.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import java.util.Vector;

class ProvisionNode extends Vector {
    
  ProvisionNode(Category cat) {
    super();
    this.addElement(cat);
  }
}
"
org/apache/log4j/test/ConfigurationFileParsing.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.test; 

import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.NDC;

public class ConfigurationFileParsing {
  
  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) {
      NDC.push(""testing"");
      PropertyConfigurator.configure(argv[0]);
      Category root = Category.getRoot();
      root.debug(""Message 1"");
      root.debug(""Message 2"");      
      NDC.pop();
      Category.shutdown();
    }
    else {
      Usage(""Wrong number of arguments."");
    }
    
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+ConfigurationFileParsing.class.getName()
		       + "" fileName"");
    System.exit(1);
  }

  
}
"
org/apache/log4j/Priority.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

// Contributors:  Kitching Simon <Simon.Kitching@orange.ch>

package org.apache.log4j;

/**
   Defines the minimum set of priorities recognized by the system,
   that is {@link #FATAL}, {@link #ERROR}, {@link #WARN}, {@link
   #INFO} and {@link #DEBUG}.

   <p>The <code>Priority</code> class may be subclassed to define a larger
   priority set.

   @author Ceki G&uuml;lc&uuml;
 */
public class Priority {

  int level;
  String levelStr;
  int syslogEquivalent;

  public final static int FATAL_INT = 50000;
  public final static int ERROR_INT = 40000;
  public final static int WARN_INT  = 30000;
  public final static int INFO_INT  = 20000;
  public final static int DEBUG_INT = 10000;

  /**
     The <code>FATAL</code> priority designates very severe error
     events that will presumably lead the application to abort.

   */
  final static public Priority FATAL = new Priority(FATAL_INT, ""FATAL"", 0);

  /**
     The <code>ERROR</code> priority designates error events that
     might still allow the application to continue running.  */
  final static public Priority ERROR = new Priority(ERROR_INT, ""ERROR"", 3);

  /**
     The <code>WARN</code> priority designates potentially harmful situations.
  */
  final static public Priority WARN  = new Priority(WARN_INT, ""WARN"",  4);

  /**
     The <code>INFO</code> priority designates informational messages
     that highlight the progress of the application at coarse-grained
     level.  */
  final static public Priority INFO  = new Priority(INFO_INT, ""INFO"",  6);

  /**
     The <code>DEBUG</code> priority designates fine-grained
     informational events that are most useful to debug an
     application.  */
  final static public Priority DEBUG = new Priority(DEBUG_INT, ""DEBUG"", 7);

  
  /**
     Instantiate a priority object.
   */
  protected
  Priority(int level, String levelStr, int syslogEquivalent) {
    this.level = level;
    this.levelStr = levelStr;
    this.syslogEquivalent = syslogEquivalent;
  }

  /**
     Return the syslog equivalent of this priority as an integer.
   */
  public
  final
  int getSyslogEquivalent() {
    return syslogEquivalent;
  }


  /**
     Returns the string representation of this priority.
   */
  final
  public
  String toString() {
    return levelStr;
  }

  /**
     Returns the integer representation of this priority.
   */
  public
  final
  int toInt() {
    return level;
  }

    
  /**
     Returns <code>true</code> if this priority has a higher or equal
     priority than the priority passed as argument, <code>false</code>
     otherwise.  
     
     <p>You should think twice before overriding the default
     implementation of <code>isGreaterOrEqual</code> method.

  */
  public
  boolean isGreaterOrEqual(Priority r) {
    return level >= r.level;
  }

  /**
     Return all possible priorities as an array of Priority objects in
     descending order.  */
  public
  static
  Priority[] getAllPossiblePriorities() {
    return new Priority[] {Priority.FATAL, Priority.ERROR, Priority.WARN, 
			     Priority.INFO, Priority.DEBUG};
  }


  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns {@link #DEBUG}. 
  */
  public
  static
  Priority toPriority(String sArg) {
    return toPriority(sArg, Priority.DEBUG);
  }

  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns {@link #DEBUG}.

  */
  public
  static
  Priority toPriority(int val) {
    return toPriority(val, Priority.DEBUG);
  }

  /**
    Convert an integer passed as argument to a priority. If the
    conversion fails, then this method returns the specified default.
  */
  public
  static
  Priority toPriority(int val, Priority defaultPriority) {
    switch(val) {
    case DEBUG_INT: return DEBUG;
    case INFO_INT: return INFO;
    case WARN_INT: return WARN;
    case ERROR_INT: return ERROR;
    case FATAL_INT: return FATAL;
    default: return defaultPriority;
    }
  }

  /**
     Convert the string passed as argument to a priority. If the
     conversion fails, then this method returns the value of
     <code>defaultPriority</code>.  
  */
  public
  static
  Priority toPriority(String sArg, Priority defaultPriority) {                  
    if(sArg == null)
       return defaultPriority;
    
    String s = sArg.toUpperCase();

    if(s.equals(""DEBUG"")) return Priority.DEBUG; 
    if(s.equals(""INFO""))  return Priority.INFO;
    if(s.equals(""WARN""))  return Priority.WARN;  
    if(s.equals(""ERROR"")) return Priority.ERROR;
    if(s.equals(""FATAL"")) return Priority.FATAL;
    return defaultPriority;
  }


}
"
org/apache/log4j/spi/ErrorHandler.java,false,"/**
  Copyright (c) 2000, Ceki Gulcu

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the ""Software""), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

package org.apache.log4j.spi;

import org.apache.log4j.Appender;

/**
   Appenders may delegate their error handling to ErrorHandlers.

   <p>Error handling is a particularly tedious to get right because by
   definition errors are hard to predict and to reproduce. 


   <p>Please take the time to contact the author in case you discover
   that errors are not properly handled. You are most welcome to
   suggest new error handling policies or criticize existing policies.


   @author Ceki G&uuml;lc&uuml;

   @since 0.9.0 */
public interface ErrorHandler extends OptionHandler {


  /**
     This method should handle the error. Information about the error
     condition is passed a parameter.
     
     @param message The message assoicated with the error.
     @param e The Exption that was thrown when the error occured.
     @param errorCode The error code associated with the error.
  */
  void error(String message, Exception e, int errorCode);


  /**
     This method prints the error message passed as a parameter.
  */
  void error(String message);

}
"
org/apache/log4j/spi/LocationInfo.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

// Contributors: Mathias Rupprecht <mmathias.rupprecht@fja.com>

package org.apache.log4j.spi;

import java.io.StringWriter;
import java.io.PrintWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.Layout;

/**
   The internal representation of caller location information.
     
   @since 0.8.3
*/
public class LocationInfo implements java.io.Serializable {
    
  /**
     Caller's line number.
  */
  transient String lineNumber;
  /**
     Caller's file name.
  */
  transient String fileName;
  /**
     Caller's fully qualified class name.
  */
  transient String className;
  /**
     Caller's method name.
  */
  transient String methodName;
  /**
     All available caller information, in the format
     <code>fully.qualified.classname.of.caller.methodName(Filename.java:line)</code>
    */
  public String fullInfo;

  private static StringWriter sw = new StringWriter();
  private static PrintWriter pw = new PrintWriter(sw);

  /**
     When location information is not available the constant
     <code>NA</code> is returned. Current value of this string
     constant is <b>?</b>.  */
  public final static String NA = ""?"";

  static final long serialVersionUID = -1325822038990805636L;


  // Check if we are running in IBM's visual age.
  static boolean inVisualAge = false;
  static {
    try {
      Class dummy = Class.forName(""com.ibm.uvm.tools.DebugSupport"");
      inVisualAge = true;
      LogLog.debug(""Detected IBM VisualAge environment."");
    } catch(Throwable e) { 
      // nothing to do
    }
  }

  /**
     Instantiate location information based on a Throwable. We
     expect the Throwable <code>t</code>, to be in the format

       <pre>
        java.lang.Throwable
        ...
          at org.apache.log4j.PatternLayout.format(PatternLayout.java:413)
          at org.apache.log4j.FileAppender.doAppend(FileAppender.java:183)
        at org.apache.log4j.Category.callAppenders(Category.java:131)
        at org.apache.log4j.Category.log(Category.java:512)
        at callers.fully.qualified.className.methodName(FileName.java:74)
	...
       </pre>

       <p>However, we can also deal with JIT compilers that ""lose"" the
       location information, especially between the parentheses.

    */
    public LocationInfo(Throwable t, String fqnOfCallingClass) {
      if(t == null)
	return;
/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

      String s;
      // Protect against multiple access to sw.
      synchronized(sw) {
	t.printStackTrace(pw);
	s = sw.toString();
	sw.getBuffer().setLength(0);
      }
      //System.out.println(""s is [""+s+""]."");
      int ibegin, iend;

      // Given the current structure of the package, the line
      // containing ""org.apache.log4j.Category."" should be printed just
      // before the caller.

      // This method of searching may not be fastest but it's safer
      // than counting the stack depth which is not guaranteed to be
      // constant across JVM implementations.      
      ibegin = s.lastIndexOf(fqnOfCallingClass);
      if(ibegin == -1) return;


      ibegin = s.indexOf(Layout.LINE_SEP, ibegin); if(ibegin == -1) return;
      ibegin+= Layout.LINE_SEP_LEN;
      
      // determine end of line
      iend = s.indexOf(Layout.LINE_SEP, ibegin); if(iend == -1) return;

      // VA has a different stack trace format which doesn't 
      // need to skip the inital 'at'
      if(!inVisualAge) {
	// back up to first blank character
	ibegin = s.lastIndexOf(""at "", iend); if(ibegin == -1) return;
	// Add 3 to skip ""at "";
	ibegin += 3;
      }
      // everything between is the requested stack item
      this.fullInfo = s.substring(ibegin, iend);
    }

    /**
       Return the fully qualified class name of the caller making the
       logging request.
    */
    public
    String getClassName() {      
      if(fullInfo == null) return NA;      
      if(className == null) {
	// Starting the search from '(' is safer because there is
	// potentially a dot between the parentheses.
	int iend = fullInfo.lastIndexOf('(');
	if(iend == -1) 
	  className = NA;
	else {
	  iend = fullInfo.lastIndexOf('.', iend);

	  // This is because a stack trace in VisualAge looks like:

          //java.lang.RuntimeException
	  //  java.lang.Throwable()
	  //  java.lang.Exception()
	  //  java.lang.RuntimeException()
	  //  void test.test.B.print()
	  //  void test.test.A.printIndirect()
	  //  void test.test.Run.main(java.lang.String [])
          int ibegin = 0;
	  if (inVisualAge) {
	    ibegin = fullInfo.lastIndexOf(' ', iend)+1;
          }

	  if(iend == -1) 
	    className = NA;
	  else
	    className = this.fullInfo.substring(ibegin, iend);
	}
      }
      return className;
    }

    /**
       Return the file name of the caller.

       <p>This information is not always available.
    */
    public 
    String getFileName() {
      if(fullInfo == null) return NA;
      
      if(fileName == null) {
	int iend = fullInfo.lastIndexOf(':');	
	if(iend == -1)
	  fileName = NA;
	else {
	  int ibegin = fullInfo.lastIndexOf('(', iend - 1);
	  fileName = this.fullInfo.substring(ibegin + 1, iend);
	}	
      }
      return fileName;
    }

    /**
       Returns the line number of the caller.

       <p>This information is not always available.       
    */
    public 
    String getLineNumber() {
      if(fullInfo == null) return NA;
      
      if(lineNumber == null) {
	int iend = fullInfo.lastIndexOf(')');	
	int ibegin = fullInfo.lastIndexOf(':', iend -1);
	if(ibegin == -1)
	  lineNumber = NA;
	else 
	  lineNumber = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return lineNumber;
    }

    /**
       Returns the method name of the caller.
    */
    public
    String getMethodName() {
      if(fullInfo == null) return NA;            
      if(methodName == null) {
	int iend = fullInfo.lastIndexOf('(');	
	int ibegin = fullInfo.lastIndexOf('.', iend);
	if(ibegin == -1)
	  methodName = NA;
	else
	  methodName = this.fullInfo.substring(ibegin + 1, iend);	
      }
      return methodName;
    }
}
"
org/apache/log4j/helpers/BoundedFIFO.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

// Contributors:     Mathias Bogaert

package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;

/**
   <code>BoundedFIFO</code> serves as the bounded first-in-first-out
   buffer heavily used by the {@link org.apache.log4j.AsyncAppender}.
   
   @author Ceki G&uuml;lc&uuml; 
   @since version 0.9.1 */
public class BoundedFIFO {
  
  LoggingEvent[] buf;
  int numElements = 0;
  int first = 0;
  int next = 0;
  int maxSize;

  /**
     Instantiate a new BoundedFIFO with a maximum size passed as argument.
   */
  public
  BoundedFIFO(int maxSize) {
   if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    buf = new LoggingEvent[maxSize];
  }
  
  /**
     Get the first element in the buffer. Returns <code>null</code> if
     there are no elements in the buffer.  */
  public
  LoggingEvent get() {
    if(numElements == 0) 
      return null;
    
    LoggingEvent r = buf[first];
    if(++first == maxSize) {
	first = 0;
    }
    numElements--;    
    return r;    
  }

  /**
     Place a {@link LoggingEvent} in the buffer. If the buffer is full
     then the event is <b>silently dropped</b>. It is the caller's
     responsability to make sure that the buffer has free space.  */
  public 
  void put(LoggingEvent o) {
    if(numElements != maxSize) {      
      buf[next] = o;    
      if(++next == maxSize) {
	next = 0;
      }
      numElements++;
    }
  }

  /**
     Get the maximum size of the buffer.
   */
  public 
  int getMaxSize() {
    return maxSize;
  }

  /**
     Return <code>true</code> if the buffer is full, i.e. of the
     number of elements in the buffer equals the buffer size. */
  public 
  boolean isFull() {
    return numElements == maxSize;
  }

  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElements;
  } 


  int min(int a, int b) {
    return a < b ? a : b;
  }


  /**
     Resize the buffer to a new size. If the new size is smaller than
     the old size events might be lost.
     
     @since 1.1
   */
  synchronized
  public 
  void resize(int newSize) {
    if(newSize == maxSize) 
      return;


   LoggingEvent[] tmp = new LoggingEvent[newSize];

   // we should not copy beyond the buf array
   int len1 = maxSize - first;

   // we should not copy beyond the tmp array
   len1 = min(len1, newSize);

   // er.. how much do we actually need to copy?
   // We should not copy more than the actual number of elements.
   len1 = min(len1, numElements);

   // Copy from buf starting a first, to tmp, starting at position 0, len1 elements.
   System.arraycopy(buf, first, tmp, 0, len1);
   
   // Are there any uncopied elements and is there still space in the new array?
   int len2 = 0;
   if((len1 < numElements) && (len1 < newSize)) {
     len2 = numElements - len1;
     len2 = min(len2, newSize - len1);
     System.arraycopy(buf, 0, tmp, len1, len2);
   }
   
   this.buf = tmp;
   this.maxSize = newSize;    
   this.first=0;   
   this.numElements = len1+len2;
   this.next = this.numElements;
   if(this.next == this.maxSize) // this should never happen, but again, it just might.
     this.next = 0;
  }

  
  /**
     Returns <code>true</code> if there is just one element in the
     buffer. In other words, if there were no elements before the last
     {@link #put} operation completed.  */
  public
  boolean wasEmpty() {
    return numElements == 1;
  }

  /**
      Returns <code>true</code> if the number of elements in the
      buffer plus 1 equals the maximum buffer size, returns
      <code>false</code> otherwise. */
  public
  boolean wasFull() {
    return (numElements+1 == maxSize);
  }

}
"
org/apache/log4j/spi/LoggingEvent.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;

import org.apache.log4j.helpers.LogLog;

import java.io.StringWriter;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.util.Hashtable;

// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Wolf Siberski
//                 Anders Kristensen <akristensen@dynamicsoft.com>

/**
   The internal representation of logging events. When an affirmative
   decision is made to log then a <code>LoggingEvent</code> instance
   is created. This instance is passed around to the different log4j
   components.

   <p>This class is of concern to those wishing to extend log4j. 

   @author Ceki G&uuml;lc&uuml;
   @author James P. Cakalic
   
   @since 0.8.2 */
public class LoggingEvent implements java.io.Serializable {

  private static long startTime = System.currentTimeMillis();

  /** Fully qualified name of the calling category class. */
  transient public final String fqnOfCategoryClass;

  /** The category of the logging event. The category field is not
  serialized for performance reasons. 

  <p>It is set by the LoggingEvent constructor or set by a remote
  entity after deserialization. */
  transient public Category category;

  /** The category name. */
  public final String categoryName;
  
  /** Priority of logging event. Priority cannot be serializable
      because it is a flyweight.  Due to its special seralization it
      cannot be declared final either. */
  transient public Priority priority;

  /** The nested diagnostic context (NDC) of logging event. */
  private String ndc;

  /** Have we tried to do an NDC lookup? If we did, there is no need
      to do it again.  Note that its value is always false when
      serialized. Thus, a receiving SocketNode will never use it's own
      (incorrect) NDC. See also writeObject method. */
  private boolean ndcLookupRequired = true;


  /** The application supplied message of logging event. */
  transient private Object message;

  /** The application supplied message rendered through the log4j
      objet rendering mechanism.*/
  private String renderedMessage;

  /** The name of thread in which this logging event was generated. */
  private String threadName;


  /** This 
      variable contains information about this event's throwable  
  */
  private ThrowableInformation throwableInfo;

  /** The number of milliseconds elapsed from 1/1/1970 until logging event
      was created. */
  public final long timeStamp;
  /** Location information for the caller. */
  private LocationInfo locationInfo;

  // Damn serialization
  static final long serialVersionUID = -868428216207166145L;

  static final Integer[] PARAM_ARRAY = new Integer[1];
  static final String TO_PRIORITY = ""toPriority"";
  static final Class[] TO_PRIORITY_PARAMS = new Class[] {int.class};
  static final Hashtable methodCache = new Hashtable(3); // use a tiny table

  /**
     Instantiate a LoggingEvent from the supplied parameters.
     
     <p>Except {@link #timeStamp} all the other fields of
     <code>LoggingEvent</code> are filled when actually needed.
     <p>
     @param category The category of this event.
     @param priority The priority of this event.
     @param message  The message of this event.
     @param throwable The throwable of this event.  */
  public LoggingEvent(String fqnOfCategoryClass, Category category, 
		      Priority priority, Object message, Throwable throwable) {
    this.fqnOfCategoryClass = fqnOfCategoryClass;
    this.category = category;
    this.categoryName = category.getName();
    this.priority = priority;
    this.message = message;
    if(throwable != null) {
      this.throwableInfo = new ThrowableInformation(throwable);
    }

    timeStamp = System.currentTimeMillis();
  }  


  /**
     Set the location information for this logging event. The collected
     information is cached for future use.
   */
  public
  LocationInfo getLocationInformation() {
    if(locationInfo == null) {
      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);
    }
    return locationInfo;
  }


  /**
     Return the message for this logging event. 

     <p>Before serialization, the returned object is the message
     passed by the user to generate the logging event. After
     serialization, the returned value equals the String form of the
     message possibly after object rendering. 

     @since 1.1 */
  public
  Object getMessage() {
    if(message != null) {
      return message;
    } else {
      return getRenderedMessage();
    }
  }

  public
  String getNDC() {
    if(ndcLookupRequired) {
      ndcLookupRequired = false;
      ndc = NDC.get();
    }
    return ndc; 
  }

  public
  String getRenderedMessage() {
     if(renderedMessage == null && message != null) {
       if(message instanceof String) 
	 renderedMessage = (String) message;
       else {
	 renderedMessage=
            category.getHierarchy().getRendererMap().findAndRender(message);
       }
     }
     return renderedMessage;
  }  

  /**
     Returns the time when the application started, in milliseconds
     elapsed since 01.01.1970.  */
  public
  static 
  long getStartTime() {
    return startTime;
  }

  public
  String getThreadName() {
    if(threadName == null)
      threadName = (Thread.currentThread()).getName();
    return threadName;
  }

  /**
     Returns the throwable information contained within this
     event. May be <code>null</code> if there is no such information.

     <p>Note that the {@link Throwable} object contained within a
     {@link ThrowableInformation} does not survive serialization.

     @since 1.1 */
  public
  ThrowableInformation getThrowableInformation() {
    return throwableInfo;
  }

  /**
     Return this event's throwable's string[] representaion.
  */
  public 
  String[] getThrowableStrRep() {

    if(throwableInfo ==  null)
      return null;
    else 
      return throwableInfo.getThrowableStrRep();
  }
	

  private 
  void readPriority(ObjectInputStream ois) 
                      throws java.io.IOException, ClassNotFoundException {

    int p = ois.readInt();
    try {
      String className = (String) ois.readObject();      
      if(className == null) {
	priority = Priority.toPriority(p);
      } else {
	Method m = (Method) methodCache.get(className);	
	if(m == null) {
	  Class clazz = Class.forName(className);
	  m = clazz.getDeclaredMethod(TO_PRIORITY, TO_PRIORITY_PARAMS);
	  methodCache.put(className, m);
	}      
	PARAM_ARRAY[0] = new Integer(p);
	priority = (Priority) m.invoke(null,  PARAM_ARRAY);
      }
    } catch(Exception e) {
	LogLog.warn(""Priority deserialization failed, reverting to default."", e);
	priority = Priority.toPriority(p);
    }
  }

  private void readObject(ObjectInputStream ois)
                        throws java.io.IOException, ClassNotFoundException {
    ois.defaultReadObject();    
    readPriority(ois);

    // Make sure that no location info is available to Layouts
    if(locationInfo == null)
      locationInfo = new LocationInfo(null, null);
  }

  private
  void writeObject(ObjectOutputStream oos) throws java.io.IOException {
    // Aside from returning the current thread name the wgetThreadName
    // method sets the threadName variable.
    this.getThreadName();    

    // This sets the renders the message in case it wasn't up to now.
    this.getRenderedMessage();

    // This call has a side effect of setting this.ndc and
    // setting ndcLookupRequired to false if not already false.
    this.getNDC();

    // This sets the throwable sting representation of the event throwable.
    this.getThrowableStrRep();

    oos.defaultWriteObject();
    
    // serialize this event's priority
    writePriority(oos);
  }

  private 
  void writePriority(ObjectOutputStream oos) throws java.io.IOException {

    oos.writeInt(priority.toInt());

    Class clazz = priority.getClass();
    if(clazz == Priority.class) {
      oos.writeObject(null);
    } else {
      // writing directly the Class object would be nicer, except that
      // serialized a Class object can not be read back by JDK
      // 1.1.x. We have to resort to this hack instead.
      oos.writeObject(clazz.getName());
    }
  }

}
"
org/apache/log4j/helpers/Loader.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.helpers;

import java.net.URL;
//import java.awt.Image;
//import java.awt.Toolkit;

/**
   Load resources (or images) from various sources.
 
  @author Sven Reimers
  @author Ceki G&uuml;lc&uuml;
 */

public class Loader  { 

  static String TSTR = ""Caught Exception while in Loader.getResource. This may be innocuous."";
  
  /**
     This method will search for <code>resource</code> in different
     places. The rearch order is as follows:

     <ol>

     <p><li>Search for <code>fully/qualified/clazz/name/resource</code>
     with the {@link ClassLoader} that loaded <code>clazz</code>.

     <p><li>Search for <code>fully/qualified/clazz/name/resource</code>
     with the <code>null</code> (bootstrap) class loader.

     <p><li>Search for <code>resource</code> with the class loader
     that loaded <code>clazz</code>. 

     <pi><li>Try one last time with
     <code>ClassLoader.getSystemResource(resource)</code> 
     </ol>
     
     
  */
  static 
  public
  URL getResource(String resource, Class clazz) {
    
    URL url = null;


    // Is it under CLAZZ/resource somewhere in the classpath?    
    // where CLAZZ is the fully qualified name of clazz where dots have been
    // changed to directory separators
    LogLog.debug(""Trying to find [""+resource+""] using Class.getResource()."");
    
    
    
    try {
      url = clazz.getResource(resource);
      if(url != null) 
	return url;
    } catch (Throwable t) {
      LogLog.warn(TSTR,t);
    }
    
    
    // attempt to get the resource under CLAZZ/resource from the
    // system class path. The system class loader should not throw
    // InvalidJarIndexExceptions
    String fullyQualified = resolveName(resource, clazz);
    LogLog.debug(""Trying to find [""+fullyQualified+
		 ""] using ClassLoader.getSystemResource()."");
    url = ClassLoader.getSystemResource(fullyQualified);
    if(url != null) 
      return url;
    
    // Let the class loader of clazz and parents (by the delagation
    // property) seearch for resource
    ClassLoader loader = clazz.getClassLoader();
    if(loader != null) {
      try {
	LogLog.debug(""Trying to find [""+resource+""] using ""+loader
		     +"" class loader."");
	url = loader.getResource(resource); 
	if(url != null) 
	  return url;
      } catch(Throwable t) {
	LogLog.warn(TSTR, t);
      }
    }
    
    
    // Attempt to get the resource from the class path. It may be the
    // case that clazz was loaded by the Extentsion class loader which
    // the parent of the system class loader. Hence the code below.
    LogLog.debug(""Trying to find [""+resource+""] using ClassLoader.getSystemResource()."");
    url = ClassLoader.getSystemResource(resource);
    return url;

  }

  /**
     Add the fully qualified name of a class before resource (replace . with /).
   */
  static
  String resolveName(String resource, Class clazz) {
    String fqcn = clazz.getName();
    int index = fqcn.lastIndexOf('.');
    if (index != -1) {
      fqcn = fqcn.substring(0, index).replace('.', '/');
      resource = fqcn+""/""+resource;
    }
    return resource;
  }


  //public static Image getGIF_Image ( String path ) {
  //  Image img = null;
  //  try {
  //	URL url = ClassLoader.getSystemResource(path);
  //	System.out.println(url);
  //	img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
  //  }
  //  catch (Exception e) {
  //	System.out.println(""Exception occured: "" + e.getMessage() + 
  //			   "" - "" + e );
  //	      
  //  }
  //  return (img);
  //}
  //
  //public static Image getGIF_Image ( URL url ) {
  //  Image img = null;
  //  try {
  //	System.out.println(url);
  //	img = (Image) (Toolkit.getDefaultToolkit()).getImage(url);
  //  } catch (Exception e) {
  //	System.out.println(""Exception occured: "" + e.getMessage() + 
  //			   "" - "" + e );
  //	      
  //  }
  //  return (img);
  //}
  //
  //public static URL getHTML_Page ( String path ) {
  //  URL url = null;
  //  return (url = ClassLoader.getSystemResource(path));
  //  }    
}
"
org/apache/log4j/config/PropertyPrinter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */

package org.apache.log4j.config;

import java.io.*;
import java.util.*;
import org.apache.log4j.*;

/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on a {@link PrintWriter}.
   
   @author  Anders Kristensen
 */
public class PropertyPrinter implements PropertyGetter.PropertyCallback {
  protected int numAppenders = 0;
  protected Hashtable appenderNames = new Hashtable();
  protected Hashtable layoutNames   = new Hashtable();
  protected PrintWriter out;
  protected boolean doCapitalize;
  
  public
  PropertyPrinter(PrintWriter out) {
    this(out, false);
  }
  
  public
  PropertyPrinter(PrintWriter out, boolean doCapitalize) {
    this.out = out;
    this.doCapitalize = doCapitalize;
    
    print(out);
    out.flush();
  }
  
  protected
  String genAppName() {
    return ""A"" + numAppenders++;
  }
  
  /**
     Returns true if the specified appender name is considered to have
     been generated, i.e. if it is of the form A[0-9]+.
  */
  protected
  boolean isGenAppName(String name) {
    if (name.length() < 2 || name.charAt(0) != 'A') return false;
    
    for (int i = 0; i < name.length(); i++) {
      if (name.charAt(i) < '0' || name.charAt(i) > '9') return false;
    }
    return true;
  }
  
  /**
   * Prints the configuration of the default log4j hierarchy as a Java
   * properties file on the specified Writer.
   * 
   * <p>N.B. print() can be invoked only once!
   */
  public
  void print(PrintWriter out) {
    printOptions(out, Category.getRoot());
    
    Enumeration cats = Category.getCurrentCategories();
    while (cats.hasMoreElements()) {
      printOptions(out, (Category) cats.nextElement());
    }
  }
  
  protected
  void printOptions(PrintWriter out, Category cat) {
    Enumeration appenders = cat.getAllAppenders();
    Priority prio = cat.getPriority();
    String appenderString = (prio == null ? """" : prio.toString());
    
    while (appenders.hasMoreElements()) {
      Appender app = (Appender) appenders.nextElement();
      String name;
      
      if ((name = (String) appenderNames.get(app)) == null) {
      
        // first assign name to the appender
        if ((name = app.getName()) == null || isGenAppName(name)) {
            name = genAppName();
        }
        appenderNames.put(app, name);
        
        printOptions(out, app, ""log4j.appender.""+name);
        if (app.getLayout() != null) {
          printOptions(out, app.getLayout(), ""log4j.appender.""+name+"".layout"");
        }
      }
      appenderString += "", "" + name;
    }
    String catKey = (cat == Category.getRoot())
        ? ""log4j.rootCategory""
        : ""log4j.category."" + cat.getName();
    if (appenderString != """") {
      out.println(catKey + ""="" + appenderString);
    }
  }
  
  protected
  void printOptions(PrintWriter out, Object obj, String fullname) {
    out.println(fullname + ""="" + obj.getClass().getName());
    PropertyGetter.getProperties(obj, this, fullname + ""."");
  }
  
  public void foundProperty(Object obj, String prefix, String name, Object value) {
    // XXX: Properties encode value.toString()
    if (obj instanceof Appender && ""name"".equals(name)) {
      return;
    }
    if (doCapitalize) {
      name = capitalize(name);
    }
    out.println(prefix + name + ""="" + value.toString());
  }
  
  public static String capitalize(String name) {
    if (Character.isLowerCase(name.charAt(0))) {
      if (name.length() == 1 || Character.isLowerCase(name.charAt(1))) {
        StringBuffer newname = new StringBuffer(name);
        newname.setCharAt(0, Character.toUpperCase(name.charAt(0)));
        return newname.toString();
      }
    }
    return name;
  }
  
  // for testing
  public static void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out));
  }
}"
org/apache/log4j/test/SpacePad.java,false,"package org.apache.log4j.test;

public class SpacePad {

  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32

  static public void main(String[] args) {
    StringBuffer sbuf = new StringBuffer();

    for(int i = 0; i < 35; i++) {
      sbuf.setLength(0);
      sbuf.append(""\"""");
      spacePad(sbuf, i);
      sbuf.append(""\"""");
      System.out.println(sbuf.toString());
    }
    
    sbuf.setLength(0);
    sbuf.append(""\"""");
    spacePad(sbuf, 67);
    sbuf.append(""\"""");
    System.out.println(sbuf.toString());
    
  }
  static
  public
  void spacePad(StringBuffer sbuf, int length) {
    //LogLog.debug(""Padding with "" + length + "" spaces."");
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org/apache/log4j/or/RendererMap.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.or;

import java.util.Hashtable;

/**
   Map class objects to an {@link ObjectRenderer}.

   @author Ceki G&uuml;lc&uuml;
   @since version 1.0 */
public class RendererMap {

  Hashtable map;

  static ObjectRenderer defaultRenderer = new DefaultRenderer();

  public
  RendererMap() {
    map = new Hashtable();
  }

  /**
     Find the appropriate renderer for the class type of the
     <code>o</code> parameter. This is accomplished by calling the
     {@link #get(Class)} method. Once a renderer is found, it is
     applied on the object <code>o</code> and the result is returned
     as a {@link String}. */
  public
  String findAndRender(Object o) {
    if(o == null)
      return null;
    else 
      return get(o.getClass()).doRender(o);
  }


  /**
     Syntactic sugar method that calls {@link #get(Class)} with the
     class of the object parameter. */
  public 
  ObjectRenderer get(Object o) {
    if(o == null) 
      return null;
    else
      return get(o.getClass());
  }
  

  /**
     Search the parents of <code>clazz</code> for a renderer. The
     renderer closest in the hierarchy will be returned. If no
     renderers could be found, then the default renderer is returned.          

     <p>The search first looks for a renderer configured for
     <code>clazz</code>. If a renderer could not be found, then the
     search continues by looking at all the interfaces implemented by
     <code>clazz</code> including the super-interfaces of each
     interface.  If a renderer cannot be found, then the search looks
     for a renderer defined for the parent (superclass) of
     <code>clazz</code>. If that fails, then all the interfaces
     implemented by the parent of <code>clazz</code> are searched and
     so on.

     <p>For example, if A0, A1, A2 are classes and X0, X1, X2, Y0, Y1
     are interfaces where A2 extends A1 which in turn extends A0 and
     similarly X2 extends X1 which extends X0 and Y1 extends Y0. Let
     us also assume that A1 implements the Y0 interface and that A2
     implements the X2 interface.

     <p>The table below shows the results returned by the
     <code>get(A2.class)</code> method depending on the renderers
     added to the map.

     <p><table border=""1"">
     <tr><th>Added renderers</th><th>Value returned by <code>get(A2.class)</code></th>

     <tr><td><code>A0Renderer</code>
         <td align=""center""><code>A0Renderer</code>  

     <tr><td><code>A0Renderer, A1Renderer</code>
         <td align=""center""><code>A1Renderer</code>  

     <tr><td><code>X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>  

     <tr><td><code>A1Renderer, X0Renderer</code>
         <td align=""center""><code>X0Renderer</code>  

     </table>
     
     <p>This search algorithm is not the most natural, although it is
     particularly easy to implement. Future log4j versions
     <em>may</em> implement a more intuitive search
     algorithm. However, the present algorithm should be acceptable in
     the vast majority of circumstances.

 */
  public
  ObjectRenderer get(Class clazz) {
    //System.out.println(""\nget: ""+clazz);    
    ObjectRenderer r = null;
    for(Class c = clazz; c != null; c = c.getSuperclass()) {
      //System.out.println(""Searching for class: ""+c);
      r = (ObjectRenderer) map.get(c);
      if(r != null) {
	return r;
      }      
      r = searchInterfaces(c);
      if(r != null)
	return r;
    }
    return defaultRenderer;
  }  
  
  ObjectRenderer searchInterfaces(Class c) {
    //System.out.println(""Searching interfaces of class: ""+c);
    
    ObjectRenderer r = (ObjectRenderer) map.get(c);
    if(r != null) {
      return r;
    } else {
      Class[] ia = c.getInterfaces();
      for(int i = 0; i < ia.length; i++) {
	r = searchInterfaces(ia[i]);
	if(r != null)
	  return r; 
      }
    }
    return null;
  }


  public
  ObjectRenderer getDefaultRenderer() {
    return defaultRenderer;
  }


  public
  void clear() {
    map.clear();
  }

  /**
     Register an {@link ObjectRenderer} for <code>clazz</code>.     
  */
  public
  void put(Class clazz, ObjectRenderer or) {
    map.put(clazz, or);
  }
}
"
org/apache/log4j/test/SysoutConfigurator.java,true,"package org.apache.log4j.test;

import java.util.Properties;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.ConsoleAppender;

/**
 * This configurator simply always adds a FileAppender writing to
 * System.out to the root Category and ignores whatever is in the
 * properties file.
 */
public class SysoutConfigurator implements Configurator {
  public
  void
  doConfigure(java.net.URL url, Hierarchy hierarchy) {
    Category.getRoot().addAppender(
        new ConsoleAppender(
            new SimpleLayout(), ConsoleAppender.SYSTEM_OUT));
  }
}
"
org/apache/log4j/helpers/CyclicBuffer.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
     
package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;

/**

   CyclicBuffer is used by other appenders to hold {@link LoggingEvent
   LoggingEvents} for immediate or differed display.
   
   <p>This buffer gives read access to any element in the buffer not
   just the first or last element.

   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0

 */
public class CyclicBuffer {
  
  LoggingEvent[] ea;
  int first; 
  int last; 
  int numElems;
  int maxSize;

  /**
     Instantiate a new CyclicBuffer of at most <code>maxSize</code> events.

     The <code>maxSize</code> argument must a positive integer.

     @param maxSize The maximum number of elements in the buffer.
  */
  public CyclicBuffer(int maxSize) throws IllegalArgumentException {
    if(maxSize < 1) {
      throw new IllegalArgumentException(""The maxSize argument (""+maxSize+
			    "") is not a positive integer."");
    }
    this.maxSize = maxSize;
    ea = new LoggingEvent[maxSize];
    first = 0;
    last = 0;
    numElems = 0;
  }
    
  /**
     Add an <code>event</code> as the last event in the buffer.

   */
  public
  void add(LoggingEvent event) {    
    ea[last] = event;    
    if(++last == maxSize)
      last = 0;

    if(numElems < maxSize)
      numElems++;
    else if(++first == maxSize)
      first = 0;
  }


  /**
     Get the <i>i</i>th oldest event currently in the buffer. If
     <em>i</em> is outside the range 0 to the number of elements
     currently in the buffer, then <code>null</code> is returned.


  */
  public
  LoggingEvent get(int i) {
    if(i < 0 || i >= numElems)
      return null;

    return ea[(first + i) % maxSize];
  }

  public 
  int getMaxSize() {
    return maxSize;
  }

  /**
     Get the oldest (first) element in the buffer. The oldest element
     is removed from the buffer.
  */
  public
  LoggingEvent get() {
    LoggingEvent r = null;
    if(numElems > 0) {
      numElems--;
      r = ea[first];
      ea[first] = null;
      if(++first == maxSize)
	first = 0;
    } 
    return r;
  }
  
  /**
     Get the number of elements in the buffer. This number is
     guaranteed to be in the range 0 to <code>maxSize</code>
     (inclusive).
  */
  public
  int length() {
    return numElems;
  } 

  /**
     Resize the cyclic buffer to <code>newSize</code>.

     @throws IllegalArgumentException if <code>newSize</code> is negative.
   */
  public 
  void resize(int newSize) {
    if(newSize < 0) {
      throw new IllegalArgumentException(""Negative array size [""+newSize+
					 ""] not allowed."");
    }
    if(newSize == numElems)
      return; // nothing to do
    
    LoggingEvent[] temp = new  LoggingEvent[newSize];

    int loopLen = newSize < numElems ? newSize : numElems;
    
    for(int i = 0; i < loopLen; i++) {
      temp[i] = ea[first];
      ea[first] = null;
      if(++first == numElems) 
	first = 0;
    }
    ea = temp;
    first = 0;
    numElems = loopLen;
    maxSize = newSize;
    if (loopLen == newSize) {
      last = 0;
    } else {
      last = loopLen;
    }
  }
}
"
org/apache/log4j/DefaultCategoryFactory.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import org.apache.log4j.spi.CategoryFactory;

class DefaultCategoryFactory implements CategoryFactory {
    
  DefaultCategoryFactory() {
  }    
    
  public
  Category makeNewCategoryInstance(String name) {
    return new Category(name);
  }    
}
"
org/apache/log4j/test/StressAsyncAppender.java,false,"//  Copyright 2000 Ceki Gulcu.  All Rights Reserved.
//  See the LICENCE file for the terms of distribution.

package org.apache.log4j.test;


import org.apache.log4j.Category;
import org.apache.log4j.FileAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;


import java.util.Random;
import java.util.Stack;

/**
   Stress test {@link AsyncAppender}.
   
 */
public class StressAsyncAppender extends Thread {

  static Category root = Category.getRoot();  

  static Random random = new Random(101);

  static final int LOOP_LENGTH = 24;
  static final int BRANCHING_FACTOR = 4;
  
  static int maxThreads;  
  static long msgCounter = 0;
  static int threadCounter = 0;  

  static double LOG_2 = Math.log(2);

  static Object lock = new Object();

  
  public 
  static 
  void main(String args[]) {
    if(args.length != 1) {
      usage();
    }

    DOMConfigurator.configure(""xml/stressAsyncAppender.xml"");

    try {
      maxThreads =  Integer.parseInt(args[0]);
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      usage();
    }
    
    while(true) {
      synchronized(lock) {
	// Adding 1 to ensure that at least 1 child is created. 	
	createChildren(randomInt(BRANCHING_FACTOR) + 1);

	// wait until all threads are finished
	try {
	  root.debug(""About to wait for notification."");
	  lock.wait();
	  root.debug(""Got a notification."");
	}
	catch(InterruptedException e) {
	  root.warn(""Unpextected InterruptedException received."", e);
	}
      }
    }
  }


  static
  void usage() {
    System.err.println(""Usage: java ""+ StressAsyncAppender.class.getName() +
			"" MAX_THREADS"");
    System.exit(1);
  }


  public
  StressAsyncAppender() {
  }

  public
  void run() {
    int loopLength = StressAsyncAppender.randomInt(LOOP_LENGTH);
    root.debug(""In run loop, loopLength = ""+loopLength);

    // half of the way, create new childres
    int createIndex = loopLength/2;
      
    for(int i = 0; i <= loopLength; i++) {

      if(i == createIndex)
	createChildren(randomInt(BRANCHING_FACTOR));
      
      synchronized(lock) {      
	root.debug(""Message number "" + msgCounter++);	
      }
      //delay(1+randomInt(4)*100);
    }    

    synchronized(lock) {
      StressAsyncAppender.threadCounter--;
      root.debug(""Exiting run loop. "" + threadCounter);
      if(StressAsyncAppender.threadCounter <= 0) {
	root.debug(""Notifying [main] thread."");
	lock.notify(); // wake up the main thread
      }
    }

  }

  public
  static
  void createChildren(int n) {
    if (n <= 0)
      return;

    synchronized(lock) {
      n = maxThreadsConstrained(n);    
      root.debug(""Creating "" + n+ "" child StressAsyncAppender threads."");
      for(int i = 0; i < n; i++) {
	root.debug(""New StressAsyncAppender, threadCounter = "" + (++threadCounter));
	new StressAsyncAppender().start();
      }
    }
  }

  static
  public
  int maxThreadsConstrained(int a) {
    int maxAllowed = StressAsyncAppender.maxThreads - 
                                                 StressAsyncAppender.threadCounter;
    return a <= maxAllowed ? a : maxAllowed;
  }

  /**
     Return a random value in the range
   */
  public
  static
  int randomInt(int n) {
    int r = random.nextInt() % n;
    return r >= 0 ? r : -r;
  }

  
  public
  void delay(long millis) {
    try {
      Thread.currentThread().sleep(millis);
    } catch(Exception e) {}
  }
  
}
"
org/apache/log4j/AsyncAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

// Contibutors:  Aaron Greenhouse <aarong@cs.cmu.edu>

package org.apache.log4j;

import org.apache.log4j.Category;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.BoundedFIFO;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import java.util.Enumeration;

/**
   The AsyncAppender lets users log events asynchronously. It uses a
   bounded buffer to store logging events.
   
   <p>The AsyncAppender will collect the events sent to it and then
   dispatch them to all the appenders that are attached to it. You can
   attach multiple appenders to an AsyncAppender.

   <p>The AsyncAppender uses a separate thread to serve the events in
   its bounded buffer. 

   <p>Refer to the results in {@link org.apache.log4j.performance.Logging}
   for the impact of using this appender.

   <p><b>Important note:</b> The <code>AsyncAppender</code> can only
   be script configured using the {@link
   org.apache.log4j.xml.DOMConfigurator}. Refer to example  configuration
   files <a href=""xml/examples/doc-files/sample4.xml"">sample4.xml</a>
   and <a href=""xml/examples/doc-files/sample5.xml"">sample5.xml</a>.


   
   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AsyncAppender extends AppenderSkeleton 
                                            implements AppenderAttachable {
  
  /**
     A string constant used in naming the option for setting the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  

     <p>Note that all option keys are case sensitive.

     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";


  /**
     A string constant used in naming the option for setting the size of the
     internal buffer where logging events are stored until they are written.
     Current value of this string constant is <b>BufferSize</b>.  

     <p>Note that all option keys are case sensitive.

     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";

  /** The default buffer size is set to 128 events. */
  public static final int DEFAULT_BUFFER_SIZE = 128;

  //static Category cat = Category.getInstance(AsyncAppender.class.getName());

  BoundedFIFO bf = new BoundedFIFO(DEFAULT_BUFFER_SIZE);

  AppenderAttachableImpl aai;
  Dispatcher dispatcher;
  boolean locationInfo = false;

  boolean interruptedWarningMessage = false;

  public
  AsyncAppender() {
    // Note: The dispatcher code assumes that the aai is set once and
    // for all!!!
    aai = new AppenderAttachableImpl();
    dispatcher = new Dispatcher(bf, this);
    dispatcher.start();
  }
  

  public 
  void addAppender(Appender newAppender) {
    synchronized(aai) {
      aai.addAppender(newAppender);
    }
  } 

  public
  void append(LoggingEvent event) {
    // Set the NDC and thread name for the calling thread as these
    // LoggingEvent fields were not set at event creation time.
    event.getNDC();
    event.getThreadName();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    synchronized(bf) {
      while(bf.isFull()) {
	try {
	  //LogLog.debug(""Waiting for free space in buffer, ""+bf.length());
	  bf.wait();
	} catch(InterruptedException e) {
	  if(!interruptedWarningMessage) {
	    interruptedWarningMessage = true;
	    LogLog.warn(""AsyncAppender interrupted."", e);
	  } else {
	    LogLog.warn(""AsyncAppender interrupted again."");
	  }
	}
      }
 
      //cat.debug(""About to put new event in buffer."");      
      bf.put(event);
      if(bf.wasEmpty()) {
	//cat.debug(""Notifying dispatcher to process events."");
	bf.notify();
      }
    }
  }

  /**
     Close this <code>AsyncAppender</code> by interrupting the
     dispatcher thread which will process all pending events before
     exiting. 
  */
  public 
  void close() {
    synchronized(this) {
      if(closed) // avoid multiple close, otherwise one gets NullPointerException
	return; 
      closed = true;
    }
    
    // The following cannot be synchronized on ""this"" because the
    // dispatcher synchronizes with ""this"" in its while loop. If we
    // did synhcronize we would systematically get deadlocks when
    // close was called.
    dispatcher.close();
    try {
      dispatcher.join();
    } catch(InterruptedException e) {
      LogLog.error(""Got an InterruptedException while waiting for the ""+
		   ""dispatcher to finish."", e);
    }
    dispatcher = null;
    bf = null;
  }

  public
  Enumeration getAllAppenders() {
    synchronized(aai) {
      return aai.getAllAppenders();
    }
  }

  public
  Appender getAppender(String name) {
    synchronized(aai) {
      return aai.getAppender(name);
    }
  }

  /**
     Returns the current value of the <b>LocationInfo</b> option.
  */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  
  /**
     The <code>AsyncAppender</code> does not require a layout. Hence,
     this method always returns <code>false</code>. */
  public 
  boolean requiresLayout() {
    return false;
  }

  public
  void removeAllAppenders() {
    synchronized(aai) {
      aai.removeAllAppenders();
    }
  }
  

  public
  void removeAppender(Appender appender) {
    synchronized(aai) {
      aai.removeAppender(appender);
    }
  }

  public
  void removeAppender(String name) {
    synchronized(aai) {
      aai.removeAppender(name);
    }
  }

  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the event that will be ultimately logged will likely to
     contain the wrong location information (if present in the log
     format).

     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  
  
  /**
     The <b>BufferSize</b> option takes a non-negative integer
     value.  This integer value determines the maximum size of the
     bounded buffer. Increasing the size of the buffer is always
     safe. However, if an existing buffer holds unwritten elements,
     then <em>decreasing the buffer size will result in event
     loss.</em> Nevertheless, while script configuring the
     AsyncAppender, it is safe to set a buffer size smaller than the
     {@link #DEFAULT_BUFFER_SIZE default buffer size} because
     configurators guarantee that an appender cannot be used before
     being completely configured. 
   */
  public
  void setBufferSize(int size) {
    bf.resize(size);
  }
  
  /**
     Returns the current value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bf.getMaxSize();
  }

 /**
     Returns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.  
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {LOCATION_INFO_OPTION, BUFFER_SIZE_OPTION});
  }

 /**
     Set AsyncAppender specific options:

     <p>On top of the options of the super class {@link
     AppenderSkeleton}, the only recognized options are
     <b>BufferSize</b> and <b>LocationInfo</b>.
     
     <p> The <b>BufferSize</b> option takes a non-negative integer
     value.  This integer value determines the maximum size of the
     bounded buffer. Increasing the size of the buffer is always
     safe. However, if an existing buffer holds unwritten elements,
     then <em>decreasing the buffer size will result in event
     loss.</em> Nevertheless, while script configuring the
     AsyncAppender, it is safe to set a buffer size smaller than the
     {@link #DEFAULT_BUFFER_SIZE default buffer size} because
     configurators guarantee that an appender cannot be used before
     being completely configured. 

     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the event that will be ultimately logged will likely to
     contain the wrong location information (if present in the log
     format).

     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.

     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
 */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);

    if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    else if (option.equals(BUFFER_SIZE_OPTION)) {
      int newSize = OptionConverter.toInt(value, DEFAULT_BUFFER_SIZE);
      bf.resize(newSize);
    }
  }
  
  /*
  public
  String getOption(String option) {
    if (option.equals(LOCATION_INFO_OPTION)) {
      return locationInfo ? ""true"" : ""false"";
    } else if (option.equals(BUFFER_SIZE_OPTION)) {
      return Integer.toString(bf.getMaxSize());
    } else {
      return super.getOption(option);
    }
  }
  */
}
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// ----------------------------------------------------------------------------
class Dispatcher extends Thread {

  BoundedFIFO bf;
  AppenderAttachableImpl aai;
  boolean interrupted = false;
  AsyncAppender container;

  Dispatcher(BoundedFIFO bf, AsyncAppender container) {
    this.bf = bf;
    this.container = container;
    this.aai = container.aai;
    // set the dispatcher priority to lowest possible value
    this.setPriority(Thread.MIN_PRIORITY);
    this.setName(""Dispatcher-""+getName());
    // set the dispatcher priority to MIN_PRIORITY plus or minus 2
    // depending on the direction of MIN to MAX_PRIORITY.
    //+ (Thread.MAX_PRIORITY > Thread.MIN_PRIORITY ? 1 : -1)*2);

  }

  void close() {
    synchronized(bf) {
      interrupted = true;   
      // We have a waiting dispacther if and only if bf.length is
      // zero.  In that case, we need to give it a death kiss.
      if(bf.length() == 0) {
	bf.notify();
      }
    }
  }



  /**
     The dispatching strategy is to wait until there are events in the
     buffer to process. After having processed an event, we release
     the monitor (variable bf) so that new events can be placed in the
     buffer, instead of keeping the monitor and processing the remaining
     events in the buffer. 

    <p>Other approaches might yield better results.

  */
  public
  void run() {

    //Category cat = Category.getInstance(Dispatcher.class.getName());

    LoggingEvent event;
    
    while(true) {
      synchronized(bf) {
	if(bf.length() == 0) {
	  // Exit loop if interrupted but only if the the buffer is empty.
	  if(interrupted) { 
	    //cat.info(""Exiting."");
	    return;
	  }
	  try {
	    //LogLog.debug(""Waiting for new event to dispatch."");
	    bf.wait();
	  } catch(InterruptedException e) {
	    LogLog.error(""The dispathcer should not be interrupted."");
	    break;
	  }
	}
	event = bf.get();
	if(bf.wasFull()) {
	  //LogLog.debug(""Notifying AsyncAppender about freed space."");
	  bf.notify();
	}
      } // synchronized
  
      // The synchronization on parent is necessary to protect against
      // operations on the aai object of the parent
      synchronized(container.aai) {
	if(aai != null && event != null) {
	  aai.appendLoopOnAppenders(event);
	}
      }
    } // while
  }
}
"
org/apache/log4j/helpers/DateTimeDateFormat.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;

/**
   Formats a {@link Date} in the format ""dd MMM YYYY HH:mm:ss,SSS"" for example,
   ""06 Nov 1994 15:49:37,459"". 
   
   @author Ceki G&uuml;lc&uuml;
   @since 0.7.5
*/
public class DateTimeDateFormat extends AbsoluteTimeDateFormat {

  String[] shortMonths;

  public
  DateTimeDateFormat() {
    super();
    shortMonths = new DateFormatSymbols().getShortMonths();
  }
  
  public
  DateTimeDateFormat(TimeZone timeZone) {
    this();
    setCalendar(Calendar.getInstance(timeZone));
  }
  
  /**
     Appends to <code>sbuf</code> the date in the format ""dd MMM YYYY
     HH:mm:ss,SSS"" for example, ""06 Nov 1994 08:49:37,459"".

     @param sbuf the string buffer to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    calendar.setTime(date);      

    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);
    sbuf.append(' ');        
    sbuf.append(shortMonths[calendar.get(Calendar.MONTH)]);
    sbuf.append(' ');    

    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);
    sbuf.append(' ');

    return super.format(date, sbuf, fieldPosition);
  }

  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org/apache/log4j/net/test/Loop.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net.test;

import org.apache.log4j.*;
import org.apache.log4j.net.SocketAppender;

public class Loop {

  public static void main(String[] args) {
    
    
    Category root = Category.getRoot();
    Category cat = Category.getInstance(Loop.class.getName());

    if(args.length != 2) 
      usage(""Wrong number of arguments."");     

    String host = args[0];
    int port = 0;

    try {
      port = Integer.valueOf(args[1]).intValue();
    }
    catch (NumberFormatException e) {
        usage(""Argument ["" + args[1]  + ""] is not in proper int form."");
    }

    SocketAppender sa = new SocketAppender(host, port);
    Layout layout = new PatternLayout(""%5p [%t] %x %c - %m\n"");
    Appender so = new ConsoleAppender(layout, ""System.out"");
    root.addAppender(sa);
    root.addAppender(so);

    int i = 0;

    while(true) {
      NDC.push(""""+ (i++));
      cat.debug(""Debug message."");
      root.info(""Info message."");
      NDC.pop();
    }

  }

  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +Loop.class.getName() + "" host port"");
    System.exit(1);
  }
    

}
"
org/apache/log4j/or/ThreadGroupRenderer.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.or;

import org.apache.log4j.Layout;


/**
   Render {@link ThreadGroup} objects in a format similar to the
   information output by the {@link ThreadGroup#list} method.
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class ThreadGroupRenderer implements ObjectRenderer {

  public
  ThreadGroupRenderer() {
  }
  
  /**
     Render a {@link ThreadGroup} object similar to the way that the
     {@link ThreadGroup#list} method output information. 

     <p>The output of a simple program consisting of one
     <code>main</code> thread is:
     <pre>
     java.lang.ThreadGroup[name=main, maxpri=10]
         Thread=[main,5,false]
     </pre>
     
     <p>The boolean value in thread information is the value returned
     by {@link Thread#isDaemon}.
     
  */
  public
  String  doRender(Object o) {
    if(o instanceof ThreadGroup) {
      StringBuffer sbuf = new StringBuffer();
      ThreadGroup tg = (ThreadGroup) o;
      sbuf.append(""java.lang.ThreadGroup[name="");
      sbuf.append(tg.getName());
      sbuf.append("", maxpri="");
      sbuf.append(tg.getMaxPriority());
      sbuf.append(""]"");
      Thread[] t = new Thread[tg.activeCount()];
      tg.enumerate(t);
      for(int i = 0; i < t.length; i++) {
	sbuf.append(Layout.LINE_SEP);	
	sbuf.append(""   Thread=["");
	sbuf.append(t[i].getName());
	sbuf.append("","");
	sbuf.append(t[i].getPriority());
	sbuf.append("","");
	sbuf.append(t[i].isDaemon());
	sbuf.append(""]"");
      }
      return sbuf.toString();
    } else {
      // this is the best we can do
      return o.toString();
    }    
  }
}  
"
org/apache/log4j/net/test/SyslogMin.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */


package org.apache.log4j.net.test;

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;


public class SyslogMin {
  
  static Category CAT = Category.getInstance(SyslogMin.class.getName());
				     
  public 
  static 
  void main(String argv[]) {

      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test(""someHost"");
  }

  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + SyslogMin.class + "" configFile"");
    System.exit(1);
  }

  
  static
  void ProgramInit(String configFile) {
    int port = 0;
    PropertyConfigurator.configure(configFile);
  }

  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    CAT.debug( ""Message "" + i++);
    CAT.info( ""Message "" + i++);
    CAT.warn( ""Message "" + i++);
    CAT.error( ""Message "" + i++);
    CAT.log(Priority.FATAL, ""Message "" + i++);
    CAT.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org/apache/log4j/spi/ErrorCode.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;


/**
   This interface defines commonly encoutered error codes.

   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0
 */
public interface ErrorCode {

  public final int GENERIC_FAILURE = 0;
  public final int WRITE_FAILURE = 1;
  public final int FLUSH_FAILURE = 2;
  public final int CLOSE_FAILURE = 3;
  public final int FILE_OPEN_FAILURE = 4;
  public final int MISSING_LAYOUT = 5;
  public final int ADDRESS_PARSE_FAILURE = 6;
}
"
org/apache/log4j/helpers/RelativeTimeDateFormat.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.helpers;

import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;

/**
   Formats a {@link Date} by printing the number of milliseconds
   elapsed since the start of the application.  This is the fastest
   printing DateFormat in the package.
   
   @author Ceki G&uuml;lc&uuml;
   
   @since 0.7.5
*/
public class RelativeTimeDateFormat extends DateFormat {

  protected final long startTime;

  public
  RelativeTimeDateFormat() {
    this.startTime = System.currentTimeMillis();
  }
  
  /**
     Appends to <code>sbuf</code> the number of milliseconds elapsed
     since the start of the application. 
     
     @since 0.7.5
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {
    //System.err.println("":""+ date.getTime() + "" - "" + startTime);
    return sbuf.append((date.getTime() - startTime));
  }

  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org/apache/log4j/RollingFileAppenderBeanInfo.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

 

package org.apache.log4j;

import java.beans.*;
import org.apache.log4j.helpers.LogLog;
import java.lang.reflect.Method;

public class RollingFileAppenderBeanInfo extends SimpleBeanInfo {

  private PropertyDescriptor[] props;

  public
  RollingFileAppenderBeanInfo() {
    Class clazz = RollingFileAppender.class;
    try {
      // the magic is here
      BeanInfo bi = Introspector.getBeanInfo(clazz,
					     Introspector.IGNORE_ALL_BEANINFO);

      props = bi.getPropertyDescriptors();
      if(props != null) {
	for(int i = 0; i < props.length; i++) {
	  if(props[i].getName().equals(""maxFileSize"")) {
	    Method m = clazz.getMethod(""setMaxFileSize"", 
				       new Class[] {String.class});
	    props[i] = new PropertyDescriptor(""maxFileSize"", null, m);
	  }
	}
      }
      // flush the bean info because getPropertyDescriptors() will now return
      // different properties
      Introspector.flushFromCaches(RollingFileAppender.class);
    } catch(IntrospectionException e) {
      LogLog.error(""Could not inspect RollingFileAppender."", e);
    } catch(NoSuchMethodException e) {
      LogLog.error(""Could not find setter method for RollingFileAppender."", e);
    }
  }

  public
  PropertyDescriptor[] getPropertyDescriptors() {
    return props;
  }
}
"
org/apache/log4j/helpers/AbsoluteTimeDateFormat.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.helpers;

import java.util.Date;
import java.util.Calendar;
import java.util.TimeZone;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;

 

/**

   Formats a {@link Date} in the format ""HH:mm:ss,SSS"" for example,
   ""15:49:37,459"".
   
   @author Ceki G&uuml;lc&uuml;
   
   @since 0.7.5
*/
public class AbsoluteTimeDateFormat extends DateFormat {

  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.AbsoluteTimeDateFormat} in layouts. Current
     value is <b>ABSOLUTE</b>.  */
  public final static String ABS_TIME_DATE_FORMAT = ""ABSOLUTE"";

  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.DateTimeDateFormat} in layouts.  Current
     value is <b>DATE</b>.
  */
  public final static String DATE_AND_TIME_DATE_FORMAT = ""DATE"";

  /**
     String constant used to specify {@link
     org.apache.log4j.helpers.ISO8601DateFormat} in layouts. Current
     value is <b>ISO8601</b>.
  */
  public final static String ISO8601_DATE_FORMAT = ""ISO8601"";

  public
  AbsoluteTimeDateFormat() {
    setCalendar(Calendar.getInstance());
  }
  
  public
  AbsoluteTimeDateFormat(TimeZone timeZone) {
    setCalendar(Calendar.getInstance(timeZone));
  }
  
  /**
     Appends to <code>sbuf</code> the time in the format
     ""HH:mm:ss,SSS"" for example, ""15:49:37,459""

     @param date the date to format
     @param sbuf the string buffer to write to
     @param fieldPosition remains untouched
    */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    // We use a previously instantiated Date object to avoid the needless
    // creation of temporary objects. This saves a few micro-secs.
    calendar.setTime(date); 
    
    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    if(hour < 10) {
      sbuf.append('0');
    }
    sbuf.append(hour);
    sbuf.append(':');

    int mins = calendar.get(Calendar.MINUTE);
    if(mins < 10) {
      sbuf.append('0');
    }
    sbuf.append(mins);
    sbuf.append(':');
    
    int secs = calendar.get(Calendar.SECOND);
    if(secs < 10) {
      sbuf.append('0');
    }
    sbuf.append(secs);
    sbuf.append(',');
    
    int millis = calendar.get(Calendar.MILLISECOND);
    if(millis < 100) 
      sbuf.append('0');
    if(millis < 10) 
      sbuf.append('0');
    
    sbuf.append(millis);
    return sbuf;
  }

  /**
     This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(String s, ParsePosition pos) {
    return null;
  }  
}
"
org/apache/log4j/test/DelayedLoop.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;

/**
   This test program sits in a loop and logs things. Its logging is
   configured by a configuration file. Changes to this configuration
   file are monitored and when a change occurs, the config file is re-read.

   
   @author Ceki G&uuml;lc&uuml; */
public class DelayedLoop {

  static Category cat = Category.getInstance(DelayedLoop.class);
  static int loopLength;

  public 
  static 
  void main(String argv[]) {

    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");
    test();
  }


  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + DelayedLoop.class.getName() +
			""configFile"");
    System.exit(1);
  }

  
  static
  void init(String configFile) {
    if(configFile.endsWith(""xml"")) {
      DOMConfigurator.configureAndWatch(configFile, 3000);
    } else {
      PropertyConfigurator.configureAndWatch(configFile, 3000);
    }
  }

  static
  void test() {
    int i = 0;
    while(true) {
      cat.debug(""MSG ""+i++);
      try {
	Thread.currentThread().sleep(1000);
      } catch(Exception e) {}
    }
  }
}
"
org/apache/log4j/or/ObjectRenderer.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.or;

/**
   Implement this interface in order to render objects as strings.

   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public interface ObjectRenderer {

  /**
     Render the object passed as parameter as a String.
   */
  public
  String doRender(Object o);
}
"
org/apache/log4j/net/SimpleSocketServer.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;


/**
   A simple {@link SocketNode} based server.

   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SimpleSocketServer port configFile

     where <em>port</em> is a part number where the server listens and
     <em>configFile</em> is a configuration file fed to the {@link
     PropertyConfigurator}.
   </pre>

    @author  Ceki G&uuml;lc&uuml;
 
    @since 0.8.4 */

public class SimpleSocketServer  {

  static Category cat = Category.getInstance(SimpleSocketServer.class.getName());

  static int port;
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) 
      init(argv[0], argv[1]);
    else 
      usage(""Wrong number of arguments."");     
    
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	cat.info(""Connected to client at "" + socket.getInetAddress());
	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, 
				  Category.getDefaultHierarchy())).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SimpleSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org/apache/log4j/net/SocketNode.java,true,"//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.

//      Copyright 2000, Ceki Gulcu. All Rights Reserved.

//      See the LICENCE file for the terms of usage and distribution.


package org.apache.log4j.net;

import java.net.InetAddress;
import java.net.Socket;
import java.net.ServerSocket;
import java.io.InputStream;
import java.io.IOException;
import java.io.ObjectInputStream;


import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;

// Contributors:  Moses Hohman <mmhohman@rainbow.uchicago.edu>

/**
   Read {@link LoggingEvent} objects sent from a remote client using
   Sockets (TCP). These logging events are logged according to local
   policy, as if they were generated locally.

   <p>For example, the socket node might decide to log events to a
   local file and also resent them to a second socket node.
   
    @author  Ceki G&uuml;lc&uuml;
 
    @since 0.8.4
*/
public class SocketNode implements Runnable {

  Socket socket;
  Hierarchy hierarchy;
  ObjectInputStream ois;

  static Category cat = Category.getInstance(SocketNode.class.getName());

  public 
  SocketNode(Socket socket, Hierarchy hierarchy) {
    this.socket = socket;
    this.hierarchy = hierarchy;
    try {
      ois = new ObjectInputStream(socket.getInputStream());
    }
    catch(Exception e) {
      cat.error(""Could not open ObjectInputStream to ""+socket, e);
    }
  }

  //public
  //void finalize() {
  //System.err.println(""-------------------------Finalize called"");
  // System.err.flush();
  //}

  public void run() {
    LoggingEvent event;
    Category remoteCategory;

    try {
      while(true) {	
	event = (LoggingEvent) ois.readObject();	
	remoteCategory = hierarchy.getInstance(event.categoryName);
	event.category = remoteCategory;
	if(event.priority.isGreaterOrEqual(remoteCategory.getChainedPriority())) {
	  remoteCategory.callAppenders(event);	
	}
      }
    }
    catch(java.io.EOFException e) {
      cat.info(""Caught java.io.EOFException closing conneciton."");
    }
    catch(java.net.SocketException e) {
      cat.info(""Caught java.net.SocketException closing conneciton."");
    }
    catch(Exception e) {
      cat.error(""Unexpected exception. Closing conneciton."", e);
    }
    
    try {
      ois.close();
    }
    catch(Exception e) {
      cat.info(""Could not close connection."", e);	
    }  
  }
}
"
org/apache/log4j/performance/ListVsVector.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.performance;


import java.util.Vector;

/**

   Compares the performance of looping through a list versus a Vector.

   Chain looping is *20* times faster than vector access on JDK 1.1.7B on NT

*/
public class ListVsVector {

  static int RUN_LENGTH = 1000000;
  static Vector v = new Vector();
  static Chain head;
  static String tmp;

  static
  public 
  void main(String[] args) {

    v.addElement(""aaa"");
    v.addElement(""bbb"");
    v.addElement(""ccc"");
    v.addElement(""ddd"");
    v.addElement(""eee"");
    
    Chain c = new Chain(""aaa"");
    head = c;
    c.next = new Chain(""bbb""); c = c.next;
    c.next = new Chain(""ccc""); c = c.next;
    c.next = new Chain(""ddd""); c = c.next;
    c.next = new Chain(""eee"");
    double t;
    t = loopChain();
    System.out.println(""Looping thourgh the chain took "" + t);

    t = loopVector();
    System.out.println(""Looping thourgh the vector took "" + t);

  }

  static
  double loopChain() {
    long before = System.currentTimeMillis();
    Chain c;
    for(int i = 0; i < RUN_LENGTH; i++) {
      c = head;
      while(c != null) {
	tmp = c.s;
	c = c.next;
      }
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double loopVector() {
    long before = System.currentTimeMillis();
    int size = v.size();
    for(int i = 0; i < RUN_LENGTH; i++) {
      for(int j = 0; j < size; j++)
	tmp = (String) v.elementAt(j);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static class Chain {
    public String s;
    public Chain next;

    Chain(String s) {
      this.s = s;
    }
    
    void setNext(Chain c) {
      next = c;
    }
  }
}
"
org/apache/log4j/test/MultipleAppenders.java,false,"

package org.apache.log4j.test;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.Category;
import org.apache.log4j.Appender;
import java.util.Enumeration;
import java.util.Vector;

public class MultipleAppenders {

  public 
  static 
  void main(String argv[]) {

    // A1 and A2 should be added to root by reading the config file
    PropertyConfigurator.configure(argv[0]);

    Category root = Category.getRoot();

    Enumeration e1 = root.getAllAppenders();
    Vector v = new Vector(1);
    
    while(e1.hasMoreElements()) {
      Appender a = (Appender) e1.nextElement();
      v.addElement(a);
      String appenderName = a.getName();	
      if(a != root.getAppender(appenderName)) {
	System.out.println(appenderName + "" lookup failed. Exiting."");
	System.exit(1);
      }
      // attempt to add the existing appender
      root.addAppender(a);
    }

    // attempt to add a null appender
    root.addAppender(null);

    Enumeration e2 = root.getAllAppenders();

    for(int i = 0; i < v.size(); i++) {
      if(v.elementAt(i) != e2.nextElement()) {
      }
    }

    if(e2.hasMoreElements()){
      System.out.println(""Failure, e2 has remaining elements. Exiting."");
      System.exit(1);      
    }
    System.out.println(""OK"");
  }

  
}
"
org/apache/log4j/spi/CategoryFactory.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.Category;

/**
   
  Implement this interface to create new instances of Category or
  a sub-class of Category.

  <p>See {@link org.apache.log4j.examples.MyCategory} for an example.

  @author Ceki G&uuml;lc&uuml;
  @since version 0.8.5
   
 */
public interface CategoryFactory {

 
  public
  Category makeNewCategoryInstance(String name);

}
"
org/apache/log4j/helpers/PatternParser.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */
package org.apache.log4j.helpers;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import org.apache.log4j.Layout;
import org.apache.log4j.NDC;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

// Contributors:   Nelson Minar <(nelson@monkey.org>
//                 Igor E. Poteryaev <jah@mail.ru>  
//                 Reinhard Deschler <reinhard.deschler@web.de> 

/**
   Most of the work of the {@link org.apache.log4j.PatternLayout} class
   is delegated to the PatternParser class.

   <p>It is this class that parses conversion patterns and creates
   a chained list of {@link OptionConverter OptionConverters}.
   
   @author <a href=mailto:""cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen       

   @since 0.8.2
*/
public class PatternParser {

  private static final char ESCAPE_CHAR = '%';
  
  private static final int LITERAL_STATE = 0;
  private static final int CONVERTER_STATE = 1;
  private static final int MINUS_STATE = 2;
  private static final int DOT_STATE = 3;
  private static final int MIN_STATE = 4;
  private static final int MAX_STATE = 5;

  static final int FULL_LOCATION_CONVERTER = 1000;
  static final int METHOD_LOCATION_CONVERTER = 1001;
  static final int CLASS_LOCATION_CONVERTER = 1002;
  static final int LINE_LOCATION_CONVERTER = 1003;
  static final int FILE_LOCATION_CONVERTER = 1004;    

  static final int RELATIVE_TIME_CONVERTER = 2000;
  static final int THREAD_CONVERTER = 2001;
  static final int PRIORITY_CONVERTER = 2002;
  static final int NDC_CONVERTER = 2003;
  static final int MESSAGE_CONVERTER = 2004;

  int state;
  protected StringBuffer currentLiteral = new StringBuffer(32);
  protected int patternLength;
  protected int i;
  PatternConverter head;
  PatternConverter tail;
  protected FormattingInfo formattingInfo = new FormattingInfo();
  protected String pattern;

  public
  PatternParser(String pattern) {
    this.pattern = pattern;
    patternLength =  pattern.length();    
    state = LITERAL_STATE;
  }

  private
  void  addToList(PatternConverter pc) {
    if(head == null) {
      head = tail = pc;
    } else {
      tail.next = pc;
      tail = pc;    
    }
  }

  private
  String extractOption() {
    if((i < patternLength) && (pattern.charAt(i) == '{')) {
      int end = pattern.indexOf('}', i);	
      if (end > i) {
	String r = pattern.substring(i + 1, end);
	i = end+1;
	return r;
      }
    }
    return null;
  }


  /**
     The option is expected to be in decimal and positive. In case of
     error, zero is returned.  */
  private
  int extractPrecisionOption() {
    String opt = extractOption();
    int r = 0;
    if(opt != null) {
      try {
	r = Integer.parseInt(opt);
	if(r <= 0) {
	    LogLog.error(
	        ""Precision option ("" + opt + "") isn't a positive integer."");
	    r = 0;
	}
      }      
      catch (NumberFormatException e) {
	LogLog.error(""Category option \""""+opt+""\"" not a decimal integer."", e);
      }      
    }
    return r;    
  }
      
  public 
  PatternConverter parse() {
    char c;
    i = 0;
    while(i < patternLength) {
      c = pattern.charAt(i++);
      switch(state) {
      case LITERAL_STATE: 
        // In literal state, the last char is always a literal.
        if(i == patternLength) {
          currentLiteral.append(c);
          continue;
        }
        if(c == ESCAPE_CHAR) {      
          // peek at the next char. 
          switch(pattern.charAt(i)) {
          case ESCAPE_CHAR:
            currentLiteral.append(c);
            i++; // move pointer
            break;
          case 'n':
            currentLiteral.append(Layout.LINE_SEP);
            i++; // move pointer
            break;
          default:
            if(currentLiteral.length() != 0) {
              addToList(new LiteralPatternConverter(
                                                  currentLiteral.toString()));
              //LogLog.debug(""Parsed LITERAL converter: \"""" 
              //           +currentLiteral+""\""."");
            }
            currentLiteral.setLength(0); 
            currentLiteral.append(c); // append %
            state = CONVERTER_STATE;
            formattingInfo.reset();
          }
        }
        else {
          currentLiteral.append(c);
        }
        break;
      case CONVERTER_STATE:
	currentLiteral.append(c);
	switch(c) {
	case '-':
	  formattingInfo.leftAlign = true;
	  break;
	case '.':
	  state = DOT_STATE;
	  break;
	default:
	  if(c >= '0' && c <= '9') {
	    formattingInfo.min = c - '0';
	    state = MIN_STATE;
	  }
	  else 
	    finalizeConverter(c);	    
	} // switch
	break;
      case MIN_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.min = formattingInfo.min*10 + (c - '0');
	else if(c == '.')
	  state = DOT_STATE;
	else {
	  finalizeConverter(c);
	}
	break;
      case DOT_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') {
	  formattingInfo.max = c - '0';
	   state = MAX_STATE;
	}
	else {
	  LogLog.error(""Error occured in position ""+i
		     +"".\n Was expecting digit, instead got char \""""+c+""\""."");
	  state = LITERAL_STATE;
	}
	break;
      case MAX_STATE:
	currentLiteral.append(c);
	if(c >= '0' && c <= '9') 
	  formattingInfo.max = formattingInfo.max*10 + (c - '0');
	else {
	  finalizeConverter(c);
	  state = LITERAL_STATE;
	}
	break;
      } // switch
    } // while
    if(currentLiteral.length() != 0) {
      addToList(new LiteralPatternConverter(currentLiteral.toString()));
      //LogLog.debug(""Parsed LITERAL converter: \""""+currentLiteral+""\""."");
    }
    return head;
  }

  protected
  void finalizeConverter(char c) {
    PatternConverter pc = null;
    switch(c) {
    case 'c':
      pc = new CategoryPatternConverter(formattingInfo,
					extractPrecisionOption());	
      //LogLog.debug(""CATEGORY converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;     
    case 'C':
      pc = new ClassNamePatternConverter(formattingInfo,
					 extractPrecisionOption());
      //LogLog.debug(""CLASS_NAME converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'd':
      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;
      DateFormat df;
      String dOpt = extractOption();
      if(dOpt != null)
	dateFormatStr = dOpt;
      
      if(dateFormatStr.equalsIgnoreCase(
                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT)) 
	df = new  ISO8601DateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
	df = new AbsoluteTimeDateFormat();
      else if(dateFormatStr.equalsIgnoreCase(
                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
	df = new DateTimeDateFormat();
      else {
	try {
	  df = new SimpleDateFormat(dateFormatStr);
	}
	catch (IllegalArgumentException e) {
	  LogLog.error(""Could not instantiate SimpleDateFormat with "" +
		       dateFormatStr, e);
	  df = (DateFormat) OptionConverter.instantiateByClassName(
			           ""org.apache.log4j.helpers.ISO8601DateFormat"",
				   DateFormat.class, null);
	}	
      }
      pc = new DatePatternConverter(formattingInfo, df);
      //LogLog.debug(""DATE converter {""+dateFormatStr+""}."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'F':
      pc = new LocationPatternConverter(formattingInfo,
					FILE_LOCATION_CONVERTER);
      //LogLog.debug(""File name converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'l':
      pc = new LocationPatternConverter(formattingInfo,
					FULL_LOCATION_CONVERTER);
      //LogLog.debug(""Location converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'L':
      pc = new LocationPatternConverter(formattingInfo,
					LINE_LOCATION_CONVERTER);
      //LogLog.debug(""LINE NUMBER converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'm':
      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);
      //LogLog.debug(""MESSAGE converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'M':
      pc = new LocationPatternConverter(formattingInfo,
					METHOD_LOCATION_CONVERTER);
      //LogLog.debug(""METHOD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
    case 'p':
      pc = new BasicPatternConverter(formattingInfo, PRIORITY_CONVERTER);
      //LogLog.debug(""PRIORITY converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 'r':
      pc = new BasicPatternConverter(formattingInfo, 
					 RELATIVE_TIME_CONVERTER);
      //LogLog.debug(""RELATIVE time converter."");
      //formattingInfo.dump();
      currentLiteral.setLength(0);
      break;
    case 't':
      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);
      //LogLog.debug(""THREAD converter."");
      //formattingInfo.dump();      
      currentLiteral.setLength(0);
      break;
      /*case 'u':
      if(i < patternLength) {
	char cNext = pattern.charAt(i);
	if(cNext >= '0' && cNext <= '9') {
	  pc = new UserFieldPatternConverter(formattingInfo, cNext - '0');
	  LogLog.debug(""USER converter [""+cNext+""]."");
	  formattingInfo.dump();      
	  currentLiteral.setLength(0);
	  i++;
	}
	else 
	  LogLog.error(""Unexpected char"" +cNext+"" at position ""+i);
      }
      break;*/
    case 'x':
      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);
      //LogLog.debug(""NDC converter."");      
      currentLiteral.setLength(0);
      break;
    default:
      LogLog.error(""Unexpected char ["" +c+""] at position ""+i
		   +"" in conversion patterrn."");
      pc = new LiteralPatternConverter(currentLiteral.toString());
      currentLiteral.setLength(0);
    }
    
    addConverter(pc);
  }

  protected
  void addConverter(PatternConverter pc) {
    currentLiteral.setLength(0);
    // Add the pattern converter to the list.
    addToList(pc);
    // Next pattern is assumed to be a literal.
    state = LITERAL_STATE;
    // Reset formatting info
    formattingInfo.reset();
  }

  // ---------------------------------------------------------------------
  //                      PatternConverters
  // ---------------------------------------------------------------------
    
  private static class BasicPatternConverter extends PatternConverter {
    int type;
    
    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);     
      this.type = type;
    }

    public
    String convert(LoggingEvent event) {
      switch(type) {
      case RELATIVE_TIME_CONVERTER: 
	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));
      case THREAD_CONVERTER:
	return event.getThreadName();
      case PRIORITY_CONVERTER:
	return event.priority.toString();
      case NDC_CONVERTER:  
	return event.getNDC();
      case MESSAGE_CONVERTER: {
	return event.getRenderedMessage();
      }
      default: return null;
      }
    }
  }
  
  private static class LiteralPatternConverter extends PatternConverter {
    private String literal;
  
    LiteralPatternConverter(String value) {
      literal = value;
    }

    public
    final
    void format(StringBuffer sbuf, LoggingEvent event) {
      sbuf.append(literal);
    }
    
    public    
    String convert(LoggingEvent event) {
      return literal;
    }
  }

  private static class DatePatternConverter extends PatternConverter {
    private DateFormat df;
    private Date date;
    
    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
      super(formattingInfo);
      date = new Date();
      this.df = df;      
    }

    public
    String convert(LoggingEvent event) {
      date.setTime(event.timeStamp);
      String converted = null;
      try {
        converted = df.format(date);
      }
      catch (Exception ex) {
        LogLog.error(""Error occured while converting date."", ex);
      }
      return converted;
    }
  }

  private class LocationPatternConverter extends PatternConverter {
    int type;
    
    LocationPatternConverter(FormattingInfo formattingInfo, int type) {
      super(formattingInfo);
      this.type = type;
    }
    
    public
    String convert(LoggingEvent event) {
      LocationInfo locationInfo = event.getLocationInformation();
      switch(type) {
      case FULL_LOCATION_CONVERTER: 
	return locationInfo.fullInfo;
      case METHOD_LOCATION_CONVERTER: 
	return locationInfo.getMethodName();
      case LINE_LOCATION_CONVERTER: 
	return locationInfo.getLineNumber();
      case FILE_LOCATION_CONVERTER: 
	return locationInfo.getFileName();
      default: return null;
      }
    }
  }

  private static abstract class NamedPatternConverter extends PatternConverter {
    int precision;
    
    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo);
      this.precision =  precision;      
    }

    abstract
    String getFullyQualifiedName(LoggingEvent event);
    
    public
    String convert(LoggingEvent event) {
      String n = getFullyQualifiedName(event);
      if(precision <= 0)
	return n;
      else {
	int len = n.length();

	// We substract 1 from 'len' when assigning to 'end' to avoid out of
	// bounds exception in return r.substring(end+1, len). This can happen if
	// precision is 1 and the category name ends with a dot. 
	int end = len -1 ;
	for(int i = precision; i > 0; i--) {	  
	  end = n.lastIndexOf('.', end-1);
	  if(end == -1)
	    return n;
	}
	return n.substring(end+1, len);
      }      
    }
  }
  
  private class ClassNamePatternConverter extends NamedPatternConverter {

    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    
    String getFullyQualifiedName(LoggingEvent event) {
      return event.getLocationInformation().getClassName();
    }
  }
  
  private class CategoryPatternConverter extends NamedPatternConverter {

    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {
      super(formattingInfo, precision);
    }
    
    String getFullyQualifiedName(LoggingEvent event) {
      return event.categoryName;
    }
  }  
}

"
org/apache/log4j/net/SocketServer.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.io.IOException;
import java.io.File;
import java.util.Hashtable;

import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.spi.RootCategory;


/**
   A {@link SocketNode} based server that uses a different hierarchy
   for each client.

   <pre>
     <b>Usage:</b> java org.apache.log4j.net.SocketServer port configFile configDir

     where <b>port</b> is a part number where the server listens,
           <b>configFile</b> is a configuration file fed to the {@link PropertyConfigurator} and
           <b>configDir</b> is a path to a directory containing configuration files, possibly one for each client host.
     </pre>

     <p>The <code>configFile</code> is used to configure the log4j
     default hierarchy that the <code>SocketServer</code> will use to
     report on its actions.

     <p>When a new connection is opened from a previously unknown
     host, say <code>foo.bar.net</code>, then the
     <code>SocketServer</code> will search for a configuration file
     called <code>foo.bar.net.lcf</code> under the directory
     <code>configDir</code> that was passed as the third argument. If
     the file can be found, then a new hierarchy is instantiated and
     configured using the configuration file
     <code>foo.bar.net.lcf</code>. If and when the host
     <code>foo.bar.net</code> opens another connection to the server,
     then the previously configured hierarchy is used.

     <p>In case there is no file called <code>foo.bar.net.lcf</code>
     under the directory <code>configDir</code>, then the
     <em>generic</em> hierarchy is used. The generic hierarchy is
     configured using a configuration file called
     <code>generic.lcf</code> under the <code>configDir</code>
     directory. If no such file exists, then the generic hierarchy will be
     identical to the log4j default hierarchy.

     <p>Having different client hosts log using different hierarchies
     ensures the total independence of the clients with respect to
     their logging settings. 

     <p>Currently, the hierarchy that will be used for a given request
     depends on the IP address of the client host. For example, two
     separate applicatons running on the same host and logging to the
     same server will share the same hierarchy. This is perfectly safe
     except that it might not provide the right amount of independence
     between applications. The <code>SocketServer</code> is intended
     as an example to be enhanced in order to implement more elaborate
     policies.

     
    @author  Ceki G&uuml;lc&uuml;
 
    @since 1.0 */

public class SocketServer  {

  static String GENERIC = ""generic"";
  static String CONFIG_FILE_EXT = "".lcf"";

  static Category cat = Category.getInstance(SocketServer.class);  
  static SocketServer server;
  static int port;

  // key=inetAddress, value=hierarchy
  Hashtable hierarchyMap;
  Hierarchy genericHierarchy;
  File dir;

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 3) 
      init(argv[0], argv[1], argv[2]);
    else 
      usage(""Wrong number of arguments."");     
    
    try {
      cat.info(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      while(true) {
	cat.info(""Waiting to accept a new client."");
	Socket socket = serverSocket.accept();
	InetAddress inetAddress =  socket.getInetAddress();
	cat.info(""Connected to client at "" + inetAddress);

	Hierarchy h = (Hierarchy) server.hierarchyMap.get(inetAddress);
	if(h == null) {
	  h = server.configureHierarchy(inetAddress);
	} 

	cat.info(""Starting new socket node."");	
	new Thread(new SocketNode(socket, h)).start();
      }
    }
    catch(Exception e) {
      e.printStackTrace();
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +SocketServer.class.getName() + "" port configFile directory"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile, String dirStr) {
    try {
      port = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    
    PropertyConfigurator.configure(configFile);
    
    File dir = new File(dirStr);    
    if(!dir.isDirectory()) {
      usage(""[""+dirStr+""] is not a directory."");
    }
    server = new SocketServer(dir);
  }


  public
  SocketServer(File directory) {
    this.dir = directory;
    hierarchyMap = new Hashtable(11);
  }

  // This method assumes that there is no hiearchy for inetAddress
  // yet. It will configure one and return it.
  Hierarchy configureHierarchy(InetAddress inetAddress) {
    cat.info(""Locating configuration file for ""+inetAddress);
    // We assume that the toSting method of InetAddress returns is in
    // the format hostname/d1.d2.d3.d4 e.g. torino/192.168.1.1
    String s = inetAddress.toString();
    int i = s.indexOf(""/"");
    if(i == -1) {
      cat.warn(""Could not parse the inetAddress [""+inetAddress+
	       ""]. Using default hierarchy."");
      return genericHierarchy();
    } else {
      String key = s.substring(0, i);
      
      File configFile = new File(dir, key+CONFIG_FILE_EXT);
      if(configFile.exists()) {
	Hierarchy h = new Hierarchy(new RootCategory(Priority.DEBUG));
	hierarchyMap.put(inetAddress, h);
	
	new PropertyConfigurator().doConfigure(configFile.getAbsolutePath(), h);

	return h;	
      } else {
	cat.warn(""Could not find config file [""+configFile+""]."");
	return genericHierarchy();
      }
    }
  }

  Hierarchy genericHierarchy() {
    if(genericHierarchy == null) {
      File f = new File(dir, GENERIC+CONFIG_FILE_EXT);
      if(f.exists()) {
	genericHierarchy = new Hierarchy(new RootCategory(Priority.DEBUG));
	new PropertyConfigurator().doConfigure(f.getAbsolutePath(), genericHierarchy);
      } else {
	cat.warn(""Could not find config file [""+f+
		 ""]. Will use the default hierarchy."");
	genericHierarchy = Category.getDefaultHierarchy();
      }
    }
    return genericHierarchy;
  }
}
"
org/apache/log4j/config/PropertySetter.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.config;

import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.OptionHandler;

/**
   General purpose Object property setter. Clients repeatedly invokes
   {@link #setProperty setProperty(name,value)} in order to invoke setters
   on the Object specified in the constructor. This class relies on the
   JavaBeans {@link Introspector} to analyze the given Object Class using
   reflection.
   
   <p>Usage:
   <pre>
     PropertySetter ps = new PropertySetter(anObject);
     ps.set(""name"", ""Joe"");
     ps.set(""age"", ""32"");
     ps.set(""isMale"", ""true"");
   </pre>
   will cause the invocations anObject.setName(""Joe""), anObject.setAge(32),
   and setMale(true) if such methods exist with those signatures.
   Otherwise an {@link IntrospectionException} are thrown.
  
   @author Anders Kristensen
   @since 1.1
 */
public class PropertySetter {
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link #setProperty} one or more times.
    
    @param obj  the object for which to set properties
   */
  public
  PropertySetter(Object obj) {
    this.obj = obj;
  }
  
  /**
     Uses JavaBeans {@link Introspector} to computer setters of object to be
     configured.
   */
  protected
  void introspect() {
    try {
      BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
      props = bi.getPropertyDescriptors();
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect ""+obj+"": "" + ex.getMessage());
      props = new PropertyDescriptor[0];
    }
  }
  

  /**
     Set the properties of an object passed as a parameter in one
     go. The <code>properties</code> are parsed relative to a
     <code>prefix</code>.

     @param obj The object to configure.
     @param properties A java.util.Properties containing keys and values.
     @param prefix Only keys having the specified prefix will be set.
  */
  public
  static
  void setProperties(Object obj, Properties properties, String prefix) {
    new PropertySetter(obj).setProperties(properties, prefix);
  }
  

  /**
     Set the properites for the object that match the
     <code>prefix</code> passed as parameter.

     
   */
  public
  void setProperties(Properties properties, String prefix) {
    int len = prefix.length();
    
    for (Enumeration e = properties.keys(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      
      // handle only properties that start with the desired frefix.
      if (key.startsWith(prefix)) {

	
	// ignore key if it contains dots after the prefix
        if (key.indexOf('.', len + 1) > 0) {
	  //System.err.println(""----------Ignoring---[""+key
	  //	     +""], prefix=[""+prefix+""]."");
	  continue;
	}
        
	String value = OptionConverter.findAndSubst(key, properties);
        key = key.substring(len);
        if (""layout"".equals(key) && obj instanceof Appender) {
          continue;
        }        
        setProperty(key, value);
      }
    }
    activate();
  }
  
  /**
     Set a property on this PropertySetter's Object. If successful, this
     method will invoke a setter method on the underlying Object. The
     setter is the one for the specified property name and the value is
     determined partly from the setter argument type and partly from the
     value specified in the call to this method.
     
     <p>If the setter expects a String no conversion is necessary.
     If it expects an int, then an attempt is made to convert 'value'
     to an int using new Integer(value). If the setter expects a boolean,
     the conversion is by new Boolean(value).
     
     @param name    name of the property
     @param value   String value of the property
   */
  public
  void setProperty(String name, String value) {
    if (value == null) return;
    
    name = Introspector.decapitalize(name);
    PropertyDescriptor prop = getPropertyDescriptor(name);
    
    //LogLog.debug(""---------Key: ""+name+"", type=""+prop.getPropertyType());

    if (prop == null) {
      LogLog.warn(""No such property ["" + name + ""] in ""+
		  obj.getClass().getName()+""."" );
    } else {
      try {
        setProperty(prop, name, value);
      } catch (PropertySetterException ex) {
        LogLog.warn(""Failed to set property "" + name +
                    "" to value \"""" + value + ""\"". "" + ex.getMessage());
      }
    }
  }
  
  /** 
      Set the named property given a {@link PropertyDescriptor}.

      @param prop A PropertyDescriptor describing the characteristics
      of the property to set.
      @param name The named of the property to set.
      @param value The value of the property.      
   */
  public
  void setProperty(PropertyDescriptor prop, String name, String value)
    throws PropertySetterException {
    Method setter = prop.getWriteMethod();
    if (setter == null) {
      throw new PropertySetterException(""No setter for property"");
    }
    Class[] paramTypes = setter.getParameterTypes();
    if (paramTypes.length != 1) {
      throw new PropertySetterException(""#params for setter != 1"");
    }
    
    Object arg;
    try {
      arg = convertArg(value, paramTypes[0]);
    } catch (Throwable t) {
      throw new PropertySetterException(""Conversion to type [""+paramTypes[0]+
					""] failed. Reason: ""+t);
    }
    if (arg == null) {
      throw new PropertySetterException(
          ""Conversion to type [""+paramTypes[0]+""] failed."");
    }
    LogLog.debug(""Setting property ["" + name + ""] to ["" +arg+""]."");
    try {
      setter.invoke(obj, new Object[]  { arg });
    } catch (Exception ex) {
      throw new PropertySetterException(ex);
    }
  }
  

  /**
     Convert <code>val</code> a String parameter to an object of a
     given type.
  */
  protected
  Object convertArg(String val, Class type) {
    if(val == null)
      return null;

    String v = val.trim();
    if (String.class.isAssignableFrom(type)) {
      return val;
    } else if (Integer.TYPE.isAssignableFrom(type)) {
      return new Integer(v);
    } else if (Long.TYPE.isAssignableFrom(type)) {
      return new Long(v);
    } else if (Boolean.TYPE.isAssignableFrom(type)) {
      if (""true"".equalsIgnoreCase(v)) {
        return Boolean.TRUE;
      } else if (""false"".equalsIgnoreCase(v)) {
        return Boolean.FALSE;
      }
    } else if (Priority.class.isAssignableFrom(type)) {
      return OptionConverter.toPriority(v, null);
    }
    return null;
  }
  
  
  protected
  PropertyDescriptor getPropertyDescriptor(String name) {
    if (props == null) introspect();
    
    for (int i = 0; i < props.length; i++) {
      if (name.equals(props[i].getName())) {
	return props[i];
      }
    }
    return null;
  }
  
  public
  void activate() {
    if (obj instanceof OptionHandler) {
      ((OptionHandler) obj).activateOptions();
    }
  }
}
"
org/apache/log4j/helpers/ISO8601DateFormat.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.text.DateFormat;
import java.text.DateFormatSymbols;

// Contributors: Arndt Schoenewald <arndt@ibm23093i821.mc.schoenewald.de>

/**
   Formats a {@link Date} in the format ""YYYY-mm-dd HH:mm:ss,SSS"" for example
   ""1999-11-27 15:49:37,459"".

   <p>Refer to the <a
   href=http://www.cl.cam.ac.uk/~mgk25/iso-time.html>summary of the
   International Standard Date and Time Notation</a> for more
   information on this format.
   
   @author Ceki G&uuml;lc&uuml;
   
   @since 0.7.5
*/
public class ISO8601DateFormat extends AbsoluteTimeDateFormat {

  public
  ISO8601DateFormat() {
  }
      
  public
  ISO8601DateFormat(TimeZone timeZone) {
    super(timeZone);
  }
  
  /**
     Appends a date in the format ""YYYY-mm-dd HH:mm:ss,SSS""
     to <code>sbuf</code>. For example: ""1999-11-27 15:49:37,459"".

     @param sbuf the <code>StringBuffer</code> to write to
  */
  public
  StringBuffer format(Date date, StringBuffer sbuf,
		      FieldPosition fieldPosition) {

    calendar.setTime(date);      

    int year =  calendar.get(Calendar.YEAR);
    sbuf.append(year);

    String month;
    switch(calendar.get(Calendar.MONTH)) {
    case Calendar.JANUARY: month = ""-01-""; break;      
    case Calendar.FEBRUARY: month = ""-02-"";  break;     
    case Calendar.MARCH: month = ""-03-""; break;      
    case Calendar.APRIL: month = ""-04-"";  break;     
    case Calendar.MAY: month = ""-05-""; break;      
    case Calendar.JUNE: month = ""-06-"";  break;     
    case Calendar.JULY: month = ""-07-""; break;      
    case Calendar.AUGUST: month = ""-08-"";  break;     
    case Calendar.SEPTEMBER: month = ""-09-""; break;      
    case Calendar.OCTOBER: month = ""-10-""; break;      
    case Calendar.NOVEMBER: month = ""-11-"";  break;           
    case Calendar.DECEMBER: month = ""-12-"";  break;
    default: month = ""-NA-""; break;
    }
    sbuf.append(month);

    int day = calendar.get(Calendar.DAY_OF_MONTH);
    if(day < 10) 
      sbuf.append('0');
    sbuf.append(day);

    sbuf.append(' ');    
    return super.format(date, sbuf, fieldPosition);
  }

  /**
    This method does not do anything but return <code>null</code>.
   */
  public
  Date parse(java.lang.String s, ParsePosition pos) {
    return null;
  }  
}
"
org/apache/log4j/helpers/AppenderAttachableImpl.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;

import org.apache.log4j.Appender;
import java.util.Vector;
import java.util.Enumeration;

/**
   A straightforward implementation of the {@link AppenderAttachable}
   interface.

   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public class AppenderAttachableImpl implements AppenderAttachable {
  
  /** Array of appenders. */
  protected Vector  appenderList;

  /**
     Attach an appender. If the appender is already in the list in
     won't be added again.
  */
  public
  void addAppender(Appender newAppender) {
    // Null values for newAppender parameter are strictly forbidden.
    if(newAppender == null)
      return;
    
    if(appenderList == null) {
      appenderList = new Vector(1);
    }
    if(!appenderList.contains(newAppender))
      appenderList.addElement(newAppender);
  }

  /**
     Call the <code>doAppend</code> method on all attached appenders.  */
  public
  int appendLoopOnAppenders(LoggingEvent event) {
    int size = 0;
    Appender appender;

    if(appenderList != null) {
      size = appenderList.size();
      for(int i = 0; i < size; i++) {
	appender = (Appender) appenderList.elementAt(i);
	appender.doAppend(event);
      }
    }    
    return size;
  }


  /**
     Get all attached appenders as an Enumeration. If there are no
     attached appenders <code>null</code> is returned.
     
     @return Enumeration An enumeration of attached appenders.
   */
  public
  Enumeration getAllAppenders() {
    if(appenderList == null)
      return null;
    else 
      return appenderList.elements();    
  }

  /**
     Look for an attached appender named as <code>name</code>.

     <p>Return the appender with that name if in the list. Return null
     otherwise.  
     
   */
  public
  Appender getAppender(String name) {
     if(appenderList == null || name == null)
      return null;

     int size = appenderList.size();
     Appender appender;
     for(int i = 0; i < size; i++) {
       appender = (Appender) appenderList.elementAt(i);
       if(name.equals(appender.getName()))
	  return appender;
     }
     return null;    
  }

  /**
     Remove all previously attached appenders.
  */
  public
  void removeAllAppenders() {
    if(appenderList != null) {
      int len = appenderList.size();      
      for(int i = 0; i < len; i++) {
	Appender a = (Appender) appenderList.elementAt(i);
	a.close();
      }
      appenderList.removeAllElements();
      appenderList = null;      
    }
  }


  /**
     Remove the appender passed as parameter form the list of attached
     appenders.  */
  public
  void removeAppender(Appender appender) {
    if(appender == null || appenderList == null) 
      return;
    appenderList.removeElement(appender);    
  }


 /**
    Remove the appender with the name passed as parameter form the
    list of appenders.  
  */
  public
  void removeAppender(String name) {
    if(name == null || appenderList == null) return;
    int size = appenderList.size();
    for(int i = 0; i < size; i++) {
      if(name.equals(((Appender)appenderList.elementAt(i)).getName())) {
	 appenderList.removeElementAt(i);
	 break;
      }
    }
  }

}
"
org/apache/log4j/Layout.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;

/**
   Extend this abstract class to create your own log layout format.
   
   @author Ceki G&uuml;lc&uuml;

*/
  
public abstract class Layout implements OptionHandler {

  // Note that the line.separator property can be looked up even by
  // applets.
  public final static String LINE_SEP = System.getProperty(""line.separator"");
  public final static int LINE_SEP_LEN  = LINE_SEP.length();


  /**
     Implement this method to create your own layout format.
  */
  abstract
  public
  String format(LoggingEvent event);

  /**
     Returns the content type output by this layout. The base class
     returns ""text/plain"". 
  */
  public
  String getContentType() {
    return ""text/plain"";
  }

  /**
     Returns the header for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getHeader() {
    return null;
  }

  /**
     Returns the footer for the layout format. The base class returns
     <code>null</code>.  */
  public
  String getFooter() {
    return null;
  }



  /**
     If the layout handles the throwable object contained within
     {@link LoggingEvent}, then the layout should return
     <code>false</code>. Otherwise, if the layout ignores throwable
     object, then the layout should return <code>true</code>.

     <p>The {@link SimpleLayout}, {@link TTCCLayout}, {@link
     PatternLayout} all return <code>true</code>. The {@link
     org.apache.log4j.xml.XMLLayout} returns <code>false</code>.

     @since 0.8.4 */
  abstract
  public
  boolean ignoresThrowable();

}
"
org/apache/log4j/test/Base64.java,false,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.


package org.apache.log4j.test;

class Base64 {

  final static int MAX_LINE = 76;
  
  static byte[] asciiEncoding =
    //A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q  
    {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
    //R  S ...                        Z   a   b   c    d    e    f    g
    82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103,
    //h    i    j    k    l    m    n    o    p    q    r    s   t     u
    104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
    //v    w    x    y    z   0   1   2   3   4   5   6   7   8   9   +   /
    118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47}; 

  static char[] charEnc = new char[64];

  static {
    for(int i = 0; i < 26; i ++) {
      charEnc[i] = (char) ('A' + i);
      charEnc[i+26] = (char) ('a' + i);
    }
    for(int i = 0; i < 10; i ++) {
      charEnc[i+52] = (char) ('0' + i);
    }
    charEnc[62] = '+';
    charEnc[63] = '/';
  }

  
  
  static
  String toString(byte[] inbuf) {
    return toString(inbuf, 0, inbuf.length);
  }
  /**
     
   */
  static
  String toString(byte[] inbuf, int offset, int length) {
    
    StringBuffer output = new StringBuffer((length)*4/3 + 1);

    int in;
    char[] out = new char[4];
    
    int i = offset;
    boolean ended = false;
    int last = offset + length;
    int j;
    int bitsRead;
        
    while(!ended) {
      in = 0;
      bitsRead = 0;
      for(j = 0; j < 3; j++) {
	if(i == last) {
	  ended = true;
	  break;
	}
	in = (in << 8) | (inbuf[i++] & 0xFF);
	bitsRead += 8;
      }

      while(bitsRead >= 6) {
	bitsRead -= 6;
	output.append(charEnc[(in >>> bitsRead) & 0x3F]);
      }

      if(bitsRead == 4) {
	output.append(charEnc[(in & 0x0F) << 2]);
	output.append(""="");
      }
      else if (bitsRead == 2) {
	output.append(charEnc[(in & 0x03) << 4]);
	output.append(""=="");
      }
    }
    return output.toString();
  }


  public static void main(String[] args) {

    byte[] inbuf = new byte[MAX_LINE];

    while(true) {
      try {
	int read = System.in.read(inbuf, 0, MAX_LINE);
	if(read == -1) break;
	System.out.println(""Read "" + read + "" chars."");
	System.out.println(Base64.toString(inbuf, 0, read));
      }
      catch (Exception e) {
	System.out.println(""Exception "" + e);
      }

    }
  }
}
"
org/apache/log4j/net/SyslogAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;

import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.helpers.SyslogWriter;
import org.apache.log4j.helpers.SyslogQuietWriter;

// Contributors: Yves Bossel <ybossel@opengets.cl>
//               Christopher Taylor <cstaylor@pacbell.net>

/**
    Use SyslogAppender to send log messages to a remote syslog daemon.
 
    @author Ceki G&uuml;lc&uuml;
    @author Anders Kristensen
 */
public class SyslogAppender extends AppenderSkeleton {
  // The following constants are extracted from a syslog.h file
  // copyrighted by the Regents of the University of California
  // I hope nobody at Berkley gets offended.
  
  /** Kernel messages */
  final static public int LOG_KERN     = 0; 
  /** Random user-level messages */
  final static public int LOG_USER     = 1<<3; 
  /** Mail system */
  final static public int LOG_MAIL     = 2<<3; 
  /** System daemons */
  final static public int LOG_DAEMON   = 3<<3; 
  /** security/authorization messages */
  final static public int LOG_AUTH     = 4<<3; 
  /** messages generated internally by syslogd */
  final static public int LOG_SYSLOG   = 5<<3; 
                                               
  /** line printer subsystem */  
  final static public int LOG_LPR      = 6<<3; 
  /** network news subsystem */
  final static public int LOG_NEWS     = 7<<3; 
  /** UUCP subsystem */
  final static public int LOG_UUCP     = 8<<3; 
  /** clock daemon */
  final static public int LOG_CRON     = 9<<3; 
  /** security/authorization  messages (private) */
  final static public int LOG_AUTHPRIV = 10<<3; 
  /** ftp daemon */
  final static public int LOG_FTP      = 11<<3; 

  // other codes through 15 reserved for system use
  /** reserved for local use */
  final static public int LOG_LOCAL0 = 16<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL1 = 17<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL2 = 18<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL3 = 19<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL4 = 20<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL5 = 21<<3; 
  /** reserved for local use */
  final static public int LOG_LOCAL6 = 22<<3; 
  /** reserved for local use*/
  final static public int LOG_LOCAL7 = 23<<3; 

   /**
     A string constant used in naming the option for setting the
     syslog server.  Current value of this string constant is
     <b>SyslogHost</b>.
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

     @since 0.8.1 */
  public static final String SYSLOG_HOST_OPTION = ""SyslogHost"";

   /**
     A string constant used in naming the option for setting facility
     type.  Current value of this string constant is <b>Facility</b>.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

     @since 0.8.1 */
  public static final String FACILITY_OPTION = ""Facility"";  

   /**
     A string constant used in naming the option for setting whether
     the facility name is printed or not.  Current value of this
     string constant is <b>FacilityPrinting</b>.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

     @since 0.8.1 */
  public static final String FACILITY_PRINTING_OPTION = ""FacilityPrinting"";  

  protected static final int SYSLOG_HOST_OI = 0;
  protected static final int FACILITY_OI = 1;
  
  static final String TAB = ""    "";

  // Have LOG_USER as default
  int syslogFacility = LOG_USER;
  String facilityStr;  
  boolean facilityPrinting = false;
  
  //SyslogTracerPrintWriter stp;
  SyslogQuietWriter sqw;  
  String syslogHost;
  
  public
  SyslogAppender() {
    this.initSyslogFacilityStr();
  }
  
  public
  SyslogAppender(Layout layout, int syslogFacility) {
    this.layout = layout;
    this.syslogFacility = syslogFacility;    
    this.initSyslogFacilityStr();
  }
		 
  public
  SyslogAppender(Layout layout, String syslogHost, int syslogFacility) {
    this(layout, syslogFacility);
    setSyslogHost(syslogHost);
  }

  /**
     Returns the option names for this component, namely the string
     array consisting of {{@link #SYSLOG_HOST_OPTION}, {@link
     #FACILITY_OPTION}, {@link #FACILITY_PRINTING_OPTION}}.

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.

     @since 0.8.1 */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		      new String[] {SYSLOG_HOST_OPTION, FACILITY_OPTION,
			            FACILITY_PRINTING_OPTION});
  }
  
  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 

   */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    
    super.setOption(option, value);    
    
    if(option.equals(SYSLOG_HOST_OPTION)) 
      this.setSyslogHost(value);
    else if(option.equals(FACILITY_PRINTING_OPTION))
      facilityPrinting = OptionConverter.toBoolean(value, facilityPrinting);
    else if(option.equals(FACILITY_OPTION)) {
      this.setFacility(value);
    }
  }
  

  /**
     Release any resources held by this SyslogAppender.

     @since 0.8.4
   */
  synchronized
  public
  void close() {
    closed = true;
    // A SyslogWriter is UDP based and needs no opening. Hence, it
    // can't be closed. We just unset the variables here.    
    sqw = null;
  }
  
  private
  void initSyslogFacilityStr() {
    facilityStr = getFacilityString(this.syslogFacility);
    
    if (facilityStr == null) {
      System.err.println(""\"""" + syslogFacility +
                  ""\"" is an unknown syslog facility. Defaulting to \""USER\""."");
      this.syslogFacility = LOG_USER;
      facilityStr = ""user:"";
    } else {
      facilityStr += "":"";
    }
  }	   

  /**
     Returns the specified syslog facility as a lower-case String,
     e.g. ""kern"", ""user"", etc.
  */
  public
  static
  String getFacilityString(int syslogFacility) {
    switch(syslogFacility) {
    case LOG_KERN:      return ""kern"";
    case LOG_USER:      return ""user"";
    case LOG_MAIL:      return ""mail"";
    case LOG_DAEMON:    return ""daemon"";
    case LOG_AUTH:      return ""auth"";
    case LOG_SYSLOG:    return ""syslog"";
    case LOG_LPR:       return ""lpr"";
    case LOG_NEWS:      return ""news"";
    case LOG_UUCP:      return ""uucp"";
    case LOG_CRON:      return ""cron"";
    case LOG_AUTHPRIV:  return ""authpriv"";
    case LOG_FTP:       return ""ftp"";
    case LOG_LOCAL0:    return ""local0"";
    case LOG_LOCAL1:    return ""local1"";
    case LOG_LOCAL2:    return ""local2"";
    case LOG_LOCAL3:    return ""local3"";
    case LOG_LOCAL4:    return ""local4"";
    case LOG_LOCAL5:    return ""local5"";
    case LOG_LOCAL6:    return ""local6"";
    case LOG_LOCAL7:    return ""local7"";
    default:            return null;
    }	   
  }	   

  /**
     Returns the integer value corresponding to the named syslog
     facility, or -1 if it couldn't be recognized.

     @param facilityName one of the strings KERN, USER, MAIL, DAEMON,
            AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, LOCAL0,
            LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7.
            The matching is case-insensitive.
     
     @since 1.1
  */
  public
  static
  int getFacility(String facilityName) {
    if(facilityName != null) {
      facilityName = facilityName.trim();
    }
    if(""KERN"".equalsIgnoreCase(facilityName)) {
      return LOG_KERN;
    } else if(""USER"".equalsIgnoreCase(facilityName)) {
      return LOG_USER;
    } else if(""MAIL"".equalsIgnoreCase(facilityName)) {
      return LOG_MAIL;
    } else if(""DAEMON"".equalsIgnoreCase(facilityName)) {
      return LOG_DAEMON;
    } else if(""AUTH"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTH;
    } else if(""SYSLOG"".equalsIgnoreCase(facilityName)) {
      return LOG_SYSLOG;
    } else if(""LPR"".equalsIgnoreCase(facilityName)) {
      return LOG_LPR;
    } else if(""NEWS"".equalsIgnoreCase(facilityName)) {
      return LOG_NEWS;
    } else if(""UUCP"".equalsIgnoreCase(facilityName)) {
      return LOG_UUCP;
    } else if(""CRON"".equalsIgnoreCase(facilityName)) {
      return LOG_CRON;
    } else if(""AUTHPRIV"".equalsIgnoreCase(facilityName)) {
      return LOG_AUTHPRIV;
    } else if(""FTP"".equalsIgnoreCase(facilityName)) {
      return LOG_FTP;
    } else if(""LOCAL0"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL0;
    } else if(""LOCAL1"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL1;
    } else if(""LOCAL2"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL2;
    } else if(""LOCAL3"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL3;
    } else if(""LOCAL4"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL4;
    } else if(""LOCAL5"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL5;
    } else if(""LOCAL6"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL6;
    } else if(""LOCAL7"".equalsIgnoreCase(facilityName)) {
      return LOG_LOCAL7;
    } else {
      return -1;
    }
  }
  
  public
  void append(LoggingEvent event) {

    if(!isAsSevereAsThreshold(event.priority))
      return;
    
    // We must not attempt to append if sqw is null.
    if(sqw == null) {
      errorHandler.error(""No syslog host is set for SyslogAppedender named \""""+
			this.name+""\""."");
      return;
    }

    String buffer = (facilityPrinting? facilityStr : """") +
                          layout.format(event);

    sqw.setPriority(event.priority.getSyslogEquivalent());    
    sqw.write(buffer);

    String[] s = event.getThrowableStrRep();
    if (s != null) {
      int len = s.length;
      if(len > 0) {
	sqw.write(s[0]);
      
	for(int i = 1; i < len; i++) {
	    sqw.write(TAB+s[i].substring(1));
	}	
      }

    }
  }

  /**
     This method returns immediately as options are activated when they
     are set.

     @see #setOption
  */
  public
  void activateOptions() {
  }

  /**
     The SyslogAppender requires a layout. Hence, this method returns
     <code>true</code>.

     @since 0.8.4 */
  public
  boolean requiresLayout() {
    return true;
  }
  
  /**
    The <b>SyslogHost</b> option is the name of the the syslog host
    where log output should go.

    <b>WARNING</b> If the SyslogHost is not set, then this appender
    will fail. 
   */
  public
  void setSyslogHost(String syslogHost) {
    this.sqw = new SyslogQuietWriter(new SyslogWriter(syslogHost), 
				     syslogFacility, errorHandler);
    //this.stp = new SyslogTracerPrintWriter(sqw);    
    this.syslogHost = syslogHost;
  }
  
  /**
     Returns the value of the <b>SyslogHost</b> option.
   */
  public
  String getSyslogHost() {
    return syslogHost;
  }
  
  /**
     Set the syslog facility. This is the <b>Facility</b> option.

     <p>The <code>facilityName</code> parameter must be one of the
     strings KERN, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP,
     CRON, AUTHPRIV, FTP, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4,
     LOCAL5, LOCAL6, LOCAL7. Case is unimportant.
     
     @since 0.8.1 */
  public
  void setFacility(String facilityName) {
    if(facilityName == null)
      return;
    
    syslogFacility = getFacility(facilityName);
    if (syslogFacility == -1) {
      System.err.println(""[""+facilityName +
                  ""] is an unknown syslog facility. Defaulting to [USER]."");
      syslogFacility = LOG_USER;
    }
    
    this.initSyslogFacilityStr();

    // If there is already a sqw, make it use the new facility.
    if(sqw != null) {
      sqw.setSyslogFacility(this.syslogFacility);
    }
  }
  
  /**
     Returns the value of the <b>Facility</b> option.
   */
  public
  String getFacility() {
    return getFacilityString(syslogFacility);
  }
  
  /**
    If the <b>FacilityPrinting</b> option is set to true, the printed
    message will include the facility name of the application. It is
    <em>false</em> by default.
   */
  public
  void setFacilityPrinting(boolean on) {
    facilityPrinting = on;
  }
  
  /**
     Returns the value of the <b>FacilityPrinting</b> option.
   */
  public
  boolean getFacilityPrinting() {
    return facilityPrinting;
  }
}
"
org/apache/log4j/SimpleLayout.java,false,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.


package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;

/**
   SimpleLayout consists of the priority of the log statement,
   followed by "" - "" and then the log message itself. For example,

   <pre>
           DEBUG - Hello world
   </pre>

   <p>
   @author Ceki G&uuml;lc&uuml;
   @since version 0.7.0

   <p>{@link PatternLayout} offers a much more powerful alternative.
*/
public class SimpleLayout extends Layout {

  StringBuffer sbuf = new StringBuffer(128);

  public SimpleLayout() {
  }

  public
  String[] getOptionStrings() {
    return new String[0];
  }

  public
  void setOption(String option, String value) {
  }
  
  public
  void activateOptions() {
  }
  
  /**
     Returns the log statement in a format consisting of the
     <code>priority</code>, followed by "" - "" and then the
     <code>message</code>. For example, <pre> INFO - ""A message""
     </pre>

     <p>The <code>category</code> parameter is ignored.
     <p>
     @return A byte array in SimpleLayout format.
    */
  public
  String format(LoggingEvent event) {

    sbuf.setLength(0);
    sbuf.append(event.priority.toString());
    sbuf.append("" - "");
    sbuf.append(event.getRenderedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }

/**
     The SimpleLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.

     @since version 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }
}
"
org/apache/log4j/performance/ConcatVsArray.java,false,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.

package org.apache.log4j.performance;

import java.util.Date;

/**
   Measure difference in performance of string concatenation versus
   creating an anonymous string array.

   <p>You should be able to see that anonymous string array
   construction is significatnly faster than string concatenation. The
   difference increases proportionally with the length of the strings
   to be concatanated.

   @author Ceki G&uuml;lc&uuml;
 */
public class ConcatVsArray {


  static
  void  Usage() {
    System.err.println(""Usage: java org.apache.log4j.performance.ConcatVsArray "" +
		       ""string1 string2 runLength\n"" +
		       ""       where runLength is an integer."");
    System.exit(1);
  }

  public static void main(String args[]) {

    if(args.length != 3) {
      Usage();
    }    

    String s1 = args[0];
    String s2 = args[1];
    int runLength = 0;
    try {
      runLength = Integer.parseInt(args[2]);      
    }
    catch(java.lang.NumberFormatException e) {
      System.err.println(e);
      Usage();
    }      

    double micros;

    String[] sa;
    long before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      sa = new String[]{s1, s2};
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The anonymous array loop took around "" + micros + "" microseconds."");

    String s;    
    before = new Date().getTime();
    for(int i = 0; i < runLength; i++) {
      s = s1 + s2;
    }
    micros = (new Date().getTime() - before)*1000.0/runLength;
    System.out.println(""The append loop took around "" + micros + "" microseconds."");

  }
}
"
org/apache/log4j/nt/test/NTMin.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.nt.test;


import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.nt.NTEventLogAppender;
import org.apache.log4j.Priority;
import org.apache.log4j.NDC;
import java.io.IOException;


public class NTMin {
  
  static Category cat = Category.getInstance(NTMin.class.getName());
				     
  public 
  static 
  void main(String argv[]) {

    //if(argv.length == 1) {
    init();
    //}
    //else {
    //Usage(""Wrong number of arguments."");
    //}
      test(""someHost"");
  }

  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + NTMin.class + """");
    System.exit(1);
  }

  
  static
  void init() {

    BasicConfigurator.configure(new NTEventLogAppender());
  }

  static
  void test(String host) {
    NDC.push(host);
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
  }
}
"
org/apache/log4j/helpers/QuietWriter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;


/**
   QuietWriter does not throw exceptions when things go
   wrong. Instead, it delegates error handling to its {@link ErrorHandler}. 

   @author Ceki G&uuml;lc&uuml;

   @since 0.7.3
*/
public class QuietWriter extends FilterWriter {

  protected ErrorHandler errorHandler;

  public
  QuietWriter(Writer writer, ErrorHandler errorHandler) {
    super(writer);
    setErrorHandler(errorHandler);
  }

  public
  void write(String string) {
    try {
      out.write(string);
    } catch(IOException e) {
      errorHandler.error(""Failed to write [""+string+""]."", e, 
			 ErrorCode.WRITE_FAILURE);
    }
  }

  public
  void flush() {
    try {
      out.flush();
    } catch(IOException e) {
      errorHandler.error(""Failed to flush writer,"", e, 
			 ErrorCode.FLUSH_FAILURE);
    }	
  }


  public
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // This is a programming error on the part of the enclosing appender.
      throw new IllegalArgumentException(""Attempted to set null ErrorHandler."");
    } else { 
      this.errorHandler = eh;
    }
  }
}
"
org/apache/log4j/PatternLayout.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */

package org.apache.log4j;

import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.NDC;
import org.apache.log4j.helpers.PatternParser;
import org.apache.log4j.helpers.PatternConverter;
import org.apache.log4j.helpers.OptionConverter;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;
import java.util.Vector;
import java.text.FieldPosition;

// Contributors:   Nelson Minar <nelson@monkey.org>
//                 Anders Kristensen <akristensen@dynamicsoft.com>

/**
   
   A flexible layout configurable with pattern string.

   <p>The goal of this class is to {@link #format format} a {@link
   LoggingEvent} and return the results as a String. The results
   depend on the <em>conversion pattern</em>.

   <p>The conversion pattern is closely related to the conversion
   pattern of the printf function in C. A conversion pattern is
   composed of literal text and format control expressions called
   <em>conversion specifiers</em>.

   <p><i>You are free to insert any literal text within the conversion
   pattern.</i>
   
   <p>Each conversion specifier starts with a percent sign (%) and is
   followed by optional <em>format modifiers</em> and a <em>conversion
   character</em>. The conversion character specifies the type of
   data, e.g. category, priority, date, thread name. The format
   modifiers control such things as field width, padding, left and
   right justification. The following is a simple example.

   <p>Let the conversion pattern be <b>""%-5p [%t]: %m%n""</b> and assume
   that the log4j environment was set to use a PatternLayout. Then the
   statements
   <pre>
   Category root = Category.getRoot();
   root.debug(""Message 1"");
   root.warn(""Message 2"");   
   </pre>
   would yield the output
   <pre>
   DEBUG [main]: Message 1
   WARN  [main]: Message 2  
   </pre>

   <p>Note that there is no explicit separator between text and
   conversion specifiers. The pattern parser knows when it has reached
   the end of a conversion specifier when it reads a conversion
   character. In the example above the conversion specifier
   <b>%-5p</b> means the priority of the logging event should be left
   justfied to a with of five characters. 
   
   The recognized conversion characters are
   
   <p>
   <table border=1 CELLPADDING=8>
   <th>Conversion Character</th>
   <th>Effect</th>

   <tr>
     <td align=center><b>c</b></td>

     <td>Used to output the category of the logging event. The
     category conversion specifier can be optionally followed by
     <em>precision specifier</em>, that is a decimal constant in
     brackets.

     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the category name will be
     printed. By default the category name is printed in full.

     <p>For example, for the category name ""a.b.c"" the pattern
     <b>%c{2}</b> will output ""b.c"".

     </td>
   </tr>

   <tr>
     <td align=center><b>C</b></td>

     <td>Used to output the fully qualified class name of the caller
     issuing the logging request. This conversion specifier
     can be optionally followed by <em>precision specifier</em>, that
     is a decimal constant in brackets.

     <p>If a precision specifier is given, then only the corresponding
     number of right most components of the class name will be
     printed. By default the class name is output in fullly qualified form.
     
     <p>For example, for the class name ""org.apache.xyz.SomeClass"", the
     pattern <b>%C{1}</b> will output ""SomeClass"".

     <p><b>WARNING</b> Generating the caller class information is
     slow. Thus, it's use should be avoided unless execution speed is
     not an issue.

     </td>
     </tr>
   
   <tr> <td align=center><b>d</b></td> <td>Used to output the date of
	 the logging event. The date conversion specifier may be
	 followed by a <em>date format specifier</em> enclosed between
	 braces. For example, <b>%d{HH:mm:ss,SSS}</b> or
	 <b>%d{dd&nbsp;MMM&nbsp;yyyy&nbsp;HH:mm:ss,SSS}</b>.  If no
	 date format specifier is given then ISO8601 format is
	 assumed.
	 
	 <p>The date format specifier admits the same syntax as the
	 time pattern string of the {@link
	 java.text.SimpleDateFormat}. Altough part of the standard
	 JDK, the performance of <code>SimpleDateFormat</code> is
	 quite poor.

	 <p>For better results it is recommended to use the log4j date
	 formatters. These can be specified using one of the strings
	 ""ABSOLUTE"", ""DATE"" and ""ISO8601"" for specifying {@link
	 org.apache.log4j.helpers.AbsoluteTimeDateFormat
	 AbsoluteTimeDateFormat}, {@link
	 org.apache.log4j.helpers.DateTimeDateFormat DateTimeDateFormat}
	 and respectively {@link
	 org.apache.log4j.helpers.ISO8601DateFormat
	 ISO8601DateFormat}. For example, <b>%d{ISO8601}</b> or
	 <b>%d{ABSOLUTE}</b>.

	 <p>These dedicated date formatters perform significantly
	 better than {@link java.text.SimpleDateFormat}.
     </td>
   </tr>

   <tr>
   <td align=center><b>F</b></td>

   <td>Used to output the file name where the logging request was
   issued.

   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.

   </tr>
   
   <tr>
   <td align=center><b>l</b></td>

     <td>Used to output location information of the caller which generated
     the logging event. 

     <p>The location information depends on the JVM implementation but
     usually consists of the fully qualified name of the calling
     method followed by the callers source the file name and line
     number between parentheses.

     <p>The location information can be very useful. However, it's
     generation is <em>extremely</em> slow. It's use should be avoided
     unless execution speed is not an issue.
   
     </td>
   </tr>

   <tr>
   <td align=center><b>L</b></td>

   <td>Used to output the line number from where the logging request
   was issued.

   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.

   </tr>

   
   <tr>
     <td align=center><b>m</b></td>
     <td>Used to output the application supplied message associated with 
     the logging event.</td>   
   </tr>

   <tr>
   <td align=center><b>M</b></td>

   <td>Used to output the method name where the logging request was
   issued.

   <p><b>WARNING</b> Generating caller location information is
   extremely slow. It's use should be avoided unless execution speed
   is not an issue.

   </tr>

   <tr>
     <td align=center><b>n</b></td>
     
     <td>Outputs the platform dependent line separator character or
     characters. 

     <p>This conversion character offers practically the same
     performance as using non-portable line separator strings such as
     ""\n"", or ""\r\n"". Thus, it is the preferred way of specifying a
     line separator.

     
   </tr>
   
   <tr>
     <td align=center><b>p</b></td>
     <td>Used to output the priority of the logging event.</td>
   </tr>
   
   <tr>

     <td align=center><b>r</b></td>

     <td>Used to output the number of milliseconds elapsed since the start
     of the application until the creation of the logging event.</td>
   </tr>  
   

   <tr>
     <td align=center><b>t</b></td>

     <td>Used to output the name of the thread that generated the
     logging event.</td>
     
   </tr>
    
   <tr>

     <td align=center><b>x</b></td>

     <td>Used to output the NDC (nested diagnostic context) associated
     with the thread that generated the logging event.
     </td>     
   </tr>

   <tr>

     <td align=center><b>%</b></td>

     <td>The sequence %% outputs a single percent sign.
     </td>     
   </tr>
   
   </table>

   <p>By default the relevant infromation is output as is. However,
   with the aid of format modifiers it is possible to change the
   minimum field width, the maximum field width and justification.

   <p>The optional format modifier is placed between the percent sign
   and the conversion character.

   <p>The first optional format modifier is the <em>left justification
   flag</em> which is just the minus (-) character. Then comes the
   optional <em>minimum field width</em> modifier. This is a decimal
   constant that represents the minimum number of characters to
   output. If the data item requires fewer characters, it is padded on
   either the left or the right until the minimum width is
   reached. The default is to pad on the left (right justify) but you
   can specify right padding with the left justification flag. The
   padding character is space. If the data item is larger than the
   minimum field width, the field is expanded to accomodate the
   data. The value is never truncated.

   <p>This behavior can be changed using the <em>maximum field
   width</em> modifier which is designated by a period followed by a
   decimal constant. If the data item is longer than the maximum
   field, then the extra characters are removed from the
   <em>beginning</em> of the data item and not from the end. For
   example, it the maximum field width is eight and the data item is
   ten characters long, then the first two characters of the data item
   are dropped. This behaviour deviates from the printf function in C
   where truncation is done from the end.

   <p>Below are various format modifier examples for the category
   conversion specifier.

   <p>
   <TABLE BORDER=1 CELLPADDING=8>
   <th>Format modifier
   <th>left justify
   <th>minimim width
   <th>maximum width
   <th>comment

   <tr>
   <td align=center>%20c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>none</td>

   <td>Left pad with spaces if the category name is less than 20
   characters long.

   <tr> <td align=center>%-20c</td> <td align=center>true</td> <td
   align=center>20</td> <td align=center>none</td> <td>Right pad with
   spaces if the category name is less than 20 characters long.
   
   <tr>
   <td align=center>%.30c</td>
   <td align=center>NA</td>
   <td align=center>none</td>
   <td align=center>30</td>

   <td>Truncate from the beginning if the category name is longer than 30
   characters.

   <tr>
   <td align=center>%20.30c</td>
   <td align=center>false</td>
   <td align=center>20</td>
   <td align=center>30</td>

   <td>Left pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   

   <tr>
   <td align=center>%-20.30c</td>
   <td align=center>true</td>
   <td align=center>20</td>
   <td align=center>30</td>

   <td>Right pad with spaces if the category name is shorter than 20
   characters. However, if category name is longer than 30 characters,
   then truncate from the beginning.   
   
   </table>

   <p>Below are some examples of conversion patterns.

   <dl>

   <p><dt><b>%r [%t] %-5p %c %x - %m\n</b> 
   <p><dd>This is essentially the TTCC layout.

   <p><dt><b>%-6r [%15.15t] %-5p %30.30c %x - %m\n</b>

   <p><dd>Similar to the TTCC layout except that the rlative time is
   right padded if less than 6 digits, thread name is right padded if
   less than 15 characters and truncated if longer and the category
   name is left padded if shorter than 30 characters and truncated if
   longer.
   
  </dl>
   
   <p>The above text is largely inspired from Peter A. Darnell and
   Philip E. Margolis' higly recommended book ""C -- a Software
   Engineering Approach"", ISBN 0-387-97389-3.
   
   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;


   @since 0.8.2 */
public class PatternLayout extends Layout {

   /**
     A string constant used in naming the option for setting the
     layout pattern. Current value of this string constant is
     <b>ConversionPattern</b>.

     <p>Note that the search for all option keys is case sensitive.
     
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
  */
  final static public String CONVERSION_PATTERN_OPTION = ""ConversionPattern"";

  /** Default pattern string for log output. Currently set to the
      string <b>""%m%n""</b> which just prints the application supplied
      message. */
  public final static String DEFAULT_CONVERSION_PATTERN =""%m%n"";

  /** A conversion pattern equivalent to the TTCCCLayout.
      Current value is <b>%r [%t] %p %c %x - %m%n</b>. */  
  public final static String TTCC_CONVERSION_PATTERN
                                             = ""%r [%t] %p %c %x - %m%n"";

  
  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;
  

  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);
  
  private String pattern;
  
  private PatternConverter head;

  private String timezone;
  
  /**
     Constructs a PatternLayout using the DEFAULT_LAYOUT_PATTERN.
      
     The default pattern just produces the application supplied message.
  */
  public PatternLayout() {
    this(DEFAULT_CONVERSION_PATTERN);
  }

  /**
     Constructs a PatternLayout using the supplied conversion pattern.
  */
  public PatternLayout(String pattern) {
    this.pattern = pattern;
    head = createPatternParser((pattern == null) ? DEFAULT_CONVERSION_PATTERN : 
			     pattern).parse();
  }
  
  /**
     Returns the the array of option strings that {@link
     PatternLayout} recognizes. The only recognized option string is
     the value of {@link #CONVERSION_PATTERN_OPTION}.
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return new String[] {CONVERSION_PATTERN_OPTION};
  }	

  /**
     The PatternLayout specific options are:

     <p>
     <dl>
     <dt><b>ConversionPattern</b>

     <p><dd>The value determines the conversion pattern used.
     
     </dl>
     
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 

   */
  public
  void setOption(String option, String value) {
    if(value == null)
      return;
    if(option.equalsIgnoreCase(CONVERSION_PATTERN_OPTION)) {
      pattern = value;
      head = createPatternParser(value).parse();
    }
    //else if(option.equals(TIMEZONE_OPTION)) {
    //try {
    //timezone = OptionConverter.substituteVars(value);
    //}
    //catch(IllegalArgumentException e) {
    //LogLog.error(""Could not substitute variables."" , e);
    //}
    //}
  }
  
  /**
     Set the <b>ConversionPattern</b> option. This is the string which
     controls formatting and consists of a mix of literal content and
     conversion specifiers.
   */
  public
  void setConversionPattern(String conversionPattern) {
    pattern = conversionPattern;
    head = createPatternParser(conversionPattern).parse();
  }
  
  /**
     Returns the value of the <b>ConversionPattern</b> option.
   */
  public
  String getConversionPattern() {
    return pattern;
  }
  
  /**
     Does not do anything as options become effective immediately. See
     {@link #setOption} method. */
  public
  void activateOptions() {
    // nothing to do.
  }
  
 /**
     The PatternLayout does not handle the throwable contained within
     {@link LoggingEvent LoggingEvents}. Thus, it returns
     <code>true</code>.

     @since 0.8.4 */
  public
  boolean ignoresThrowable() {
    return true;
  }

  /**
    Returns PatternParser used to parse the conversion string. Subclasses
    may override this to return a subclass of PatternParser which recognize
    custom conversion characters.

    @since 0.9.0
  */
  protected PatternParser createPatternParser(String pattern) {
    return new PatternParser(pattern);
  }


  /**
     Produces a formatted string as specified by the conversion pattern.
  */
  public String format(LoggingEvent event) {
    // Reset working stringbuffer
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    
    PatternConverter c = head;

    while(c != null) {
      c.format(sbuf, event);
      c = c.next;
    }
    return sbuf.toString();
  }
}
"
org/apache/log4j/helpers/FileWatchdog.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE file.
 */

// Contributors:  Mathias Bogaert

package org.apache.log4j.helpers;

import java.io.File;
import org.apache.log4j.helpers.LogLog;

/**
   Check every now and then that a certain file has not changed. If it
   has, then call the {@link #doOnChange} method.


   @author Ceki G&uuml;lc&uuml;
   @since version 0.9.1 */
public abstract class FileWatchdog extends Thread {

  /**
     The default delay between every file modification check, set to 60
     seconds.  */
  static final public long DEFAULT_DELAY = 60000; 
  /**
     The name of the file to observe  for changes.
   */
  protected String filename;
  
  /**
     The delay to observe between every check. By default set {@link
     #DEFAULT_DELAY}. */
  protected long delay = DEFAULT_DELAY; 
  
  File file;
  long lastModif = 0; 
  boolean warnedAlready = false;
  boolean interrupted = false;

  protected
  FileWatchdog(String filename) {
    this.filename = filename;
    file = new File(filename);
    setDaemon(true);
    checkAndConfigure();
  }

  /**
     Set the delay to observe between each check of the file changes.
   */
  public
  void setDelay(long delay) {
    this.delay = delay;
  }

  abstract 
  protected 
  void doOnChange();

  protected
  void checkAndConfigure() {
    boolean fileExists;
    try {
      fileExists = file.exists();
    } catch(SecurityException  e) {
      LogLog.warn(""Was not allowed to read check file existance, file:[""+
		  filename+""]."");
      interrupted = true; // there is no point in continuing
      return;
    }

    if(fileExists) {
      long l = file.lastModified(); // this can also throw a SecurityException
      if(l > lastModif) {           // however, if we reached this point this
	lastModif = l;              // is very unlikely.
	doOnChange();
	warnedAlready = false;
      }
    } else {
      if(!warnedAlready) {
	LogLog.debug(""[""+filename+""] does not exist."");
	warnedAlready = true;
      }
    }
  }

  public
  void run() {    
    while(!interrupted) {
      try {
	Thread.currentThread().sleep(delay);
      } catch(InterruptedException e) {
	// no interruption expected
      }
      checkAndConfigure();
    }
  }
}
"
org/apache/log4j/Hierarchy.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

// WARNING This class MUST not have references to the Category or
// WARNING RootCategory classes in its static initiliazation neither 
// WARNING directly nor indirectly.

// Contributors:
//                Luke Blanshard <luke@quiq.com>
//                Mario Schomburg - IBM Global Services/Germany
//                Anders Kristensen
//                Igor Poteryaev
 
package org.apache.log4j;


import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.log4j.spi.RootCategory;
import org.apache.log4j.spi.CategoryFactory;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;

/**
   This class is specialized in retreiving categories by name and
   also maintaining the category hierarchy.

   <p><em>The casual user should not have to deal with this class
   firectly.</em> In fact, up until version 0.9.0, this class had
   default package access. However, if you are in an environment where
   multiple applications run in the same VM, then read on.

   <p>The structure of the category hierachy is maintained by the
   {@link #getInstance} method. The hierrachy is such that children
   link to their parent but parents do not have any pointers to their
   children. Moreover, categories can be instantiated in any order, in
   particular decendant before ancestor.

   <p>In case a decendant is created before a particular ancestor,
   then it creates a provision node for the ancestor and adds itself
   to the provision node. Other decendants of the same ancestor add
   themselves to the previously created provision node.

   <p>See the code below for further details.
   
   @author Ceki G&uuml;lc&uuml; 

*/
public class Hierarchy {

  // DISABLE_OFF should be set to a value lower than all possible
  // priorities.
  static final int DISABLE_OFF = -1;
  static final int DISABLE_OVERRIDE = -2;  
  
  static 
  private
  CategoryFactory defaultFactory = new DefaultCategoryFactory();


  Hashtable ht;
  Category root;
  RendererMap rendererMap;
  
  int disable;

  boolean emittedNoAppenderWarning = false;
  boolean emittedNoResourceBundleWarning = false;  

  /**
     Create a new Category hierarchy.

     @param root The root of the new hierarchy.

   */
  public
  Hierarchy(Category root) {
    ht = new Hashtable();
    this.root = root;
    // Don't disable any priority level by default.
    disable = DISABLE_OFF;
    this.root.setHierarchy(this);
    rendererMap = new RendererMap();
  }

  /**
     Add an object renderer for a specific class.       
   */
  public
  void addRenderer(Class classToRender, ObjectRenderer or) {
    rendererMap.put(classToRender, or);
  }
  

  /**
     This call will clear all category definitions from the internal
     hashtable. Invoking this method will irrevocably mess up the
     category hiearchy.
     
     <p>You should <em>really</em> know what you are doing before
     invoking this method.

     @since 0.9.0 */
  public
  void clear() {
    //System.out.println(""\n\nAbout to clear internal hash table."");
    ht.clear();
  }

  /**
     Check if the named category exists in the hirarchy. If so return
     its reference, otherwise returns <code>null</code>.
     
     @param name The name of the category to search for.
     
  */
  public
  Category exists(String name) {    
    Object o = ht.get(new CategoryKey(name));
    if(o instanceof Category) {
      return (Category) o;
    } else {
      return null;
    }
  }


  /**
     Similar to {@link #disable(Priority)} except that the priority
     argument is given as a String.  */
  public
  void disable(String priorityStr) {
    if(disable != DISABLE_OVERRIDE) {  
      Priority p = Priority.toPriority(priorityStr, null);
      if(p != null) {
	disable = p.level;
      } else {
	LogLog.warn(""Could not convert [""+priorityStr+""] to Priority."");
      }
    }
  }


  /**
     Disable all logging requests of priority <em>equal to or
     below</em> the priority parameter <code>p</code>, for
     <em>all</em> categories in this hierarchy. Logging requests of
     higher priority then <code>p</code> remain unaffected.

     <p>Nevertheless, if the {@link
     BasicConfigurator#DISABLE_OVERRIDE_KEY} system property is set to
     ""true"" or any value other than ""false"", then logging requests are
     evaluated as usual, i.e. according to the <a
     href=""../../../../manual.html#selectionRule"">Basic Selection Rule</a>.

     <p>The ""disable"" family of methods are there for speed. They
     allow printing methods such as debug, info, etc. to return
     immediately after an interger comparison without walking the
     category hierarchy. In most modern computers an integer
     comparison is measured in nanoseconds where as a category walk is
     measured in units of microseconds.

     <p>Other configurators define alternate ways of overriding the
     disable override flag. See {@link PropertyConfigurator} and
     {@link org.apache.log4j.xml.DOMConfigurator}.


     @since 0.8.5 */
  public
  void disable(Priority p) {
    if((disable != DISABLE_OVERRIDE) && (p != null)) {
      disable = p.level;
    }
  }
  
  /**
     Disable all logging requests regardless of category and priority.
     This method is equivalent to calling {@link #disable} with the
     argument {@link Priority#FATAL}, the highest possible priority.

     @since 0.8.5 */
  public
  void disableAll() {
    disable(Priority.FATAL);
  }


  /**
     Disable all logging requests of priority DEBUG regardless of
     category.  Invoking this method is equivalent to calling {@link
     #disable} with the argument {@link Priority#DEBUG}.

     @since 0.8.5 */
  public
  void disableDebug() {
    disable(Priority.DEBUG);
  }


  /**
     Disable all logging requests of priority INFO and below
     regardless of category. Note that DEBUG messages are also
     disabled.  

     <p>Invoking this method is equivalent to calling {@link #disable}
     with the argument {@link Priority#INFO}.

     @since 0.8.5 */
  public
  void disableInfo() {
    disable(Priority.INFO);
  }  

  /**
     Undoes the effect of calling any of {@link #disable}, {@link
     #disableAll}, {@link #disableDebug} and {@link #disableInfo}
     methods. More precisely, invoking this method sets the Category
     class internal variable called <code>disable</code> to its
     default ""off"" value.

     @since 0.8.5 */
  public
  void enableAll() {
    disable = DISABLE_OFF;
  }
  
  /**
     Override the shipped code flag if the <code>override</code>
     parameter is not null.

     <p>If <code>override</code> is null then there is nothing to do.
     Otherwise, set Category.shippedCode to false if override has a
     value other than ""false"".     
  */
  public
  void overrideAsNeeded(String override) {
    // If override is defined, any value other than false will be
    // interpreted as true.    
    if(override != null) {
      LogLog.debug(""Handling non-null disable override directive: \""""+
		   override +""\""."");
      if(OptionConverter.toBoolean(override, true)) {
	LogLog.debug(""Overriding all disable methods."");
	disable = DISABLE_OVERRIDE;
      }
    }
  }


  /**
     Return a new category instance named as the first parameter using
     the default factory. 
     
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated and
     lthen inked with its existing ancestors as well as children.
     
     @param name The name of the category to retreive.

 */
  public
  Category getInstance(String name) {
    return getInstance(name, defaultFactory);
  }

 /**
     Return a new category instance named as the first parameter using
     <code>factory</code>.
     
     <p>If a category of that name already exists, then it will be
     returned.  Otherwise, a new category will be instantiated by the
     <code>factory</code> parameter and linked with its existing
     ancestors as well as children.
     
     @param name The name of the category to retreive.
     @param factory The factory that will make the new category instance.

 */
  public
  Category getInstance(String name, CategoryFactory factory) {
    //System.out.println(""getInstance(""+name+"") called."");
    CategoryKey key = new CategoryKey(name);    
    // Synchronize to prevent write conflicts. Read conflicts (in
    // getChainedPriority method) are possible only if variable
    // assignments are non-atomic.
    Category category;
    
    synchronized(ht) {
      Object o = ht.get(key);
      if(o == null) {
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this);
	ht.put(key, category);      
	updateParents(category);
	return category;
      } else if(o instanceof Category) {
	return (Category) o;
      } else if (o instanceof ProvisionNode) {
	//System.out.println(""(""+name+"") ht.get(this) returned ProvisionNode"");
	category = factory.makeNewCategoryInstance(name);
	category.setHierarchy(this); 
	ht.put(key, category);
	updateChildren((ProvisionNode) o, category);
	updateParents(category);	
	return category;
      }
      else {
	// It should be impossible to arrive here
	return null;  // but let's keep the compiler happy.
      }
    }
  }


  /**
     Returns all the currently defined categories in this hierarchy as
     an {@link java.util.Enumeration Enumeration}.

     <p>The root category is <em>not</em> included in the returned
     {@link Enumeration}.  */
  public
  Enumeration getCurrentCategories() {
    // The accumlation in v is necessary because not all elements in
    // ht are Category objects as there might be some ProvisionNodes
    // as well.
    Vector v = new Vector(ht.size());
    
    Enumeration elems = ht.elements();
    while(elems.hasMoreElements()) {
      Object o = elems.nextElement();
      if(o instanceof Category) {
	v.addElement(o);
      }
    }
    return v.elements();
  }


  public
  boolean isDisabled(int level) {
    return disable >=  level;
  }

  /**
     Get the renderer map for this hierarchy.
  */
  public
  RendererMap getRendererMap() {
    return rendererMap;
  }


  /**
     Get the root of this hierarchy.
     
     @since 0.9.0
   */
  public
  Category getRoot() {
    return root;
  }


  /**
     Reset all values contained in this hierarchy instance to their
     default.  This removes all appenders from all categories, sets
     the priority of all non-root categories to <code>null</code>,
     sets their additivity flag to <code>true</code> and sets the priority
     of the root category to {@link Priority#DEBUG DEBUG}.  Moreover,
     message disabling is set its default ""off"" value.

     <p>Existing categories are not removed. They are just reset.

     <p>This method should be used sparingly and with care as it will
     block all logging until it is completed.</p>

     @since version 0.8.5 */
  public
  void resetConfiguration() {

    getRoot().setPriority(Priority.DEBUG);
    root.setResourceBundle(null);
    disable = Hierarchy.DISABLE_OFF;
    
    // the synchronization is needed to prevent JDK 1.2.x hashtable
    // surprises
    synchronized(ht) {    
      shutdown(); // nested locks are OK    
    
      Enumeration cats = getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.setPriority(null);
	c.setAdditivity(true);
	c.setResourceBundle(null);
      }
    }
    rendererMap.clear();
  }

  /**
     Set the disable override value given a string.
 
     @since 1.1
   */
  public
  void setDisableOverride(String override) {
    if(OptionConverter.toBoolean(override, true)) {
      LogLog.debug(""Overriding disable."");
      disable =  DISABLE_OVERRIDE;
    }
  }



  /**
     Shutting down a hierarchy will <em>safely</em> close and remove
     all appenders in all categories including the root category.
     
     <p>Some appenders such as {@link org.apache.log4j.net.SocketAppender}
     and {@link AsyncAppender} need to be closed before the
     application exists. Otherwise, pending logging events might be
     lost.

     <p>The <code>shutdown</code> method is careful to close nested
     appenders before closing regular appenders. This is allows
     configurations where a regular appender is attached to a category
     and again to a nested appender.
     

     @since 1.0 */
  public 
  void shutdown() {
    Category root = getRoot();    

    // begin by closing nested appenders
    root.closeNestedAppenders();

    synchronized(ht) {
      Enumeration cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.closeNestedAppenders();
      }

      // then, remove all appenders
      root.removeAllAppenders();
      cats = this.getCurrentCategories();
      while(cats.hasMoreElements()) {
	Category c = (Category) cats.nextElement();
	c.removeAllAppenders();
      }      
    }
  }


  /**
     This method loops through all the *potential* parents of
     'cat'. There 3 possible cases:

     1) No entry for the potential parent of 'cat' exists

        We create a ProvisionNode for this potential parent and insert
        'cat' in that provision node.

     2) There entry is of type Category for the potential parent.

        The entry is 'cat's nearest existing parent. We update cat's
        parent field with this entry. We also break from the loop
        because updating our parent's parent is our parent's
        responsibility.
	 
     3) There entry is of type ProvisionNode for this potential parent.

        We add 'cat' to the list of children for this potential parent.
   */
  final
  private
  void updateParents(Category cat) {
    String name = cat.name;
    int length = name.length();
    boolean parentFound = false;
    
    //System.out.println(""UpdateParents called for "" + name);
    
    // if name = ""w.x.y.z"", loop thourgh ""w.x.y"", ""w.x"" and ""w"", but not ""w.x.y.z"" 
    for(int i = name.lastIndexOf('.', length-1); i >= 0; 
	                                 i = name.lastIndexOf('.', i-1))  {
      String substr = name.substring(0, i);

      //System.out.println(""Updating parent : "" + substr);
      CategoryKey key = new CategoryKey(substr); // simple constructor
      Object o = ht.get(key);
      // Create a provision node for a future parent.
      if(o == null) {
	//System.out.println(""No parent ""+substr+"" found. Creating ProvisionNode."");
	ProvisionNode pn = new ProvisionNode(cat);
	ht.put(key, pn);
      } else if(o instanceof Category) {
	parentFound = true;
	cat.parent = (Category) o;
	//System.out.println(""Linking "" + cat.name + "" -> "" + ((Category) o).name);
	break; // no need to update the ancestors of the closest ancestor
      } else if(o instanceof ProvisionNode) {
	((ProvisionNode) o).addElement(cat);
      } else {
	Exception e = new IllegalStateException(""unexpected object type "" + 
					o.getClass() + "" in ht."");
	e.printStackTrace();			   
      }
    }
    // If we could not find any existing parents, then link with root.
    if(!parentFound) 
      cat.parent = root;
  }

  /** 
      We update the links for all the children that placed themselves
      in the provision node 'pn'. The second argument 'cat' is a
      reference for the newly created Category, parent of all the
      children in 'pn'

      We loop on all the children 'c' in 'pn':

         If the child 'c' has been already linked to a child of
         'cat' then there is no need to update 'c'.

	 Otherwise, we set cat's parent field to c's parent and set
	 c's parent field to cat.

  */
  final
  private
  void updateChildren(ProvisionNode pn, Category cat) {
    //System.out.println(""updateChildren called for "" + cat.name);
    final int last = pn.size();

    for(int i = 0; i < last; i++) {
      Category c = (Category) pn.elementAt(i);
      //System.out.println(""Updating child "" +p.name);

      // Unless this child already points to a correct (lower) parent,
      // make cat.parent point to c.parent and c.parent to cat.
      if(!c.parent.name.startsWith(cat.name)) {
	cat.parent = c.parent;
	c.parent = cat;      
      }
    }
  }    

}


"
org/apache/log4j/net/SMTPAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Layout;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.CyclicBuffer;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.TriggeringEventEvaluator;
import java.util.Properties;
import java.util.Date;

import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.AddressException;
import javax.mail.internet.MimeUtility;

/**
   Send an e-mail when a specific logging event occurs, typically on
   errors or fatal errors.

   <p>The number of logging events delivered in this e-mail depend on
   the value of <b>BufferSize</b> option. The
   <code>SMTPAppender</code> keeps only the last
   <code>BufferSize</code> logging events in its cyclic buffer. This
   keeps memory requirements at a reasonable level while still
   delivering useful application context.
   
   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class SMTPAppender extends AppenderSkeleton {
  String to;
  String from;
  String subject;
  String smtpHost;
  int bufferSize = 512;

  CyclicBuffer cb = new CyclicBuffer(bufferSize);
  Session session;
  Message msg;
  boolean locationInfo = false;


 /**
     A string constant used in naming the <em>To</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>To</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String TO_OPTION = ""To"";

 /**
     A string constant used in naming the <em>From</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>From</b>.

     <p>Note that all option keys are case sensitive.

     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.     
  */
  public static final String FROM_OPTION = ""From"";

 /**
     A string constant used in naming the <em>Subject</em> field of
     outgoing e-mail output file. Current value of this string
     constant is <b>Subject</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String SUBJECT_OPTION = ""Subject"";


 /**
     A string constant used in naming the SMTP host that will be
     contacted to send the e-mail. Current value of this string
     constant is <b>SMTPHost</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String SMTP_HOST_OPTION = ""SMTPHost"";

 /**
     A string constant used in naming the cyclic buffer size option.
     Current value of this string constant is <b>BufferSize</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String BUFFER_SIZE_OPTION = ""BufferSize"";


 /**
     A string constant used in naming the class of the
     TriggeringEventEvaluator that this SMTPApepdner wll use. Current
     value of this string constant is <b>EvaluatorClass</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String EVALUATOR_CLASS_OPTION = ""EvaluatorClass"";


  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  

     <p>Note that all option keys are case sensitive.

     @deprecated Options are now handled using the JavaBeans paradigm. 
     This constant will be removed in the <em>near</em> term.
  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";
  
  protected TriggeringEventEvaluator evaluator;



  /**
     The default constructor will instantiate the appender with a
     {@link TriggeringEventEvaluator} that will tirgger on events with
     priority ERROR or higher.*/
  public
  SMTPAppender() {
    this(new DefaultEvaluator());
  }

  
  /**
     Use <code>evaluator</code> passed as parameter as the {@link
     TriggeringEventEvaluator} for this SMTPAppender.  */
  public 
  SMTPAppender(TriggeringEventEvaluator evaluator) {
    this.evaluator = evaluator;
  }

 /**
     Retuns the option names for this component in addition in
     addition to the options of its super class {@link
     AppenderSkeleton}.
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TO_OPTION, FROM_OPTION, SUBJECT_OPTION, 
			  SMTP_HOST_OPTION, BUFFER_SIZE_OPTION,  
			  EVALUATOR_CLASS_OPTION, LOCATION_INFO_OPTION });
  }
  

  /**
     Activate the specified options, such as the smtp host, the
     recipient, from, etc. */
  public
  void activateOptions() {
    Properties props = System.getProperties();
    if (smtpHost != null)
      props.put(""mail.smtp.host"", smtpHost);

     session = Session.getDefaultInstance(props, null);
     //session.setDebug(true);
     msg = new MimeMessage(session);
     
     try {
       if (from != null)
	 msg.setFrom(getAddress(from));
       else
	 msg.setFrom();

       msg.setRecipients(Message.RecipientType.TO, parseAddress(to));
       if(subject != null)
	 msg.setSubject(subject);
     } catch(MessagingException e) {
       LogLog.error(""Could not activate SMTPAppender options."", e );
     }
  }
  
  /**
     Perform SMTPAppender specific appending actions, mainly adding
     the event to a cyclic buffer and checking if the event triggers
     an e-mail to be sent. */
  public
  void append(LoggingEvent event) {

    if(!checkEntryConditions()) {
      return;
    }

    event.getThreadName();
    event.getNDC();
    if(locationInfo) {
      event.getLocationInformation();	
    }
    cb.add(event);    
    if(evaluator.isTriggeringEvent(event)) {
      sendBuffer();
    }
  }

 /**
     This method determines if there is a sense in attempting to append.
     
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.msg == null) {
      errorHandler.error(""Message object not configured."");
      return false;
    }

    if(this.evaluator == null) {
      errorHandler.error(""No TriggeringEventEvaluator is set for appender [""+
			 name+""]."");
      return false;
    }

    
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+name+""]."");
      return false;
    }
    return true;
  }


  synchronized
  public
  void close() {
    this.closed = true;
  }

  InternetAddress getAddress(String addressStr) {
    try {
      return new InternetAddress(addressStr);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  InternetAddress[] parseAddress(String addressStr) {
    try {
      return InternetAddress.parse(addressStr, true);
    } catch(AddressException e) {
      errorHandler.error(""Could not parse address [""+addressStr+""]."", e,
			 ErrorCode.ADDRESS_PARSE_FAILURE);
      return null;
    }
  }

  /**
     Returns value of the <b>To</b> option.
   */
  public
  String getTo() {
    return to;
  }


  /**
     The <code>SMTPAppender</code> requires a {@link Layout layout}.  
  */
  public
  boolean requiresLayout() {
    return true;
  }

  /**
     Send the contents of the cyclic buffer as an e-mail message.
   */
  protected
  void sendBuffer() {

    // Note: this code already owns the monitor for this
    // appender. This frees us from needing to synchronize on 'cb'.
    try {      
      MimeBodyPart part = new MimeBodyPart();

      StringBuffer sbuf = new StringBuffer();
      String t = layout.getHeader();
      if(t != null)
	sbuf.append(t);
      int len =  cb.length(); 
      for(int i = 0; i < len; i++) {
	//sbuf.append(MimeUtility.encodeText(layout.format(cb.get())));
	LoggingEvent event = cb.get();
	sbuf.append(layout.format(event));
	if(layout.ignoresThrowable()) {
	  String[] s = event.getThrowableStrRep();
	  if (s != null) {
	    for(int j = 0; j < s.length; j++) {
	      sbuf.append(s[j]);
	    }
	  }
	}
      }
      t = layout.getFooter();
      if(t != null)
	sbuf.append(t);
      part.setContent(sbuf.toString(), layout.getContentType());      

      Multipart mp = new MimeMultipart();
      mp.addBodyPart(part);
      msg.setContent(mp);

      msg.setSentDate(new Date());
      Transport.send(msg);      
    } catch(Exception e) {
      LogLog.error(""Error occured while sending e-mail notification."", e);
    }
  }
  


  /**
     Returns value of the <b>EvaluatorClass</b> option.
   */
  public
  String getEvaluatorClass() {
    return evaluator == null ? null : evaluator.getClass().getName();
  }
  
  /**
     Returns value of the <b>From</b> option.
   */
  public
  String getFrom() {
    return from;
  }

  /**
     Returns value of the <b>Subject</b> option.
   */
  public
  String getSubject() {
    return subject;
  }


/**
   @deprecated Use the setter method for the option directly, instead
   of the generic <code>setOption</code> method.  */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    

    if(option.equals(TO_OPTION)) 
      to = value;
    else if (option.equals(FROM_OPTION))
      from = value;
    else if (option.equals(SMTP_HOST_OPTION)) 
      smtpHost = value;
    else if (option.equals(SUBJECT_OPTION)) 
      subject = value;
    else if (option.equals(EVALUATOR_CLASS_OPTION)) {      
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
                                           TriggeringEventEvaluator.class,
                                                       evaluator);    
    } else if (option.equals(BUFFER_SIZE_OPTION)) {
      bufferSize = OptionConverter.toInt(value, bufferSize);    
      cb.resize(bufferSize);
    } else if (option.equals(LOCATION_INFO_OPTION))
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
  }


  /**
     The <b>From</b> option takes a string value which should be a
     e-mail address of the sender.
   */
  public
  void setFrom(String from) {
    this.from = from;
  }


  
  /**
     The <b>Subject</b> option takes a string value which should be a
     the subject of the e-mail message.
   */
  public
  void setSubject(String subject) {
    this.subject = subject;
  }
  

  /**
     The <b>BufferSize</b>option takes a positive integer
     representing the maximum number of logging events to collect in a
     cyclic buffer. When the <code>BufferSize</code> is reached,
     oldest events are deleted as new events are added to the
     buffer. By default the size of the cyclic buffer is 512 events.
   */
  public
  void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
    cb.resize(bufferSize);
  }
  
  /**
     The <b>SMTPHost</b> option takes a string value which should be a
     the host name of the SMTP server that will send the e-mail message.
   */
  public
  void setSMTPHost(String smtpHost) {
    this.smtpHost = smtpHost;
  }
  
  /**
     Returns value of the <b>SMTPHost</b> option.
   */
  public
  String getSMTPHost() {
    return smtpHost;
  }

  /**
     The <b>To</b> option takes a string value which should be a
     comma separated list of e-mail address of the recipients.
   */
  public
  void setTo(String to) {
    this.to = to;
  }

  

  /**
     Returns value of the <b>BufferSize</b> option.
   */
  public
  int getBufferSize() {
    return bufferSize;
  }
  
  /**
     The <b>EvaluatorClass</b> option takes a string value
     repsenting the name of the class implementing the {@link
     TriggeringEventEvaluator} interface. A corresponding object will
     be instantiated and assigned as the triggering event evaluator
     for the SMTPAppender.
   */
  public
  void setEvaluatorClass(String value) {
      evaluator = (TriggeringEventEvaluator) 
                OptionConverter.instantiateByClassName(value, 
					   TriggeringEventEvaluator.class,
						       evaluator);    
  }
  
  
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no effort
     to extract the location information related to the event. As a
     result, the layout that formats the events as they are sent out
     in an e-mail is likely to place the wrong location information
     (if present in the format).
     
     <p>Location information extraction is comparatively very slow and
     should be avoided unless performance is not a concern.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
}

class DefaultEvaluator implements TriggeringEventEvaluator {
  /**
     Is this <code>event</code> the e-mail triggering event?
     
     <p>This method returns <code>true</code>, if the event priority
     has ERROR priority or higher. Otherwisem it returns
     <code>false</code>. */
  public 
  boolean isTriggeringEvent(LoggingEvent event) {
    return event.priority.isGreaterOrEqual(Priority.ERROR); 
  }
}
"
org/apache/log4j/net/test/SMTPMin.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net.test;

import org.apache.log4j.*;
import java.io.IOException;
import java.io.InputStreamReader;

public class SMTPMin {
  
  static Category cat = Category.getInstance(SMTPMin.class);

  public 
  static 
  void main(String argv[]) {
    if(argv.length == 1) 
      init(argv[0]);
    else 
      usage(""Wrong number of arguments."");     
    
    NDC.push(""some context"");
    test();
  }

  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + SMTPMin.class.getName()
		       + "" configFile"");
    System.exit(1);
  }

  static
  void init(String configFile) {
    PropertyConfigurator.configure(configFile);
  }


  static
  void test() {
    int i  = 0;
    cat.debug( ""Message "" + i++);
    cat.debug(""Message "" + i++,  new Exception(""Just testing.""));
    cat.info( ""Message "" + i++);
    cat.warn( ""Message "" + i++);
    cat.error( ""Message "" + i++);
    cat.log(Priority.FATAL, ""Message "" + i++);
    Category.shutdown();
    Thread.currentThread().getThreadGroup().list();
  }
  
}
"
org/apache/log4j/performance/NewVsSetLen.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.performance;

/**

   This program compares the cost of creating a new StringBuffer and
   converting it to a String versus keeping the same StringBuffer,
   setting its size to zero and then converting it to String.

   <p>The table below gives some figures.

<p>   <table border=""1"" cellpadding=""4"">
   <tr BGCOLOR=""#33CCFF"">
     <th BGCOLOR=""#CCCCCC"" rowspan=""2"">Total Message length
     <th colspan=""2"" align=""center"">0
     <th colspan=""2"" align=""center"">1
     <th colspan=""2"" align=""center"">2
     <th colspan=""2"" align=""center"">4
     <th colspan=""2"" align=""center"">8
   </tr>

   <tr BGCOLOR=""#3366FF"">
     <td>New Buffer</td> <td>setLength</td> 
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
     <td>New Buffer</td> <td>setLength</td>
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">256 
   <td>33 <td>22 
   <td>34 <td>22
   <td>34 <td>22
   <td>34 <td>22 
   <td>33 <td>23
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1024 
   <td>58 <td>41
   <td>59 <td>45
   <td>59 <td>48
   <td>59 <td>51 
   <td>60 <td>44
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">4096 
   <td>146 <td>132
   <td>138 <td>132
   <td>144 <td>126
   <td>142 <td>132
   <td>136 <td>132 
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">16384 
   <td>617 <td>593 
   <td>593 <td>609
   <td>601 <td>617
   <td>601 <td>632 
   <td>593 <td>632
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">65536 
   <td>3218 <td>3281
   <td>3093 <td>3125 
   <td>3125 <td>3156
   <td>3125 <td>3281 
   <td>3062 <td>3562
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">262144 
   <td>14750 <td>15125
   <td>14000 <td>15500 
   <td>14000 <td>16125 
   <td>14000 <td>18000 
   <td>14000 <td>21375 
   </tr>

   <tr align=""right""> 
   <td BGCOLOR=""#CCCCCC"">1048576 
   <td>87500 <td>80000
   <td>60500 <td>82000 
   <td>57000 <td>93000 
   <td>57500 <td>118500 
   <td>57500 <td>168500 
   </tr>

   <caption ALIGN=""BOTTOM"">Performance comparisons of new buffer
   creation versus setLength(0) approach for various message sizes and
   secondary loop lengths.
   </caption>
   </table>

   <p>The tests copy a message to a destination string buffer and then
   copy a 256 character buffer to another buffer the number of times
   as specified by the secondary loop length.


   <p>The <code>setLength(0)</code> method is usually faster. However,
   after copying a large string it becomes slow even when copying
   small strings.


   <p>This is due to a peculiarity in the <code>copy</code> method in
   StringBuffer class which creates a character array of the same
   length as the old buffer even if the vast majority of those
   characters are unused. 

   <p>The tests were performed on Linux using IBM's JDK 1.1.8.

   <p>The test script is a crude model of what might happen in
   reality. If you remain unconvinced of its results, then please send
   your alternative measurement scenario.

   

   
*/
public class NewVsSetLen {

  static String s;

  static int BIGBUF_LEN = 1048576;
  static int SBUF_LEN = 256;
  static int RUN_LENGTH = BIGBUF_LEN/4;

  static char[] sbuf = new char[SBUF_LEN];
  static char[] bigbuf = new char[BIGBUF_LEN];

  {
    for(int i = 0; i < SBUF_LEN; i++) {
      sbuf[i] = (char) (i);
    }

    for(int i = 0; i < BIGBUF_LEN; i++) {
      bigbuf[i] = (char) (i);
    }
  }


  static
  public 
  void main(String[] args) {    
 
    int t;

    for(int len = SBUF_LEN; len <= BIGBUF_LEN; len*=4, RUN_LENGTH /= 4) {
      System.out.println(""<td>""+len+""\n"");
      for(int second = 0; second < 16;) {
	System.out.println(""SECOND loop=""+second +"", RUN_LENGTH=""
			   +RUN_LENGTH+"", len=""+len);
	t = (int)newBuffer(len, second);;

	System.out.print(""<td>"" + t);
	t = (int)setLen(len, second);
	System.out.println("" <td>"" + t + "" \n"");
	if(second == 0) {
	  second = 1;
	} else {
	  second *= 2;
	}
      }
    }
    
  }

  static
  double newBuffer(int size, int second) {    
    long before = System.currentTimeMillis();

    for(int i = 0; i < RUN_LENGTH; i++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
    }

    for(int x = 0; x <  second; x++) {
      StringBuffer buf = new StringBuffer(SBUF_LEN);
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double setLen(int size, int second) {
    long before = System.currentTimeMillis();

    StringBuffer buf = new StringBuffer(SBUF_LEN);

    for(int i = 0; i < RUN_LENGTH; i++) {
      buf.append(sbuf, 0, sbuf.length);
      buf.append(bigbuf, 0, size);
      s = buf.toString();
      buf.setLength(0);
    }

    for(int x = 0; x < second; x++) {
      buf.append(sbuf, 0, SBUF_LEN);
      s = buf.toString();
      buf.setLength(0);
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org/apache/log4j/helpers/PatternConverter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import org.apache.log4j.spi.LoggingEvent;

/**

   <p>PatternConverter is an abtract class that provides the
   formatting functionality that derived classes need.

   <p>Conversion specifiers in a conversion patterns are parsed to
   individual PatternConverters. Each of which is responsible for
   converting a logging event in a converter specific manner.

   @author <a href=""mailto:cakalijp@Maritz.com"">James P. Cakalic</a>
   @author Ceki G&uuml;lc&uuml;

   @since 0.8.2
 */
public abstract class PatternConverter {
  public PatternConverter next;
  int min = -1;
  int max = 0x7FFFFFFF;
  boolean leftAlign = false;

  protected
  PatternConverter() {  }
  
  protected
  PatternConverter(FormattingInfo fi) {
    min = fi.min;
    max = fi.max;
    leftAlign = fi.leftAlign;
  }

  /**
     Derived pattern converters must override this method in order to
     convert conversion specifiers in the correct way.
  */
  abstract
  protected
  String convert(LoggingEvent event);

  /**
     A template method for formatting in a converter specific way.
   */
  public
  void format(StringBuffer sbuf, LoggingEvent e) {
    String s = convert(e);

    if(s == null) {
      if(0 < min)
	spacePad(sbuf, min);
      return;
    }

    int len = s.length();

    if(len > max)
      sbuf.append(s.substring(len-max));
    else if(len < min) {
      if(leftAlign) {	
	sbuf.append(s);
	spacePad(sbuf, min-len);
      }
      else {
	spacePad(sbuf, min-len);
	sbuf.append(s);
      }
    }
    else
      sbuf.append(s);
  }	

  static String[] SPACES = {"" "", ""  "", ""    "", ""        "", //1,2,4,8 spaces
			    ""                "", // 16 spaces
			    ""                                "" }; // 32 spaces

  /**
     Fast space padding method.
  */
  public
  void spacePad(StringBuffer sbuf, int length) {
    while(length >= 32) {
      sbuf.append(SPACES[5]);
      length -= 32;
    }
    
    for(int i = 4; i >= 0; i--) {	
      if((length & (1<<i)) != 0) {
	sbuf.append(SPACES[i]);
      }
    }
  }
}
"
org/apache/log4j/test/PrintProperties.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */

package org.apache.log4j.test;

import java.io.*;
import org.apache.log4j.config.PropertyPrinter;

/**
   Prints the configuration of the log4j default hierarchy
   (which needs to be auto-initialized) as a propoperties file
   on System.out.
   
   @author  Anders Kristensen
 */
public class PrintProperties {
  public
  static
  void main(String[] args) {
    new PropertyPrinter(new PrintWriter(System.out), true);
  }
}"
org/apache/log4j/spi/AppenderAttachable.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.Appender;
import java.util.Enumeration;

/**
   Interface for attaching appenders to objects.

   @author Ceki G&uuml;lc&uuml;
   @since 0.9.1 */
public interface AppenderAttachable {
  
  /**
     Add an appender.
   */
  public
  void addAppender(Appender newAppender);

  /**
     Get all previously added appenders as an Enumeration.  */
  public
  Enumeration getAllAppenders();

  /**
     Get an appender by name.
   */
  public
  Appender getAppender(String name);

  /**
     Remove all previously added appenders.
  */
  void removeAllAppenders();


  /**
     Remove the appender passed as parameter from the list of appenders.
  */
   void removeAppender(Appender appender);


 /**
    Remove the appender with the name passed as parameter from the
    list of appenders.  
  */
 void
 removeAppender(String name);   
}

"
org/apache/log4j/config/PropertyGetter.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.
 */

package org.apache.log4j.config;

import java.beans.*;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import org.apache.log4j.Appender;
import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;


/**
   Used for inferring configuration information for a log4j's component.
   
   @author  Anders Kristensen
 */
public class PropertyGetter {
  protected static final Object[] NULL_ARG = new Object[] {};
  protected Object obj;
  protected PropertyDescriptor[] props;
  
  public interface PropertyCallback {
    void foundProperty(Object obj, String prefix, String name, Object value);
  }
  
  /**
    Create a new PropertySetter for the specified Object. This is done
    in prepartion for invoking {@link
    #getProperties(PropertyGetter.PropertyCallback, String)} one or
    more times.
    
    @param obj the object for which to set properties */
  public
  PropertyGetter(Object obj) throws IntrospectionException {
    BeanInfo bi = Introspector.getBeanInfo(obj.getClass());
    props = bi.getPropertyDescriptors();
    this.obj = obj;
  }
  
  public
  static
  void getProperties(Object obj, PropertyCallback callback, String prefix) {
    try {
      new PropertyGetter(obj).getProperties(callback, prefix);
    } catch (IntrospectionException ex) {
      LogLog.error(""Failed to introspect object "" + obj, ex);
    }
  }
  
  public
  void getProperties(PropertyCallback callback, String prefix) {
    for (int i = 0; i < props.length; i++) {
        Method getter = props[i].getReadMethod();
        if (getter == null) continue;
        if (!isHandledType(getter.getReturnType())) {
          //System.err.println(""Ignoring "" + props[i].getName() +"" "" + getter.getReturnType());
          continue;
        }
        String name = props[i].getName();
        try {
          Object result = getter.invoke(obj, NULL_ARG);
          //System.err.println(""PROP "" + name +"": "" + result);
          if (result != null) {
            callback.foundProperty(obj, prefix, name, result);
          }
        } catch (Exception ex) {
          LogLog.warn(""Failed to get value of property "" + name);
        }
    }
  }
  
  protected
  boolean isHandledType(Class type) {
    return String.class.isAssignableFrom(type) ||
           Integer.TYPE.isAssignableFrom(type) ||
           Long.TYPE.isAssignableFrom(type)    ||
           Boolean.TYPE.isAssignableFrom(type) ||
           Priority.class.isAssignableFrom(type);
  }
}
"
org/apache/log4j/net/JMSSink.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.or.MessageRenderer;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;

import javax.jms.*;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;

/**
   A simple application receiving the logging events sent by a JMSAppender.
   

   @author Ceki G&uuml;lc&uuml;
*/
public class JMSSink  {

  static public void main(String[] args) {
    if(args.length != 3) {
      usage(""Wrong number of arguments."");     
    }

    String tcfBindingName = args[0];
    String topicBindingName = args[1];
    PropertyConfigurator.configure(args[2]);

    Category.getDefaultHierarchy().addRenderer(Message.class, 
					       new MessageRenderer());

    try {
      Context ctx = new InitialContext();      
      TopicConnectionFactory topicConnectionFactory;
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, 
							       tcfBindingName);

      TopicConnection topicConnection = 
	                        topicConnectionFactory.createTopicConnection(); 
      topicConnection.start();
    
      TopicSession topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);

      Topic topic = (Topic)ctx.lookup(topicBindingName);

      //TopicSubscriber topicSubscriber = topicSession.createSubscriber(topic);
      TopicSubscriber topicSubscriber = 
           topicSession.createDurableSubscriber(topic, ""x"");

      
      LoggingEvent event;
      Category remoteCategory;    

      while(true) {
	ObjectMessage msg = (ObjectMessage)topicSubscriber.receive();      
	event = (LoggingEvent) msg.getObject();
	remoteCategory = Category.getInstance(event.categoryName);
	remoteCategory.callAppenders(event);	
	
	// dump the JMSMessage
	// remoteCategory.debug(msg);

      }
    } catch(Exception e) {
      LogLog.error(""Could not read JMS message."", e);
    }
  }


  protected
  static
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }  


  static
  void usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java "" + JMSSink.class.getName()
            + "" TopicConnectionFactoryBindingName TopicBindingName configFile"");
    System.exit(1);
  }
}
"
org/apache/log4j/helpers/LogLog.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

/**
   This class used to output log statements from within the log4j package.

   <p>Log4j components cannot make log4j logging calls. However, it is
   sometimes useful for the user to learn about what log4j is
   doing. You can enable log4j internal logging by defining the
   <b>log4j.configDebug</b> variable.

   <p>All log4j internal debug calls go to <code>System.out</code>
   where as internal error messages are sent to
   <code>System.err</code>. All internal messages are prepended with
   the string ""log4j: "".
   
   @since 0.8.2
   @author Ceki G&uuml;lc&uuml;
*/
public class LogLog {

  /**
     Defining this value makes log4j print log4j-internal debug
     statements to <code>System.out</code>.
     
    <p> The value of this string is <b>log4j.debug</b>.
    
    <p>Note that the search for all option names is case sensitive.  */
  public static final String DEBUG_KEY=""log4j.debug"";

 
  /**
     Defining this value makes log4j components print log4j-internal
     debug statements to <code>System.out</code>.
     
    <p> The value of this string is <b>log4j.configDebug</b>.
    
    <p>Note that the search for all option names is case sensitive.  

    @deprecated Use {@link #DEBUG_KEY} instead.
  */
  public static final String CONFIG_DEBUG_KEY=""log4j.configDebug"";

  protected static boolean debugEnabled = false;  

  /**
     In quietMode not even errors generate any output.
   */
  private static boolean quietMode = false;

  private static final String PREFIX = ""log4j: "";
  private static final String ERR_PREFIX = ""log4j:ERROR "";
  private static final String WARN_PREFIX = ""log4j:WARN "";

  static {
    String key = OptionConverter.getSystemProperty(DEBUG_KEY, null);

    if(key == null) {
      key = OptionConverter.getSystemProperty(CONFIG_DEBUG_KEY, null);
    }

    if(key != null) { 
      debugEnabled = OptionConverter.toBoolean(key, true);
    }
  }

  /**
     Allows to enable/disable log4j internal logging.
   */
  static
  public
  void setInternalDebugging(boolean enabled) {
    debugEnabled = enabled;
  }

  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
    }
  }

  /**
     This method is used to output log4j internal debug
     statements. Output goes to <code>System.out</code>.
  */
  public
  static
  void debug(String msg, Throwable t) {
    if(debugEnabled && !quietMode) {
      System.out.println(PREFIX+msg);
      if(t != null)
	t.printStackTrace(System.out);
    }
  }
  

  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.
  */
  public
  static
  void error(String msg) {
    if(quietMode)
      return;
    System.err.println(ERR_PREFIX+msg);
  }  

  /**
     This method is used to output log4j internal error
     statements. There is no way to disable error statements.
     Output goes to <code>System.err</code>.  
  */
  public
  static
  void error(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(ERR_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  

  /**
     In quite mode no LogLog generates strictly no output, not even
     for errors. 

     @param quietMode A true for not
  */
  public
  static
  void setQuietMode(boolean quietMode) {
    LogLog.quietMode = quietMode;
  }

  /**
     This method is used to output log4j internal warning
     statements. There is no way to disable warning statements.
     Output goes to <code>System.err</code>.  */
  public
  static
  void warn(String msg) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
  }  

  /**
     This method is used to output log4j internal warnings. There is
     no way to disable warning statements.  Output goes to
     <code>System.err</code>.  */
  public
  static
  void warn(String msg, Throwable t) {
    if(quietMode)
      return;

    System.err.println(WARN_PREFIX+msg);
    if(t != null) {
      t.printStackTrace();
    }
  }  
}
"
org/apache/log4j/performance/Logging.java,true,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.

//      Copyright 2000, Ceki Gulcu. All Rights Reserved.

//      See the LICENCE file for the terms of distribution.

package org.apache.log4j.performance;

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.Appender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.net.SocketAppender;
import org.apache.log4j.FileAppender;

import org.apache.log4j.Priority;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.NDC;
import org.apache.log4j.performance.NOPWriter;

import java.util.Enumeration;

/**
   Measure the performance of logging.

   <p>Experimental results are listed below in units of
   <b>micro-seconds</b>. Measurements were done on a AMD Duron clocked
   at 800Mhz running Windows 2000 and Sun's 1.3 JDK.

<p><table border=1>

<tr>
<th>Layout 
<th>NullAppender 
<th>FileAppender
<th>FileAppender (no flush)
<th>AsyncAppender (no flush)

<tr>
<td>SimpleLayout 
<td>4
<td>21
<td>16
<td>31

<tr>
<td>PatternLayout ""%p - %m%n"" 
<td>4
<td>21
<td>16
<td>31

<tr>
<td>PatternLayout ""%-5p - %m%n""
<td>4
<td>NA
<td>NA
<td>NA

<tr>
<td>TTCCLayout/RELATIVE
<td>10
<td>37
<td>31
<td>45

<tr>
<td>PatternLayout ""%r [%t] %-5p %c{2} %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA

<tr>
<td>PatternLayout ""%r [%t] %-5p %.10c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA

<tr>
<td>PatternLayout ""%r [%t] %-5p %.20c %x - %m%n""
<td>11
<td>NA
<td>NA
<td>NA

<tr>
<td>PatternLayout ""%r [%t] %-5p %c - %m%n""
<td>9
<td>36
<td>29
<td>45

<tr>
<td>TTCCLayout/ISO8601
<td>25
<td>58
<td>51
<td>68

<tr>
<td>PatternLayout ""%d{ISO8601} [%t] %-5p %c %x - %m%n""
<td>28
<td>62
<td>55
<td>73

<tr>
<td>PatternLayout ""%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] %-5p %c %x - %m%n""
<td>46
<td>82
<td>72
<td>91

<tr>
<td>PatternLayout ""%l - %m%n""
<td> 1353
<td> 1565
<td> 1474 
<td> 1459 

<tr>
<td>PatternLayout ""%C.%M.%L - %m%n""
<td>1379 
<td>NA
<td>NA
<td>NA

</table>

   <p>The results of the measurements (should) show that:

   <ol>

   <li><b>The PatternLayout perforance is very close to the performance of
   a dedicated layout of equivalent format.</b>

   <p><li>Format specifiers in conversion patterns have almost no impact
   on performance.

   <p>Formating time and date information is costly. Using relative
   time has the least impact on performance. It is recommended that to
   use log4j specific date formatters such as the {@link
   org.apache.log4j.helpers.ISO8601DateFormat} instead of the standard {@link
   java.text.SimpleDateFormat} because of its poor performance. See
   the <b>%d</b> conversion character in {@link
   org.apache.log4j.PatternLayout}.
   
   <p><li>Avoiding the flush operation at the end of each append
   results in a performance gain of 10 to 20 percent. However, there
   is safety tradeoff invloved in skipping flushing. Indeed, when
   flushing is skipped, then it is likely that the last few log events
   will not be recorded on disk when the application exits. This is a
   high price to pay even for a 20% performance gain.

   <p><li>The <code>AsyncAppender</code> does not automatically
   increase performance. On the contrary, it significantly degrades
   performance. The performance tests done here very quickly fill up
   the bounded buffer of the <code>AsyncAppender</code> and there is
   cosiderable overhead in managing this bounded buffer.
   
   <p>On the other hand, had we interleaved logging operations with
   long blocking and non CPU-intensive operations, such as I/O,
   network access, sleeping threads, then the
   <code>AsyncAppender</code> would have tremendously reduced the cost
   of logging in terms of overall application runtime.

   <p>In a variant of this test, we have inserted a short sleep
   operation between every 10 log operations. When the total slept
   time is substracted, logging with the <code>AsyncLogger</code>
   takes no time at all. In other words, logging is done for ""free"".

   <p><li>Extracting location information is (comparatively) very
   slow. It should be avoided unless performace is not a concern.

   </ol>

   @author Ceki G&uuml;lc&uuml;

 */
public class Logging {

  static int runLength;
  static int delay = -1;
  /**
     A delay is applied after every <code>burstLen</code> log
     requests.  The default value of this constant is 100.  */
  static  int burstLen = 100;
  static int DELAY_MULT = 1000/burstLen;
  
  static Category cat = Category.getInstance(""A0123456789.B0123456789.C0123456789"");

  static
  void  Usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java ""+Logging.class.getName()+"" confFile runLength [delay] [burstLen]\n""+
      ""        confFile is an XML configuration file and\n""+
      ""        runLength (integer) is the length of test loop.\n""+
      ""        delay is the time in millisecs to wait every bustLen log requests."");
    System.exit(1);
  }

  /**
     <b>Usage:</b> <code>java org.apache.log4j.performance.Logging confFile runLength [delay] [burstLen]</code>

     <p><code>confFile</code> is an XML configuration file and
      <code>runLength</code> (integer) is the length of test loop,
      <code>delay</code> is the time in millisecs to sleep every
      <code>bustLen</code> log requests.

      <p>This application just prints the average time it took to log.


   */
  public static void main(String argv[]) {

    if(argv.length == 2)
      init(argv[0], argv[1], null, null);
    else if( argv.length == 4)
      init(argv[0], argv[1], argv[2], argv[3]);
    else
      Usage(""Wrong number of arguments."");

    
    NDC.push(""some context"");

    double delta;
    String msg = ""ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890"";
     if(delay <= 0) 
      delta = NoDelayLoop(cat, msg);
    else
      delta = DelayedLoop(cat, msg);
		
    System.out.print((int)delta); 

    Category.shutdown();

  }
  
  /**
    Program wide initialization method.
    */
  static
  void init(String configFile, String runLengthStr, String delayStr, 
	    String burstLenStr) {
    try {
      runLength   = Integer.parseInt(runLengthStr);
      if(delayStr != null) {
	delay = Integer.parseInt(delayStr);
      }
      if(delayStr != null) {
	burstLen = Integer.parseInt(burstLenStr);
	DELAY_MULT = 1000/burstLen;	
      }      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
    }      
    DOMConfigurator.configure(configFile);
  }
  
  static
  double NoDelayLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
    }
    return ((System.currentTimeMillis() - before)*1000.0)/runLength;    
  }

  static
  double DelayedLoop(Category category, String msg) { 
    long before = System.currentTimeMillis();
    int j = 0;
    Thread currentThread = Thread.currentThread();
    for(int i = 0; i < runLength; i++) {
      category.info(msg);
      if(j++ == burstLen) {
	j = 0;
	try{currentThread.sleep(delay);}catch(Exception e){}
      }
      
    }
    double actualTime = ((System.currentTimeMillis()-before)*1000.0/runLength);
    System.out.println(""actual time: ""+actualTime);
    return (actualTime - delay*DELAY_MULT); 
  }  
}
"
org/apache/log4j/test/Min.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.Layout;
import org.apache.log4j.Appender;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.net.SyslogAppender;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.TTCCLayout;
import org.apache.log4j.Priority;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.helpers.AbsoluteTimeDateFormat;
import java.io.IOException;

/**
   This class tests the functionality of the Log class and the
   different layouts.

   @author  Ceki G&uuml;lc&uuml;
*/
public class Min {

  public 
  static 
  void main(String argv[]) {

      if(argv.length == 1) {
	ProgramInit(argv[0]);
      }
      else {
	Usage(""Wrong number of arguments."");
      }
      test1();
  }


  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java org.apache.log4j.test.Min "" +
			""simple|ttcc"");
    System.exit(1);
  }


  /**
    Program wide initialization method.
    */

  static
  void ProgramInit(String layoutType) {

    Appender appender = null;	
    Layout layout = null;
        
    if(layoutType.equals(""simple"")) 
      layout = new SimpleLayout();
    else if(layoutType.equals(""ttcc"")) {
      layout = new TTCCLayout(AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT);
    }
    else 
      Usage(""Wrong layoutType ["" + layoutType +""]."");


    appender = new ConsoleAppender(layout, ""System.out"");
    BasicConfigurator.configure(appender);
  }

  
  static
  void test1() {

    int i = 0;

    // In the lines below, the category names are chosen as an aid in
    // remembering their priority values. In general, the category
    // names should have no bearing to priority values.
    
    Category ERR = Category.getInstance(""ERR"");
    ERR.setPriority(Priority.ERROR);
    Category INF = Category.getInstance(""INF"");
    INF.setPriority(Priority.INFO);
    Category INF_ERR = Category.getInstance(""INF.ERR"");
    INF_ERR.setPriority(Priority.ERROR);
    Category DEB = Category.getInstance(""DEB"");
    DEB.setPriority(Priority.DEBUG);
    
    // Note: categories with undefined priority 
    Category INF_UNDEF = Category.getInstance(""INF.UNDEF"");
    Category INF_ERR_UNDEF = Category.getInstance(""INF.ERR.UNDEF"");    
    Category UNDEF = Category.getInstance(""UNDEF"");   


    // These should all log.----------------------------
    ERR.log(Priority.FATAL, ""Message "" + i); i++;  //0
    ERR.error( ""Message "" + i); i++;          

    INF.log(Priority.FATAL, ""Message "" + i); i++; // 2
    INF.error( ""Message "" + i); i++;         
    INF.warn ( ""Message "" + i); i++; 
    INF.info ( ""Message "" + i); i++;

    INF_UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  //6
    INF_UNDEF.error( ""Message "" + i); i++;         
    INF_UNDEF.warn ( ""Message "" + i); i++; 
    INF_UNDEF.info ( ""Message "" + i); i++; 
    
    
    INF_ERR.log(Priority.FATAL, ""Message "" + i); i++;  // 10
    INF_ERR.error( ""Message "" + i); i++;  

     INF_ERR_UNDEF.log(Priority.FATAL, ""Message "" + i); i++; 
    INF_ERR_UNDEF.error( ""Message "" + i); i++;             

    DEB.log(Priority.FATAL, ""Message "" + i); i++;  //14
    DEB.error( ""Message "" + i); i++;         
    DEB.warn ( ""Message "" + i); i++; 
    DEB.info ( ""Message "" + i); i++; 
    DEB.debug( ""Message "" + i); i++; 

    
    // defaultPriority=DEBUG
    UNDEF.log(Priority.FATAL, ""Message "" + i); i++;  // 19
    UNDEF.error(""Message "" + i); i++;         
    UNDEF.warn (""Message "" + i); i++; 
    UNDEF.info (""Message "" + i); i++; 
    UNDEF.debug(""Message "" + i, new Exception(""Just testing."")); i++;    

    // -------------------------------------------------
    // The following should not log
    ERR.warn(""Message "" + i);  i++; 
    ERR.info(""Message "" + i);  i++; 
    ERR.debug(""Message "" + i);  i++; 
      
    INF.debug(""Message "" + i);  i++; 
    INF_UNDEF.debug(""Message "" + i); i++; 


    INF_ERR.warn(""Message "" + i);  i++; 
    INF_ERR.info(""Message "" + i);  i++; 
    INF_ERR.debug(""Message "" + i); i++; 
    INF_ERR_UNDEF.warn(""Message "" + i);  i++; 
    INF_ERR_UNDEF.info(""Message "" + i);  i++; 
    INF_ERR_UNDEF.debug(""Message "" + i); i++; 
    // -------------------------------------------------
      
    INF.info(""Messages should bear numbers 0 through 23."");
  }     
}
"
org/apache/log4j/helpers/OptionConverter.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import java.util.Properties;
import java.net.URL;
import org.apache.log4j.Category;
import org.apache.log4j.Hierarchy;
import org.apache.log4j.Priority;
import org.apache.log4j.spi.Configurator;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.log4j.PropertyConfigurator;

// Contributors:   Avy Sharell (sharell@online.fr)
//                 Anders Kristensen
//                 Matthieu Verbert (mve@zurich.ibm.com)


/**
   A convenience class to convert property values to specific types.

   @author Ceki G&uuml;lc&uuml;
   @author Simon Kitching;
*/	
public class OptionConverter {

  static String DELIM_START = ""${"";
  static char   DELIM_STOP  = '}';
  static int DELIM_START_LEN = 2;
  static int DELIM_STOP_LEN  = 1;
  
  static StringBuffer sbuf = new StringBuffer();

  /** OptionConverter is a static class. */
  private OptionConverter() {}
  
  public
  static
  String[] concatanateArrays(String[] l, String[] r) {
    int len = l.length + r.length;
    String[] a = new String[len];

    System.arraycopy(l, 0, a, 0, l.length);
    System.arraycopy(r, 0, a, l.length, r.length);

    return a;
  }
  
  public
  static
  String convertSpecialChars(String s) {
    char c;
    int len = s.length();
    StringBuffer sbuf = new StringBuffer(len);
    
    int i = 0;
    while(i < len) {
      c = s.charAt(i++);
      if (c == '\\') {
	c =  s.charAt(i++);
	if(c == 'n')      c = '\n';
	else if(c == 'r') c = '\r';
	else if(c == 't') c = '\t';
	else if(c == 'f') c = '\f';
	else if(c == '\b') c = '\b';					
	else if(c == '\""') c = '\""';				
	else if(c == '\'') c = '\'';			
	else if(c == '\\') c = '\\';			
      }
      sbuf.append(c);      
    }
    return sbuf.toString();
  }


  /**
     Very similar to <code>System.getProperty</code> except
     that the {@link SecurityException} is hidden.

     @param key The key to search for.
     @param def The default value to return.
     @return the string value of the system property, or the default
     value if there is no property with that key.

     @since 1.1 */
  public
  static
  String getSystemProperty(String key, String def) {
    try {
      return System.getProperty(key, def);
    } catch(Throwable e) { // MS-Java throws com.ms.security.SecurityExceptionEx 
      LogLog.debug(""Was not allowed to read system property \""""+key+""\""."");
      return def;
    }
  }

  
  public
  static
  Object instantiateByKey(Properties props, String key, Class superClass,
				Object defaultValue) {

    // Get the value of the property in string form
    String className = findAndSubst(key, props);
    if(className == null) {
      LogLog.error(""Could not find value for key "" + key);
      return defaultValue;
    }
    // Trim className to avoid trailing spaces that cause problems.
    return OptionConverter.instantiateByClassName(className.trim(), superClass,
						  defaultValue);
  }

  /**
     If <code>value</code> is ""true"", then <code>true</code> is
     returned. If <code>value</code> is ""false"", then
     <code>true</code> is returned. Otherwise, <code>default</code> is
     returned.

     <p>Case of value is unimportant.  */
  public
  static
  boolean toBoolean(String value, boolean dEfault) {
    if(value == null)
      return dEfault;
    String trimmedVal = value.trim();
    if(""true"".equalsIgnoreCase(trimmedVal)) 
      return true;
    if(""false"".equalsIgnoreCase(trimmedVal))
      return false;
    return dEfault;
  }

  public
  static
  int toInt(String value, int dEfault) {
    if(value != null) {
      String s = value.trim();
      try {
	return Integer.valueOf(s).intValue();
      }
      catch (NumberFormatException e) {
	 LogLog.error(""["" + s + ""] is not in proper int form."");
	e.printStackTrace();
      }
    }
    return dEfault;
  }

  /**
     Converts a standard or custom priority level to a Priority
     object.  <p> If <code>value</code> is of form
     ""priority#classname"", then the specified class' toPriority method
     is called to process the specified priority string; if no '#'
     character is present, then the default {@link org.apache.log4j.Priority}
     class is used to process the priority value.  

     <p> If any error occurs while converting the value to a priority,
     the dflt value (which may be null) is returned.  

     <p> Case of
     value is unimportant for the priority level, but is significant
     for any class name part present.  
     
     @since 1.1
  */
  public
  static
  Priority toPriority(String value, Priority defaultValue) {
    if(value == null)
      return defaultValue;

    int hashIndex = value.indexOf('#');
    if (hashIndex == -1) {
      // no class name specified : use standard Priority class
      return Priority.toPriority(value, defaultValue);
    }

    Priority result = defaultValue;

    String clazz = value.substring(hashIndex+1);
    String priorityName = value.substring(0, hashIndex);

    LogLog.debug(""toPriority"" + "":class=["" + clazz + ""]"" 
		 + "":pri=["" + priorityName + ""]"");

    try {
      Class customPriority = Class.forName(clazz);

      // get a ref to the specified class' static method
      // toPriority(String, org.apache.log4j.Priority)
      Class[] paramTypes = new Class[] { String.class,
					 org.apache.log4j.Priority.class
                                       };
      java.lang.reflect.Method toPriorityMethod =
                      customPriority.getMethod(""toPriority"", paramTypes);

      // now call the toPriority method, passing priority string + default
      Object[] params = new Object[] {priorityName, defaultValue};
      Object o = toPriorityMethod.invoke(null, params);

      result = (Priority) o;
    } catch(ClassNotFoundException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""] not found."");
    } catch(NoSuchMethodException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
        + "" does not have a constructor which takes one string parameter"", e);
    } catch(java.lang.reflect.InvocationTargetException e) {
      LogLog.warn(""custom priority class ["" + clazz + ""]""
		   + "" could not be instantiated"", e);
    } catch(ClassCastException e) {
      LogLog.warn(""class ["" + clazz
        + ""] is not a subclass of org.apache.log4j.Priority"", e);
    } catch(IllegalAccessException e) {
      LogLog.warn(""class [""+clazz+
		   ""] cannot be instantiated due to access restrictions"", e);
    } catch(Exception e) {
      LogLog.warn(""class [""+clazz+""], priority [""+priorityName+
		   ""] conversion failed."", e);
    }
    return result;
   }
 
  public
  static
  long toFileSize(String value, long dEfault) {
    if(value == null)
      return dEfault;
    
    String s = value.trim().toUpperCase();
    long multiplier = 1;
    int index;
    
    if((index = s.indexOf(""KB"")) != -1) {      
      multiplier = 1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""MB"")) != -1) {
      multiplier = 1024*1024;
      s = s.substring(0, index);
    }
    else if((index = s.indexOf(""GB"")) != -1) {
      multiplier = 1024*1024*1024;
      s = s.substring(0, index);
    }    
    if(s != null) {
      try {
	return Long.valueOf(s).longValue() * multiplier;
      }
      catch (NumberFormatException e) {
	LogLog.error(""["" + s + ""] is not in proper int form."");
	LogLog.error(""["" + value + ""] not in expected format."", e);
      }
    }
    return dEfault;
  }

  /**
     Find the value corresponding to <code>key</code> in
     <code>props</code>. Then perform variable substitution on the
     found value.

 */
  public
  static
  String findAndSubst(String key, Properties props) {
    String value = props.getProperty(key);
    if(value == null) 
      return null;      
    
    try {
      return substVars(value, props);
    } catch(IllegalArgumentException e) {
      LogLog.error(""Bad option value [""+value+""]."", e);
      return value;
    }    
  }
   
  /**
     Instantiate an object given a class name. Check that the
     <code>className</code> is a subclass of
     <code>superClass</code>. If that test fails or the object could
     not be instantiated, then <code>defaultValue</code> is returned.

     @param className The fully qualified class name of the object to instantiate.
     @param superClass The class to which the new object should belong.
     @param defaultValue The object to return in case of non-fulfillment
   */
  public
  static
  Object instantiateByClassName(String className, Class superClass,
				Object defaultValue) {
    if(className != null) {
      try {
	Class classObj = Class.forName(className);
	if(!superClass.isAssignableFrom(classObj)) {
	  LogLog.error(""A \""""+className+""\"" object is not assignable to a \""""+
		       superClass.getName() + ""\"" variable."");
	  return defaultValue;	  
	}
	return classObj.newInstance();
      }
      catch (Exception e) {
	LogLog.error(""Could not instantiate class ["" + className + ""]."", e);
      }
    }
    return defaultValue;    
  }


  /**
     Perform variable substitution in string <code>val</code> from the
     values of keys found in the system propeties.

     <p>The variable substitution delimeters are <b>${</b> and <b>}</b>.
     
     <p>For example, if the System properties contains ""key=value"", then
     the call
     <pre>
     String s = OptionConverter.substituteVars(""Value of key is ${key}."");
     </pre>
  
     will set the variable <code>s</code> to ""Value of key is value."".

     <p>If no value could be found for the specified key, then the
     <code>props</code> parameter is searched, if the value could not
     be found there, then substitution defaults to the empty string.

     <p>For example, if system propeties contains no value for the key
     ""inexistentKey"", then the call

     <pre>
     String s = OptionConverter.subsVars(""Value of inexistentKey is [${inexistentKey}]"");
     </pre>
     will set <code>s</code> to ""Value of inexistentKey is []""     

     <p>An {@link java.lang.IllegalArgumentException} is thrown if
     <code>val</code> contains a start delimeter ""${"" which is not
     balanced by a stop delimeter ""}"". </p>

     <p><b>Author</b> Avy Sharell</a></p>

     @param val The string on which variable substitution is performed.
     @throws IllegalArgumentException if <code>val</code> is malformed.

  */
  public static
  String substVars(String val, Properties props) throws
                        IllegalArgumentException {
    sbuf.setLength(0);

    int i = 0;
    int j, k;
    
    while(true) {
      j=val.indexOf(DELIM_START, i);
      if(j == -1) {
	if(i==0)
	  return val;
	else {
	  sbuf.append(val.substring(i, val.length()));
	  return sbuf.toString();
	}
      }
      else {
	sbuf.append(val.substring(i, j));
	k = val.indexOf(DELIM_STOP, j);
	if(k == -1) {
	  throw new IllegalArgumentException('""'+val+
		      ""\"" has no closing brace. Opening brace at position "" + j 
					     + '.');
	}
	else {
	  j += DELIM_START_LEN;
	  String key = val.substring(j, k);
	  // first try in System properties
	  String replacement = getSystemProperty(key, null);
	  // then try props parameter
	  if(replacement == null && props != null) {
	    replacement =  props.getProperty(key);
	  }

	  if(replacement != null) 
	    sbuf.append(replacement);
	  i = k + DELIM_STOP_LEN;	    
	}
      }
    }
  }


  /**
     Configure log4j given a URL. 

     <p>The URL format is important. Its <em>reference</em> part is
     taken as the class name of the configurator. For example, if you
     invoke your application using the command line

     <pre> java -Dlog4j.configuration=file:/temp/myconfig.xyz#com.myCompany.myConfigurator
     </pre>

     then the log4j will be configured by a new instance of
     <code>com.myCompany.myConfigurator</code> by interpreting the
     file referenced by <code>file:/temp/myconfig.xyz</code>.  The
     configurator you specify <em>must</em> implement the {@link
     Configurator} interface.

     <p>If the URL has no reference part, then the {@link
     PropertyConfigurator} will parse the URL. However, if the URL
     ends with a "".xml"" extension, then the {@link DOMConfigurator}
     will be used to parse the URL.

     <p>All configurations steps are taken on the
     <code>hierarchy</code> passed as parameter.
     
     @author based on code written by Anders Kristensen

     @since 1.0 */
  static
  public
  void selectAndConfigure(URL url, Hierarchy hierarchy) {
    String clazz = url.getRef();

    Configurator configurator = null;

    if(clazz != null) {
      LogLog.debug(""Preferred configurator class: "" + clazz);
      configurator = (Configurator) instantiateByClassName(clazz, 
							   Configurator.class,
							   null);
      if(configurator == null) {
	LogLog.error(""Could not instantiate configurator [""+clazz+""]."");
	return;
      }
    } else {
      String filename = url.getFile();
      if(filename != null && filename.endsWith("".xml"")) {
	try {
	  configurator = new DOMConfigurator();
	} catch(NoClassDefFoundError e) {
	  LogLog.warn(""Could not find DOMConfigurator!"", e);
	  return;
	}
      } else {
	configurator = new PropertyConfigurator();
      }
    }

    configurator.doConfigure(url, hierarchy);
  }
}
"
org/apache/log4j/spi/ThrowableInformation.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import java.io.Writer;
import java.io.PrintWriter;
import java.util.Vector;

/**
   


 */
public class ThrowableInformation implements java.io.Serializable {


  private transient Throwable throwable;
  private String[] rep;
  
  static private VectorWriter vw = new VectorWriter();
  
  public
  ThrowableInformation(Throwable throwable) {
    this.throwable = throwable;
  }

  public
  Throwable getThrowable() {
    return throwable;
  }
  
  public
  String[] getThrowableStrRep() {
    if(rep != null) {
      return (String[]) rep.clone();
    } else {
      throwable.printStackTrace(vw);
      rep = vw.toStringArray();
      vw.clear();
      return rep;
    }
  }

  
}


class VectorWriter extends PrintWriter {
    
  private Vector v;
  
  VectorWriter() {
    super(new NullWriter());
    v = new Vector();
  }
  
  public
  void println(Object o) {      
    v.addElement(o.toString());
  }
  
  // JDK 1.1.x apprenly uses this form of println while in
  // printStackTrace()
  public
  void println(char[] s) {
    v.addElement(new String(s));
  }
  
  public  
  void println(String s) {
    v.addElement(s);
  }

  public
  String[] toStringArray() {
    int len = v.size();
    String[] sa = new String[len];
    for(int i = 0; i < len; i++) {
      sa[i] = (String) v.elementAt(i);
    }
    return sa;
  }

  public
  void clear() {
    v.setSize(0);
  }
}  

class NullWriter extends Writer {    
  
  public 
  void close() {
  }

  public 
  void flush() {
  }

  public
  void write(char[] cbuf, int off, int len) {
  }
}

"
org/apache/log4j/spi/RootCategory.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import  org.apache.log4j.Category;
import  org.apache.log4j.Priority;
import  org.apache.log4j.helpers.LogLog;

// Contibutors: Mathias Bogaert

/**
   RootCategory sits at the top of the category hierachy. It is a
   regular category except that it provides several guarantees.

   <p>First, it cannot be assigned a <code>null</code>
   priority. Second, since root category cannot have a parent, the
   {@link #getChainedPriority} method always returns the value of the
   priority field without walking the hierarchy.

   @author Ceki G&uuml;lc&uuml;

 */
final public class RootCategory extends Category {

  /**
     The root category names itself as ""root"". However, the root
     category cannot be retrieved by name.  
  */
  public
  RootCategory(Priority priority) {
    super(""root"");
    setPriority(priority);
  }

  
  /**
     Return the assigned priority value without walking the category
     hierarchy.
  */
  final
  public 
  Priority getChainedPriority() {
    return priority;
  }

  /**
     Setting a null value to the priority of the root category may have catastrophic
     results. We prevent this here.

     @since 0.8.3 */
  final  
  public
  void setPriority(Priority priority) {
    if(priority == null) {
      LogLog.error(""You have tried to set a null priority to root."",
		   new Throwable());
    }
    else {
      this.priority = priority;
    }
  }
}
"
org/apache/log4j/test/ShortSocketServer.java,false,"

package org.apache.log4j.test;

import java.net.Socket;
import java.net.ServerSocket;
import java.io.IOException;

import org.apache.log4j.Category;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.net.SocketNode;
import org.apache.log4j.net.SocketServer;

/**
*/

public class ShortSocketServer  {

  static Category cat = Category.getInstance(ShortSocketServer.class.getName());

  static int port;
  
  public 
  static 
  void main(String argv[]) {
    if(argv.length == 2) {
      init(argv[0], argv[1]);
    } else {
      usage(""Wrong number of arguments."");     
    }
    
    try {
      LogLog.debug(""Listening on port "" + port);
      ServerSocket serverSocket = new ServerSocket(port);
      LogLog.debug(""Waiting to accept a new client."");
      Socket socket = serverSocket.accept();
      LogLog.debug(""Connected to client at "" + socket.getInetAddress());
      LogLog.debug(""Starting new socket node."");	
      SocketNode sn = new SocketNode(socket, Category.getDefaultHierarchy());
      Thread t = new Thread(sn);
      t.start(); 
      t.join();
    }
    catch(Exception e) {
      cat.error(""Error while in main."", e);
    }
  }

  
  static
  void  usage(String msg) {
    System.err.println(msg);
    System.err.println(
      ""Usage: java "" +ShortSocketServer.class.getName() + "" port configFile"");
    System.exit(1);
  }
    
  static
  void init(String portStr, String configFile) {
    try {
      port   = Integer.parseInt(portStr);      
    }
    catch(java.lang.NumberFormatException e) {
      e.printStackTrace();
      usage(""Could not interpret port number [""+ portStr +""]."");
    }
    PropertyConfigurator.configure(configFile);    
  }
}
"
org/apache/log4j/FileAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
//import org.apache.log4j.helpers.TracerPrintWriter;

// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>

/**
   FileAppender appends log events to a file. 
   
   <b>Support for java.io.Writer and console appending has been
   deprecated and will be removed in the near future.</b> You are
   stongly encouraged to use the replacement solutions: {@link
   WriterAppender} and {@link ConsoleAppender}.
   

   @author Ceki G&uuml;lc&uuml; */
public class FileAppender extends WriterAppender {

 /**
     A string constant used in naming the option for setting the
     output file. Current value of this string constant is
     <b>File</b>.

     <p>Note that all option keys are case sensitive.
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public static final String FILE_OPTION = ""File"";


  /**
     A string constant used in naming the option that determines whether 
     the output file will be truncated or appended to. Current value
     of this string constant is <b>Append</b>.

     <p>Note that all option keys are case sensitive.

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.     
  */
  public static final String APPEND_OPTION = ""Append"";


  /** Append to or truncate the file? The default value for this
      variable is <code>true</code>, meaning that by default a
      <code>FileAppender</code> will append to an existing file and
      not truncate it.

      <p>This option is meaningful only if the FileAppender opens the
      file.      
  */
  protected boolean fileAppend = true;

  /**
     The name of the log file. */
  protected String fileName = null;

  /**
     Is the QuietWriter ours or was it created and passed by the user?     

     @deprecated FileAppender will not support streams passed by the
     user in the future. */
  protected boolean qwIsOurs = false;

  /**
     The default constructor does not do anything. 
  */
  public
  FileAppender() {
  }


  /**
     Instantiate a FileAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  

     @deprecated <b>The functionality of this constructor form has
     been replaced by the {@link WriterAppender}. This constructor
     will be removed in the <em>near</em> term.</b>

  */
  public
  FileAppender(Layout layout, OutputStream os) {
    super(layout, os);
  }
  
  /**
     Instantiate a FileAppender and set the output destination to
     <code>writer</code>.

     <p>The <code>writer</code> must have been opened by the user.  

     @deprecated <b>The functionality of constructor form has been
     replaced by the {@link WriterAppender}. This constructor will be
     removed in the <em>near</em> term.</b>
  */
  public
  FileAppender(Layout layout, Writer writer) {
    super(layout, writer);
  }                    


  /**
    Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.

    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file designated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  FileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    this.layout = layout;
    this.setFile(filename, append);
  }

  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.

    <p>The file will be appended to.  */
  public
  FileAppender(Layout layout, String filename) throws IOException {
    this(layout, filename, true);
  }

  /**
     The <b>File</b> option takes a string value which should be
     the name of the file to append to. Special values ""System.out"" or
     ""System.err"" are interpreted as the standard out and standard
     error streams.

     <p><font color=""#DD0044""><b>Note that the ""System.out"" or ""System.err""
     options are deprecated. Use {@link ConsoleAppender}
     instead.</b></font>

     <p>If the option is set to ""System.out"" or ""System.err"" the
     output will go to the corresponding stream. Otherwise, if the
     option is set to the name of a file, then the file will be opened
     and output will go there.
     
     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
   */
  public void setFile(String file) {
    // Trim spaces from both ends. The users probably does not want 
    // trailing spaces in file names.
    String val = file.trim();
    if(val.equalsIgnoreCase(""System.out"")) {
      setWriter(new OutputStreamWriter(System.out));
    } else if(val.equalsIgnoreCase(""System.err"")) {
      setWriter(new OutputStreamWriter(System.err));
    } else {
      fileName = val;
    }
  }

  /** 
      Returns the value of the <b>Append</b> option. 
   */
  public
  boolean getAppend() {
    return fileAppend;
  }

  
  /** Returns the value of the <b>File</b> option. */
  public
  String getFile() {
    return fileName;
  }
  
  /**
     Returns the option names for this component, namely the string
     array {@link #FILE_OPTION}, {@link #APPEND_OPTION}} in addition
     to the options of its super class {@link WriterAppender}.  

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.

  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {FILE_OPTION, APPEND_OPTION});
  }


  /**
     <The <b>Append</b> option takes a boolean value. It is set to
     <code>true</code> by default. If true, then <code>File</code>
     will be opened in append mode by {@link #setFile setFile} (see
     above). Otherwise, {@link #setFile setFile} will open
     <code>File</code> in truncate mode.

     <p>Note: Actual opening of the file is made when {@link
     #activateOptions} is called, not when the options are set.
   */
  public
  void setAppend(boolean flag) {
    fileAppend = flag;
  }
  

  /**
     If the value of {@link #FILE_OPTION} is not <code>null</code>, then {@link
     #setFile} is called with the values of {@link #FILE_OPTION} and
     {@link #APPEND_OPTION}.

     @since 0.8.1 */
  public
  void activateOptions() {    
    if(fileName != null) {
      try {
	setFile(fileName, fileAppend);
      }
      catch(java.io.IOException e) {
	errorHandler.error(""setFile(""+fileName+"",""+fileAppend+"") call failed."",
			   e, ErrorCode.FILE_OPEN_FAILURE);
      }
    } else {
      //LogLog.error(""File option not set for appender [""+name+""]."");
      LogLog.warn(""File option not set for appender [""+name+""]."");
      LogLog.warn(""Are you using FileAppender instead of ConsoleAppender?"");
    }
  }

 /**
     Closes the previously opened file.
  */
  protected
  void closeFile() {
    // FIXME (remove qwIsOurs)
    if(this.qw != null && this.qwIsOurs) {
      try {
	this.qw.close();
      }
      catch(java.io.IOException e) {
	// Exceptionally, it does not make sense to delegate to an
	// ErrorHandler. Since a closed appender is basically dead.
	LogLog.error(""Could not close "" + qw, e);
      }
    }
  }

  /**
    <p>Sets and <i>opens</i> the file where the log output will
    go. The specified file must be writable. 

    <p>If there was already an opened file, then the previous file
    is closed first. 

    @param fileName The path to the log file.
    @param append   If true will append to fileName. Otherwise will
        truncate fileName.  */
  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    reset();
    this.setQWForFiles(new FileWriter(fileName, append));
    //this.tp = new TracerPrintWriter(qw);
    this.fileName = fileName;
    this.fileAppend = append;
    this.qwIsOurs = true;
    writeHeader();
  }


  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method.  */
  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    
    if(key.equalsIgnoreCase(FILE_OPTION)) {
      // Trim spaces from both ends. The users probably does not want 
      // trailing spaces in file names.
      String val = value.trim();
      if(val.equalsIgnoreCase(""System.out"")) {
	setWriter(new OutputStreamWriter(System.out));
      } else if(val.equalsIgnoreCase(""System.err"")) {
	setWriter(new OutputStreamWriter(System.err));
      } else {
	fileName = val;
      }
    }
    else if (key.equalsIgnoreCase(APPEND_OPTION)) {
      fileAppend = OptionConverter.toBoolean(value, fileAppend);
    }
  }

  /**
     Sets the quiet writer being used.
     
     This method is overriden by {@link RollingFileAppender}.
   */
  protected
  void setQWForFiles(Writer writer) {
     this.qw = new QuietWriter(writer, errorHandler);
  }


  /**
     Close any previously opened file and call the parent's
     <code>reset</code>.  */
  protected
  void reset() {
    closeFile();
    this.fileName = null;
    if(qwIsOurs) {
      super.reset();    
    } else {
      this.qw = null;
      //this.tp = null;    
    }
  }  
}

"
org/apache/log4j/WriterAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;

// Contibutors: Jens Uwe Pipka <jens.pipka@gmx.de>

/**
   WriterAppender appends log events to a {@link java.io.Writer} or an
   {@link java.io.OutputStream} depending on the user's choice.

   @author Ceki G&uuml;lc&uuml;
   @since 1.1 */
public class WriterAppender extends AppenderSkeleton {

  /**
     A string constant used in naming the option for immediate
     flushing of the output stream at the end of each append
     operation. Current value of this string constant is
     <b>ImmediateFlush</b>.

     <p>Note that all option keys are case sensitive.     

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed. 
  */
  public static final String IMMEDIATE_FLUSH_OPTION = ""ImmediateFlush"";

  /**
     Immediate flush means that the undelying writer or output stream
     will be flushed at the end of each append operation. Immediate
     flush is slower but ensures that each append request is actually
     written. If <code>immediateFlush</code> is set to
     <code>false</code>, then there is a good chance that the last few
     logs events are not actually written to persistent media if and
     when the application crashes.

     <p>The <code>immediateFlush</code> variable is set to
     <code>true</code> by default.

  */
  protected boolean immediateFlush = true;

  /**
     This is the {@link QuietWriter quietWriter} where we will write
     to. 
  */
  protected QuietWriter qw;

  
  /**
     This default constructor does nothing.  */
  public
  WriterAppender() {
  }

  /**
     Instantiate a WriterAppender and set the output destination to a
     new {@link OutputStreamWriter} initialized with <code>os</code>
     as its {@link OutputStream}.  */
  public
  WriterAppender(Layout layout, OutputStream os) {
    this(layout, new OutputStreamWriter(os));
  }
  
  /**
     Instantiate a WriterAppender and set the output destination to
     <code>writer</code>.

     <p>The <code>writer</code> must have been previously opened by
     the user.  */
  public
  WriterAppender(Layout layout, Writer writer) {
    this.layout = layout;
    this.setWriter(writer);
  }

  /**
     If the <b>ImmediateFlush</b> option is set to
     <code>true</code>, the appender will flush at the end of each
     write. This is the default behaviour. If the option is set to
     <code>false</code>, then the underlying stream can defer writing
     to physical medium to a later time. 

     <p>Avoiding the flush operation at the end of each append results in
     a performance gain of 10 to 20 percent. However, there is safety
     tradeoff involved in skipping flushing. Indeed, when flushing is
     skipped, then it is likely that the last few log events will not
     be recorded on disk when the application exits. This is a high
     price to pay even for a 20% performance gain.
   */
  public
  void setImmediateFlush(boolean value) {
    immediateFlush = value;
  }

  /**
     Returns value of the <b>ImmediateFlush</b> option.
   */
  public
  boolean getImmediateFlush() {
    return immediateFlush;
  }

  /**
     Does nothing.
  */
  public
  void activateOptions() {    
  }


  /**
     This method is called by the {@link AppenderSkeleton#doAppend}
     method. 

     <p>If the output stream exists and is writable then write a log
     statement to the output stream. Otherwise, write a single warning
     message to <code>System.err</code>.

     <p>The format of the output will depend on this appender's
     layout.
     
  */
  public
  void append(LoggingEvent event) {

    // Reminder: the nesting of calls is:
    //
    //    doAppend()
    //      - check threshold
    //      - filter
    //      - append();
    //        - checkEntryConditions();
    //        - subAppend();

    if(!checkEntryConditions()) {
      return;
    }
    subAppend(event);
   } 

  /**
     This method determines if there is a sense in attempting to append.
     
     <p>It checks whether there is a set output target and also if
     there is a set layout. If these checks fail, then the boolean
     value <code>false</code> is returned. */
  protected
  boolean checkEntryConditions() {
    if(this.closed) {
      LogLog.warn(""Not allowed to write to a closed appender."");
      return false;
    }

    if(this.qw == null) {
      errorHandler.error(""No output stream or file set for appender named [""+ 
			name+""]."");
      return false;
    }
    
    if(this.layout == null) {
      errorHandler.error(""No layout set for appender named [""+ name+""]."");
      return false;
    }
    return true;
  }


  /**
     Close this appender instance. The underlying stream or writer is
     also closed.
     
     <p>Closed appenders cannot be reused.

     @see #setWriter
     @since 0.8.4 */
  public
  synchronized
  void close() {
    if(this.closed)
      return;
    this.closed = true;
    writeFooter();
    reset();
  }

  /**
     Close the underlying {@link java.io.Writer}.
  */
  protected 
  void closeWriter() {
    if(qw != null) {
      try {
	qw.close();
      } catch(IOException e) {
	LogLog.error(""Could not close "" + qw, e); // do need to invoke an error handler
	                                          // at  this late stage
      }
    }
  }


  /**
     Retuns the option names for this component.

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
           new String[] {IMMEDIATE_FLUSH_OPTION});
  }

  
  /**
     Set the {@link ErrorHandler} for this FileAppender and also the
     underlying {@link QuietWriter} if any. */
  public
  synchronized 
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
      if(this.qw != null) {
	this.qw.setErrorHandler(eh);
      }
    }    
  }

  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
   */
 public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);
    
    if (key.equalsIgnoreCase(IMMEDIATE_FLUSH_OPTION)) {
      immediateFlush = OptionConverter.toBoolean(value, immediateFlush);
    }
  }  
  
  /**
    <p>Sets the Writer where the log output will go. The
    specified Writer must be opened by the user and be
    writable.
    
    <p>The <code>java.io.Writer</code> will be closed when the
    appender instance is closed.

    
    <p><b>WARNING:</b> Logging to an unopened Writer will fail.
    <p>  
    @param Writer An already opened Writer.  */
  public
  synchronized
  void setWriter(Writer writer) {
    reset();
    this.qw = new QuietWriter(writer, errorHandler);
    //this.tp = new TracerPrintWriter(qw);
    writeHeader();
  }


  /**
     Actual writing occurs here.

     <p>Most sub-classes of <code>FileAppender</code> will need to
     override this method.

     @since 0.9.0 */
  protected
  void subAppend(LoggingEvent event) {
    this.qw.write(this.layout.format(event));

    if(layout.ignoresThrowable()) {
      String[] s = event.getThrowableStrRep();
      if (s != null) {
	int len = s.length;
	for(int i = 0; i < len; i++) {
	  this.qw.write(s[i]);
	  this.qw.write(Layout.LINE_SEP);
	}
      }
    }
 
    if(this.immediateFlush) {
      this.qw.flush();
    } 
  }



  /**
     The WriterAppender requires a layout. Hence, this method returns
     <code>true</code>.
  */
  public
  boolean requiresLayout() {
    return true;
  }

  /**
     Clear internal references to the writer and other variables.

     Sub-classes can override this method for an alternate closing
     behaviour.  */
  protected
  void reset() {
    closeWriter();
    this.qw = null;
    //this.tp = null;    
  }


  /**
     Write a footer as produced by the embedded layout's {@link
     Layout#getFooter} method.  */
  protected
  void writeFooter() {
    if(layout != null) {
      String f = layout.getFooter();
      if(f != null && this.qw != null)
	this.qw.write(f);
    }
  }

/**
     Write a header as produced by the embedded layout's {@link
     Layout#getHeader} method.  */
  protected 
  void writeHeader() {
    if(layout != null) {
      String h = layout.getHeader();
      if(h != null && this.qw != null)
	this.qw.write(h);
    }
  }
}
"
org/apache/log4j/helpers/SyslogQuietWriter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;



import java.io.Writer;
import java.io.FilterWriter;
import java.io.IOException;
import org.apache.log4j.spi.ErrorHandler;

/**
   SyslogQuietWriter extends QuietWriter by prepending the syslog
   priority code before each printed String.

   @since 0.7.3
*/
public class SyslogQuietWriter extends QuietWriter {

  int syslogFacility;
  int priority;

  public
  SyslogQuietWriter(Writer writer, int syslogFacility, ErrorHandler eh) {
    super(writer, eh);
    this.syslogFacility = syslogFacility;
  }

  public
  void setPriority(int priority) {
    this.priority = priority;
  }

  public
  void setSyslogFacility(int syslogFacility) {
    this.syslogFacility = syslogFacility;
  }
  
  public
  void write(String string) {
    super.write(""<""+(syslogFacility | priority)+"">"" + string);
  }
}
"
org/apache/log4j/HTMLLayout.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.LocationInfo;
import org.apache.log4j.helpers.OptionConverter;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.Writer;

/**
   This layout outputs events in a HTML table.

   @author Ceki G&uuml;lc&uuml;   
 */
public class HTMLLayout extends Layout {

  protected final int BUF_SIZE = 256;
  protected final int MAX_CAPACITY = 1024;

  static String TRACE_PREFIX = ""<br>&nbsp;&nbsp;&nbsp;&nbsp;"";

  // output buffer appended to when format() is invoked
  private StringBuffer sbuf = new StringBuffer(BUF_SIZE);

  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  

     <p>Note that all option keys are case sensitive.
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";

  /**
     A string constant used in naming the option for setting the the
     HTML document title.  Current value of this string
     constant is <b>Title</b>.  
  */
  public static final String TITLE_OPTION = ""Title"";

  // Print no location info by default
  boolean locationInfo = false;

  String title = ""Log4J Log Messages"";

  /**
     Returns a String consisting of one element {@link
     #LOCATION_INFO_OPTION}. 
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
 */
  public
  String[] getOptionStrings() {
    return new String[] {LOCATION_INFO_OPTION, TITLE_OPTION};
  }

  /**
     Set HTMLLayout specific options.

     <p>The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 

     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
     
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 

   */
  public
  void setOption(String key, String value) {
    if(value == null) return;

    if (key.equalsIgnoreCase(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);
    }
    else if (key.equalsIgnoreCase(TITLE_OPTION)) {
      title = value;
    }
  }
  
  /**
     The <b>LocationInfo</b> option takes a boolean value. By
     default, it is set to false which means there will be no location
     information output by this layout. If the the option is set to
     true, then the file name and line number of the statement
     at the origin of the log statement will be output. 

     <p>If you are embedding this layout within an {@link
     org.apache.log4j.net.SMTPAppender} then make sure to set the
     <b>LocationInfo</b> option of that appender as well.
   */
  public
  void setLocationInfo(boolean flag) {
    locationInfo = flag;
  }
  
  /**
     Returns the current value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }

  /**
    The <b>Title</b> option takes a String value. This option sets the
    document title of the generated HTML document.
    
    <p>Defaults to 'Log4J Log Messages'.
  */
  public
  void setTitle(String title) {
    this.title = title;
  }

  /**
     Returns the current value of the <b>Title</b> option.
  */
  public
  String getTitle() {
    return title;
  }
  
 /**
     Returns the content type output by this layout, i.e ""text/html"".
  */
  public
  String getContentType() {
    return ""text/html"";
  }

  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }
  
  public 
  String format(LoggingEvent event) {
    
    if(sbuf.capacity() > MAX_CAPACITY) {
      sbuf = new StringBuffer(BUF_SIZE);
    } else {
      sbuf.setLength(0);
    }
    
    sbuf.append(Layout.LINE_SEP + ""<tr>"" + Layout.LINE_SEP);
 
    sbuf.append(""<td>"");
    sbuf.append(event.timeStamp - event.getStartTime());
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\"""" + event.getThreadName() + "" thread\"">"");
    sbuf.append(escapeHTMLTags(event.getThreadName()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\""Priority\"">"");
    if (event.priority.equals(Priority.DEBUG)) {
      sbuf.append(""<font color=\""#339933\"">"");
      sbuf.append(event.priority);      
      sbuf.append(""</font>"");
    }
    else if(event.priority.isGreaterOrEqual(Priority.WARN)) {
      sbuf.append(""<font color=\""#993300\""><strong>"");
      sbuf.append(event.priority);      
      sbuf.append(""</strong></font>"");
    } else {
      sbuf.append(event.priority);      
    }
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    sbuf.append(""<td title=\"""" + event.categoryName + "" category\"">"");
    sbuf.append(escapeHTMLTags(event.categoryName));
    sbuf.append(""</td>"" + Layout.LINE_SEP);

    if(locationInfo) {
      LocationInfo locInfo = event.getLocationInformation();
      sbuf.append(""<td>"");
      sbuf.append(escapeHTMLTags(locInfo.getFileName()));
      sbuf.append(':');
      sbuf.append(locInfo.getLineNumber());
      sbuf.append(""</td>"" + Layout.LINE_SEP);
    }

    sbuf.append(""<td title=\""Message\"">"");
    sbuf.append(escapeHTMLTags(event.getRenderedMessage()));
    sbuf.append(""</td>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);

    if (event.getNDC() != null) {
      sbuf.append(""<tr><td bgcolor=\""#EEEEEE\"" style=\""font-size : xx-small;\"" colspan=\""6\"" title=\""Nested Diagnostic Context\"">"");
      sbuf.append(""NDC: "" + escapeHTMLTags(event.getNDC()));
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    String[] s = event.getThrowableStrRep(); 
    if(s != null) {
      sbuf.append(""<tr><td bgcolor=\""#993300\"" style=\""color:White; font-size : xx-small;\"" colspan=\""6\"">"");
      appendThrowableAsHTML(s, sbuf);
      sbuf.append(""</td></tr>"" + Layout.LINE_SEP);
    }

    return sbuf.toString();
  }

  void appendThrowableAsHTML(String[] s, StringBuffer sbuf) {
    if(s != null) {
      int len = s.length;
      if(len == 0) 
	return;
      sbuf.append(escapeHTMLTags(s[0]));
      sbuf.append(Layout.LINE_SEP);
      for(int i = 1; i < len; i++) {
	sbuf.append(TRACE_PREFIX);
	sbuf.append(escapeHTMLTags(s[i]));
	sbuf.append(Layout.LINE_SEP);
      }
    }
  }

  /**
     Returns appropriate HTML headers.
  */
  public
  String getHeader() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" \""http://www.w3.org/TR/html4/loose.dtd\"">""  + Layout.LINE_SEP);
    sbuf.append(""<html>"" + Layout.LINE_SEP);
    sbuf.append(""<head>"" + Layout.LINE_SEP);
    sbuf.append(""<title>"" + title + ""</title>"" + Layout.LINE_SEP);
    sbuf.append(""<style type=\""text/css\"">""  + Layout.LINE_SEP);
    sbuf.append(""<!--""  + Layout.LINE_SEP);
    sbuf.append(""body, table {font-family: arial,sans-serif; font-size: x-small;}"" + Layout.LINE_SEP);
    sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"" + Layout.LINE_SEP);
    sbuf.append(""-->"" + Layout.LINE_SEP);
    sbuf.append(""</style>"" + Layout.LINE_SEP);
    sbuf.append(""</head>"" + Layout.LINE_SEP);
    sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"" + Layout.LINE_SEP);
    sbuf.append(""<hr size=\""1\"" noshade>"" + Layout.LINE_SEP);
    sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"" + Layout.LINE_SEP);
    sbuf.append(""<tr>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Time</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Thread</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Priority</th>"" + Layout.LINE_SEP);
    sbuf.append(""<th>Category</th>"" + Layout.LINE_SEP);
    if(locationInfo) {
      sbuf.append(""<th>File:Line</th>"" + Layout.LINE_SEP);
    }
    sbuf.append(""<th>Message</th>"" + Layout.LINE_SEP);
    sbuf.append(""</tr>"" + Layout.LINE_SEP);
    return sbuf.toString();
  }

  /**
     Returns the appropriate HTML footers.
  */
  public
  String getFooter() {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append(""</table>"" + Layout.LINE_SEP);
    sbuf.append(""<br>"" + Layout.LINE_SEP);
    sbuf.append(""</body></html>"");
    return sbuf.toString();
  }
 
  /**
     The HTML layout handles the throwable contained in logging
     events. Hence, this method return <code>false</code>.  */
  public
  boolean ignoresThrowable() {
    return false;
  }

  /**
   * This method takes a string which may contain HTML tags (ie, <b>, <table>,
   * etc) and converts the '<' and '>' characters to their HTML escape
   * sequences.
   *
   * @param input The text to be converted.
   * @return The input string with the characters '<' and '>' replaced with
   *  &lt; and &gt; respectively.
   */
  private String escapeHTMLTags(String input) {
    //Check if the string is null or zero length -- if so, return
    //what was sent in.
    
    if( input == null || input.length() == 0 ) {
        return input;
    }
    
    //Use a StringBuffer in lieu of String concatenation -- it is
    //much more efficient this way.
    
    StringBuffer buf = new StringBuffer(input.length() + 6);
    char ch = ' ';
    
    for(int i=0; i < input.length(); i++) {
        ch = input.charAt(i);
        if(ch == '<') {
            buf.append(""&lt;"");
        }
        else if(ch == '>') {
            buf.append(""&gt;"");
        }
        else {
            buf.append(ch);
        }
    }

    return buf.toString();
  }
}
"
org/apache/log4j/performance/SystemTime.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.performance;

/**
   Measures the time required to make a System.currentTimeMillis() and
   Thread.currentThread().getName() calls.

   <p>On an 233Mhz NT machine (JDK 1.1.7B) the
   System.currentTimeMillis() call takes under half a microsecond to
   complete whereas the Thread.currentThread().getName() call takes
   about 4 micro-seconds.

*/
public class SystemTime {

  static int RUN_LENGTH = 1000000;

  static
  public 
  void main(String[] args) {    
    double t = systemCurrentTimeLoop();
    System.out.println(""Average System.currentTimeMillis() call took "" + t);

    t = currentThreadNameloop();
    System.out.println(""Average Thread.currentThread().getName() call took "" 
		       + t);
    
  }

  static
  double systemCurrentTimeLoop() {
    long before = System.currentTimeMillis();
    long l;
    for(int i = 0; i < RUN_LENGTH; i++) {
      l = System.currentTimeMillis();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }

  static
  double currentThreadNameloop() {
    long before = System.currentTimeMillis();
    String t;
    for(int i = 0; i < RUN_LENGTH; i++) {
      t = Thread.currentThread().getName();
    }
    return (System.currentTimeMillis() - before)*1000.0/RUN_LENGTH;    
  }  
}
"
org/apache/log4j/or/MessageRenderer.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.or;

import org.apache.log4j.Layout;
import org.apache.log4j.helpers.LogLog;

import javax.jms.Message;
import javax.jms.JMSException;
import javax.jms.DeliveryMode;
import java.util.Enumeration;

/**
   Render <code>javax.jms.Message</code> objects.

   @author Ceki G&uuml;lc&uuml;
   @since 1.0 */
public class MessageRenderer implements ObjectRenderer {

  public
  MessageRenderer() {
  }

   
  /**
     Render a {@link Message}.
  */
  public
  String  doRender(Object o) {
    if(o instanceof Message) {  
      StringBuffer sbuf = new StringBuffer();
      Message m = (Message) o;
      try {
	sbuf.append(""DeliveryMode="");
	switch(m.getJMSDeliveryMode()) {
	case DeliveryMode.NON_PERSISTENT : 	
	  sbuf.append(""NON_PERSISTENT"");
	  break;
	case DeliveryMode.PERSISTENT : 	
	  sbuf.append(""PERSISTENT"");
	  break;
	default: sbuf.append(""UNKNOWN"");
	}
	sbuf.append("", CorrelationID="");
	sbuf.append(m.getJMSCorrelationID());

	sbuf.append("", Destination="");
	sbuf.append(m.getJMSDestination());

	sbuf.append("", Expiration="");
	sbuf.append(m.getJMSExpiration());

	sbuf.append("", MessageID="");
	sbuf.append(m.getJMSMessageID());

	sbuf.append("", Priority="");
	sbuf.append(m.getJMSPriority());

	sbuf.append("", Redelivered="");
	sbuf.append(m.getJMSRedelivered());

	sbuf.append("", ReplyTo="");
	sbuf.append(m.getJMSReplyTo());

	sbuf.append("", Timestamp="");
	sbuf.append(m.getJMSTimestamp());

	sbuf.append("", Type="");
	sbuf.append(m.getJMSType());

	//Enumeration enum = m.getPropertyNames();
	//while(enum.hasMoreElements()) {
	//  String key = (String) enum.nextElement();
	//  sbuf.append(""; ""+key+""="");
	//  sbuf.append(m.getStringProperty(key));
	//}

      } catch(JMSException e) {
	LogLog.error(""Could not parse Message."", e);
      }
      return sbuf.toString();
    } else {
      return o.toString();
    }
  }
}
"
org/apache/log4j/helpers/SyslogWriter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;


import java.io.Writer;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.DatagramPacket;
import java.net.UnknownHostException;
import java.net.SocketException;
import java.io.IOException;

/**
   SyslogWriter is a wrapper around the java.net.DatagramSocket class
   so that it behaves like a java.io.Writer.

   @since 0.7.3
*/
public class SyslogWriter extends Writer {

  final int SYSLOG_PORT = 514;
  static String syslogHost;
  
  private InetAddress address;
  private DatagramSocket ds;

  public
  SyslogWriter(String syslogHost) {
    this.syslogHost = syslogHost;

    try {      
      this.address = InetAddress.getByName(syslogHost);
    }
    catch (UnknownHostException e) {
      LogLog.error(""Could not find "" + syslogHost +
			 "". All logging will FAIL."", e);
    }

    try {
      this.ds = new DatagramSocket();
    }
    catch (SocketException e) {
      e.printStackTrace(); 
      LogLog.error(""Could not instantiate DatagramSocket to "" + syslogHost +
			 "". All logging will FAIL."", e);
    }
  }


  public
  void write(char[] buf, int off, int len) throws IOException {
    this.write(new String(buf, off, len));
  }
  
  public
  void write(String string) throws IOException {
    DatagramPacket packet = new DatagramPacket(string.getBytes(),
					       string.length(), 
					       address, SYSLOG_PORT);

    if(this.ds != null)
      ds.send(packet);
    
  }

  public
  void flush() {}

  public
  void close() {}
}
"
org/apache/log4j/performance/NOPWriter.java,false,"//      Copyright 1996-1999, International Business Machines 
//      Corporation. All Rights Reserved.

package org.apache.log4j.performance;

import java.io.Writer;
import java.io.IOException;

/**
  Extends {@link Writer} with methods that return immediately without
  doing anything. This class is used to measure the cost of
  constructing a log message but not actually writing to the
  OutputStream.
   
  @author  Ceki G&uuml;lc&uuml;
*/
public class NOPWriter extends Writer {

  //public
  //NOPWriter() {
  //}
  

  public
  void write(char[] cbuf) throws IOException {}

  public
  void write(char[] cbuf, int off, int len) throws IOException {}


  public
  void write(int b) throws IOException {}

  public 
  void write(String s) throws IOException {} 

  public 
  void write(String s, int off, int len) throws IOException {} 

  public 
  void flush() throws IOException {
  }

  public 
  void close() throws IOException {
    System.err.println(""Close called."");
  }
}
"
org/apache/log4j/Appender.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.LoggingEvent;

/**
   Implement this interface for your own strategies for printing log
   statements. 

   @author Ceki G&uuml;lc&uuml;
*/
public interface Appender {

  /**
     Add a filter to the end of the filter list.

     @since 0.9.0
   */
  void addFilter(Filter newFilter);

  /**
     Returns the head Filter. The Filters are organized in a linked list
     and so all Filters on this Appender are available through the result.
     
     @return the head Filter or null, if no Filters are present
     @since 1.1
  */
  public
  Filter getFilter();

  /**
     Clear the list of filters by removing all the filters in it.
     
     @since 0.9.0
   */
  public
  void clearFilters();

  /**
     Release any resources allocated within the appender such as file
     handles, network connections, etc.

     <p>It is a programming error to append to a closed appender.

     @since 0.8.4
  */
  public
  void close();
  
  /**
     Log in Appender specific way.  */
  public
  void doAppend(LoggingEvent event);


  /**
     Get the name of this appender. The name uniquely identifies the
     appender.  */
  public
  String getName();


  /**
     Set the {@link ErrorHandler} for this appender.

     @ since 0.9.0
   */
  public
  void setErrorHandler(ErrorHandler errorHandler);

  /**
     Returns the {@link ErrorHandler} for this appender.

     @since 1.1
   */
  public
  ErrorHandler getErrorHandler();

  /**
     Set the {@link Layout} for this appender.

     @since 0.8.1
  */
  public
  void setLayout(Layout layout);

  /**
     Returns this appenders layout.
     
     @since 1.1
  */
  public
  Layout getLayout();
  

  /**
     Set the name of this appender. The name is used by other
     components to identify this appender.

     @since 0.8.1
  */
  public
  void setName(String name);

  /**
     Configurators call this method to determine if the appender
    requires a layout. If this method returns <code>true</code>,
    meaning that layout is required, then the configurator will
    configure an layout using the configuration information at its
    disposal.  If this method returns <code>false</code>, meaning that
    a layout is not required, then layout configuration will be
    skipped even if there is available layout configuration
    information at the disposal of the configurator..

     <p>In the rather exceptional case, where the appender
     implementation admits a layout but can also work without it, then
     the appender should return <code>true</code>.
     
     @since 0.8.4 */
  public
  boolean requiresLayout();
}
"
org/apache/log4j/test/CategoryWrapper.java,false,"
package org.apache.log4j.test;

import org.apache.log4j.*;

/**
   This is just to test that wrapper can work. This implementation is
   actually quite bad and should be avoided.

*/

public class CategoryWrapper {


  Category c;
  static String FQCN = CategoryWrapper.class.getName();

  CategoryWrapper(String name) {
    c = Category.getInstance(name);
  }

  public 
  static 
  void main(String argv[]) {    
    Layout layout = new PatternLayout(""%p [%t] %C %F - %m\n"");
    Appender out = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_OUT);
    CategoryWrapper w1 = new CategoryWrapper(""c1"");
    w1.addAppender(out);
    w1.print(""hello"");
  }


  public 
  void addAppender(Appender appender) {
    c.addAppender(appender);
  }

  public 
  void print(String msg) {

    // You have to supply the fully qualified named of the wrapper
    // class to the specially tailored category.log method for
    // PatternLayout's %C conversion pattern to work.

    // We have to add the "".print"" string because the invocation of
    // wrapper.print method is made from the wrapper itself (main
    // method). This is highly unusual. The fqcn of the wrapper is
    // normally sufficient.

    c.log(FQCN+"".print"", Priority.DEBUG, msg, null);
  }
  
  
  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println(""Usage: java ""+CategoryWrapper.class.getName()
		       + "" fileName"");
    System.exit(1);
  }
}
"
org/apache/log4j/helpers/OnlyOnceErrorHandler.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import  org.apache.log4j.spi.ErrorHandler;

/**

   The <code>OnlyOnceErrorHandler</code> implements log4j's default
   error handling policy which consists of emitting a message for the
   first error in an appender and ignoring all following errors.

   <p>The error message is printed on <code>System.err</code>. 

   <p>This policy aims at protecting an otherwise working application
   from being flooded with error messages when logging fails.

   @author Ceki G&uuml;lc&uuml;
   @since 0.9.0 */
public class OnlyOnceErrorHandler implements ErrorHandler {


  final String WARN_PREFIX = ""log4j warning: "";
  final String ERROR_PREFIX = ""log4j error: "";

  boolean firstTime = true;

  /**
     Returns <code>null</code> as <code>OnlyOnceErrorHandler</code>
     has no options. 
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
 */
  public
  String[] getOptionStrings() {
    return null;
  }

  /**
     No options to set.
     
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
  }

  /**
     No options to activate.
  */
  public
  void activateOptions() {
  }


  /**
     Prints the message and the stack trace of the exception on
     <code>System.err</code>.  */
  public
  void error(String message, Exception e, int errorCode) { 
    if(firstTime) {
      LogLog.error(message, e);
      firstTime = false;
    }
  }

  /**
     Returns <code>null</code> as <code>OnlyOnceErrorHandler</code>
     has no options.  
  public
  String[] getOptionStrings() {
    return null;
  }*/

  /**
     No options to set.
  public
  void setOption(String key, String value) {
  }
  */

  /**
     No options to get.
  public
  String getOption(String key) {
    return null;
  }
  */

  /**
     Print a the error message passed as parameter on
     <code>System.err</code>.  
  */
  public
  void error(String message) {
    if(firstTime) {
      LogLog.error(message);
      firstTime = false;
    }
  }
}
"
org/apache/log4j/net/SocketAppender.java,true,"//      Copyright 1996-2000, International Business Machines
//      Corporation. All Rights Reserved.
//
//      See the LICENCE file for the terms of distribution.



// Contributors: Dan MacDonald <dan@redknee.com>

package org.apache.log4j.net;

import java.net.InetAddress;
import java.net.Socket;
import java.io.OutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.PrintWriter;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.Category;
import org.apache.log4j.Priority;
import org.apache.log4j.AppenderSkeleton;

/**
    Sends {@link LoggingEvent} objects to a remote a log server,
    usually a {@link SocketNode}.

    <p>The SocketAppender has the following properties:

    <ul>

      <p><li>If sent to a {@link SocketNode}, remote logging is
      non-intrusive as far as the log event is concerned. In other
      words, the event will be logged with the same time stamp, {@link
      org.apache.log4j.NDC}, location info as if it were logged locally by
      the client.

      <p><li>SocketAppenders do not use a layout. They ship a
      serialized {@link LoggingEvent} object to the server side.

      <p><li>Remote logging uses the TCP protocol. Consequently, if
      the server is reachable, then log events will eventually arrive
      at the server.
    
      <p><li>If the remote server is down, the logging requests are
      simply dropped. However, if and when the server comes back up,
      then event transmission is resumed transparently. This
      transparent reconneciton is performed by a <em>connector</em>
      thread which periodically attempts to connect to the server.
    
      <p><li>Logging events are automatically <em>buffered</em> by the
      native TCP implementation. This means that if the link to server
      is slow but still faster than the rate of (log) event production
      by the client, the client will not be affected by the slow
      network connection. However, if the network connection is slower
      then the rate of event production, then the client can only
      progress at the network rate. In particular, if the network link
      to the the server is down, the client will be blocked.

      <p>On the other hand, if the network link is up, but the server
      is down, the client will not be blocked when making log requests
      but the log events will be lost due to server unavailability.

      <p><li>Even if a <code>SocketAppender</code> is no longer
      attached to any category, it will not be garbage collected in
      the presence of a connector thread. A connector thread exists
      only if the connection to the server is down. To avoid this
      garbage collection problem, you should {@link #close} the the
      <code>SocketAppender</code> explicitly. See also next item.

      <p>Long lived applications which create/destroy many
      <code>SocketAppender</code> instances should be aware of this
      garbage collection problem. Most other applications can safely
      ignore it.

      <p><li>If the JVM hosting the <code>SocketAppender</code> exits
      before the <code>SocketAppender</code> is closed either
      explicitly or subsequent to garbage collection, then there might
      be untransmitted data in the pipe which might be lost. This is a
      common problem on Windows based systems.

      <p>To avoid lost data, it is usually sufficient to {@link #close}
      the <code>SocketAppender</code> either explicitly or by calling
      the {@link Category#shutdown} method before exiting the
      application.  


     </ul>
    
    @author  Ceki G&uuml;lc&uuml;
    @since 0.8.4 */

public class SocketAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the option for setting the the
     host name of the remote server.  Current value of this string
     constant is <b>RemoteHost</b>. See the {@link #setOption} method
     for the meaning of this option.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String REMOTE_HOST_OPTION = ""RemoteHost"";

 /**
     A string constant used in naming the option for setting the the
     port to contect on the remote server.  Current value of this string
     constant is <b>Port</b>.  See the {@link #setOption} method
     for the meaning of this option.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String PORT_OPTION = ""Port"";

  /**
     A string constant used in naming the option for setting the the
     location information flag.  Current value of this string
     constant is <b>LocationInfo</b>.  See the {@link #setOption} method
     for the meaning of this option.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String LOCATION_INFO_OPTION = ""LocationInfo"";

  /**
     A string constant used in naming the option for setting the delay
     between each reconneciton attempt to remote server.  Current
     value a of this string constant is <b>ReconnectionDelay</b>.  See
     the {@link #setOption} method for the meaning of this option.

     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String RECONNECTION_DELAY_OPTION = ""ReconnectionDelay"";

  /**
     The default port number of remote logging server (4560).
  */
  static final int DEFAULT_PORT                 = 4560;
  
  /**
     The default reconnection delay (30000 milliseconds or 30 seconds).
  */
  static final int DEFAULT_RECONNECTION_DELAY   = 30000;

  /**
     We remember host name as String in addition to the resolved
     InetAddress so that it can be returned via getOption().
  */
  String remoteHost;
  
  InetAddress address;
  int port = DEFAULT_PORT;
  ObjectOutputStream oos;
  int reconnectionDelay = DEFAULT_RECONNECTION_DELAY;
  boolean locationInfo = false;

  private Connector connector;

  int counter = 0; 
  

  // reset the ObjectOutputStream every 70 calls
  //private static final int RESET_FREQUENCY = 70;
  private static final int RESET_FREQUENCY = 1;

  public SocketAppender() {
  }

  /**
     Connects to remote server at <code>address</code> and <code>port</code>.
  */
  public
  SocketAppender(InetAddress address, int port) {
    this.address = address;
    this.remoteHost = address.getHostName();
    this.port = port;
    connect(address, port);
  }

  /**
     Connects to remote server at <code>host</code> and <code>port</code>.
  */
  public
  SocketAppender(String host, int port) { 
    this.port = port;
    this.address = getAddressByName(host);
    this.remoteHost = host;
    connect(address, port);
  }
  
  /**
     Retuns the option names for this component, namely the string
     array consisting of {{@link #REMOTE_HOST_OPTION}, {@link
     #PORT_OPTION}, {@link #LOCATION_INFO_OPTION}, {@link
     #RECONNECTION_DELAY_OPTION}} in addition to the options of its
     super class {@link AppenderSkeleton}.

     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
    */
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
                          new String[] {REMOTE_HOST_OPTION, PORT_OPTION, 
					LOCATION_INFO_OPTION,
					RECONNECTION_DELAY_OPTION});
  }

  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method.
   */
  public
  void setOption(String option, String value) {
    if(value == null) return;
    super.setOption(option, value);    

    if(option.equals(REMOTE_HOST_OPTION)) {
      address = getAddressByName(value);
      remoteHost = value;
    } else if (option.equals(PORT_OPTION)) {
      port = OptionConverter.toInt(value, port);
    } else if (option.equals(LOCATION_INFO_OPTION)) {
      locationInfo = OptionConverter.toBoolean(value, locationInfo);    
    } else if (option.equals(RECONNECTION_DELAY_OPTION)) {
      reconnectionDelay = OptionConverter.toInt(value, reconnectionDelay);  
    }
  }
  
  /**
     Connect to the specified <b>RemoteHost</b> and <b>Port</b>. 
  */
  public
  void activateOptions() {
    connect(address, port);
  }

  /**
     Close this appender. 
     <p>This will mark the appender as closed and
     call then {@link #cleanUp} method.
  */
  synchronized
  public
  void close() {
    if(closed)
      return;

    this.closed = true;
    cleanUp();
  }

  /**
     Drop the connection to the remote host and release the underlying
     connector thread if it has been created
   */
  public 
  void cleanUp() {
    if(oos != null) {
      try {
	oos.close();
      }
      catch(IOException e) {
	LogLog.error(""Could not close oos."", e);
      }
      oos = null;      
    }
    if(connector != null) {
      //LogLog.debug(""Interrupting the connector."");      
      connector.interrupted = true;
      connector = null;  // allow gc
    }
  }

  void connect(InetAddress address, int port) {
    if(this.address == null)
      return;
    try {
      // First, close the previous connection if any.
      cleanUp();          
      oos = new ObjectOutputStream(new Socket(address, port).getOutputStream());
    }
    catch(IOException e) {
      LogLog.error(""Could not connect to remote log4j server at [""
		   +address.getHostName()+""]. We will try again later."", e);
      fireConnector();
    }
  }


  public
  void append(LoggingEvent event) {
    if(event == null)
      return;

    if(address==null) {
      errorHandler.error(""No remote host is set for SocketAppender named \""""+
			this.name+""\""."");
      return;
    }

    if(oos != null) {
      try {
	if(locationInfo) {
	   event.getLocationInformation();	
	} 
	oos.writeObject(event);
	//LogLog.debug(""=========Flushing."");
	oos.flush();
	if(++counter >= RESET_FREQUENCY) {
	  counter = 0;
	  // Failing to reset the object output stream every now and
	  // then creates a serious memory leak.
	  //System.err.println(""Doing oos.reset()"");
	  oos.reset();
	}
      }
      catch(IOException e) {
	oos = null;
	LogLog.warn(""Detected problem with connection: ""+e);
	if(reconnectionDelay > 0) {
	  fireConnector();
	}
      }
    }
  }

  void fireConnector() {
    if(connector == null) {
      LogLog.debug(""Starting a new connector thread."");
      connector = new Connector();
      connector.setDaemon(true);
      connector.setPriority(Thread.MIN_PRIORITY);
      connector.start();      
    }
  }
  
  static
  InetAddress getAddressByName(String host) {
    try {
      return InetAddress.getByName(host);
    }	
    catch(Exception e) {
      LogLog.error(""Could not find address of [""+host+""]."", e);
      return null;
    }
  }

  /**
     The SocketAppender does not use a layout. Hence, this method returns
     <code>false</code>.
  */
  public
  boolean requiresLayout() {
    return false;
  }

  /**
     The <b>RemoteHost</b> option takes a string value which should be
     the host name of the server where a {@link SocketNode} is running.
   */
  public
  void setRemoteHost(String host) {
    address = getAddressByName(host);
    remoteHost = host;
  }
  
  /**
     Returns value of the <b>RemoteHost</b> option.
   */
  public
  String getRemoteHost() {
    return remoteHost;
  }
  
  /**
     The <b>Port</b> option takes a positive integer representing
     the port where the server is waiting for connections.
   */
  public
  void setPort(int port) {
    this.port = port;
  }
  
  /**
     Returns value of the <b>Port</b> option.
   */
  public
  int getPort() {
    return port;
  }
  
  /**
     The <b>LocationInfo</b> option takes a boolean value. If true,
     the information sent to the remote host will include location
     information. By default no location information is sent to the server.
   */
  public
  void setLocationInfo(boolean locationInfo) {
    this.locationInfo = locationInfo;
  }
  
  /**
     Returns value of the <b>LocationInfo</b> option.
   */
  public
  boolean getLocationInfo() {
    return locationInfo;
  }
  
  /**
     The <b>ReconnectionDelay</b> option takes a positive integer
     representing the number of milliseconds to wait between each
     failed connection attempt to the server. The default value of
     this option is 30000 which corresponds to 30 seconds.
     
     <p>Setting this option to zero turns off reconnection
     capability.
   */
  public
  void setReconnectionDelay(int delay) {
    this.reconnectionDelay = delay;
  }
  
  /**
     Returns value of the <b>ReconnectionDelay</b> option.
   */
  public
  int getReconnectionDelay() {
    return reconnectionDelay;
  }
  
  /**
     The Connector will reconnect when the server becomes available
     again.  It does this by attempting to open a new connection every
     <code>reconnectionDelay</code> milliseconds.

     <p>It stops trying whenever a connection is established. It will
     restart to try reconnect to the server when previpously open
     connection is droppped.

     @author  Ceki G&uuml;lc&uuml; 
     @since 0.8.4
  */
  class Connector extends Thread {

    boolean interrupted = false;

    public
    void run() {
      Socket socket;      
      while(!interrupted) {
	try {
	  sleep(reconnectionDelay);
	  LogLog.debug(""Attempting connection to ""+address.getHostName());
	  socket = new Socket(address, port);
	  synchronized(this) {
	    oos = new ObjectOutputStream(socket.getOutputStream()); 
	    connector = null;
	    break;
	  }
	}
	catch(InterruptedException e) {
	  LogLog.debug(""Connector interrupted. Leaving loop."");
	  return;
	}
	catch(java.net.ConnectException e) {
	  LogLog.debug(""Remote host ""+address.getHostName()
		       +"" refused connection."");
	}
	catch(IOException e) {	  
	  LogLog.debug(""Could not connect to "" + address.getHostName()+
		       "". Exception is "" + e);
	}
      }
      //LogLog.debug(""Exiting Connector.run() method."");
    }
    
    /**
       public
       void finalize() {
       LogLog.debug(""Connector finalize() has been called."");
       }
    */
  }

}
"
org/apache/log4j/test/Hello.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.test; 

import org.apache.log4j.Category;
import org.apache.log4j.BasicConfigurator;

/**
   Very simple log4j usage example.

   @author  Ceki G&uuml;lc&uuml;   
 */
public class Hello {

  static Category cat = Category.getInstance(Hello.class);

  public 
  static 
  void main(String argv[]) {
    BasicConfigurator.configure();
    cat.debug(""Hello world."");
    cat.info(""What a beatiful day."");
  }
}
"
org/apache/log4j/spi/OptionHandler.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

import org.apache.log4j.FileAppender;

/**
   A string based interface to configure package components.

   @author Ceki G&uuml;lc&uuml;
   @author Anders Kristensen
   @since 0.8.1
 */
public interface OptionHandler {

  /**
     Activate the options that were previously set with calls to option
     setters.

     <p>This allows to defer activiation of the options until all
     options have been set. This is required for components which have
     related options that remain ambigous until all are set.

     <p>For example, the FileAppender has the
     {@link FileAppender#setFile File} and
     {@link FileAppender#setAppend Append} options both of which are
     ambigous until the other is also set.
  */
  void activateOptions();

  /**
     Return list of strings that the OptionHandler instance recognizes.
     
     @deprecated We now use JavaBeans style getters/setters.
   */
  String[] getOptionStrings();

  /**
     Set <code>option</code> to <code>value</code>.

     <p>The handling of each option depends on the OptionHandler
     instance. Some options may become active immediately whereas
     other may be activated only when {@link #activateOptions} is
     called.
     
     @deprecated We now use JavaBeans style getters/setters.
  */
  void setOption(String option, String value);
}
"
org/apache/log4j/BasicConfigurator.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

// Contibutors: ""Luke Blanshard"" <Luke@quiq.com>
//              ""Mark DONSZELMANN"" <Mark.Donszelmann@cern.ch>
//              ""Muly Oved"" <mulyoved@hotmail.com>

package org.apache.log4j;

import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.or.ObjectRenderer;
import org.apache.log4j.or.RendererMap;
import java.util.Enumeration;

/**
   Use this class to quickly configure the package.

   <p>For file based configuration see {@link
   PropertyConfigurator}. For XML based configuration see {@link
   org.apache.log4j.xml.DOMConfigurator DOMConfigurator}.

   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public class BasicConfigurator {

  /**
     <p><code>DISABLE_OVERRIDE_KEY</code> is the name of the constant
     holding the string value <b>log4j.disableOverride</b>.

     <p>Setting the system property <b>log4j.disableOverride</b> to
     ""true"" or any other value than ""false"" overrides the effects of
     all methods {@link Hierarchy#disable}, {@link
     Hierarchy#disableAll}, {@link Hierarchy#disableDebug} and {@link
     Hierarchy#disableInfo}. Thus, enabling normal evaluation of logging
     requests, i.e. according to the <a
     href=""../../manual.html#selectionRule"">Basic Selection Rule</a>.

     <p>If both <code>log4j.disableOverride</code> and a
     <code>log4j.disable</code> options are present, then
     <code>log4j.disableOverride</code> as the name indicates
     overrides any <code>log4j.disable</code> options.
     
     @since 0.8.5 */ 
     public static final String DISABLE_OVERRIDE_KEY = ""log4j.disableOverride"";

  /**
     <p><code>DISABLE_KEY</code> is the name of the constant
     holding the string value <b>log4j.disable</b>.

     <p>Setting the system property <b>log4j.disable</b> to DEBUG,
     INFO, WARN, ERROR or FATAL is equivalent to calling the {@link
     Hierarchy#disable} method with the corresponding priority.

     <p>If both <code>log4j.disableOverride</code> and a
     <code>log4j.disable</code> options are present, then
     <code>log4j.disableOverride</code> as the name indicates
     overrides any <code>log4j.disable</code> options.
     
     @since 1.1 */
     public static final String DISABLE_KEY = ""log4j.disable"";


  /**
     Special priority value signifying inherited behaviour. The
     current value of this string constant is <b>inherited</b>.

  */
  public static final String INHERITED = ""inherited"";


  // Check if value of(DISABLE_OVERRIDE_KEY) system property is set.
  // If it is set to ""true"" or any value other than ""false"", then set
  // static variable Category.disable to Category.DISABLE_OVERRIDE.
  static {    
    String override = OptionConverter.getSystemProperty(DISABLE_OVERRIDE_KEY, null);
    if(override != null) {
      Category.defaultHierarchy.setDisableOverride(override);
    } else { // check for log4j.disable only in absence of log4j.disableOverride
      String disableStr = OptionConverter.getSystemProperty(DISABLE_KEY, null);
      if(disableStr != null) {
	Category.defaultHierarchy.disable(disableStr);
      }
    }
  }


  protected BasicConfigurator() {
  }

  /**
     Used by subclasses to add a renderer to the hierarchy passed as parameter.
   */
  protected
  void addRenderer(Hierarchy hierarchy, String renderedClassName, 
		   String renderingClassName) {
    LogLog.debug(""Rendering class: [""+renderingClassName+""], Rendered class: [""+
		 renderedClassName+""]."");
    ObjectRenderer renderer = (ObjectRenderer) 
             OptionConverter.instantiateByClassName(renderingClassName, 
						    ObjectRenderer.class,
						    null);
    if(renderer == null) {
      LogLog.error(""Could not instantiate renderer [""+renderingClassName+""]."");
      return;
    } else {
      try {
	Class renderedClass = Class.forName(renderedClassName);
	hierarchy.rendererMap.put(renderedClass, renderer);
      } catch(ClassNotFoundException e) {
	LogLog.error(""Could not find class [""+renderedClassName+""]."", e);
      }
    }
  }

  /**
     See {@link Hierarchy#disable(String)}.

     @deprecated Use <code>Category.getDefaultHierarchy().disable()</code> instead.  */
  public
  static
  void disable(String priorityStr) {
    Category.getDefaultHierarchy().disable(priorityStr);
  }

  /**
     See {@link Hierarchy#disable(Priority)}.

     @deprecated Use <code>Category.getDefaultHierarchy().disable(p)</code> instead.  */
  public
  static
  void disable(Priority p) {
  
  }
  

  /**
     See {@link Hierarchy#disableAll()}.

     @deprecated Use <code>Category.getDefaultHierarchy().disableAll()</code> instead.  */  
  public
  static
  void disableAll() {
      Category.getDefaultHierarchy().disable(Priority.FATAL);
  }

 /**
     See {@link Hierarchy#disableDebug()}.

     @deprecated Use <code>Category.getDefaultHierarchy().disableDebug()</code> instead.  */ 
  public
  static
  void disableDebug() {
    Category.getDefaultHierarchy().disable(Priority.DEBUG);
  }  

 /**
     See {@link Hierarchy#disableInfo()}.

     @deprecated Use <code>Category.getDefaultHierarchy().disableInfo()</code> instead.  */ 
  public
  static
  void disableInfo() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  } 
  

 /**
     See {@link Hierarchy#enableAll()}.

     @deprecated Use <code>Category.getDefaultHierarchy().enableAll()</code> instead.  */ 
  public
  static
  void enableAll() {
    Category.getDefaultHierarchy().disable(Priority.INFO);
  }

  /**
     Add a {@link FileAppender} that uses {@link PatternLayout} using
     the {@link PatternLayout#TTCC_CONVERSION_PATTERN} and prints to
     <code>System.out</code> to the root category.  */
  static
  public
  void configure() {
    Category root = Category.getRoot();
    root.addAppender(new ConsoleAppender(
           new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
  }

  /**
     Add <code>appender</code> to the root category.
     @param appender The appender to add to the root category.
  */
  static
  public
  void configure(Appender appender) {
    Category root = Category.getRoot();
    root.addAppender(appender);
  }

  /**
     Reset the default hierarchy to its defaut. It is equivalent to
     calling
     <code>Category.getDefaultHierarchy().resetConfiguration()</code>.
 
     See {@link Hierarchy#resetConfiguration()} for more details.  */
  public
  static
  void resetConfiguration() {
    Category.defaultHierarchy.resetConfiguration();
  }

  /**
     @deprecated Use <code>hierarchy.resetConfiguration()</code> instead.
  */
  public
  static
  void resetConfiguration(Hierarchy hierarchy) {
    hierarchy.resetConfiguration();
  }
}
"
org/apache/log4j/helpers/CountingQuietWriter.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import java.io.File;
import java.io.Writer;
import java.io.FileWriter;
import java.io.FilterWriter;
import java.io.IOException;

import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;

/**
   Counts the number of bytes written.

   @author Heinz Richter, heinz.richter@frogdot.com
   @since 0.8.1

   */
public class CountingQuietWriter extends QuietWriter {

  protected long count;

  public
  CountingQuietWriter(Writer writer, ErrorHandler eh) {
    super(writer, eh);
  }
  
  public
  void write(String string) {
    try {
      out.write(string);
      count += string.length();
    }
    catch(IOException e) {
      errorHandler.error(""Write failure."", e, ErrorCode.WRITE_FAILURE);
    }
  }

  public
  long getCount() {
    return count;
  }

  public
  void setCount(long count) {
    this.count = count;
  }
  
}
"
org/apache/log4j/test/L7D.java,false,"

//      Copyright 1996-2000, International Business Machines 
//      Corporation. All Rights Reserved.
// 
//      See the LICENCE file for the terms of distribution.

package org.apache.log4j.test; 

import org.apache.log4j.*;
import java.util.*;
import java.text.*;

/**
   This class is a simple test of the localization routines in
   Category class.

   @author Ceki G&uuml;lc&uuml;, IBM Zurich Research Laboratory */
public class L7D {
  static ResourceBundle[] bundles;
  

  public 
  static 
  void main(String args[]) {
    if(args.length == 3) 
      init(args[0], args[1], args[2]);
    else 
      Usage(""Wrong number of arguments."");

    test();
  }

  static
  void Usage(String msg) {
    System.err.println(msg);
    System.err.println( ""Usage: java "" + L7D.class.getName() +
			""configFile ISO639LanguageCode ISO2166CountryCode"");
    System.exit(1);
  }

  static
  void init(String configFile, String lanCode, String countryCode) {
    PropertyConfigurator.configure(configFile);
    bundles = new ResourceBundle[3];

    try {
      bundles[0] = ResourceBundle.getBundle(""L7D"", new Locale(""en"", ""US""));
      bundles[1] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""FR""));
      bundles[2] = ResourceBundle.getBundle(""L7D"", new Locale(""fr"", ""CH"")); 
					 
    }
    catch(MissingResourceException e) {
      e.printStackTrace();
    }
  }

  static
  void test() { 
    Category root = Category.getRoot();
    
    for(int i = 0; i < bundles.length; i++) {
      root.setResourceBundle(bundles[i]);
      
      root.l7dlog(Priority.DEBUG, ""bogus1"", null);            
      root.l7dlog(Priority.INFO, ""test"", null);
      root.l7dlog(Priority.WARN, ""hello_world"", null);
      root.l7dlog(Priority.DEBUG, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.ERROR, ""bogusMsg"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);      
      root.l7dlog(Priority.ERROR, ""msg1"",
		  new Object[] {new Integer(i+1), ""log4j""}, null);
      root.l7dlog(Priority.INFO, ""bogus2"", null);
    }
    
  }
  
}
"
org/apache/log4j/net/JMSAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.net;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.ErrorCode;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.OptionConverter;

import java.util.Properties;
import javax.jms.*;
import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;

/**
   A simple appender based on JMS.
   
   @author Ceki G&uuml;lc&uuml;
*/
public class JMSAppender extends AppenderSkeleton {
  /**
     A string constant used in naming the topic connection factory
     binding name option.  output file. Current value of this string
     constant is <b>TopicConnectionFactoryBindingName</b>.

     <p>Note that all option keys are case sensitive.
     
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION 
                                                 = ""TopicConnectionFactoryBindingName"";

  /**
     A string constant used in naming the topic binding name option.
     Current value of this string constant is <b>TopicBindingName</b>.

     <p>Note that all option keys are case sensitive.
     
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

  */
  public static final String TOPIC_BINDING_NAME_OPTION = ""TopicBindingName"";

  TopicConnection  topicConnection;
  TopicSession topicSession;
  TopicPublisher  topicPublisher;
  String topicBindingName;
  String tcfBindingName;

  public 
  JMSAppender() {
  }

 /**
     Retuns the option names for this component, namely the string
     array {@link #TOPIC_BINDING_NAME_OPTION}, {@link
     #TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION} in addition to the
     options of its super class {@link AppenderSkeleton}.
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  
  public
  String[] getOptionStrings() {
    return OptionConverter.concatanateArrays(super.getOptionStrings(),
          new String[] {TOPIC_BINDING_NAME_OPTION, 
			  TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION});
  }

 /**
     Set <code>JMSAppender</code> specific options.
          
     The options of the super class {@link AppenderSkeleton} are also
     recognized.

     <p>The <b>TopicConnectionFactoryBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>TopicConnectionFactory</code> from the JNDI context.

     <p>The <b>TopicBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>Topic</code> from the JNDI context.         
     
     
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 

 */

  public
  void setOption(String key, String value) {
    if(value == null) return;
    super.setOption(key, value);    
    
    if(key.equals(TOPIC_BINDING_NAME_OPTION)) 
      topicBindingName = value;
    else if(key.equals(TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION)) {
      tcfBindingName = value;
    }
  }
  
  /**
     The <b>TopicConnectionFactoryBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>TopicConnectionFactory</code> from the JNDI context.
   */
  public
  void setTopicConnectionFactoryBindingName(String tcfBindingName) {
    this.tcfBindingName = tcfBindingName;
  }
  
  /**
     Returns the value of the <b>TopicConnectionFactoryBindingName</b> option.
   */
  public
  String getTopicConnectionFactoryBindingName() {
    return tcfBindingName;
  }
  
  /**
     The <b>TopicBindingName</b> option takes a
     string value. Its value will be used to lookup the appropriate
     <code>Topic</code> from the JNDI context.
   */
  public
  void setTopicBindingName(String topicBindingName) {
    this.topicBindingName = topicBindingName;
  }
  
  /**
     Returns the value of the <b>TopicBindingName</b> option.
   */
  public
  String getTopicBindingName() {
    return topicBindingName;
  }
  
  public
  void activateOptions() {
    TopicConnectionFactory  topicConnectionFactory;

    try {
      Context ctx = new InitialContext();      
      topicConnectionFactory = (TopicConnectionFactory) lookup(ctx, tcfBindingName);
      topicConnection = topicConnectionFactory.createTopicConnection();
      topicConnection.start();
    
      topicSession = topicConnection.createTopicSession(false,
							Session.AUTO_ACKNOWLEDGE);
      
      Topic topic = (Topic) lookup(ctx, topicBindingName);
      topicPublisher = topicSession.createPublisher(topic);

      ctx.close();      
    } catch(Exception e) {
      errorHandler.error(""Error while activating options for appender named [""+name+
			 ""]."", e, ErrorCode.GENERIC_FAILURE);
    }
  }
 
  protected
  Object lookup(Context ctx, String name) throws NamingException {
    try {
      return ctx.lookup(name);
    } catch(NameNotFoundException e) {
      LogLog.error(""Could not find name [""+name+""]."");
      throw e;
    }    
  }
  
  protected
  boolean checkEntryConditions() {
    String fail = null;

    if(this.topicConnection == null) {
      fail = ""No TopicConnection"";
    } else if(this.topicSession == null) {
      fail = ""No TopicSession"";
    } else if(this.topicPublisher == null) {
      fail = ""No TopicPublisher"";
    } 

    if(fail != null) {
      errorHandler.error(fail +"" for JMSAppender named [""+name+""]."");      
      return false;
    } else {
      return true;
    }
  }

  /**
     Close this JMSAppender. Closing releases all resources used by the
     appender. A closed appender cannot be re-opened. */
  public 
  synchronized // avoid concurrent append and close operations
  void close() {
    if(this.closed) 
      return;

    LogLog.debug(""Closing appender [""+name+""]."");
    this.closed = true;    

    try {
      if(topicSession != null) 
	topicSession.close();	
      if(topicConnection != null) 
	topicConnection.close();
    } catch(Exception e) {
      LogLog.error(""Error while closing JMSAppender [""+name+""]."", e);	
    }   
    // Help garbage collection
    topicPublisher = null;
    topicSession = null;
    topicConnection = null;
  }

  /**
     This method called by {@link AppenderSkeleton#doAppend} method to
     do most of the real appending work.  */
  public
  void append(LoggingEvent event) {
    if(!checkEntryConditions()) {
      return;
    }

    try {
      ObjectMessage msg = topicSession.createObjectMessage();
      msg.setObject(event);
      topicPublisher.publish(msg);
    } catch(Exception e) {
      errorHandler.error(""Could not publish message in JMSAppender [""+name+""]."", e, 
			 ErrorCode.GENERIC_FAILURE);
    }
  }

  public
  boolean requiresLayout() {
    return false;
  }  
}
"
org/apache/log4j/spi/TriggeringEventEvaluator.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j.spi;

/**
   
   Implementions of this interface allow certain appenders to decide
   when to perform an appender specific action.

  <p>For example the {@link org.apache.log4j.net.SMTPAppender} sends
  an email when the {@link #isTriggeringEvent} method returns
  <code>true</code> and adds the event to an internal buffer when the
  returned result is <code>false</code>.

  @author Ceki G&uuml;lc&uuml;
  @since version 1.0
   
 */
public interface TriggeringEventEvaluator {
  
  /**
     Is this the triggering event?
   */
  public boolean isTriggeringEvent(LoggingEvent event);
}
"
org/apache/log4j/config/PropertySetterException.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.config;

/**
 * Thrown when an error is encountered whilst attempting to set a property
 * using the {@link PropertySetter} utility class.
 * 
 * @author Anders Kristensen
 * @since 1.1
 */
public class PropertySetterException extends Exception {
  protected Throwable rootCause;
  
  public
  PropertySetterException(String msg) {
    super(msg);
  }
  
  public
  PropertySetterException(Throwable rootCause)
  {
    super();
    this.rootCause = rootCause;
  }
  
  /**
     Returns descriptive text on the cause of this exception.
   */
  public
  String getMessage() {
    String msg = super.getMessage();
    if (msg == null && rootCause != null) {
      msg = rootCause.getMessage();
    }
    return msg;
  }
}"
org/apache/log4j/helpers/NullEnumeration.java,false,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.APL file.
 */

package org.apache.log4j.helpers;

import java.util.Enumeration;
import java.util.NoSuchElementException;

/**
   
  An always-empty Enumerator.

  @author Anders Kristensen
  @since version 1.0
 */
public class NullEnumeration implements Enumeration {
  private static final NullEnumeration instance = new NullEnumeration();
  
  private
  NullEnumeration() {
  }
  
  public
  static
  NullEnumeration getInstance() {
    return instance;
  }
  
  public
  boolean hasMoreElements() {
    return false;
  }
  
  public
  Object nextElement() {
    throw new NoSuchElementException();
  }
}
"
org/apache/log4j/RollingFileAppender.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */



package org.apache.log4j;

import java.beans.*;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.io.File;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import org.apache.log4j.helpers.OptionConverter;
import org.apache.log4j.helpers.QuietWriter;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.helpers.CountingQuietWriter;
import org.apache.log4j.spi.LoggingEvent;

/**
   RollingFileAppender extends FileAppender to backup the log files when 
   they reach a certain size. 

   @author Heinz Richter
   @author Ceki G&uuml;lc&uuml;
   
*/
public class RollingFileAppender extends FileAppender {
  /**
     A string constant used in naming the option for setting the
     maximum size of the log file. Current value of this string constant is
     <b>MaxFileSize</b>.
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.

   */
  static final public String MAX_FILE_SIZE_OPTION = ""MaxFileSize"";
  
   /**
     A string constant used in naming the option for setting the the
     number of backup files to retain. Current value of this string
     constant is <b>MaxBackupIndex</b>. 
     
     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
 */
  static final public String MAX_BACKUP_INDEX_OPTION = ""MaxBackupIndex"";  

  /**
     The default maximum file size is 10MB. 
  */
  protected long maxFileSize = 10*1024*1024; 

  /**
     There is one backup file by default.
   */
  protected int  maxBackupIndex  = 1;    

  /**
     The default constructor simply calls its {@link
     FileAppender#FileAppender parents constructor}.  */
  public
  RollingFileAppender() {
    super();
  }
  
  /**
    Instantiate a RollingFileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the ouput
    destination for this appender.

    <p>If the <code>append</code> parameter is true, the file will be
    appended to. Otherwise, the file desginated by
    <code>filename</code> will be truncated before being opened.
  */
  public
  RollingFileAppender(Layout layout, String filename, boolean append)
                                      throws IOException {
    super(layout, filename, append);
  }

  /**
     Instantiate a FileAppender and open the file designated by
    <code>filename</code>. The opened filename will become the output
    destination for this appender.

    <p>The file will be appended to.  */
  public
  RollingFileAppender(Layout layout, String filename) throws IOException {
    super(layout, filename);
  }

  /**
     Returns the value of the <b>MaxBackupIndex</b> option.
   */
  public
  int getMaxBackupIndex() {
    return maxBackupIndex;
  }

 /**
    Get the maximum size that the output file is allowed to reach
    before being rolled over to backup files.

    @since 1.1
 */
  public
  long getMaximumFileSize() {
    return maxFileSize;
  }
  
  /**
     Retuns the option names for this component, namely {@link
     #MAX_FILE_SIZE_OPTION} and {@link #MAX_BACKUP_INDEX_OPTION} in
     addition to the options of {@link FileAppender#getOptionStrings}

     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
  */
  public
  String[] getOptionStrings() {

    return OptionConverter.concatanateArrays(super.getOptionStrings(),
		 new String[] {MAX_FILE_SIZE_OPTION, MAX_BACKUP_INDEX_OPTION});
  }

  /**
     Implements the usual roll over behaviour.

     <p>If <code>MaxBackupIndex</code> is positive, then files
     {<code>File.1</code>, ..., <code>File.MaxBackupIndex -1</code>}
     are renamed to {<code>File.2</code>, ..., 
     <code>File.MaxBackupIndex</code>}. Moreover, <code>File</code> is
     renamed <code>File.1</code> and closed. A new <code>File</code> is
     created to receive further log output.

     <p>If <code>MaxBackupIndex</code> is equal to zero, then the
     <code>File</code> is truncated with no backup files created.
     
   */
  public // synchronization not necessary since doAppend is alreasy synched
  void rollOver() {
    File target;    
    File file;

    LogLog.debug(""rolling over count="" + ((CountingQuietWriter) qw).getCount());
    LogLog.debug(""maxBackupIndex=""+maxBackupIndex);
    
    // If maxBackups <= 0, then there is no file renaming to be done.
    if(maxBackupIndex > 0) {
      // Delete the oldest file, to keep Windows happy.
      file = new File(fileName + '.' + maxBackupIndex);    
      if (file.exists())
       file.delete();
      
      // Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
      for (int i = maxBackupIndex - 1; i >= 1; i--) {
	file = new File(fileName + ""."" + i);
	if (file.exists()) {
	  target = new File(fileName + '.' + (i + 1));
	  LogLog.debug(""Renaming file "" + file + "" to "" + target);
	  file.renameTo(target);
	}
      }

      // Rename fileName to fileName.1
      target = new File(fileName + ""."" + 1);

      this.closeFile(); // keep windows happy. 

      file = new File(fileName);
      LogLog.debug(""Renaming file "" + file + "" to "" + target);
      file.renameTo(target);
    }
    
    try {
      // This will also close the file. This is OK since multiple
      // close operations are safe.
      this.setFile(fileName, false);
    }
    catch(IOException e) {
      LogLog.error(""setFile(""+fileName+"", false) call failed."", e);
    }
  }

  public
  synchronized
  void setFile(String fileName, boolean append) throws IOException {
    super.setFile(fileName, append);
    if(append) {
      File f = new File(fileName);
      ((CountingQuietWriter) qw).setCount(f.length());
    }
  }

  /**
     
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 

  */
  public
  void setOption(String key, String value) {
    super.setOption(key, value);    
    if(key.equalsIgnoreCase(MAX_FILE_SIZE_OPTION)) {
      maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
    }
    else if(key.equalsIgnoreCase(MAX_BACKUP_INDEX_OPTION)) {
      maxBackupIndex = OptionConverter.toInt(value, maxBackupIndex);
    }
  }
  
  /**
     Set the maximum number of backup files to keep around.
     
     <p>The <b>MaxBackupIndex</b> option determines how many backup
     files are kept before the oldest is erased. This option takes
     a positive integer value. If set to zero, then there will be no
     backup files and the log file will be truncated when it reaches
     <code>MaxFileSize</code>.
   */
  public
  void setMaxBackupIndex(int maxBackups) {
    this.maxBackupIndex = maxBackups;    
  }
  
  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.

     @deprecated Use {@link #setMaximumFileSize} instead.
   */
  public
  void setMaxFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }

  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.

     <p>This method is equivalent to {@link #setMaxFileSize} except
     that it is required for differentiating the setter taking a
     <code>long</code> argument from the setter taking a
     <code>String</code> argument by the JavaBeans {@link
     java.beans.Introspector Introspector}.

     @see #setMaxFileSize(String)
 */
  public
  void setMaximumFileSize(long maxFileSize) {
    this.maxFileSize = maxFileSize;
  }


  /**
     Set the maximum size that the output file is allowed to reach
     before being rolled over to backup files.
     
     <p>In configuration files, the <b>MaxFileSize</b> option takes an
     long integer in the range 0 - 2^63. You can specify the value
     with the suffixes ""KB"", ""MB"" or ""GB"" so that the integer is
     interpreted being expressed respectively in kilobytes, megabytes
     or gigabytes. For example, the value ""10KB"" will be interpreted
     as 10240.
   */
  public
  void setMaxFileSize(String value) {
    maxFileSize = OptionConverter.toFileSize(value, maxFileSize + 1);
  }

  protected
  void setQWForFiles(Writer writer) {
     this.qw = new CountingQuietWriter(writer, errorHandler);
  }

  /**
     This method differentiates RollingFileAppender from its super
     class.  

     @since 0.9.0
  */
  protected
  void subAppend(LoggingEvent event) {
    super.subAppend(event);
    if((fileName != null) &&
                     ((CountingQuietWriter) qw).getCount() >= maxFileSize) 
      this.rollOver();
   }
}
"
org/apache/log4j/AppenderSkeleton.java,true,"/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software
 * License version 1.1, a copy of which has been included with this
 * distribution in the LICENSE.APL file.  */

package org.apache.log4j;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.Filter;
import org.apache.log4j.spi.ErrorHandler;
import org.apache.log4j.spi.OptionHandler;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.helpers.OnlyOnceErrorHandler;
import org.apache.log4j.helpers.LogLog;


/** 
   Abstract super-class of the other appenders in the package.
   
   This class provides the code for common functionality, such as
   support for threshold filtering and support for general filters.

   @since 0.8.1
   @author Ceki G&uuml;lc&uuml; */
public abstract class AppenderSkeleton implements Appender, OptionHandler {

  /**
     A string constant used in naming the option for setting the
     threshold for the appender. See also {@link #setThreshold
     setThreshold} method. Current value of this string constant is
     <b>Threshold</b>.

     @deprecated Options are now handled using the JavaBeans paradigm.
     This constant is not longer needed and will be removed in the
     <em>near</em> term.
     
  */
  public static final String THRESHOLD_OPTION = ""Threshold"";


  /** The layout variable does not need to be set if the appender
      implementation has its own layout. */
  protected Layout layout;

  /** Appenders are named. */
  protected String name;

  /**
     There is no priority threshold filtering by default.  */
  protected Priority threshold;

  /** 
      It is assumed and enforced that errorHandler is never null.
  */
  protected ErrorHandler errorHandler = new OnlyOnceErrorHandler();

  /** The first filter in the filter chain. Set to <code>null</code>
      initially. */
  protected Filter headFilter;
  /** The last filter in the filter chain. */
  protected Filter tailFilter;

  /**
     Is this appender closed? 
   */
  protected boolean closed = false;


  /**
     Derived appenders should override this method if option structure
     requires it.  */
  public
  void activateOptions() {
  }


  /**
     Add a filter to end of the filter list.

     @since 0.9.0
   */
  public
  void addFilter(Filter newFilter) {
    if(headFilter == null) {
      headFilter = tailFilter = newFilter;
    } else {
      tailFilter.next = newFilter;
      tailFilter = newFilter;    
    }
  }

  /**
     Subclasses of <code>AppenderSkeleton</code> should imlement this
     method to perform actual logging. See also {@link #doAppend
     AppenderSkeleton.doAppend} method.

     @since 0.9.0
  */
  abstract
  protected
  void append(LoggingEvent event);


  /**
     Clear the filters chain.
     
     @since 0.9.0 */
  public
  void clearFilters() {
    headFilter = tailFilter = null;
  }

  /**
     Finalize this appender by calling the imlenentation's
     <code>close</code> method.

     @since 0.8.4
  */
  public
  void finalize() {
    // An appender might be closed then garbage collected. There is no
    // point in closing twice.
    if(this.closed) 
      return;

    LogLog.debug(""Finalizing appender named [""+name+""]."");
    close();
  }


  /** 
      Return the currently set {@link ErrorHandler} for this
      Appender.  

      @since 0.9.0 */
  public
  ErrorHandler getErrorHandler() {
    return this.errorHandler;
  }


  /**
     Returns the head Filter.
     
     @since 1.1
  */
  public
  Filter getFilter() {
    return headFilter;
  }

  /** 
      Return the first filter in the filter chain for this
      Appender. The return value may be <code>null</code> if no is
      filter is set.
      
  */
  public
  final
  Filter getFirstFilter() {
    return headFilter;
  }

  /**
     Returns the layout of this appender. The value may be null.
  */
  public
  Layout getLayout() {
    return layout;
  }


  /**
     Returns the name of this FileAppender.
   */
  public
  final
  String getName() {
    return this.name;
  }

  /**
     Returns the string array {{@link #THRESHOLD_OPTION}}.

     <p>Configurable appenders must override this method to return the
     additional options they accept.  
     
     @deprecated We now use JavaBeans introspection to configure
     components. Options strings are no longer needed.
   */
  public
  String[] getOptionStrings() {
    return new String[] {THRESHOLD_OPTION};
  }

  

  /**
     Returns this appenders threshold priority. See the {@link
     #setThreshold} method for the meaning of this option.
     
     @since 1.1 */
  public
  Priority getThreshold() {
    return threshold;
  }


  /**
     Check whether the message priority is below the appender's
     threshold. Ig there is no threshold set, then the return value is
     always <code>true</code>.

  */
  public
  boolean isAsSevereAsThreshold(Priority priority) {
    return ((threshold == null) || priority.isGreaterOrEqual(threshold));
  }


  /**
     This method performs threshold checks and invokes filters before
     delegating actual logging to the sub-classes specific {@link
     AppenderSkeleton#append} method.

   */
  public
  synchronized 
  void doAppend(LoggingEvent event) {
    if(closed) {
      LogLog.error(""Attempted to append to closed appender named [""+name+""]."");
    }

    if(!isAsSevereAsThreshold(event.priority)) {
      return;
    }

    Filter f = this.headFilter;
    
    FILTER_LOOP:
    while(f != null) {
      switch(f.decide(event)) {
      case Filter.DENY: return;
      case Filter.ACCEPT: break FILTER_LOOP;
      case Filter.NEUTRAL: f = f.next;
      }
    }
    
    this.append(event);    
  }

  /** 
      Set the {@link ErrorHandler} for this Appender.
      @since 0.9.0
  */
  public
  synchronized
  void setErrorHandler(ErrorHandler eh) {
    if(eh == null) {
      // We do not throw exception here since the cause is probably a
      // bad config file.
      LogLog.warn(""You have tried to set a null error-handler."");
    } else {
      this.errorHandler = eh;
    }
  }

  /**
     Set the layout for this appender. Note that some appenders have
     their own (fixed) layouts or do not use one. For example, the
     {@link org.apache.log4j.net.SocketAppender} ignores the layout set
     here. 
  */
  public
  void setLayout(Layout layout) {
    this.layout = layout;
  }

  
  /**
     Set the name of this Appender.
   */
  public
  void setName(String name) {
    this.name = name;
  }


  /**
     @deprecated Use the setter method for the option directly instead
     of the generic <code>setOption</code> method. 
  */
  public
  void setOption(String key, String value) {
    if(key.equalsIgnoreCase(THRESHOLD_OPTION)) {
      threshold = Priority.toPriority(value);
    }
  }
  
  /**
     Set the threshold priority. All log events with lower priority
     than the threshold priority are ignored by the appender.
     
     <p>In configuration files this option is specified by setting the
     value of the <b>Threshold</b> option to a priority
     string, such as ""DEBUG"", ""INFO"" and so on.
     
     @since 0.8.3 */
  public
  void setThreshold(Priority threshold) {
    this.threshold = threshold;
  }  
}
"
