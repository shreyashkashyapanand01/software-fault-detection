File,Bug,SRC
org/apache/camel/processor/loadbalancer/RandomLoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.List;

/**
 * Implements the random load balancing policy
 *
 * @version $Revision: 1.1 $
 */
public class RandomLoadBalancer extends QueueLoadBalancer {

    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        while (true) {
            int index = (int) Math.round(Math.random() * size);
            if (index < size) {
                return processors.get(index);
            }
        }
    }
}
"
org/apache/camel/builder/ValueBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;

/**
 * A builder of expressions or predicates based on values.
 *
 * @version $Revision: $
 */
public class ValueBuilder<E extends Exchange> implements Expression<E> {
    private Expression<E> expression;

    public ValueBuilder(Expression<E> expression) {
        this.expression = expression;
    }

    public Object evaluate(E exchange) {
        return expression.evaluate(exchange);
    }

    public Expression<E> getExpression() {
        return expression;
    }

    @Override
    public String toString() {
        return expression.toString();
    }

    // Predicate builders
    //-------------------------------------------------------------------------

    @Fluent
    public Predicate<E> isNotEqualTo(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isNotEqualTo(expression, right));
    }

    @Fluent
    public Predicate<E> isEqualTo(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isEqualTo(expression, right));
    }

    @Fluent
    public Predicate<E> isLessThan(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThan(expression, right));
    }

    @Fluent
    public Predicate<E> isLessThanOrEqualTo(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(expression, right));
    }

    @Fluent
    public Predicate<E> isGreaterThan(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThan(expression, right));
    }

    @Fluent
    public Predicate<E> isGreaterThanOrEqualTo(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(expression, right));
    }

    @Fluent
    public Predicate<E> isInstanceOf(@FluentArg(""class"")Class type) {
        return onNewPredicate(PredicateBuilder.isInstanceOf(expression, type));
    }

    @Fluent
    public Predicate<E> matchesRegex(@FluentArg(""regex"")String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }

    @Fluent
    public Predicate<E> isNull() {
        return onNewPredicate(PredicateBuilder.isNull(expression));
    }

    @Fluent
    public Predicate<E> isNotNull() {
        return onNewPredicate(PredicateBuilder.isNotNull(expression));
    }

    /**
     * Create a predicate that the left hand expression contains the value of the right hand expression
     *
     * @param value the element which is compared to be contained within this expression
     * @return a predicate which evaluates to true if the given value expression is contained within this
     * expression value
     */
    @Fluent
    public Predicate<E> contains(@FluentArg(""value"")Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.contains(expression, right));
    }


    /**
     * Creates a predicate which is true if this expression matches the given regular expression
     *
     * @param regex the regular expression to match
     * @return a predicate which evaluates to true if the expression matches the regex
     */
    @Fluent
    public Predicate<E> regex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }


    // Expression builders
    //-------------------------------------------------------------------------

    @Fluent
    public ValueBuilder<E> tokenize() {
        return tokenize(""\n"");
    }

    @Fluent
    public ValueBuilder<E> tokenize(@FluentArg(""token"")String token) {
        Expression<E> newExp = ExpressionBuilder.tokenizeExpression(expression, token);
        return new ValueBuilder<E>(newExp);
    }

    /**
     * Tokenizes the string conversion of this expression using the given regular expression
     */
    @Fluent
    public ValueBuilder<E> regexTokenize(@FluentArg(""regex"")String regex) {
        Expression<E> newExp = ExpressionBuilder.regexTokenize(expression, regex);
        return new ValueBuilder<E>(newExp);
    }

    /**
     * Replaces all occurrencies of the regular expression with the given replacement
     */
    @Fluent
    public ValueBuilder<E> regexReplaceAll(@FluentArg(""regex"")String regex, @FluentArg(""replacement"")String replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }

    /**
     * Replaces all occurrencies of the regular expression with the given replacement
     */
    @Fluent
    public ValueBuilder<E> regexReplaceAll(@FluentArg(""regex"")String regex, @FluentArg(""replacement"")Expression<E> replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }


    /**
     * Converts the current value to the given type using the registered type converters
     *
     * @param type the type to convert the value to
     * @return the current builder
     */
    @Fluent
    public ValueBuilder<E> convertTo(@FluentArg(""type"")Class type) {
        Expression<E> newExp = ExpressionBuilder.convertTo(expression, type);
        return new ValueBuilder<E>(newExp);
    }

    /**
     * Converts the current value a String using the registered type converters
     *
     * @return the current builder
     */
    @Fluent
    public ValueBuilder<E> convertToString() {
        return convertTo(String.class);
    }

    /**
     * Appends the string evaluation of this expression with the given value
     * @param value the value or expression to append
     * @return the current builder
     */
    @Fluent
    public ValueBuilder<E> append(@FluentArg(""value"") Object value) {
        return new ValueBuilder<E>(ExpressionBuilder.append(expression, asExpression(value)));
    }

    
    // Implementation methods
    //-------------------------------------------------------------------------

    /**
     * A stategy method to allow derived classes to deal with the newly created predicate
     * in different ways
     */
    protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
        return predicate;
    }

    protected Expression<E> asExpression(Object value) {
        if (value instanceof Expression) {
            return (Expression<E>) value;
        }
        else {
            return ExpressionBuilder.constantExpression(value);
        }
    }
}
"
org/apache/camel/builder/ResequencerBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.Exchange;
import org.apache.camel.Service;
import org.apache.camel.processor.Resequencer;

import java.util.List;

/**
 * @version $Revision: 1.1 $
 */
public class ResequencerBuilder extends FromBuilder {
    private final List<Expression<Exchange>> expressions;
    private long batchTimeout = 1000L;
    private int batchSize = 100;

    public ResequencerBuilder(FromBuilder builder, List<Expression<Exchange>> expressions) {
        super(builder);
        this.expressions = expressions;
    }

    @Override
    public Route createRoute() throws Exception {
        final Processor processor = super.createProcessor();
        final Resequencer resequencer = new Resequencer(getFrom(), processor, expressions);

        return new Route<Exchange>(getFrom()) {
            protected void addServices(List<Service> list) throws Exception {
                list.add(resequencer);
            }

            @Override
            public String toString() {
                return ""ResequencerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
            }
        };
    }

    // Builder methods
    //-------------------------------------------------------------------------
    public ResequencerBuilder batchSize(int batchSize) {
        setBatchSize(batchSize);
        return this;
    }

    public ResequencerBuilder batchTimeout(int batchTimeout) {
        setBatchTimeout(batchTimeout);
        return this;
    }

    // Properties
    //-------------------------------------------------------------------------
    public int getBatchSize() {
        return batchSize;
    }

    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }

    public long getBatchTimeout() {
        return batchTimeout;
    }

    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
}
"
org/apache/camel/Message.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.util.Map;

/**
 * Implements the <a href=""http://activemq.apache.org/camel/message.html"">Message</a>
 * pattern and represents an inbound or outbound message as part of an {@link Exchange}
 * 
 * @version $Revision$
 */
public interface Message {
    
    /**
     * @return the id of the message
     */
    String getMessageId();
    
    /**
     * set the id of the message
     * @param messageId
     */
    void setMessageId(String messageId);

    /**
     * Returns the exchange this message is related to
     * 
     * @return
     */
    Exchange getExchange();
    
    /**
     * Accesses a specific header
     *
     * @param name
     * @return object header associated with the name
     */
    Object getHeader(String name);

    /**
     * Returns a header associated with this message by name and specifying the type required
     *
     * @param name the name of the header
     * @param type the type of the header
     * @return the value of the given header or null if there is no property for the given name or it cannot be
     * converted to the given type
     */
    <T> T getHeader(String name, Class<T> type);

    /**
     * Sets a header on the message
     *
     * @param name  of the header
     * @param value to associate with the name
     */
    void setHeader(String name, Object value);

    /**
     * Returns all of the headers associated with the message
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getHeaders();
    
    /**
     * Set all the headers associated with this message
     * @param headers
     */
    void setHeaders(Map<String,Object> headers);

    /**
     * Returns the body of the message as a POJO
     *
     * @return the body of the message
     */
    public Object getBody();

    /**
     * Returns the body as the specified type
     *
     * @param type the type that the body
     * @return the body of the message as the specified type
     */
    public <T> T getBody(Class<T> type);

    /**
     * Sets the body of the message
     */
    public void setBody(Object body);

    /**
     * Sets the body of the message as a specific type
     */
    public <T> void setBody(Object body, Class<T> type);

    /**
     * Creates a copy of this message so that it can be used and possibly modified further in another exchange
     * 
     * @return a new message instance copied from this message
     */
    Message copy();

}
"
org/apache/camel/builder/ConstantProcessorBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * @version $Revision$
 */
public class ConstantProcessorBuilder implements ProcessorFactory {
    private Processor processor;

    public ConstantProcessorBuilder(Processor processor) {
        this.processor = processor;
    }

    public Processor createProcessor() {
        return processor;
    }
}
"
org/apache/camel/CamelTemplate.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ProducerCache;

import java.util.HashMap;
import java.util.Map;

/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate et al)
 * for working with Camel and sending {@link Message} instances in an {@link Exchange}
 * to an {@link Endpoint}.
 *
 * @version $Revision$
 */
public class CamelTemplate<E extends Exchange> extends ServiceSupport {
    private CamelContext context;
    private ProducerCache<E> producerCache = new ProducerCache<E>();
    private boolean useEndpointCache = true;
    private Map<String, Endpoint<E>> endpointCache = new HashMap<String, Endpoint<E>>();
    private Endpoint<E> defaultEndpoint;


    public CamelTemplate(CamelContext context) {
        this.context = context;
    }

    public CamelTemplate(CamelContext context, Endpoint defaultEndpoint) {
        this(context);
        this.defaultEndpoint = defaultEndpoint;
    }

    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param exchange    the exchange to send
     */
    public E send(String endpointUri, E exchange) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        send(endpoint, exchange);
        return exchange;
    }

    /**
     * Sends an exchange to an endpoint using a supplied @{link Processor} to populate the exchange
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     */
    public E send(String endpointUri, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor);
    }

    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public E send(Endpoint<E> endpoint, E exchange) {
        E convertedExchange = endpoint.toExchangeType(exchange);
        producerCache.send(endpoint, convertedExchange);
        return exchange;
    }

    /**
     * Sends an exchange to an endpoint using a supplied @{link Processor} to populate the exchange
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        return producerCache.send(endpoint, processor);
    }

    /**
     * Send the body to an endpoint
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    public Object sendBody(Endpoint<E> endpoint, final Object body) {
        E result = send(endpoint, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }

    /**
     * Send the body to an endpoint
     *
     * @param endpointUri
     * @param body        = the payload
     * @return the result
     */
    public Object sendBody(String endpointUri, final Object body) {
        E result = send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }

    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload send
     * @param header      the header name
     * @param headerValue the header value
     * @return the result
     */
    public Object sendBody(String endpointUri, final Object body, final String header, final Object headerValue) {
        E result = send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setHeader(header, headerValue);
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }
    
    /**
     * Sends the body to an endpoint with the specified headers and header values
     *
     * @param endpointUri the endpoint URI to send to
     * @param body        the payload send
     * @return the result
     */
    public Object sendBody(String endpointUri, final Object body, final Map<String, Object> headers) {
        E result = send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                for (Map.Entry<String, Object> header : headers.entrySet()) {
                    in.setHeader(header.getKey(), header.getValue());
				}
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }

    // Methods using the default endpoint
    //-----------------------------------------------------------------------

    /**
     * Sends the body to the default endpoint and returns the result content
     *
     * @param body the body to send
     * @return the returned message body
     */
    public Object sendBody(Object body) {
        return sendBody(getMandatoryDefaultEndpoint(), body);
    }

    /**
     * Sends the exchange to the default endpoint
     *
     * @param exchange the exchange to send
     */
    public E send(E exchange) {
        return send(getMandatoryDefaultEndpoint(), exchange);
    }

    /**
     * Sends an exchange to the default endpoint
     * using a supplied @{link Processor} to populate the exchange
     *
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Processor processor) {
        return send(getMandatoryDefaultEndpoint(), processor);
    }


    // Properties
    //-----------------------------------------------------------------------
    public Producer<E> getProducer(Endpoint<E> endpoint) {
        return producerCache.getProducer(endpoint);
    }

    public CamelContext getContext() {
        return context;
    }

    public Endpoint<E> getDefaultEndpoint() {
        return defaultEndpoint;
    }

    public void setDefaultEndpoint(Endpoint<E> defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }

    /**
     * Sets the default endpoint to use if none is specified
     */
    public void setDefaultEndpointUri(String endpointUri) {
        setDefaultEndpoint(getContext().getEndpoint(endpointUri));
    }

    public boolean isUseEndpointCache() {
        return useEndpointCache;
    }

    public void setUseEndpointCache(boolean useEndpointCache) {
        this.useEndpointCache = useEndpointCache;
    }

    // Implementation methods
    //-----------------------------------------------------------------------

    protected Endpoint resolveMandatoryEndpoint(String endpointUri) {
        Endpoint endpoint = null;

        if (isUseEndpointCache()) {
            synchronized (endpointCache) {
                endpoint = endpointCache.get(endpointUri);
                if (endpoint == null) {
                    endpoint = context.getEndpoint(endpointUri);
                    if (endpoint != null) {
                        endpointCache.put(endpointUri, endpoint);
                    }
                }
            }
        }
        else {
            endpoint = context.getEndpoint(endpointUri);
        }
        if (endpoint == null) {
            throw new NoSuchEndpointException(endpointUri);
        }
        return endpoint;
    }

    protected Endpoint<E> getMandatoryDefaultEndpoint() {
        Endpoint<E> answer = getDefaultEndpoint();
        ObjectHelper.notNull(answer, ""defaultEndpoint"");
        return answer;
    }

    protected void doStart() throws Exception {
        producerCache.start();
    }

    protected void doStop() throws Exception {
        producerCache.stop();
    }

    protected Object extractResultBody(E result) {
        return result != null ? result.getOut().getBody() : null;
    }
}
"
org/apache/camel/processor/ChoiceProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.util.ServiceHelper;
import org.apache.camel.impl.ServiceSupport;

import java.util.ArrayList;
import java.util.List;

/**
 * Implements a Choice structure where one or more predicates are used which if they are true their processors
 * are used, with a default otherwise clause used if none match.
 *
 * @version $Revision$
 */
public class ChoiceProcessor extends ServiceSupport implements Processor {
    private List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
    private Processor otherwise;

    public ChoiceProcessor(List<FilterProcessor> filters, Processor otherwise) {
        this.filters = filters;
        this.otherwise = otherwise;
    }

    public void process(Exchange exchange) throws Exception {
        for (FilterProcessor filterProcessor : filters) {
            Predicate<Exchange> predicate = filterProcessor.getPredicate();
            if (predicate != null && predicate.matches(exchange)) {
                filterProcessor.getProcessor().process(exchange);
                return;
            }
        }
        if (otherwise != null) {
            otherwise.process(exchange);
        }
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (FilterProcessor processor : filters) {
            if (first) {
                first = false;
            }
            else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor.getPredicate().toString());
            builder.append("": "");
            builder.append(processor.getProcessor());
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }

    public List<FilterProcessor> getFilters() {
        return filters;
    }

    public Processor getOtherwise() {
        return otherwise;
    }


    protected void doStart() throws Exception {
        ServiceHelper.startServices(filters);
        ServiceHelper.startServices(otherwise);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(otherwise);
        ServiceHelper.stopServices(filters);
    }
}
"
org/apache/camel/util/UuidGenerator.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Generator for Globally unique Strings.
 */

public class UuidGenerator {

    private static final Logger log = Logger.getLogger(UuidGenerator.class.getName());
    private static final String UNIQUE_STUB;
    private static int instanceCount;
    private static String hostName;
    private String seed;
    private long sequence;
    
    static {
        String stub = """";
        boolean canAccessSystemProps = true;
        try{
            SecurityManager sm = System.getSecurityManager();
            if(sm != null){
                sm.checkPropertiesAccess();
            }
        }catch(SecurityException se){
            canAccessSystemProps = false;
        }
        
        if ( canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
                ServerSocket ss = new ServerSocket(0);
                stub=""/"" + ss.getLocalPort() + ""-"" + System.currentTimeMillis() + ""/"";
                Thread.sleep(100);
                ss.close();
            }catch(Exception ioe){
                log.log(Level.WARNING, ""could not generate unique stub"",ioe);
            }
        }else{
            hostName=""localhost"";
            stub = ""-1-"" +System.currentTimeMillis() +""-"";
        }
        UNIQUE_STUB = stub;
    }
    
    /**
     * As we have to find the hostname as a side-affect of generating
     * a unique stub, we allow it's easy retrevial here
     * @return the local host name
     */
    
    public static String getHostName(){
        return hostName;
    }
    
    /**
     * Construct an IdGenerator
     *
     */
    
    public UuidGenerator(String prefix){
        synchronized(UNIQUE_STUB){
            this.seed = prefix + UNIQUE_STUB +(instanceCount++) +""-"";
        }
    }
    
    public UuidGenerator(){
        this(""ID-"" + hostName);
    }
    
    /**
     * Generate a unqiue id
     * @return a unique id
     */
    
    public synchronized String generateId(){
        return this.seed + (this.sequence++);
    }
    
    /**
     * Generate a unique ID - that is friendly for a URL or file system
     * @return a unique id
     */
    public String generateSanitizedId(){
        String result = generateId();
        result = result.replace(':', '-');
        result = result.replace('_', '-');
        result = result.replace('.', '-');
        return result;
    }

}
"
org/apache/camel/impl/LoggingExceptionHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A default implementation of {@link ExceptionHandler} which uses a {@link Logger} to
 * log to an arbitrary {@link Log} with some {@link LoggingLevel}
 *
 * @version $Revision: 1.1 $
 */
public class LoggingExceptionHandler implements ExceptionHandler {
    private final Logger logger;

    public LoggingExceptionHandler(Class ownerType) {
        this(new Logger(LogFactory.getLog(ownerType), LoggingLevel.ERROR));
    }

    public LoggingExceptionHandler(Logger logger) {
        this.logger = logger;
    }

    public void handleException(Throwable exception) {
        logger.log(exception.getMessage(), exception);
    }
}
"
org/apache/camel/Consumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * A consumer of message exchanges from an {@link Endpoint}
 *
 * @version $Revision$
 */
public interface Consumer<E extends Exchange> extends Service {
}
"
org/apache/camel/builder/RecipientListBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.RecipientList;

/**
 * Creates a dynamic <a href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a> pattern.
 *
 * @version $Revision$
 */
public class RecipientListBuilder<E extends Exchange> extends BuilderSupport implements ProcessorFactory {
    private final Expression expression;


    public RecipientListBuilder(FromBuilder parent, Expression expression) {
        super(parent);
        this.expression = expression;
    }

    public Processor createProcessor() {
        return new RecipientList(expression);
    }
}
"
org/apache/camel/builder/xml/InvalidXPathExpression.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.RuntimeExpressionException;

import javax.xml.xpath.XPathException;

/**
 * An exception thrown if am XPath expression could not be parsed or evaluated
 *
 * @version $Revision: 521180 $
 */
public class InvalidXPathExpression extends RuntimeExpressionException {
    private final String xpath;

    public InvalidXPathExpression(String xpath, XPathException e) {
        super(""Invalid xpath: "" + xpath + "". Reason: "" + e, e);
        this.xpath = xpath;
    }

    public String getXpath() {
        return xpath;
    }
}
"
org/apache/camel/Converter.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * An annotation used to mark classes and methods to indicate code capable of converting from a type to another type
 * which are then auto-discovered using the <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Conversion Support</a>
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Converter {
}
"
org/apache/camel/impl/DefaultMessage.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Message;

import java.util.HashMap;
import java.util.Map;

/**
 * The default implementation of {@link Message}
 *
 * @version $Revision$
 */
public class DefaultMessage extends MessageSupport {
    private Map<String, Object> headers;

    @Override
    public String toString() {
        return ""Message: "" + getBody();
    }

    public Object getHeader(String name) {
        return getHeaders().get(name);
    }

    public <T> T getHeader(String name, Class<T> type) {
        Object value = getHeader(name);
        return getExchange().getContext().getTypeConverter().convertTo(type, value);
    }

    public void setHeader(String name, Object value) {
        if (headers == null) {
            headers = createHeaders();
        }
        headers.put(name, value);
    }

    public Map<String, Object> getHeaders() {
        if (headers == null) {
            headers = createHeaders();
        }
        return headers;
    }

    public void setHeaders(Map<String, Object> headers) {
        this.headers = headers;
    }

    public DefaultMessage newInstance() {
        return new DefaultMessage();
    }

    /**
     * A factory method to lazily create the headers to make it easy to create efficient Message implementations
     * which only construct and populate the Map on demand
     *
     * @return return a newly constructed Map possibly containing headers from the underlying inbound transport
     */
    protected Map<String, Object> createHeaders() {
        HashMap<String, Object> map = new HashMap<String, Object>();
        populateInitialHeaders(map);
        return map;
    }

    /**
     * A strategy method populate the initial set of headers on an inbound message from an underlying binding
     *
     * @param map is the empty header map to populate
     */
    protected void populateInitialHeaders(Map<String, Object> map) {
    }
}
"
org/apache/camel/component/file/FileComponent.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;

import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;

import java.io.File;
import java.util.Map;

/**
 * The <a href=""http://activemq.apache.org/camel/file.html"">File Component</a> for working with file systems
 *
 * @version $Revision: 523772 $
 */
public class FileComponent extends DefaultComponent<FileExchange> {
    public FileComponent() {
    }

    public FileComponent(CamelContext context) {
        super(context);
    }

    protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        File file = new File(remaining);
        FileEndpoint result = new FileEndpoint(file, remaining, this);
        IntrospectionSupport.setProperties(result, parameters);
        return result;
    }
}
"
org/apache/camel/component/pojo/PojoInvocation.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;

import java.lang.reflect.Method;

public class PojoInvocation {

	private final Object proxy;
	private final Method method;
	private final Object[] args;

	public PojoInvocation(Object proxy, Method method, Object[] args) {
		this.proxy = proxy;
		this.method = method;
		this.args = args;
	}

	public Object[] getArgs() {
		return args;
	}

	public Method getMethod() {
		return method;
	}

	public Object getProxy() {
		return proxy;
	}


}
"
org/apache/camel/impl/DefaultPollingConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.PollingConsumer;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * A default implementation of the {@link PollingConsumer} which uses the normal asynchronous consumer mechanism
 * along with a {@link BlockingQueue} to allow the caller to pull messages on demand.
 * 
 * @version $Revision: 1.1 $
 */
public class DefaultPollingConsumer<E extends Exchange> extends PollingConsumerSupport<E> implements Processor {
    private static final transient Log log = LogFactory.getLog(DefaultPollingConsumer.class);
    private BlockingQueue<E> queue;
    private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler(new Logger(log));
    private Consumer<E> consumer;

    public DefaultPollingConsumer(Endpoint<E> endpoint) {
        this(endpoint, new ArrayBlockingQueue<E>(1000));
    }

    public DefaultPollingConsumer(Endpoint<E> endpoint, BlockingQueue<E> queue) {
        super(endpoint);
        this.queue = queue;
    }

    public E receiveNoWait() {
        return receive(0);
    }

    public E receive() {
        while (!isStopping() && !isStopped()) {
            try {
                return queue.take();
            }
            catch (InterruptedException e) {
                handleInteruptedException(e);
            }
        }
        return null;
    }

    public E receive(long timeout) {
        try {
            return queue.poll(timeout, TimeUnit.MILLISECONDS);
        }
        catch (InterruptedException e) {
            handleInteruptedException(e);
            return null;
        }
    }

    public void process(Exchange exchange) throws Exception {
        queue.offer((E) exchange);
    }

    public ExceptionHandler getInteruptedExceptionHandler() {
        return interuptedExceptionHandler;
    }

    public void setInteruptedExceptionHandler(ExceptionHandler interuptedExceptionHandler) {
        this.interuptedExceptionHandler = interuptedExceptionHandler;
    }

    protected void handleInteruptedException(InterruptedException e) {
        getInteruptedExceptionHandler().handleException(e);
    }

    protected void doStart() throws Exception {
        // lets add ourselves as a consumer
        consumer = getEndpoint().createConsumer(this);
        consumer.start();
    }

    protected void doStop() throws Exception {
        if (consumer != null) {
            try {
                consumer.stop();
            }
            finally {
                consumer = null;
            }
        }
    }
}
"
org/apache/camel/impl/CachingInjector.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.impl.converter.TypeConverterRegistry;

/**
 * A caching proxy so that a single 
 * @version $Revision$
 */
public class CachingInjector<T> {
    private final TypeConverterRegistry repository;
    private final Class<T> type;
    private T instance;

    public CachingInjector(TypeConverterRegistry repository, Class<T> type) {
        this.repository = repository;
        this.type = type;
    }

    public synchronized T newInstance() {
        if (instance == null) {
            instance = createInstance(type);
        }
        return instance;
    }

    protected T createInstance(Class<T> type) {
        return (T) repository.getInjector().newInstance(type);
    }
}
"
org/apache/camel/Route.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * A <a href=""http://activemq.apache.org/camel/routes.html"">Route</a>
 * defines the processing used on an inbound message exchange
 * from a specific {@see Endpoint} within a {@link CamelContext}
 *
 * @version $Revision$
 */
public abstract class Route<E extends Exchange> {
    private final Map<String, Object> properties = new HashMap<String, Object>(16);
    private Endpoint<E> endpoint;
    private List<Service> services = new ArrayList<Service>();

    public Route(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }

    public Endpoint<E> getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }

    /**
     * This property map is used to associate information about
     * the route.
     *
     * @return
     */
    public Map<String, Object> getProperties() {
        return properties;
    }

    public List<Service> getServicesForRoute() throws Exception {
        List<Service> servicesForRoute = new ArrayList<Service>(getServices());
        addServices(servicesForRoute);
        return servicesForRoute;
    }

    /**
     * Returns the additional services required for this particular route
     */
    public List<Service> getServices() throws Exception {
        return services;
    }

    public void setServices(List<Service> services) {
        this.services = services;
    }

    /**
     * Strategy method to allow derived classes to lazily load services for the route
     */
    protected abstract void addServices(List<Service> services) throws Exception;
}
"
org/apache/camel/spi/Policy.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import org.apache.camel.Processor;

/**
 * A strategy capable of applying interceptors to a processor
 *
 * @version $Revision: 1.1 $
 */
public interface Policy<E> {

    /**
     * Wraps any applicable interceptors around the given processor
     *
     * @param processor the processor to be intercepted
     * @return either the original processor or a processor wrapped in one or more interceptors
     */
    Processor wrap(Processor processor);
}
"
org/apache/camel/util/ExpressionHelper.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;

/**
 * A collection of helper methods for working with expressions.
 *
 * @version $Revision: 1.1 $
 */
public class ExpressionHelper {

    /**
     * Evaluates the given expression on the exchange as a String value
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the result of the evaluation as a string.
     */
    public static <E extends Exchange> String evaluateAsString(Expression<E> expression, E exchange) {
        return evaluateAsType(expression, exchange, String.class);
    }

    /**
     * Evaluates the given expression on the exchange, converting the result to the given type
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @param resultType the type of the result that is required
     * @return the result of the evaluation as the specified type.
     */
    public static <T, E extends Exchange> T evaluateAsType(Expression<E> expression, E exchange, Class<T> resultType) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(resultType, value);
    }
}
"
org/apache/camel/MessageDriven.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Used to indicate a method on a POJO which is used as a {@link Consumer} of {@link Exchange} instances to process
 * {@link Message} instances.
 *
 * Either a <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an endpoint
 * should be configured, or a name of an endpoint
 * which refers to a Spring bean name in your Spring ApplicationContext.
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface MessageDriven {
    String uri() default """";
    String name() default """";
}
"
org/apache/camel/builder/SplitterBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.Splitter;

/**
 * A builder for the <a href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
 * where an expression is evaluated to iterate through each of the parts of a message and then each part is then send to some endpoint.

 * @version $Revision$
 */
public class SplitterBuilder extends FromBuilder {
    private final Expression expression;

    public SplitterBuilder(FromBuilder parent, Expression expression) {
        super(parent);
        this.expression = expression;
    }

    public Processor createProcessor() throws Exception {
        // lets create a single processor for all child predicates
        Processor destination = super.createProcessor();
        return new Splitter(destination, expression);
    }
}
"
org/apache/camel/processor/loadbalancer/StickyLoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Iterator;

/**
 * Implements a sticky load balancer using an {@link Expression} to calculate
 * a correlation key to perform the sticky load balancing; rather like jsessionid in the web
 * or JMSXGroupID in JMS.
 *
 * @version $Revision: 1.1 $
 */
public class StickyLoadBalancer extends QueueLoadBalancer {
    private Expression<Exchange> correlationExpression;
    private QueueLoadBalancer loadBalancer;
    private int numberOfHashGroups = 64 * 1024;
    private Map<Object, Processor> stickyMap = new HashMap<Object, Processor>();

    public StickyLoadBalancer(Expression<Exchange> correlationExpression) {
        this(correlationExpression, new RoundRobinLoadBalancer());
    }

    public StickyLoadBalancer(Expression<Exchange> correlationExpression, QueueLoadBalancer loadBalancer) {
        this.correlationExpression = correlationExpression;
        this.loadBalancer = loadBalancer;
    }

    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        Object value = correlationExpression.evaluate(exchange);
        Object key = getStickyKey(value);

        Processor processor;
        synchronized (stickyMap) {
            processor = stickyMap.get(key);
            if (processor == null) {
                processor = loadBalancer.chooseProcessor(processors, exchange);
                stickyMap.put(key, processor);
            }
        }
        return processor;
    }

    @Override
    public void removeProcessor(Processor processor) {
        synchronized (stickyMap) {
            Iterator<Map.Entry<Object,Processor>> iter = stickyMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<Object, Processor> entry = iter.next();
                if (processor.equals(entry.getValue())) {
                    iter.remove();
                }
            }
        }
        super.removeProcessor(processor);
    }


    // Properties
    //-------------------------------------------------------------------------
    public int getNumberOfHashGroups() {
        return numberOfHashGroups;
    }

    public void setNumberOfHashGroups(int numberOfHashGroups) {
        this.numberOfHashGroups = numberOfHashGroups;
    }

    // Implementation methods
    //-------------------------------------------------------------------------

    /**
     * A strategy to create the key for the sticky load balancing map.
     * The default implementation uses the hash code of the value
     * then modulos by the numberOfHashGroups to avoid the sticky map getting too big
     *
     * @param value the correlation value
     * @return the key to be used in the sticky map
     */
    protected Object getStickyKey(Object value) {
        int hashCode = 37;
        if (value != null) {
            hashCode = value.hashCode();
        }
        if (numberOfHashGroups > 0) {
            hashCode = hashCode % numberOfHashGroups;
        }
        return hashCode;
    }
}
"
org/apache/camel/builder/IdempotentConsumerBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Expression;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;

/**
 * A builder of an {@link IdempotentConsumer}
 *
 * @version $Revision: 1.1 $
 */
public class IdempotentConsumerBuilder extends FromBuilder implements ProcessorFactory {
    private final Expression messageIdExpression;
    private final MessageIdRepository messageIdRegistry;

    public IdempotentConsumerBuilder(FromBuilder fromBuilder, Expression messageIdExpression, MessageIdRepository messageIdRegistry) {
        super(fromBuilder);
        this.messageIdRegistry = messageIdRegistry;
        this.messageIdExpression = messageIdExpression;
    }

    // Properties
    //-------------------------------------------------------------------------
    public MessageIdRepository getMessageIdRegistry() {
        return messageIdRegistry;
    }

    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected Processor wrapInErrorHandler(Processor processor) throws Exception {
        // lets do no wrapping in error handlers as the parent FromBuilder will do that
        return processor;
    }

    @Override
    protected Processor wrapProcessor(Processor processor) {
        return new IdempotentConsumer(messageIdExpression, messageIdRegistry, processor);
    }
}
"
org/apache/camel/impl/converter/PropertyEditorTypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;

import org.apache.camel.TypeConverter;

/**
 * Uses the java.beans.PropertyEditor conversion system to convert Objects to and from String values.
 * 
 * @version $Revision: 523731 $
 */
public class PropertyEditorTypeConverter implements TypeConverter {
	
	
	public <T> T convertTo(Class<T> toType, Object value) {
		
		// We can't convert null values since we can't figure out a property editor for it.
		if( value == null )
			return null;
		
		if( value.getClass() == String.class ) {
			
			// No conversion needed.
			if( toType == String.class ) {
				return toType.cast(value);
			}
			
	        PropertyEditor editor = PropertyEditorManager.findEditor(toType);
	        if( editor != null ) { 
	            editor.setAsText(value.toString());
	            return toType.cast(editor.getValue());
	        }
	        
		} else  if( toType == String.class ) {
			
	        PropertyEditor editor = PropertyEditorManager.findEditor(value.getClass());
	        if( editor != null ) { 
	            editor.setValue(value);
	            return toType.cast(editor.getAsText());
	        }
	        
		}
        return null;
	}

}
"
org/apache/camel/spi/Marshaller.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import java.io.IOException;
import java.io.OutputStream;

/**
 * @version $Revision: 520124 $
 */
public interface Marshaller {
	
	/**
     * Marshals the object to the given Stream.
     */
	void marshal(Object graph, OutputStream stream) throws IOException;
}
"
org/apache/camel/impl/DefaultConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Exchange;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;

/**
 * @version $Revision$
 */
public class DefaultConsumer<E extends Exchange> extends ServiceSupport implements Consumer<E> {
    private Endpoint<E> endpoint;
    private Processor processor;
    private ExceptionHandler exceptionHandler;

    public DefaultConsumer(Endpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }

    @Override
	public String toString() {
		return ""Consumer on "" + endpoint;
	}


	public Endpoint<E> getEndpoint() {
        return endpoint;
    }

    public Processor getProcessor() {
        return processor;
    }

    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }

    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }

    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     *
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org/apache/camel/component/file/FileProducer.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package org.apache.camel.component.file;

import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.File;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

/**
 * A {@link Producer} implementation for File
 *
 * @version $Revision: 523016 $
 */
public class FileProducer extends DefaultProducer {
    private static final transient Log log = LogFactory.getLog(FileProducer.class);
    private final FileEndpoint endpoint;

    public FileProducer(FileEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }

    /**
     * @param exchange
     * @see org.apache.camel.Processor#process(Exchange)
     */
    public void process(Exchange exchange) {
        process(endpoint.toExchangeType(exchange));
    }

    public void process(FileExchange exchange){
        String fileName = exchange.getIn().getMessageId();
        ByteBuffer payload=exchange.getIn().getBody(ByteBuffer.class);
        payload.flip();
        File file = null;
        if(endpoint.getFile()!=null&&endpoint.getFile().isDirectory()){
            
            file=new File(endpoint.getFile(),fileName);
           
        }else{
            file=new File(fileName);
        }
        buildDirectory(file);
        try{
            FileChannel fc=new RandomAccessFile(file,""rw"").getChannel();
            fc.position(fc.size());
            fc.write(payload);
            fc.close();
        }catch(Throwable e){
            log.error(""Failed to write to File: ""+file,e);
        }
    }
    
    private void buildDirectory(File file) {
        String dirName = file.getAbsolutePath();
        int index = dirName.lastIndexOf(File.separatorChar);
        if (index > 0) {
            dirName = dirName.substring(0,index);
            File dir = new File(dirName);
            dir.mkdirs();
        }
    }
}
"
org/apache/camel/FailedToCreateProducerException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * @version $Revision$
 */
public class FailedToCreateProducerException extends RuntimeCamelException {
    private final Endpoint endpoint;

    public FailedToCreateProducerException(Endpoint endpoint, Throwable cause) {
        super(""Failed to create Producer for endpoint: "" + endpoint + "". Reason: ""+ cause, cause);
        this.endpoint = endpoint;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }
}
"
org/apache/camel/processor/idempotent/NoMessageIdException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;

import org.apache.camel.Expression;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;

/**
 * An exception thrown if no message ID could be found on a message which is to be used with the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 1.1 $
 */
public class NoMessageIdException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Expression expression;

    public NoMessageIdException(Exchange exchange, Expression expression) {
        super(""No message ID could be found using expression: "" + expression + "" on message exchange: "" + exchange);
        this.exchange = exchange;
        this.expression = expression;
    }

    /**
     * The exchange which caused this failure
     */
    public Exchange getExchange() {
        return exchange;
    }

    /**
     * The expression which was used
     */
    public Expression getExpression() {
        return expression;
    }
}
"
org/apache/camel/impl/converter/ArrayTypeConverter.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.TypeConverter;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

/**
 * A type converter which is used to convert to and from array types particularly for derived types of array
 * component types and dealing with primitive array types.
 *
 * @version $Revision: $
 */
public class ArrayTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isArray()) {
            if (value instanceof Collection) {
                Collection collection = (Collection) value;
                Object array = Array.newInstance(type.getComponentType(), collection.size());
                if (array instanceof Object[]) {
                    collection.toArray((Object[]) array);
                }
                else {
                    int index = 0;
                    for (Object element : collection) {
                        Array.set(array, index++, element);
                    }
                }
                return (T) array;
            }
            else if (value != null && value.getClass().isArray()) {
                int size = Array.getLength(value);
                Object answer = Array.newInstance(type.getComponentType(), size);
                for (int i = 0; i < size; i++) {
                    Array.set(answer, i, Array.get(value, i));
                }
                return (T) answer;
            }
        }
        else if (Collection.class.isAssignableFrom(type)) {
            if (value != null) {
                if (value instanceof Object[]) {
                    return (T) Arrays.asList((Object[]) value);
                }
                else if (value.getClass().isArray()) {
                    int size = Array.getLength(value);
                    List answer = new ArrayList(size);
                    for (int i = 0; i < size; i++) {
                        answer.add(Array.get(value, i));
                    }
                    return (T) answer;
                }
            }
        }
        return null;
    }
}
"
org/apache/camel/component/direct/DirectEndpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;

import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ProducerCache;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Represents a direct endpoint that synchronously invokes the consumers of the endpoint when a producer 
 * sends a message to it.
 *
 * @org.apache.xbean.XBean
 * @version $Revision: 519973 $
 */
public class DirectEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private static final Log log = LogFactory.getLog(DirectEndpoint.class);

	private final CopyOnWriteArrayList<DefaultConsumer<E>> consumers = new CopyOnWriteArrayList<DefaultConsumer<E>>();
	
	boolean allowMultipleConsumers=true;	
	
    public DirectEndpoint(String uri, DirectComponent<E> component) {
        super(uri, component);
    }

    public Producer createProducer() throws Exception {
        return new DefaultProducer(this) {
            public void process(Exchange exchange) throws Exception {
            	DirectEndpoint.this.process(exchange);
            }
        };    	
    }

    protected void process(Exchange exchange) throws Exception {
    	if (consumers.isEmpty()) {
    		log.warn(""No consumers available on "" + this + "" for "" + exchange);
    	}
    	else {
	    	for (DefaultConsumer<E> consumer : consumers) {
				consumer.getProcessor().process(exchange);
			}
    	}
    }

	public Consumer<E> createConsumer(Processor processor) throws Exception {
		return new DefaultConsumer<E>(this, processor) {
			@Override
			public void start() throws Exception {
				if( !allowMultipleConsumers && !consumers.isEmpty() )
					throw new IllegalStateException(""Endpoint ""+getEndpointUri()+"" only allows 1 active consumer but you attempted to start a 2nd consumer."");
				
				consumers.add(this);
				super.start();
			}
			
			@Override
			public void stop() throws Exception {
				super.stop();
				consumers.remove(this);
			}
		};
    }

    public E createExchange() {
    	// How can we create a specific Exchange if we are generic??
    	// perhaps it would be better if we did not implement this. 
        return (E) new DefaultExchange(getContext());
    }

	public boolean isAllowMultipleConsumers() {
		return allowMultipleConsumers;
	}
	public void setAllowMultipleConsumers(boolean allowMutlipleConsumers) {
		this.allowMultipleConsumers = allowMutlipleConsumers;
	}

	public boolean isSingleton() {
		return true;
	}

}
"
org/apache/camel/processor/FilterProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;

/**
 * @version $Revision$
 */
public class FilterProcessor extends ServiceSupport implements Processor {
    private Predicate<Exchange> predicate;
    private Processor processor;

    public FilterProcessor(Predicate<Exchange> predicate, Processor processor) {
        this.predicate = predicate;
        this.processor = processor;
    }

    public void process(Exchange exchange) throws Exception {
        if (predicate.matches(exchange)) {
            processor.process(exchange);
        }
    }

    @Override
    public String toString() {
        return ""filter ("" + predicate + "") "" + processor;
    }

    public Predicate<Exchange> getPredicate() {
        return predicate;
    }

    public Processor getProcessor() {
        return processor;
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
}
"
org/apache/camel/processor/loadbalancer/LoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.List;

/**
 * A strategy for load balancing across a number of {@link Processor} instances
 *
 * @version $Revision: 1.1 $
 */
public interface LoadBalancer extends Processor {
    /**
     * Adds a new processor to the load balancer
     *
     * @param processor the processor to be added to the load balancer
     */
    void addProcessor(Processor processor);

    /**
     * Removes the given processor from the load balancer
     *
     * @param processor the processor to be removed from the load balancer
     */
    void removeProcessor(Processor processor);

    /**
     * Returns the current processors available to this load balancer
     *
     * @return the processors available
     */
    List<Processor> getProcessors();
}
"
org/apache/camel/impl/PredicateSupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Predicate;
import org.apache.camel.Exchange;

/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision: 1.1 $
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {

    public void assertMatches(String text, E exchange) {
        if (! matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange));
        }
    }

    protected String assertionFailureMessage(E exchange) {
        return this + "" failed on "" + exchange;
    }
}
"
org/apache/camel/component/file/FileMessage.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;

import java.io.File;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultMessage;

/**
 * A {@link Exchange} for  File
 * 
 * @version $Revision: 520985 $
 */
public class FileMessage extends DefaultMessage{
    private File file;

    public FileMessage() {
        this(new File("".""));
    }

    public FileMessage(File file) {
        this.file=file;
    }

    @Override
    public String toString() {
        return ""FileMessage: "" + file;
    }

    @Override
    public FileExchange getExchange() {
        return (FileExchange) super.getExchange();
    }

   
    public File getFile() {
        return file;
    }

    public void setFile(File file) {
        this.file=file;
    }

    
   
    @Override
    public FileMessage newInstance() {
        return new FileMessage();
    }
   
}
"
org/apache/camel/builder/Builder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;

/**
 * A helper class for including portions of the
 * <a href=""http://activemq.apache.org/camel/expression.html"">expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">predicate</a>
 * <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision: 1.1 $
 */
public class Builder {

    /**
     * Returns a constant expression
     */
    public static <E extends Exchange> ValueBuilder<E> constant(Object value) {
        Expression<E> expression = ExpressionBuilder.constantExpression(value);
        return new ValueBuilder<E>(expression);
    }

    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> header(@FluentArg(""name"") String name) {
        Expression<E> expression = ExpressionBuilder.headerExpression(name);
        return new ValueBuilder<E>(expression);
    }

    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> body() {
        Expression<E> expression = ExpressionBuilder.bodyExpression();
        return new ValueBuilder<E>(expression);
    }

    /**
     * Returns a predicate and value builder for the inbound message body as a specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> bodyAs( Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T>bodyExpression(type);
        return new ValueBuilder<E>(expression);
    }

    /**
     * Returns a predicate and value builder for the outbound body on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> outBody() {
        Expression<E> expression = ExpressionBuilder.bodyExpression();
        return new ValueBuilder<E>(expression);
    }

    /**
     * Returns a predicate and value builder for the outbound message body as a specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> outBody(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T>bodyExpression(type);
        return new ValueBuilder<E>(expression);
    }


    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }

    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name, final String defaultValue) {
        return new ValueBuilder<E>(ExpressionBuilder.<E>systemProperty(name, defaultValue));
    }
}
"
org/apache/camel/processor/loadbalancer/LoadBalancerSupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * A default base class for a {@link LoadBalancer} implementation
 *
 * @version $Revision: 1.1 $
 */
public abstract class LoadBalancerSupport implements LoadBalancer {
    private List<Processor> processors = new CopyOnWriteArrayList<Processor>();

    public void addProcessor(Processor processor) {
        processors.add(processor);
    }

    public void removeProcessor(Processor processor) {
        processors.remove(processor);
    }

    public List<Processor> getProcessors() {
        return processors;
    }
}
"
org/apache/camel/CamelContext.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;

/**
 * Interface used to represent the context used to configure routes and the
 * policies to use during message exchanges between endpoints.
 *
 * @version $Revision$
 */
public interface CamelContext extends Service {

    // Component Management Methods
    //-----------------------------------------------------------------------

    /**
     * Adds a component to the context.
     */
    void addComponent(String componentName, Component component);

    /**
     * Gets a component from the context by name.
     */
    Component getComponent(String componentName);

    /**
     * Gets a component from the context by name and specifying the expected type of component.
     */
    <T extends Component> T getComponent(String name, Class<T> componentType);

    /**
     * Removes a previously added component.
     *
     * @param componentName
     * @return the previously added component or null if it had not been previously added.
     */
    Component removeComponent(String componentName);

    /**
     * Gets the a previously added component by name or lazily creates the component
     * using the factory Callback.
     *
     * @param componentName the name of the component
     * @param factory       used to create a new component instance if the component was not previously added.
     * @return
     */
    Component getOrCreateComponent(String componentName, Callable<Component> factory);

    // Endpoint Management Methods
    //-----------------------------------------------------------------------

    /**
     * Resolves the given URI to an {@see Endpoint}.  If the URI has a singleton endpoint
     * registered, then the singleton is returned.  Otherwise, a new {@see Endpoint} is created
     * and if the endpoint is a singleton it is registered as a singleton endpoint.
     */
    Endpoint getEndpoint(String uri);

    /**
     * Resolves the given URI to an {@see Endpoint} of the specified type.
     * If the URI has a singleton endpoint registered, then the singleton is returned.
     * Otherwise, a new {@see Endpoint} is created and if the endpoint is a
     * singleton it is registered as a singleton endpoint.
     */
    <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType);

    /**
     * Returns the collection of all registered singleton endpoints.
     */
    Collection<Endpoint> getSingletonEndpoints();

    /**
     * Adds the endpoint to the context using the given URI.  The endpoint will be registered as a singleton.
     *
     * @param uri the URI to be used to resolve this endpoint
     * @param endpoint the endpoint to be added to the context
     * @return the old endpoint that was previously registered to the context if there was
     * already an endpoint for that URI
     * @throws Exception if the new endpoint could not be started or the old endpoint could not be stopped
     */
    Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception;

    /**
     * Removes the singleton endpoint with the given URI
     *
     * @param uri the URI to be used to remove
     * @return the endpoint that was removed or null if there is no endpoint for this URI
     * @throws Exception if endpoint could not be stopped
     */
    Endpoint removeSingletonEndpoint(String uri) throws Exception;


    // Route Management Methods
    //-----------------------------------------------------------------------

    /**
     * Returns the current routes in this context
     *
     * @return the current routes in this context
     */
    List<Route> getRoutes();

    /**
     * Sets the routes for this context, replacing any current routes
     *
     * @param routes the new routes to use
     */
    void setRoutes(List<Route> routes);

    /**
     * Adds a collection of routes to this context
     *
     * @param routes the routes to add
     */
    void addRoutes(Collection<Route> routes) throws Exception;

    /**
     * Adds a collection of routes to this context using the given builder
     * to build them
     *
     * @param builder the builder which will create the routes and add them to this context
     * @throws Exception if the routes could not be created for whatever reason
     */
    void addRoutes(RouteBuilder builder) throws Exception;

    // Properties
    //-----------------------------------------------------------------------

    /**
     * Returns the converter of exchanges from one type to another
     * @return
     */
    ExchangeConverter getExchangeConverter();

    /**
     * Returns the type converter used to coerce types from one type to another
     */
    TypeConverter getTypeConverter();

    /**
     * Returns the injector used to instantiate objects by type
     */
    Injector getInjector();

}
"
org/apache/camel/component/file/FileExchange.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;

import java.io.File;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;

/**
 * A {@link Exchange} for File
 * 
 * @version $Revision: 520985 $
 */
public class FileExchange extends DefaultExchange {

    private File file;
    /**
     * Constructor
     * @param camelContext
     * @param file
     */
    public FileExchange(CamelContext camelContext, File file) {
        super(camelContext);
        setIn(new FileMessage(file));
        this.file = file;
    }
    
    /**
     * @return the file
     */
    public File getFile(){
        return this.file;
    }
    
    /**
     * @param file the file to set
     */
    public void setFile(File file){
        this.file=file;
    }
}
"
org/apache/camel/builder/xml/MessageVariableResolver.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import javax.xml.xpath.XPathVariableResolver;
import java.util.HashMap;
import java.util.Map;

/**
 * A variable resolver for XPath expressions which support properties on the messge, exchange as well
 * as making system properties and environment properties available.
 *
 * @version $Revision: 521692 $
 */
public class MessageVariableResolver implements XPathVariableResolver {
    public static final String SYSTEM_PROPERTIES_NAMESPACE = ""http://camel.apache.org/xml/variables/system-properties"";
    public static final String ENVIRONMENT_VARIABLES = ""http://camel.apache.org/xml/variables/environment-variables"";
    public static final String EXCHANGE_PROPERTY = ""http://camel.apache.org/xml/variables/exchange-property"";
    public static final String IN_HEADER = ""http://camel.apache.org/xml/variables/in-header"";
    public static final String OUT_HEADER = ""http://camel.apache.org/xml/variables/out-header"";

    private static final transient Log log = LogFactory.getLog(MessageVariableResolver.class);

    private Exchange exchange;
    private Map<String, Object> variables = new HashMap<String, Object>();

    public Exchange getExchange() {
        return exchange;
    }

    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }

    public Object resolveVariable(QName name) {
        String uri = name.getNamespaceURI();
        String localPart = name.getLocalPart();
        Object answer = null;

        if (uri == null || uri.length() == 0) {
            answer = variables.get(localPart);
            if (answer == null) {
                Message message = exchange.getIn();
                if (message != null) {
                    answer = message.getHeader(localPart);
                }
                if (answer == null) {
                    answer = exchange.getProperty(localPart);
                }
            }
        }
        else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {
            try {
                answer = System.getProperty(localPart);
            }
            catch (Exception e) {
                log.debug(""Security exception evaluating system property: "" + localPart + "". Reason: "" + e, e);
            }
        }
        else if (uri.equals(ENVIRONMENT_VARIABLES)) {
            answer = System.getenv().get(localPart);
        }
        else if (uri.equals(EXCHANGE_PROPERTY)) {
            answer = exchange.getProperty(localPart);
        }
        else if (uri.equals(IN_HEADER)) {
            answer = exchange.getIn().getHeader(localPart);
        }
        else if (uri.equals(OUT_HEADER)) {
            answer = exchange.getOut().getHeader(localPart);
        }

        // TODO support exposing CamelContext properties/resources via XPath?
        return answer;
    }

    public void addVariable(String localPart, Object value) {
        variables.put(localPart, value);
    }
}
"
org/apache/camel/util/Time.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.util.concurrent.TimeUnit;
import java.util.Date;

/**
 * A helper class for working with times in various units
 *
 * @version $Revision: $
 */
public class Time {
    private long number;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;

    public static Time millis(long value) {
        return new Time(value, TimeUnit.MILLISECONDS);
    }

    public static Time micros(long value) {
        return new Time(value, TimeUnit.MICROSECONDS);
    }

    public static Time nanos(long value) {
        return new Time(value, TimeUnit.NANOSECONDS);
    }

    public static Time seconds(long value) {
        return new Time(value, TimeUnit.SECONDS);
    }

    public static Time minutes(long value) {
        return new Time(minutesAsSeconds(value), TimeUnit.MILLISECONDS);
    }

    public static Time hours(long value) {
        return new Time(hoursAsSeconds(value), TimeUnit.MILLISECONDS);
    }

    public static Time days(long value) {
        return new Time(daysAsSeconds(value), TimeUnit.MILLISECONDS);
    }

    public Time(long number, TimeUnit timeUnit) {
        this.number = number;
        this.timeUnit = timeUnit;
    }

    public long toMillis() {
        return timeUnit.toMillis(number);
    }

    public Date toDate() {
        return new Date(toMillis());
    }

    public long getNumber() {
        return number;
    }

    public TimeUnit getTimeUnit() {
        return timeUnit;
    }

    protected static long minutesAsSeconds(long value) {
        return value * 60;
    }

    protected static long hoursAsSeconds(long value) {
        return minutesAsSeconds(value) * 60;
    }

    protected static long daysAsSeconds(long value) {
        return hoursAsSeconds(value) * 24;
    }
}
"
org/apache/camel/ResolveEndpointFailedException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * A runtime exception thrown if an {@link Endpoint} can not be resolved via URI
 * 
 * @version $Revision$
 */
public class ResolveEndpointFailedException extends RuntimeCamelException {
    private final String uri;

    public ResolveEndpointFailedException(String uri, Throwable cause) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + cause, cause);
        this.uri = uri;
    }

    public String getUri() {
        return uri;
    }
}
"
org/apache/camel/component/file/FileEndpoint.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;

import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ScheduledPollEndpoint;

import java.io.File;

/**
 * A <a href=""http://activemq.apache.org/camel/file.html"">File Endpoint</a> for working with file systems
 *
 * @version $Revision: 523016 $
 */
public class FileEndpoint extends ScheduledPollEndpoint<FileExchange> {
    private File file;
    private boolean autoCreate=true;

    protected FileEndpoint(File file, String endpointUri, FileComponent component) {
        super(endpointUri, component);
        this.file = file;
    }

    /**
     * @return a Producer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createProducer()
     */
    public Producer<FileExchange> createProducer() throws Exception {
        Producer<FileExchange> result = new FileProducer(this);
        return result;
    }

    /**
     * @param file
     * @return a Consumer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createConsumer(org.apache.camel.Processor)
     */
    public Consumer<FileExchange> createConsumer(Processor file) throws Exception {
        Consumer<FileExchange> result = new FileConsumer(this, file);
        configureConsumer(result);
        return result;
    }

    /**
     * @param file
     * @return a FileExchange
     * @see org.apache.camel.Endpoint#createExchange()
     */
    public FileExchange createExchange(File file) {
        return new FileExchange(getContext(), file);
    }

    /**
     * @return an Exchange
     * @see org.apache.camel.Endpoint#createExchange()
     */
    public FileExchange createExchange() {
        return createExchange(getFile());
    }

    public File getFile() {
        if (autoCreate && !file.exists()) {
            file.mkdirs();
        }
        return file;
    }

    public boolean isSingleton() {
        return true;
    }

    
    /**
     * @return the autoCreate
     */
    public boolean isAutoCreate(){
        return this.autoCreate;
    }

    
    /**
     * @param autoCreate the autoCreate to set
     */
    public void setAutoCreate(boolean autoCreate){
        this.autoCreate=autoCreate;
    }
}
"
org/apache/camel/builder/LoggingErrorHandlerBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingErrorHandler;
import org.apache.camel.processor.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Uses the {@link Logger} as an error handler
 * 
 * @version $Revision$
 */
public class LoggingErrorHandlerBuilder implements ErrorHandlerBuilder {
    private Log log = LogFactory.getLog(Logger.class);
    private LoggingLevel level = LoggingLevel.INFO;

    public LoggingErrorHandlerBuilder() {
    }

    public LoggingErrorHandlerBuilder(Log log) {
        this.log = log;
    }

    public LoggingErrorHandlerBuilder(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }

    public ErrorHandlerBuilder copy() {
        LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder();
        answer.setLog(getLog());
        answer.setLevel(getLevel());
        return answer;
    }

    public Processor createErrorHandler(Processor processor) {
        return new LoggingErrorHandler(processor, log, level);
    }

    public LoggingLevel getLevel() {
        return level;
    }

    public void setLevel(LoggingLevel level) {
        this.level = level;
    }

    public Log getLog() {
        return log;
    }

    public void setLog(Log log) {
        this.log = log;
    }
}
"
org/apache/camel/builder/ProcessorBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;

/**
 * A builder of a number of different {@link Processor} implementations
 *
 * @version $Revision: 1.1 $
 */
public class ProcessorBuilder {

    /**
     * Creates a processor which sets the body of the IN message to the value of the expression
     */
    public static Processor setBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getIn().setBody(newBody);
            }

            @Override
            public String toString() {
                return ""setBody("" + expression + "")"";
            }
        };
    }

    /**
     * Creates a processor which sets the body of the IN message to the value of the expression
     */
    public static Processor setOutBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getOut().setBody(newBody);
            }

            @Override
            public String toString() {
                return ""setOutBody("" + expression + "")"";
            }
        };
    }

    /**
     * Sets the header on the IN message
     */
    public static Processor setHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getIn().setHeader(name, value);
            }

            @Override
            public String toString() {
                return ""setHeader("" + name + "", "" + expression + "")"";
            }
        };
    }

    /**
     * Sets the header on the OUT message
     */
    public static Processor setOutHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getOut().setHeader(name, value);
            }

            @Override
            public String toString() {
                return ""setOutHeader("" + name + "", "" + expression + "")"";
            }
        };
    }

    /**
     * Sets the property on the exchange
     */
    public static Processor setProperty(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.setProperty(name, value);
            }

            @Override
            public String toString() {
                return ""setProperty("" + name + "", "" + expression + "")"";
            }
        };
    }
}
"
org/apache/camel/builder/Fluent.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/** 
 * Used to annotate fluent API methods.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Fluent {
	
	/**
	 * Used to change the default element name of the action.
	 * @return
	 */
	String value() default """";
	
	/** 
	 * Should nested elements be evaluated against the current builder.
	 * @return
	 */
	boolean nestedActions() default false;

	/** 
	 * Should this method be called at the end of the evaluating the 
	 * element.
	 * @return
	 */
	boolean callOnElementEnd() default false;
}
"
org/apache/camel/impl/MessageSupport.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.util.UuidGenerator;

/**
 * A base class for implementation inheritence providing the core {@link Message} body
 * handling features but letting the derived class deal with headers.
 *
 * Unless a specific provider wishes to do something particularly clever with headers you probably
 * want to just derive from {@link DefaultMessage}
 *
 * @version $Revision$
 */
public abstract class MessageSupport implements Message {
    private static final UuidGenerator defaultIdGenerator = new UuidGenerator();
    private Exchange exchange;
    private Object body;
    private String messageId = defaultIdGenerator.generateId();
    

    public Object getBody() {
        if (body == null) {
            body = createBody();
        }
        return body;
    }

    @SuppressWarnings({""unchecked""})
    public <T> T getBody(Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            return e.getContext().getTypeConverter().convertTo(type, getBody());
        }
        return (T) getBody();
    }

    public void setBody(Object body) {
        this.body = body;
    }

    public <T> void setBody(Object body, Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            T value = e.getContext().getTypeConverter().convertTo(type, body);
            if (value != null) {
                body = value;
            }
        }
        setBody(body);
    }

    public Message copy() {
        Message answer = newInstance();
        answer.setMessageId(getMessageId());
        answer.setBody(getBody());
        answer.getHeaders().putAll(getHeaders());
        return answer;
    }

    public Exchange getExchange() {
        return exchange;
    }

    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }

    /**
     * Returns a new instance
     *
     * @return
     */
    public abstract Message newInstance();


    /**
     * A factory method to allow a provider to lazily create the message body for inbound messages from other sources
     *
     * @return the value of the message body or null if there is no value available
     */
    protected Object createBody() {
        return null;
    }

    
    /**
     * @return the messageId
     */
    public String getMessageId(){
        return this.messageId;
    }

    
    /**
     * @param messageId the messageId to set
     */
    public void setMessageId(String messageId){
        this.messageId=messageId;
    }
}
"
org/apache/camel/converter/jaxp/StringSource.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;

/**
 * A helper class which provides a JAXP {@link Source} from a String
 * which can be read as many times as required.
 *
 * @version $Revision$
 */
public class StringSource extends StreamSource implements Serializable {

    private final String text;
    private String encoding = ""UTF-8"";

    public StringSource(String text) {
        if (text == null) {
            throw new NullPointerException(""text can not be null"");
        }
        this.text = text;
    }

    public StringSource(String text, String systemId) {
        this(text);
        setSystemId(systemId);
    }

    public StringSource(String text, String systemId, String encoding) {
        this.text = text;
        this.encoding=encoding;
        setSystemId(systemId);
    }

    public InputStream getInputStream() {
        try {
            return new ByteArrayInputStream(text.getBytes(encoding));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public Reader getReader() {
        return new StringReader(text);
    }

    public String toString() {
        return ""StringSource["" + text + ""]"";
    }

    public String getText() {
        return text;
    }

}
"
org/apache/camel/component/mock/MockEndpoint.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Message;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A Mock endpoint which provides a literate, fluent API for testing routes using
 * a <a href=""http://jmock.org/"">JMock style</a> API.
 *
 * @version $Revision: 1.1 $
 */
public class MockEndpoint extends DefaultEndpoint<Exchange> {
    private static final transient Log log = LogFactory.getLog(MockEndpoint.class);
    private int expectedCount = -1;
    private Map<Integer, Processor> processors = new HashMap<Integer, Processor>();
    private List<Exchange> receivedExchanges = new ArrayList<Exchange>();
    private List<Throwable> failures = new ArrayList<Throwable>();
    private List<Runnable> tests = new ArrayList<Runnable>();
    private CountDownLatch latch;
    private long sleepForEmptyTest = 0L;
	private int expectedMinimumCount=-1;

    public static void assertWait(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
    	long start = System.currentTimeMillis();
    	long left = unit.toMillis(timeout);
    	long end = start + left;
        for (MockEndpoint endpoint : endpoints) {
			if( !endpoint.await(left, TimeUnit.MILLISECONDS) )
	    		throw new AssertionError(""Timeout waiting for endpoints to receive enough messages. ""+endpoint.getEndpointUri()+"" timed out."");
			left = end - System.currentTimeMillis();
			if( left <= 0 )
				left = 0;
        }
    }

    public static void assertIsSatisfied(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
    	assertWait(timeout, unit, endpoints);
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }

    public static void assertIsSatisfied(MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }

    public static void expectsMessageCount(int count, MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.expectsMessageCount(count);
        }
    }

    public MockEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }

    public Exchange createExchange() {
        return new DefaultExchange(getContext());
    }

    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""You cannot consume from this endpoint"");
    }

    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) {
                onExchange(exchange);
            }
        };
    }

    // Testing API
    //-------------------------------------------------------------------------

    /**
     * Validates that all the available expectations on this endpoint are satisfied; or throw an exception
     */
    public void assertIsSatisfied() throws InterruptedException {
        assertIsSatisfied(sleepForEmptyTest);
    }
    
    /**
     * Validates that all the available expectations on this endpoint are satisfied; or throw an exception
     */
    public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {
        if (latch != null) {
            // now lets wait for the results
            latch.await(10, TimeUnit.SECONDS);
        }
        else if (expectedCount == 0) {
            // lets wait a little bit just in case
            if (timeoutForEmptyEndpoints > 0) {
                Thread.sleep(timeoutForEmptyEndpoints);
            }
        }

        if (expectedCount >= 0) {
            int receivedCounter = getReceivedCounter();
            assertEquals(""Received message count"" , expectedCount, receivedCounter);
        }
        
        if( expectedMinimumCount >= 0 ) {
            int receivedCounter = getReceivedCounter();
            assertTrue(""Received message count ""+receivedCounter+"", expected at least ""+expectedCount, expectedCount <= receivedCounter);
        	
        }

        for (Runnable test : tests) {
            test.run();
        }

        for (Throwable failure : failures) {
           if (failure != null) {
               log.error(""Caught on "" + getEndpointUri() + "" Exception: "" + failure, failure);
               fail(""Failed due to caught exception: "" + failure);
           }
        }
    }

    /**
     * Specifies the expected number of message exchanges that should be received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be expected by this endpoint
     */
    public void expectedMessageCount(int expectedCount) {
        this.expectedCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        }
        else {
            latch = new CountDownLatch(expectedCount);
        }
    }

    /**
     * Specifies the minimum number of expected message exchanges that should be received by this endpoint
     *
     * @param expectedCount the number of message exchanges that should be expected by this endpoint
     */
    public void expectedMinimumMessageCount(int expectedCount) {
        this.expectedMinimumCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        }
        else {
            latch = new CountDownLatch(expectedMinimumCount);
        }
    }

    /**
     * Adds an expectation that the given body values are received by this endpoint
     */
    public void expectedBodiesReceived(final List bodies) {
        expectedMessageCount(bodies.size());

        expects(new Runnable() {
            public void run() {
                int counter = 0;
                for (Object expectedBody : bodies) {
                    Exchange exchange = getReceivedExchanges().get(counter++);
                    assertTrue(""No exchange received for counter: "" + counter, exchange != null);

                    Message in = exchange.getIn();

                    Object actualBody = (expectedBody != null)
                            ? in.getBody(expectedBody.getClass()) : in.getBody();

                    assertEquals(""Body of message: "" + counter, expectedBody, actualBody);

                    log.debug(getEndpointUri() + "" >>>> message: "" + counter + "" with body: "" + actualBody);
                }
            }
        });
    }

    /**
     * Adds an expectation that the given body values are received by this endpoint
     */
    public void expectedBodiesReceived(Object... bodies) {
        List bodyList = new ArrayList();
        for (Object body : bodies) {
            bodyList.add(body);
        }
        expectedBodiesReceived(bodyList);
    }


    /**
     * Adds the expection which will be invoked when enough messages are received
     */
    public void expects(Runnable runnable) {
        tests.add(runnable);
    }

    /**
     * Adds an assertion to the given message index
     *
     * @param messageIndex the number of the message
     * @return the assertion clause
     */
    public AssertionClause message(final int messageIndex) {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                applyAssertionOn(MockEndpoint.this, messageIndex, assertExchangeReceived(messageIndex));
            }
        };
        expects(clause);
        return clause;
    }

    /**
     * Adds an assertion to all the received messages
     *
     * @return the assertion clause
     */
    public AssertionClause allMessages() {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                List<Exchange> list = getReceivedExchanges();
                int index = 0;
                for (Exchange exchange : list) {
                    applyAssertionOn(MockEndpoint.this, index++, exchange);
                }
            }
        };
        expects(clause);
        return clause;
    }

    /**
     * Asserts that the given index of message is received (starting at zero)
     */
    public Exchange assertExchangeReceived(int index) {
        int count = getReceivedCounter();
        assertTrue(""Not enough messages received. Was: "" + count, count > index);
        return getReceivedExchanges().get(index);
    }

    // Properties
    //-------------------------------------------------------------------------
    public List<Throwable> getFailures() {
        return failures;
    }

    public int getReceivedCounter() {
        return getReceivedExchanges().size();
    }

    public List<Exchange> getReceivedExchanges() {
        return receivedExchanges;
    }

    public int getExpectedCount() {
        return expectedCount;
    }

    public long getSleepForEmptyTest() {
        return sleepForEmptyTest;
    }

    /**
     * Allows a sleep to be specified to wait to check that this endpoint really is empty when
     * {@link #expectedMessageCount(int)} is called with zero
     *
     * @param sleepForEmptyTest the milliseconds to sleep for to determine that this endpoint really is empty
     */
    public void setSleepForEmptyTest(long sleepForEmptyTest) {
        this.sleepForEmptyTest = sleepForEmptyTest;
    }

    // Implementation methods
    //-------------------------------------------------------------------------
    protected synchronized void onExchange(Exchange exchange) {
        try {
            log.debug(getEndpointUri() + "" >>>> "" + exchange);

            receivedExchanges.add(exchange);

            Processor processor = processors.get(getReceivedCounter());
            if (processor != null) {
                processor.process(exchange);
            }

            if (latch != null) {
                latch.countDown();
            }
        }
        catch (Exception e) {
            failures.add(e);
        }
    }

    protected void assertEquals(String message, Object expectedValue, Object actualValue) {
        if (!ObjectHelper.equals(expectedValue, actualValue)) {
            fail(message + "". Expected: <"" + expectedValue + ""> but was: <"" + actualValue + "">"");
        }
    }

    protected void assertTrue(String message, boolean predicate) {
        if (!predicate) {
            fail(message);
        }
    }

    protected void fail(Object message) {
        throw new AssertionError(getEndpointUri() + "" "" + message);
    }

	public int getExpectedMinimumCount() {
		return expectedMinimumCount;
	}

	public void await() throws InterruptedException {
		if( latch!=null ) {
			latch.await();
		}
	}

	public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
		if( latch!=null ) {
			return latch.await(timeout, unit);
		}
		return true;
	}
	
	public boolean isSingleton() {
		return true;
	}
	
}
"
org/apache/camel/impl/converter/DefaultTypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @version $Revision$
 */
public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistry {
    private static final transient Log log = LogFactory.getLog(DefaultTypeConverter.class);
    private Map<TypeMapping, TypeConverter> typeMappings = new HashMap<TypeMapping, TypeConverter>();
    private Injector injector;
    private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
    private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
    private boolean loaded;

    public DefaultTypeConverter() {
        typeConverterLoaders.add(new AnnotationTypeConverterLoader());
        fallbackConverters.add(new PropertyEditorTypeConverter());
        fallbackConverters.add(new ToStringTypeConverter());
        fallbackConverters.add(new ArrayTypeConverter());
    }

    public DefaultTypeConverter(Injector injector) {
        this();
        this.injector = injector;
    }

    public <T> T convertTo(Class<T> toType, Object value) {
        if (toType.isInstance(value)) {
            return toType.cast(value);
        }
        checkLoaded();
        TypeConverter converter = getOrFindTypeConverter(toType, value);
        if (converter != null) {
            return converter.convertTo(toType, value);
        }

        for (TypeConverter fallback : fallbackConverters) {
            T rc = fallback.convertTo(toType, value);
            if (rc != null) {
                return rc;
            }
        }

        // lets avoid NullPointerException when converting to boolean for null values
        if (boolean.class.isAssignableFrom(toType)) {
            return (T) Boolean.FALSE;
        }
        return null;
    }

    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            TypeConverter converter = typeMappings.get(key);
            if (converter != null) {
                log.warn(""Overriding type converter from: "" + converter + "" to: "" + typeConverter);
            }
            typeMappings.put(key, typeConverter);
        }
    }

    public TypeConverter getTypeConverter(Class toType, Class fromType) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            return typeMappings.get(key);
        }
    }

    public Injector getInjector() {
        if (injector == null) {
            injector = new ReflectionInjector();
        }
        return injector;
    }

    public void setInjector(Injector injector) {
        this.injector = injector;
    }

    protected <T> TypeConverter getOrFindTypeConverter(Class toType, Object value) {
        Class fromType = null;
        if (value != null) {
            fromType = value.getClass();
        }
        TypeMapping key = new TypeMapping(toType, fromType);
        TypeConverter converter;
        synchronized (typeMappings) {
            converter = typeMappings.get(key);
            if (converter == null) {
                converter = findTypeConverter(toType, fromType, value);
                if (converter != null) {
                    typeMappings.put(key, converter);
                }
            }
        }
        return converter;
    }

    /**
     * Tries to auto-discover any available type converters
     */
    protected TypeConverter findTypeConverter(Class toType, Class fromType, Object value) {
        // lets try the super classes of the from type
        if (fromType != null) {
            Class fromSuperClass = fromType.getSuperclass();
            if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {

                TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                if (converter == null) {
                    converter = findTypeConverter(toType, fromSuperClass, value);
                }
                if (converter != null) {
                    return converter;
                }
            }
            for (Class type : fromType.getInterfaces()) {
                TypeConverter converter = getTypeConverter(toType, type);
                if (converter != null) {
                    return converter;
                }
            }

            // lets test for arrays
            if (fromType.isArray() && !fromType.getComponentType().isPrimitive()) {
                // TODO can we try walking the inheritence-tree for the element types?
                if (!fromType.equals(Object[].class)) {
                    fromSuperClass = Object[].class;

                    TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                    if (converter == null) {
                        converter = findTypeConverter(toType, fromSuperClass, value);
                    }
                    if (converter != null) {
                        return converter;
                    }
                }
            }
        }

        // lets try classes derived from this toType
        if (fromType != null) {
	        Set<Map.Entry<TypeMapping, TypeConverter>> entries = typeMappings.entrySet();
	        for (Map.Entry<TypeMapping, TypeConverter> entry : entries) {
	            TypeMapping key = entry.getKey();
	            Class aToType = key.getToType();
	            if (toType.isAssignableFrom(aToType)) {
	                if (fromType.isAssignableFrom(key.getFromType())) {
	                    return entry.getValue();
	                }
	            }
	        }
        }

        // TODO look at constructors of toType?
        return null;
    }

    /**
     * Checks if the registry is loaded and if not lazily load it
     */
    protected synchronized void checkLoaded() {
        if (!loaded) {
            loaded = true;
            for (TypeConverterLoader typeConverterLoader : typeConverterLoaders) {
                try {
                    typeConverterLoader.load(this);
                }
                catch (Exception e) {
                    throw new RuntimeCamelException(e);
                }
            }
        }
    }

    /**
     * Represents a mapping from one type (which can be null) to another
     */
    protected static class TypeMapping {
        Class toType;
        Class fromType;

        public TypeMapping(Class toType, Class fromType) {
            this.toType = toType;
            this.fromType = fromType;
        }

        public Class getFromType() {
            return fromType;
        }

        public Class getToType() {
            return toType;
        }

        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping) object;
                return ObjectHelper.equals(this.fromType, that.fromType) && ObjectHelper.equals(this.toType, that.toType);
            }
            return false;
        }

        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }

        @Override
        public String toString() {
            return ""["" + fromType + ""=>"" + toType + ""]"";
        }
    }
}
"
org/apache/camel/processor/idempotent/MessageIdRepository.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;

/**
 * Access to a repository of Message IDs to implement the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 1.1 $
 */
public interface MessageIdRepository {

    /**
     * Returns true if this messageId has been processed before
     * otherwise this messageId is added to the repository and false is returned.
     *
     * @param messageId the String ID of the message
     * @return true if the message has been processed succesfully before otherwise false
     */
    boolean contains(String messageId);
}
"
org/apache/camel/component/processor/ProcessorEndpoint.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.Consumer;
import org.apache.camel.Producer;
import org.apache.camel.Component;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancer;

/**
 * A base class for creating {@link Endpoint} implementations from a {@link Processor}
 *
 * @version $Revision: 1.1 $
 */
public class ProcessorEndpoint extends DefaultEndpoint<Exchange> {
    private final Processor processor;
    private final LoadBalancer loadBalancer;

    protected ProcessorEndpoint(String endpointUri, Component component, Processor processor, LoadBalancer loadBalancer) {
        super(endpointUri, component);
        this.processor = processor;
        this.loadBalancer = loadBalancer;
    }

    public Exchange createExchange() {
        return new DefaultExchange(getContext());
    }

    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }

    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new ProcessorEndpointConsumer(this, processor);
    }

    public Processor getProcessor() {
        return processor;
    }

    public LoadBalancer getLoadBalancer() {
        return loadBalancer;
    }

    protected void onExchange(Exchange exchange) throws Exception {
        processor.process(exchange);

        // now lets output to the load balancer
        loadBalancer.process(exchange);
    }

	public boolean isSingleton() {
		return true;
	}
}
"
org/apache/camel/builder/xml/NamespaceBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import java.util.Map;
import java.util.HashMap;
import java.util.Set;

/**
 * A helper class for creating namespaces which can then be used to create XPath expressions
 *
 * @version $Revision: 1.1 $
 */
public class NamespaceBuilder {
    private Map<String,String> namespaces = new HashMap<String, String>();

    public static NamespaceBuilder namespaceContext() {
        return new NamespaceBuilder();
    }

    public static NamespaceBuilder namespaceContext(String prefix, String uri) {
        return new NamespaceBuilder().namespace(prefix, uri);
    }

    public NamespaceBuilder namespace(String prefix, String uri) {
        namespaces.put(prefix, uri);
        return this;
    }

    /**
     * Creates a new XPath expression using the current namespaces
     *
     * @param xpath the XPath expression
     * @return a new XPath expression
     */
    public XPathBuilder xpath(String xpath) {
        XPathBuilder answer = XPathBuilder.xpath(xpath);
        Set<Map.Entry<String,String>> entries = namespaces.entrySet();
        for (Map.Entry<String, String> entry : entries) {
          answer.namespace(entry.getKey(), entry.getValue());
        }
        return answer;
    }
}
"
org/apache/camel/builder/PolicyBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.util.ArrayList;
import java.util.Collections;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Policy;

/**
 * @version $Revision: 519943 $
 */
public class PolicyBuilder implements ProcessorFactory {
    private final ArrayList<Policy> policies = new ArrayList<Policy>();
	private final FromBuilder parent;
	private FromBuilder target;

	public PolicyBuilder(FromBuilder parent) {
        this.parent = parent;
	}
	
	@Fluent(""policy"")
	public PolicyBuilder add(@FluentArg(""ref"") Policy interceptor) {
		policies.add(interceptor);
		return this;
	}
	
	@Fluent(callOnElementEnd=true)
    public FromBuilder target() {
        this.target = new FromBuilder(parent);
        return target;
    }

    public Processor createProcessor() throws Exception {
    	
    	// The target is required.
    	if( target == null ) 
    		throw new RuntimeCamelException(""target not provided."");
    	
        Processor last = target.createProcessor();
    	Collections.reverse(policies);
        for (Policy p : policies) {
            last = p.wrap(last);
        }
        
        return last;
    }
}
"
org/apache/camel/impl/DefaultExchange.java,true,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.util.UuidGenerator;

import java.util.HashMap;
import java.util.Map;

/**
 * A default implementation of {@link Exchange}
 *
 * @version $Revision$
 */
public class DefaultExchange implements Exchange {
    private static final UuidGenerator defaultIdGenerator = new UuidGenerator();
    protected final CamelContext context;
    private Map<String, Object> headers;
    private Message in;
    private Message out;
    private Message fault;
    private Throwable exception;
    private String exchangeId = DefaultExchange.defaultIdGenerator.generateId();

    public DefaultExchange(CamelContext context) {
        this.context = context;
    }

    @Override
    public String toString() {
        return ""Exchange["" + in + ""]"";
    }

    public Exchange copy() {
        Exchange exchange = newInstance();
        exchange.copyFrom(this);
        return exchange;
    }

    public void copyFrom(Exchange exchange) {
        if (exchange == this) {
            return;
        }
        setHeaders(safeCopy(exchange.getProperties()));
        setIn(safeCopy(exchange.getIn()));
        setOut(safeCopy(exchange.getOut()));
       	setFault(safeCopy(exchange.getFault()));        
        setException(exchange.getException());
    }

    static private Map<String, Object> safeCopy(Map<String, Object> properties) {
		if(properties == null)
			return null;
		return new HashMap<String, Object>(properties);
	}

	static private Message safeCopy(Message message) {
    	if( message == null)
    		return null;
    	return message.copy();
	}

	public Exchange newInstance() {
        return new DefaultExchange(context);
    }

    public CamelContext getContext() {
        return context;
    }

    public Object getProperty(String name) {
        if (headers != null) {
            return headers.get(name);
        }
        return null;
    }

    public <T> T getProperty(String name, Class<T> type) {
        Object value = getProperty(name);
        return getContext().getTypeConverter().convertTo(type, value);
    }

    public void setProperty(String name, Object value) {
        getProperties().put(name, value);
    }

    public Map<String, Object> getProperties() {
        if (headers == null) {
            headers = new HashMap<String, Object>();
        }
        return headers;
    }

    public void setHeaders(Map<String, Object> headers) {
        this.headers = headers;
    }

    public Message getIn() {
        if (in == null) {
            in = createInMessage();
            configureMessage(in);
        }
        return in;
    }

    public void setIn(Message in) {
        this.in = in;
        configureMessage(in);
    }

    public Message getOut() {
        return getOut(true);
    }

    public Message getOut(boolean lazyCreate) {
        if (out == null && lazyCreate) {
            out = createOutMessage();
            configureMessage(out);
        }
        return out;
    }

    public void setOut(Message out) {
        this.out = out;
        configureMessage(out);
    }

    public Throwable getException() {
        return exception;
    }

    public void setException(Throwable exception) {
        this.exception = exception;
    }

    public Message getFault() {
        return fault;
    }

    public void setFault(Message fault) {
        this.fault = fault;
        configureMessage(fault);
    }

    public String getExchangeId() {
        return exchangeId;
    }

    public void setExchangeId(String id) {
        this.exchangeId = id;
    }

    /**
     * Factory method used to lazily create the IN message
     */
    protected Message createInMessage() {
        return new DefaultMessage();
    }

    /**
     * Factory method to lazily create the OUT message
     */
    protected Message createOutMessage() {
        return new DefaultMessage();
    }

    /**
     * Configures the message after it has been set on the exchange
     */
    protected void configureMessage(Message message) {
        if (message instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport) message;
            messageSupport.setExchange(this);
        }
    }
}
"
org/apache/camel/util/ExpressionListComparator.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;

import java.util.Comparator;
import java.util.List;

/**
 * An implementation of {@link java.util.Comparator} which takes a list of
 * {@link org.apache.camel.Expression} objects which is evaluated
 * on each exchange to compare them
 *
 * @version $Revision: 1.1 $
 */
public class ExpressionListComparator<E extends Exchange> implements Comparator<E> {
    private final List<Expression<E>> expressions;

    public ExpressionListComparator(List<Expression<E>> expressions) {
        this.expressions = expressions;
    }

    public int compare(E e1, E e2) {
        for (Expression<E> expression : expressions) {
            Object o1 = expression.evaluate(e1);
            Object o2 = expression.evaluate(e2);
            int answer = ObjectHelper.compare(o1, o2);
            if (answer != 0) {
                return answer;
            }
        }
        return 0;
    }
}"
org/apache/camel/RuntimeCamelException.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * @version $Revision$
 */
public class RuntimeCamelException extends RuntimeException {
	private static final long serialVersionUID = 8046489554418284257L;

	public RuntimeCamelException() {
    }

    public RuntimeCamelException(String message) {
        super(message);
    }

    public RuntimeCamelException(String message, Throwable cause) {
        super(message, cause);
    }

    public RuntimeCamelException(Throwable cause) {
        super(cause);
    }
}
"
org/apache/camel/impl/ScheduledPollConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/**
 * A useful base class for any consumer which is polling based
 *
 * @version $Revision$
 */
public abstract class ScheduledPollConsumer<E extends Exchange> extends DefaultConsumer<E> implements Runnable {
    private static final transient Log log = LogFactory.getLog(ScheduledPollConsumer.class);
    
    private final ScheduledExecutorService executor;
    private long initialDelay = 1000;
    private long delay = 500;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private boolean useFixedDelay;
    private ScheduledFuture<?> future;

    public ScheduledPollConsumer(DefaultEndpoint<E> endpoint, Processor processor) {
        this(endpoint, processor, endpoint.getExecutorService());
    }

    public ScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor);
        this.executor = executor;
        if (executor == null) {
            throw new IllegalArgumentException(""A non null ScheduledExecutorService must be provided."");
        }
    }

    /**
     * Invoked whenever we should be polled
     */
    public void run() {
        log.debug(""Starting to poll"");
        try {
            poll();
        }
        catch (Exception e) {
            log.warn(""Caught: "" + e, e);
        }
    }

    // Properties
    //-------------------------------------------------------------------------
    public long getInitialDelay() {
        return initialDelay;
    }

    public void setInitialDelay(long initialDelay) {
        this.initialDelay = initialDelay;
    }

    public long getDelay() {
        return delay;
    }

    public void setDelay(long delay) {
        this.delay = delay;
    }

    public TimeUnit getTimeUnit() {
        return timeUnit;
    }

    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }

    public boolean isUseFixedDelay() {
        return useFixedDelay;
    }

    public void setUseFixedDelay(boolean useFixedDelay) {
        this.useFixedDelay = useFixedDelay;
    }

    // Implementation methods
    //-------------------------------------------------------------------------

    /**
     * The polling method which is invoked periodically to poll this consumer
     *
     * @throws Exception
     */
    protected abstract void poll() throws Exception;

    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (isUseFixedDelay()) {
            future = executor.scheduleWithFixedDelay(this, getInitialDelay(), getDelay(), getTimeUnit());
        }
        else {
            future = executor.scheduleAtFixedRate(this, getInitialDelay(), getDelay(), getTimeUnit());
        }
    }

    @Override
    protected void doStop() throws Exception {
        if (future != null) {
            future.cancel(false);
        }
        super.doStop();
    }
}
"
org/apache/camel/processor/CompositeProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;

import java.util.Collection;

/**
 * Represents a composite pattern, aggregating a collection of processors together as a single processor
 *
 * @version $Revision$
 */
public class CompositeProcessor extends ServiceSupport implements Processor {
    private final Collection<Processor> processors;

    public CompositeProcessor(Collection<Processor> processors) {
        this.processors = processors;
    }

    public void process(Exchange exchange) throws Exception {
        for (Processor processor : processors) {
            processor.process(exchange);
        }
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""[ "");
        boolean first = true;
        for (Processor processor : processors) {
            if (first) {
                first = false;
            }
            else {
                builder.append("", "");
            }
            builder.append(processor.toString());
        }
        builder.append("" ]"");
        return builder.toString();
    }

    public Collection<Processor> getProcessors() {
        return processors;
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);
    }
}
"
org/apache/camel/impl/converter/TypeConverterLoader.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

/**
 * @version $Revision$
 */
public interface TypeConverterLoader {
    /**
     * A pluggable strategy to load type converters into a registry from some kind of mechanism
     *
     * @param registry the registry to load the type converters into
     * @throws Exception if the type converters could not be loaded
     */
    void load(TypeConverterRegistry registry) throws Exception;
}
"
org/apache/camel/component/jmx/JMXExchange.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;

import javax.management.Notification;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;

/**
 * A {@link Exchange} for a jmx notification
 * 
 * @version $Revision: 520985 $
 */
public class JMXExchange extends DefaultExchange {

	/**
	 * Constructor
	 * @param camelContext
	 * @param file
	 */
	public JMXExchange(CamelContext camelContext,Notification notification){
		super(camelContext);
		setIn(new JMXMessage(notification));
	}
}
"
org/apache/camel/TypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * A pluggable strategy to be able to convert objects
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">to different types</a>
 * such as to and from String, InputStream/OutputStream, Reader/Writer, Document, byte[], ByteBuffer etc
 *
 * @version $Revision$
 */
public interface TypeConverter {
    /**
     * Converts the value to the specified type
     * @param type the requested type
     * @param value the value to be converted
     * @return the converted value or null if it can not be converted
     */
    <T> T convertTo(Class<T> type, Object value);
}
"
org/apache/camel/builder/xml/XsltBuilder.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Exchange;
import org.apache.camel.ExpectedBodyTypeException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeTransformException;
import org.apache.camel.converter.jaxp.XmlConverter;
import static org.apache.camel.util.ObjectHelper.notNull;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.stream.StreamSource;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Creates a <a href=""http://activemq.apache.org/camel/processor.html"">Processor</a>
 * which performs an XSLT transformation of the IN message body
 *
 * @version $Revision: 531854 $
 */
public class XsltBuilder implements Processor {
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private XmlConverter converter = new XmlConverter();
    private Transformer transformer;
    private ResultHandler resultHandler = new StringResultHandler();
    private boolean failOnNullBody = true;

    public XsltBuilder() {
    }

    public XsltBuilder(Transformer transformer) {
        this.transformer = transformer;
    }

    @Override
    public String toString() {
        return ""XSLT["" + transformer + ""]"";
    }

    public synchronized void process(Exchange exchange) throws Exception {
        Transformer transformer = getTransformer();
        if (transformer == null) {
            throw new IllegalArgumentException(""No transformer configured!"");
        }
        configureTransformer(transformer, exchange);
        Source source = getSource(exchange);
        Result result = resultHandler.getResult();
        transformer.transform(source, result);
        resultHandler.setBody(exchange.getIn());
    }

    // Builder methods
    //-------------------------------------------------------------------------

    /**
     * Creates an XSLT processor using the given transformer instance
     */
    public static XsltBuilder xslt(Transformer transformer) {
        return new XsltBuilder(transformer);
    }

    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        XsltBuilder answer = new XsltBuilder();
        answer.setTransformerSource(xslt);
        return answer;
    }

    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }

    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(xslt.openStream());
    }

    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }

    /**
     * Sets the output as being a byte[]
     */
    public XsltBuilder outputBytes() {
        setResultHandler(new StreamResultHandler());
        return this;
    }

    /**
     * Sets the output as being a String
     */
    public XsltBuilder outputString() {
        setResultHandler(new StringResultHandler());
        return this;
    }

    /**
     * Sets the output as being a DOM
     */
    public XsltBuilder outputDOM() {
        setResultHandler(new DomResultHandler());
        return this;
    }

    public XsltBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }

    // Properties
    //-------------------------------------------------------------------------

    public Map<String, Object> getParameters() {
        return parameters;
    }

    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }

    public Transformer getTransformer() {
        return transformer;
    }

    public void setTransformer(Transformer transformer) {
        this.transformer = transformer;
    }

    public boolean isFailOnNullBody() {
        return failOnNullBody;
    }

    public void setFailOnNullBody(boolean failOnNullBody) {
        this.failOnNullBody = failOnNullBody;
    }

    public ResultHandler getResultHandler() {
        return resultHandler;
    }

    public void setResultHandler(ResultHandler resultHandler) {
        this.resultHandler = resultHandler;
    }

    public void setTransformerSource(Source source) throws TransformerConfigurationException {
        setTransformer(converter.getTransformerFactory().newTransformer(source));
    }

    // Implementation methods
    // -------------------------------------------------------------------------

    /**
     * Converts the inbound body to a {@link Source}
     */
    protected Source getSource(Exchange exchange) {
        Message in = exchange.getIn();
        Source source = in.getBody(Source.class);
        if (source == null) {
            if (isFailOnNullBody()) {
                throw new ExpectedBodyTypeException(exchange, Source.class);
            }
            else {
                try {
                    source = converter.toSource(converter.createDocument());
                }
                catch (ParserConfigurationException e) {
                    throw new RuntimeTransformException(e);
                }
            }
        }
        return source;
    }

    /**
     * Configures the transformerwith exchange specific parameters
     */
    protected void configureTransformer(Transformer transformer, Exchange exchange) {
        transformer.clearParameters();

        addParameters(transformer, exchange.getProperties());
        addParameters(transformer, exchange.getIn().getHeaders());
        addParameters(transformer, getParameters());

        transformer.setParameter(""exchange"", exchange);
        transformer.setParameter(""in"", exchange.getIn());
        transformer.setParameter(""out"", exchange.getOut());
    }

    protected void addParameters(Transformer transformer, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            transformer.setParameter(entry.getKey(), entry.getValue());
        }
    }
}
"
org/apache/camel/impl/PollingConsumerRoute.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Route;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;

import java.util.List;

/**
 * A {@link Route} which starts with a
 * <a href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling Consumer</a>
 *
 * @version $Revision: 1.1 $
 */
public class PollingConsumerRoute<E extends Exchange> extends Route<E> {
    private Processor processor;

    public PollingConsumerRoute(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }

    @Override
    public String toString() {
        return ""PollingConsumerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
    }

    public Processor getProcessor() {
        return processor;
    }

    public void setProcessor(Processor processor) {
        this.processor = processor;
    }

    /**
     * Factory method to lazily create the complete list of services required for this route
     * such as adding the processor or consumer
     */
    protected void addServices(List<Service> services) throws Exception {
        Processor processor = getProcessor();
        if (processor instanceof Service) {
            Service service = (Service) processor;
            services.add(service);
        }
        Endpoint<E> endpoint = getEndpoint();
        PollingConsumer<E> consumer = endpoint.createPollingConsumer();
        if (consumer != null) {
            services.add(consumer);
        }
    }
}"
org/apache/camel/util/CollectionHelper.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * A number of helper methods for working with collections
 *
 * @version $Revision: 1.1 $
 */
public class CollectionHelper {
    /**
     * Sets the value of the entry in the map for the given key, though if the map already contains a value for the
     * given key then the value is appended to a list of values.
     *
     * @param map   the map to add the entry to
     * @param key   the key in the map
     * @param value the value to put in the map
     */
    public static void appendValue(Map map, Object key, Object value) {

        Object oldValue = map.get(key);
        if (oldValue != null) {
            List list;
            if (oldValue instanceof List) {
                list = (List) oldValue;
            }
            else {
                list = new ArrayList();
                list.add(oldValue);
            }
            list.add(value);
        }
        else {
            map.put(key, value);
        }
    }
}
"
org/apache/camel/spi/Provider.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

/**
 * A provider of newly constructed objects
 *
 * @version $Revision$
 */
public interface Provider<T> {

    /**
     * Returns the newly constructed instance
     */
    T get();
}
"
org/apache/camel/component/queue/QueueEndpointConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.queue;

import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;

import java.util.concurrent.TimeUnit;

/**
 * @version $Revision$
 */
public class QueueEndpointConsumer<E extends Exchange> extends ServiceSupport implements Consumer<E>, Runnable {
    private QueueEndpoint<E> endpoint;
    private Processor processor;
    private Thread thread;

    public QueueEndpointConsumer(QueueEndpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }

    @Override
    public String toString() {
        return ""QueueEndpointConsumer: "" + endpoint.getEndpointUri();
    }

    public void run() {
        while (!isStopping()) {
            E exchange;
            try {
                exchange = endpoint.getQueue().poll(1000, TimeUnit.MILLISECONDS);
            }
            catch (InterruptedException e) {
                break;
            }
            if (exchange != null && !isStopping()) {
                try {
                    processor.process(exchange);
                }
                catch (Throwable e) {
                    e.printStackTrace();
                }
            }
        }
    }

    protected void doStart() throws Exception {
        thread = new Thread(this, endpoint.getEndpointUri());
        thread.setDaemon(true);
        thread.start();
    }

    protected void doStop() throws Exception {
        thread.join();
    }
}
"
org/apache/camel/builder/ProcessorFactory.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * An interface representing a builder of a {@link Processor}
 * 
 * @version $Revision$
 */
public interface ProcessorFactory {

    public Processor createProcessor() throws Exception;

}
"
org/apache/camel/impl/DefaultComponentResolver.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;

/**
 * The default implementation of {@link ComponentResolver}
 * which tries to find components by using the URI scheme prefix and searching for a file of the URI
 * scheme name in the <b>META-INF/services/org/apache/camel/component/</b>
 * directory on the classpath.
 *
 * @version $Revision$
 */
public class DefaultComponentResolver<E extends Exchange> implements ComponentResolver<E> {
    protected static final FactoryFinder componentFactory = new FactoryFinder(""META-INF/services/org/apache/camel/component/"");

    public Component<E> resolveComponent(String name, CamelContext context) {
        Class type;
        try {
            type = componentFactory.findClass(name);
        }
        catch (NoFactoryAvailableException e) {
            return null;
        }
        catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no EndpointResolver registered for scheme : "" + name, e);
        }
        if (type == null) {
            return null;
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component<E>)context.getInjector().newInstance(type);
        }
        else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: "" + type.getName());
        }
    }
}
"
org/apache/camel/util/FactoryFinder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.spi.Injector;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

public class FactoryFinder {
    private final String path;
    private final ConcurrentHashMap classMap = new ConcurrentHashMap();

    public FactoryFinder() {
        this(""META-INF/services/org/apache/camel/"");
    }

    public FactoryFinder(String path) {
        this.path = path;
    }

    /**
     * Creates a new instance of the given key
     *
     * @param key is the key to add to the path to find a text file
     *            containing the factory name
     * @return a newly created instance
     */
    public Object newInstance(String key)
            throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException {
        return newInstance(key, (String) null);
    }

    public Object newInstance(String key, String propertyPrefix)
            throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException {
        Class clazz = findClass(key, propertyPrefix);
        return clazz.newInstance();
    }

    public Object newInstance(String key, Injector injector) throws IOException, ClassNotFoundException {
        return newInstance(key, injector, null);
    }

    public Object newInstance(String key, Injector injector, String propertyPrefix) throws IOException, ClassNotFoundException {
        Class type = findClass(key, propertyPrefix);
        return injector.newInstance(type);
    }

    public Class findClass(String key) throws ClassNotFoundException, IOException {
        return findClass(key, null);
    }

    public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
        if (propertyPrefix == null) {
            propertyPrefix = """";
        }

        Class clazz = (Class) classMap.get(propertyPrefix + key);
        if (clazz == null) {
            clazz = newInstance(doFindFactoryProperies(key), propertyPrefix);
            classMap.put(propertyPrefix + key, clazz);
        }
        return clazz;
    }

    private Class newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException, IOException {

        String className = properties.getProperty(propertyPrefix + ""class"");
        if (className == null) {
            throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
        }
        Class clazz = null;
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader != null) {
            try {
                clazz = loader.loadClass(className);
            }
            catch (ClassNotFoundException e) {
                // ignore
            }
        }
        if (clazz == null) {
            clazz = FactoryFinder.class.getClassLoader().loadClass(className);
        }
        return clazz;
    }

    private Properties doFindFactoryProperies(String key) throws IOException {
        String uri = path + key;

        // lets try the thread context class loader first
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        if (classLoader == null) {
            classLoader = getClass().getClassLoader();
        }
        InputStream in = classLoader.getResourceAsStream(uri);
        if (in == null) {
            in = FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
            if (in == null) {
                throw new NoFactoryAvailableException(uri);
            }
        }

        // lets load the file
        BufferedInputStream reader = null;
        try {
            reader = new BufferedInputStream(in);
            Properties properties = new Properties();
            properties.load(reader);
            return properties;
        }
        finally {
            try {
                reader.close();
            }
            catch (Exception e) {
            }
        }
    }
}
"
org/apache/camel/Processor.java,true,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * A <a href=""http://activemq.apache.org/camel/processor.html"">processor</a>
 * is used to implement the
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
 * and <a href=""http://activemq.apache.org/camel/message-transformer.html"">Message Transformer</a>
 * patterns and to process message exchanges.
 *
 * @version $Revision$
 */
public interface Processor {

    /**
     * Processes the message exchange
     * 
     * @throws Exception if an internal processing error has occurred. 
     */
    void process(Exchange exchange) throws Exception;
}
"
org/apache/camel/impl/converter/InstanceMethodTypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.impl.CachingInjector;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * A {@link TypeConverter} implementation which instantiates an object
 * so that an instance method can be used as a type converter
 *
 * @version $Revision$
 */
public class InstanceMethodTypeConverter implements TypeConverter {
    private final CachingInjector injector;
    private final Method method;

    public InstanceMethodTypeConverter(CachingInjector injector, Method method) {
        this.injector = injector;
        this.method = method;
    }

    @Override
    public String toString() {
        return ""InstanceMethodTypeConverter: "" + method;
    }

    public synchronized <T> T convertTo(Class<T> type, Object value) {
        Object instance = injector.newInstance();
        if (instance == null) {
            throw new RuntimeCamelException(""Could not instantiate aninstance of: "" + type.getName());
        }
        return (T) ObjectHelper.invokeMethod(method, instance, value);
    }
}
"
org/apache/camel/spi/XmlUnmarshaller.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;

/**
 * Unmarshallers that unmarshall to XML should extend this base class.
 * 
 * @version $Revision: 520124 $
 */
public abstract class XmlUnmarshaller implements Unmarshaller {
	
	/**
     * Unmarshals the given stream into an object.
     */
    public Object unmarshal(InputStream stream) throws IOException {
    	return unmarshal(new StreamSource(stream));
    }

	/**
     * Unmarshals the given stream into an object.
     */
    abstract public Object unmarshal(Source stream) throws IOException;
    
}
"
org/apache/camel/spi/ComponentResolver.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import org.apache.camel.Component;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponentResolver;

/**
 * Represents a resolver of components from a URI to be able to auto-load them using some
 * discovery mechanism like {@link DefaultComponentResolver}
 *
 * @version $Revision$
 */
public interface ComponentResolver<E extends Exchange> {
    
    /**
     * Attempts to resolve the component for the given URI
     *
     * @param name the component name to resolve
     * @param context the context to load the component if it can be resolved
     * @return the component which is added to the context or null if it can not be resolved
     */
    Component<E> resolveComponent(String name, CamelContext context) throws Exception;
}
"
org/apache/camel/builder/PipelineBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.Pipeline;

import java.util.Collection;

/**
 * A builder for the {@link Pipeline} pattern
 *
 * @version $Revision$
 */
public class PipelineBuilder extends FromBuilder {
    private final Collection<Endpoint> endpoints;

    public PipelineBuilder(FromBuilder parent, Collection<Endpoint> endpoints) {
        super(parent);
        this.endpoints = endpoints;
    }

    @Override
    public Processor createProcessor() throws Exception {
        return new Pipeline(endpoints);
    }
}
"
org/apache/camel/impl/DefaultComponent.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
import org.apache.camel.util.ObjectHelper;

import java.net.URI;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;

/**
 * @version $Revision$
 */
public abstract  class DefaultComponent<E extends Exchange> extends ServiceSupport implements Component<E> {

	private int defaultThreadPoolSize = 5;
    private CamelContext camelContext;
    private ScheduledExecutorService executorService;

    public DefaultComponent() {
    }

    public DefaultComponent(CamelContext context) {
        this.camelContext = context;
    }


    public Endpoint<E> createEndpoint(String uri) throws Exception {
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");        
        URI u = new URI(uri);
        String path = u.getHost();
        if (path == null) {
            path = u.getSchemeSpecificPart();
        }
        Map parameters = URISupport.parseParamters(u);

        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);
        if (endpoint == null) {
            return null;
        }
        if (parameters != null) {
            if (endpoint instanceof ScheduledPollEndpoint) {
                ScheduledPollEndpoint scheduledPollEndpoint = (ScheduledPollEndpoint) endpoint;
                scheduledPollEndpoint.configureProperties(parameters);
            }
            IntrospectionSupport.setProperties(endpoint, parameters);
        }
        return endpoint;
    }

    public CamelContext getCamelContext() {
        return camelContext;
    }

    public void setCamelContext(CamelContext context) {
        this.camelContext = context;
    }

    public ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            executorService = createExecutorService();
        }
        return executorService;
    }

    public void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }

    /**
     * A factory method to create a default thread pool and executor
     */
    protected ScheduledExecutorService createExecutorService() {
        return new ScheduledThreadPoolExecutor(defaultThreadPoolSize, new ThreadFactory() {
            int counter;

            public synchronized Thread newThread(Runnable runnable) {
                Thread thread = new Thread(runnable);
                thread.setName(""Thread"" + (++counter) + "" "" + DefaultComponent.this.toString());
                return thread;
            }
        });
    }

    protected void doStart() throws Exception {
    }

    protected void doStop() throws Exception {
        if (executorService != null) {
            executorService.shutdown();
        }
    }


    /**
     * A factory method allowing derived components to create a new endpoint from the given URI,
     * remaining path and optional parameters
     *
     * @param uri        the full URI of the endpoint
     * @param remaining  the remaining part of the URI without the query parameters or component prefix
     * @param parameters the optional parameters passed in
     * @return a newly created endpoint or null if the endpoint cannot be created based on the inputs
     */
    abstract protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception;
}
"
org/apache/camel/builder/MulticastBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.MulticastProcessor;

import java.util.Collection;

/**
 * A builder for the {@link MulticastProcessor} pattern
 *
 * @version $Revision$
 */
public class MulticastBuilder extends FromBuilder {
    private final Collection<Endpoint> endpoints;

    public MulticastBuilder(FromBuilder parent, Collection<Endpoint> endpoints) {
        super(parent);
        this.endpoints = endpoints;
    }

    @Override
    public Processor createProcessor() throws Exception {
        return new MulticastProcessor(endpoints);
    }
}
"
org/apache/camel/view/RouteDotGenerator.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;

import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

/**
 * A <a href=""http://www.graphviz.org/"">DOT</a> file creator plugin which
 * creates a DOT file showing the current routes
 *
 * @version $Revision: 523881 $
 */
public class RouteDotGenerator {
    private static final transient Log log = LogFactory.getLog(RouteDotGenerator.class);
    private String file = ""CamelRoutes.dot"";

    public String getFile() {
        return file;
    }

    /**
     * Sets the destination file name to create the destination diagram
     */
    public void setFile(String file) {
        this.file = file;
    }

    public void drawRoutes(CamelContext context) throws IOException {
        PrintWriter writer = new PrintWriter(new FileWriter(file));
        generateFile(writer, context);
    }

    protected void generateFile(PrintWriter writer, CamelContext context) {
        writer.println(""digraph \""Camel Routes\"" {"");
        writer.println();
        writer.println(""label=\""Camel Container: "" + context + ""\""];"");
        writer.println();
        writer.println(""node [style = \""rounded,filled\"", fillcolor = yellow, fontname=\""Helvetica-Oblique\""];"");
        writer.println();
        printRoutes(writer, context.getRoutes());
    }

    protected void printRoutes(PrintWriter writer, List<Route> routes) {
        for (Route r : routes) {
            Endpoint end = r.getEndpoint();
            writer.print(end.getEndpointUri());
            writer.print("" -> "");
            writer.print(r);
            writer.print("" -> "");
            if (r instanceof EventDrivenConsumerRoute) {
                EventDrivenConsumerRoute consumerRoute = (EventDrivenConsumerRoute) r;
                Processor p = consumerRoute.getProcessor();
                writer.println(p);
            }
        }
    }
}
"
org/apache/camel/util/URISupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @version $Revision$
 */
public class URISupport {
    public static class CompositeData {
        String scheme;
        String path;
        URI components[];
        Map parameters;
        String fragment;
        public String host;

        public URI[] getComponents() {
            return components;
        }

        public String getFragment() {
            return fragment;
        }

        public Map getParameters() {
            return parameters;
        }

        public String getScheme() {
            return scheme;
        }

        public String getPath() {
            return path;
        }

        public String getHost() {
            return host;
        }

        public URI toURI() throws URISyntaxException {
            StringBuffer sb = new StringBuffer();
            if (scheme != null) {
                sb.append(scheme);
                sb.append(':');
            }

            if (host != null && host.length() != 0) {
                sb.append(host);
            }
            else {
                sb.append('(');
                for (int i = 0; i < components.length; i++) {
                    if (i != 0) {
                        sb.append(',');
                    }
                    sb.append(components[i].toString());
                }
                sb.append(')');
            }

            if (path != null) {
                sb.append('/');
                sb.append(path);
            }
            if (!parameters.isEmpty()) {
                sb.append(""?"");
                sb.append(createQueryString(parameters));
            }
            if (fragment != null) {
                sb.append(""#"");
                sb.append(fragment);
            }
            return new URI(sb.toString());
        }
    }

    public static Map parseQuery(String uri) throws URISyntaxException {
        try {
            Map rc = new HashMap();
            if (uri != null) {
                String[] parameters = uri.split(""&"");
                for (int i = 0; i < parameters.length; i++) {
                    int p = parameters[i].indexOf(""="");
                    if (p >= 0) {
                        String name = URLDecoder.decode(parameters[i].substring(0, p), ""UTF-8"");
                        String value = URLDecoder.decode(parameters[i].substring(p + 1), ""UTF-8"");
                        rc.put(name, value);
                    }
                    else {
                        rc.put(parameters[i], null);
                    }
                }
            }
            return rc;
        }
        catch (UnsupportedEncodingException e) {
            throw (URISyntaxException) new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }

    public static Map parseParamters(URI uri) throws URISyntaxException {
        String query = uri.getQuery();
        if (query == null) {
            String schemeSpecificPart = uri.getSchemeSpecificPart();
            int idx = schemeSpecificPart.lastIndexOf('?');
            if (idx < 0) {
                return Collections.EMPTY_MAP;
            }
            else {
                query = schemeSpecificPart.substring(idx + 1);
            }
        }
        else {
            query = stripPrefix(query, ""?"");
        }
        return parseQuery(query);
    }

    /**
     * Removes any URI query from the given uri
     */
    public static URI removeQuery(URI uri) throws URISyntaxException {
        return createURIWithQuery(uri, null);
    }

    /**
     * Creates a URI with the given query
     */
    public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
        return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(), query, uri.getFragment());
    }

    public static CompositeData parseComposite(URI uri) throws URISyntaxException {

        CompositeData rc = new CompositeData();
        rc.scheme = uri.getScheme();
        String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"").trim();

        parseComposite(uri, rc, ssp);

        rc.fragment = uri.getFragment();
        return rc;
    }

    /**
     * @param uri
     * @param rc
     * @param ssp
     * @throws URISyntaxException
     */
    private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
        String componentString;
        String params;

        if (!checkParenthesis(ssp)) {
            throw new URISyntaxException(uri.toString(), ""Not a matching number of '(' and ')' parenthesis"");
        }

        int p;
        int intialParen = ssp.indexOf(""("");
        if (intialParen == 0) {
            rc.host = ssp.substring(0, intialParen);
            p = rc.host.indexOf(""/"");
            if (p >= 0) {
                rc.path = rc.host.substring(p);
                rc.host = rc.host.substring(0, p);
            }
            p = ssp.lastIndexOf("")"");
            componentString = ssp.substring(intialParen + 1, p);
            params = ssp.substring(p + 1).trim();
        }
        else {
            componentString = ssp;
            params = """";
        }

        String components[] = splitComponents(componentString);
        rc.components = new URI[components.length];
        for (int i = 0; i < components.length; i++) {
            rc.components[i] = new URI(components[i].trim());
        }

        p = params.indexOf(""?"");
        if (p >= 0) {
            if (p > 0) {
                rc.path = stripPrefix(params.substring(0, p), ""/"");
            }
            rc.parameters = parseQuery(params.substring(p + 1));
        }
        else {
            if (params.length() > 0) {
                rc.path = stripPrefix(params, ""/"");
            }
            rc.parameters = Collections.EMPTY_MAP;
        }
    }

    /**
     * @param str
     * @return
     */
    private static String[] splitComponents(String str) {
        ArrayList l = new ArrayList();

        int last = 0;
        int depth = 0;
        char chars[] = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]) {
                case '(':
                    depth++;
                    break;
                case ')':
                    depth--;
                    break;
                case ',':
                    if (depth == 0) {
                        String s = str.substring(last, i);
                        l.add(s);
                        last = i + 1;
                    }
            }
        }

        String s = str.substring(last);
        if (s.length() != 0) {
            l.add(s);
        }

        String rc[] = new String[l.size()];
        l.toArray(rc);
        return rc;
    }

    public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }

    public static URI stripScheme(URI uri) throws URISyntaxException {
        return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), ""//""));
    }

    public static String createQueryString(Map options) throws URISyntaxException {
        try {
            if (options.size() > 0) {
                StringBuffer rc = new StringBuffer();
                boolean first = true;
                for (Iterator iter = options.keySet().iterator(); iter.hasNext();) {
                    if (first) {
                        first = false;
                    }
                    else {
                        rc.append(""&"");
                    }

                    String key = (String) iter.next();
                    String value = (String) options.get(key);
                    rc.append(URLEncoder.encode(key, ""UTF-8""));
                    rc.append(""="");
                    rc.append(URLEncoder.encode(value, ""UTF-8""));
                }
                return rc.toString();
            }
            else {
                return """";
            }
        }
        catch (UnsupportedEncodingException e) {
            throw (URISyntaxException) new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }

    /**
     * Creates a URI from the original URI and the remaining paramaters
     *
     * @throws URISyntaxException
     */
    public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
        String s = createQueryString(params);
        if (s.length() == 0) {
            s = null;
        }
        return createURIWithQuery(originalURI, s);
    }

    static public URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
        return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr.getPath(), bindAddr.getQuery(), bindAddr.getFragment());
    }

    public static boolean checkParenthesis(String str) {
        boolean result = true;
        if (str != null) {
            int open = 0;
            int closed = 0;

            int i = 0;
            while ((i = str.indexOf('(', i)) >= 0) {
                i++;
                open++;
            }
            i = 0;
            while ((i = str.indexOf(')', i)) >= 0) {
                i++;
                closed++;
            }
            result = open == closed;
        }
        return result;
    }

    public int indexOfParenthesisMatch(String str) {
        int result = -1;

        return result;
    }
}
"
org/apache/camel/builder/FilterBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.Predicate;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * @version $Revision$
 */
public class FilterBuilder extends FromBuilder {
    private Predicate predicate;

    public FilterBuilder(FromBuilder builder, Predicate predicate) {
        super(builder);
        this.predicate = predicate;
    }

    /**
     * Adds another predicate using a logical AND
     */
    public FilterBuilder and(Predicate predicate) {
        this.predicate = PredicateBuilder.and(this.predicate, predicate);
        return this;
    }

    /**
     * Adds another predicate using a logical OR
     */
    public FilterBuilder or(Predicate predicate) {
        this.predicate = PredicateBuilder.or(this.predicate, predicate);
        return this;
    }

    public Predicate getPredicate() {
        return predicate;
    }

    public FilterProcessor createProcessor() throws Exception {
        // lets create a single processor for all child predicates
        Processor childProcessor = super.createProcessor();
        return new FilterProcessor(predicate, childProcessor);
    }

}
"
org/apache/camel/processor/Splitter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.ServiceSupport;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.apache.camel.util.ServiceHelper;

import java.util.Iterator;

/**
 * Implements a dynamic <a href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
 * where an expression is evaluated to iterate through each of the parts of a message and then each part is then send to some endpoint.
 *
 * @version $Revision$
 */
public class Splitter extends ServiceSupport implements Processor {
    private final Processor processor;
    private final Expression expression;

    public Splitter(Processor destination, Expression expression) {
        this.processor = destination;
        this.expression = expression;
        notNull(destination, ""destination"");
        notNull(expression, ""expression"");
    }

    @Override
    public String toString() {
        return ""Splitter[on: "" + expression + "" to: "" + processor + ""]"";
    }

    public void process(Exchange exchange) throws Exception {
        Object value = expression.evaluate(exchange);
        Iterator iter = ObjectConverter.iterator(value);
        while (iter.hasNext()) {
            Object part = iter.next();
            Exchange newExchange = exchange.copy();
            newExchange.getIn().setBody(part);
            processor.process(newExchange);
        }
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
}
"
org/apache/camel/RuntimeTransformException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Thrown if a message transformation fails
 * 
 * @version $Revision: 521156 $
 */
public class RuntimeTransformException extends RuntimeCamelException {

	private static final long serialVersionUID = -8417806626073055262L;

    public RuntimeTransformException(String message) {
        super(message);
    }

    public RuntimeTransformException(String message, Throwable cause) {
        super(message, cause);
    }

    public RuntimeTransformException(Throwable cause) {
        super(cause);
    }
}
"
org/apache/camel/converter/CollectionConverter.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;

import org.apache.camel.Converter;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Some core java.util Collection based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 524215 $
 */
@Converter
public class CollectionConverter {

    /**
     * Converts a collection to an array
     */
    @Converter
    public static Object[] toArray(Collection value) {
        if (value == null) {
            return null;
        }
        return value.toArray();
    }

    /**
     * Converts an array to a collection
     */
    @Converter
    public static List toList(Object[] array) {
        return Arrays.asList(array);
    }

    @Converter
    public static Set toSet(Object[] array) {
        Set answer = new HashSet();
        for (Object element : array) {
            answer.add(element);
        }
        return answer;
    }

    @Converter
    public static Set toSet(Collection collection) {
        return new HashSet(collection);
    }

    @Converter
    public static Set toSet(Map map) {
        return map.entrySet();
    }
}
"
org/apache/camel/ExpectedBodyTypeException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Thrown if the body could not be converted to the required type
 *
 * @version $Revision: 1.1 $
 */
public class ExpectedBodyTypeException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Class expectedBodyType;

    public ExpectedBodyTypeException(Exchange exchange, Class expectedBodyType) {
        super(""Could not extract IN message body as type: "" + expectedBodyType + "" body is: "" + exchange.getIn().getBody());
        this.exchange = exchange;
        this.expectedBodyType = expectedBodyType;
    }

    public Exchange getExchange() {
        return exchange;
    }

    public Class getExpectedBodyType() {
        return expectedBodyType;
    }
}
"
org/apache/camel/component/mock/AssertionClause.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.builder.ExpressionBuilder.bodyExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
import org.apache.camel.builder.Fluent;
import org.apache.camel.builder.FluentArg;
import org.apache.camel.builder.ValueBuilder;

import java.util.ArrayList;
import java.util.List;

/**
 * A builder of assertions on message exchanges
 *
 * @version $Revision: 1.1 $
 */
public abstract class AssertionClause<E extends Exchange> implements Runnable {

    private List<Predicate<E>> predicates = new ArrayList<Predicate<E>>();

    // Builder methods
    //-------------------------------------------------------------------------

    /**
     * Adds the given predicate to this assertion clause
     */
    public AssertionClause<E> predicate(Predicate<E> predicate) {
        addPredicate(predicate);
        return this;
    }

    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    @Fluent
    public ValueBuilder<E> header(@FluentArg(""name"")String name) {
        Expression<E> expression = headerExpression(name);
        return new PredicateValueBuilder(expression);
    }

    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    @Fluent
    public PredicateValueBuilder body() {
        Expression<E> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }

    /**
     * Returns a predicate and value builder for the inbound message body as a specific type
     */
    @Fluent
    public <T> PredicateValueBuilder bodyAs(@FluentArg(""class"")Class<T> type) {
        Expression<E> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }

    /**
     * Returns a predicate and value builder for the outbound body on an exchange
     */
    @Fluent
    public PredicateValueBuilder outBody() {
        Expression<E> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }

    /**
     * Returns a predicate and value builder for the outbound message body as a specific type
     */
    @Fluent
    public <T> PredicateValueBuilder outBody(@FluentArg(""class"")Class<T> type) {
        Expression<E> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }

    /**
     * Performs any assertions on the given exchange
     */
    protected void applyAssertionOn(MockEndpoint endpoint, int index, E exchange) {
        for (Predicate<E> predicate : predicates) {
            predicate.assertMatches(endpoint.getEndpointUri() + "" "", exchange);
        }
    }

    protected void addPredicate(Predicate<E> predicate) {
        predicates.add(predicate);
    }

    public class PredicateValueBuilder extends ValueBuilder<E> {

        public PredicateValueBuilder(Expression<E> expression) {
            super(expression);
        }

        protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
            addPredicate(predicate);
            return predicate;
        }
    }
}
"
org/apache/camel/builder/xml/ResultHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Message;

import javax.xml.transform.Result;

/**
 * A strategy for handling XSLT results
 *
 * @version $Revision: 1.1 $
 */
public interface ResultHandler {
    Result getResult();

    void setBody(Message in);
}
"
org/apache/camel/builder/xml/XPathBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import static org.apache.camel.converter.ObjectConverter.toBoolean;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.Message;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;

import javax.xml.namespace.QName;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import javax.xml.xpath.XPathFunctionResolver;
import java.io.StringReader;

/**
 * Creates an XPath expression builder
 *
 * @version $Revision: 531854 $
 */
public class XPathBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private final String text;
    private XPathFactory xpathFactory;
    private Class documentType = Document.class;
    private QName resultType = null;
    private String objectModelUri = null;
    private DefaultNamespaceContext namespaceContext;
    private XPathFunctionResolver functionResolver;
    private XPathExpression expression;
    private MessageVariableResolver variableResolver = new MessageVariableResolver();

    public static XPathBuilder xpath(String text) {
        return new XPathBuilder(text);
    }

    public XPathBuilder(String text) {
        this.text = text;
    }

    @Override
    public String toString() {
        return ""XPath: "" + text;
    }

    public boolean matches(E exchange) {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        return toBoolean(booleanResult);
    }

    public void assertMatches(String text, E exchange) throws AssertionError {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        if (!toBoolean(booleanResult)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as returned <"" + booleanResult + "">"");
        }
    }

    public Object evaluate(E exchange) {
        return evaluateAs(exchange, resultType);
    }


    // Builder methods
    //-------------------------------------------------------------------------

    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> booleanResult() {
        resultType = XPathConstants.BOOLEAN;
        return this;
    }

    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeResult() {
        resultType = XPathConstants.NODE;
        return this;
    }

    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> nodeSetResult() {
        resultType = XPathConstants.NODESET;
        return this;
    }

    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> numberResult() {
        resultType = XPathConstants.NUMBER;
        return this;
    }

    /**
     * Sets the expression result type to boolean
     *
     * @return the current builder
     */
    public XPathBuilder<E> stringResult() {
        resultType = XPathConstants.STRING;
        return this;
    }

    /**
     * Sets the object model URI to use
     *
     * @return the current builder
     */
    public XPathBuilder<E> objectModel(String uri) {
        this.objectModelUri = uri;
        return this;
    }

    /**
     * Sets the {@link XPathFunctionResolver} instance to use on these XPath expressions
     *
     * @return the current builder
     */
    public XPathBuilder<E> functionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
        return this;
    }

    /**
     * Registers the namespace prefix and URI with the builder so that the prefix can be used in XPath expressions
     *
     * @param prefix is the namespace prefix that can be used in the XPath expressions
     * @param uri is the namespace URI to which the prefix refers
     * @return the current builder
     */
    public XPathBuilder<E> namespace(String prefix, String uri) {
        getNamespaceContext().add(prefix, uri);
        return this;
    }

    /**
     * Registers a variable (in the global namespace) which can be referred to from XPath expressions
     */
    public XPathBuilder<E> variable(String name, Object value) {
        variableResolver.addVariable(name, value);
        return this;
    }


    // Properties
    //-------------------------------------------------------------------------
    public XPathFactory getXPathFactory() throws XPathFactoryConfigurationException {
        if (xpathFactory == null) {
            if (objectModelUri != null) {
                xpathFactory = XPathFactory.newInstance(objectModelUri);
            }
            xpathFactory = XPathFactory.newInstance();
        }
        return xpathFactory;
    }

    public void setXPathFactory(XPathFactory xpathFactory) {
        this.xpathFactory = xpathFactory;
    }

    public Class getDocumentType() {
        return documentType;
    }

    public void setDocumentType(Class documentType) {
        this.documentType = documentType;
    }

    public String getText() {
        return text;
    }

    public QName getResultType() {
        return resultType;
    }

    public DefaultNamespaceContext getNamespaceContext() {
        if (namespaceContext == null) {
            try {
                namespaceContext = new DefaultNamespaceContext(getXPathFactory());
            }
            catch (XPathFactoryConfigurationException e) {
                throw new RuntimeExpressionException(e);
            }
        }
        return namespaceContext;
    }

    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {
        this.namespaceContext = namespaceContext;
    }

    public XPathFunctionResolver getFunctionResolver() {
        return functionResolver;
    }

    public void setFunctionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
    }

    public XPathExpression getExpression() throws XPathFactoryConfigurationException, XPathExpressionException {
        if (expression == null) {
            expression = createXPathExpression();
        }
        return expression;
    }

    public void setNamespacesFromDom(Element node) {
        getNamespaceContext().setNamespacesFromDom(node);        
    }

    // Implementation methods
    //-------------------------------------------------------------------------


    /**
     * Evaluates the expression as the given result type
     */
    protected synchronized Object evaluateAs(E exchange, QName resultType) {
        variableResolver.setExchange(exchange);
        try {
            Object document = getDocument(exchange);
            if (resultType != null) {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource) document;
                    return getExpression().evaluate(inputSource, resultType);
                }
                else {
                    return getExpression().evaluate(document, resultType);
                }
            }
            else {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource) document;
                    return getExpression().evaluate(inputSource);
                }
                else {
                    return getExpression().evaluate(document);
                }
            }
        }
        catch (XPathExpressionException e) {
            throw new InvalidXPathExpression(getText(), e);
        }
        catch (XPathFactoryConfigurationException e) {
            throw new InvalidXPathExpression(getText(), e);
        }
    }

    protected XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {
        XPath xPath = getXPathFactory().newXPath();

        // lets now clear any factory references to avoid keeping them around
        xpathFactory = null;

        xPath.setNamespaceContext(getNamespaceContext());
        xPath.setXPathVariableResolver(variableResolver);
        if (functionResolver != null) {
            xPath.setXPathFunctionResolver(functionResolver);
        }
        return xPath.compile(text);
    }

    /**
     * Strategy method to extract the document from the exchange
     */
    protected Object getDocument(E exchange) {
        Message in = exchange.getIn();
        Class type = getDocumentType();
        Object answer = null;
        if (type != null) {
            answer = in.getBody(type);
        }
        if (answer == null) {
            answer = in.getBody();
        }

        // lets try coerce some common types into something JAXP can deal with
        if (answer instanceof String) {
            answer = new InputSource(new StringReader(answer.toString()));
        }
        return answer;
    }


}
"
org/apache/camel/converter/jaxp/XmlConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;


import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.lang.reflect.Constructor;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.Converter;

/**
 * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}
 *
 * @version $Revision$
 */
@Converter
public class XmlConverter {
    public static final String DEFAULT_CHARSET_PROPERTY = ""org.apache.camel.default.charset"";

    public static String defaultCharset = ObjectHelper.getSystemProperty(DEFAULT_CHARSET_PROPERTY, ""UTF-8"");

    private DocumentBuilderFactory documentBuilderFactory;
    private TransformerFactory transformerFactory;

    /*
     * When converting a DOM tree to a SAXSource,
     * we try to use Xalan internal DOM parser if
     * available.  Else, transform the DOM tree
     * to a String and build a SAXSource on top of
     * it.
     */
    private static final Class dom2SaxClass;

    static {
        Class cl = null;
        try {
            cl = Class.forName(""org.apache.xalan.xsltc.trax.DOM2SAX"");
        } catch (Throwable t) {}
        dom2SaxClass = cl;
    }


    public XmlConverter() {
    }

    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }


    /**
     * Converts the given input Source into the required result
     */
    public void toResult(Source source, Result result) throws TransformerException {
        if (source == null) {
            return;
        }
        Transformer transformer = createTransfomer();
        if (transformer == null) {
            throw new TransformerException(""Could not create a transformer - JAXP is misconfigured!"");
        }
        transformer.setOutputProperty(OutputKeys.ENCODING, defaultCharset);
        transformer.transform(source, result);
    }

    /**
     * Converts the given byte[] to a Source
     */
    @Converter
    public BytesSource toSource(byte[] data) {
        return new BytesSource(data);
    }


    /**
     * Converts the given String to a Source
     */
    @Converter
    public StringSource toSource(String data) {
        return new StringSource(data);
    }

    /**
     * Converts the given Document to a Source
     */
    @Converter
    public DOMSource toSource(Document document) {
        return new DOMSource(document);
    }

    /**
     * Converts the given input Source into text
     */
    @Converter
    public String toString(Source source) throws TransformerException {
        if (source == null) {
            return null;
        } else if (source instanceof StringSource) {
            return ((StringSource) source).getText();
        } else if (source instanceof BytesSource) {
            return new String(((BytesSource) source).getData());
        } else {
            StringWriter buffer = new StringWriter();
            toResult(source, new StreamResult(buffer));
            return buffer.toString();
        }
    }

    /**
     * Converts the given input Node into text
     */
    @Converter
    public String toString(Node node) throws TransformerException {
        return toString(new DOMSource(node));
    }

    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        if (source instanceof DOMSource) {
            return (DOMSource) source;
        }
        else if (source instanceof SAXSource) {
            return toDOMSourceFromSAX((SAXSource) source);
        }
        else if (source instanceof StreamSource) {
            return toDOMSourceFromStream((StreamSource) source);
        }
        else {
            return null;
        }
    }

    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {
        if (source instanceof SAXSource) {
            return (SAXSource) source;
        }
        else if (source instanceof DOMSource) {
            return toSAXSourceFromDOM((DOMSource) source);
        }
        else if (source instanceof StreamSource) {
            return toSAXSourceFromStream((StreamSource) source);
        }
        else {
            return null;
        }
    }

    @Converter
    public StreamSource toStreamSource(Source source) throws TransformerException {
        if (source instanceof StreamSource) {
            return (StreamSource) source;
        } else if (source instanceof DOMSource) {
            return toStreamSourceFromDOM((DOMSource) source);
        } else if (source instanceof SAXSource) {
            return toStreamSourceFromSAX((SAXSource) source);
        } else {
            return null;
        }
    }

    @Converter
    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {
        InputSource inputSource = source.getInputSource();
        if (inputSource != null) {
            if (inputSource.getCharacterStream() != null) {
                return new StreamSource(inputSource.getCharacterStream());
            }
            if (inputSource.getByteStream() != null) {
                return new StreamSource(inputSource.getByteStream());
            }
        }
        String result = toString(source);
        return new StringSource(result);
    }

    @Converter
    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {
        String result = toString(source);
        return new StringSource(result);
    }

    @Converter
    public SAXSource toSAXSourceFromStream(StreamSource source) {
        InputSource inputSource;
        if (source.getReader() != null) {
            inputSource = new InputSource(source.getReader());
        } else {
            inputSource = new InputSource(source.getInputStream());
        }
        inputSource.setSystemId(source.getSystemId());
        inputSource.setPublicId(source.getPublicId());
        return new SAXSource(inputSource);
    }

    @Converter
    public Reader toReaderFromSource(Source src) throws TransformerException {
        StreamSource stSrc = toStreamSource(src);
        Reader r = stSrc.getReader();
        if (r == null) {
            r = new InputStreamReader(stSrc.getInputStream());
        }
        return r;
    }

    @Converter
    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilder builder = createDocumentBuilder();
        String systemId = source.getSystemId();
        Document document = null;
        Reader reader = source.getReader();
        if (reader != null) {
            document = builder.parse(new InputSource(reader));
        } else {
            InputStream inputStream = source.getInputStream();
            if (inputStream != null) {
                InputSource inputsource = new InputSource(inputStream);
                inputsource.setSystemId(systemId);
                document = builder.parse(inputsource);
            }
            else {
                throw new IOException(""No input stream or reader available"");
            }
        }
        return new DOMSource(document, systemId);
    }

    @Converter
    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {
        if (dom2SaxClass != null) {
            try {
                Constructor cns = dom2SaxClass.getConstructor(new Class[] { Node.class });
                XMLReader converter = (XMLReader) cns.newInstance(new Object[] { source.getNode() });
                return new SAXSource(converter, new InputSource());
            } catch (Exception e) {
                throw new TransformerException(e);
            }
        } else {
            String str = toString(source);
            StringReader reader = new StringReader(str);
            return new SAXSource(new InputSource(reader));
        }
    }

    @Converter
    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {
        return new DOMSource(toDOMNodeFromSAX(source));
    }

    @Converter
    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        DOMResult result = new DOMResult();
        toResult(source, result);
        return result.getNode();
    }

    /**
     * Converts the given TRaX Source into a W3C DOM node
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     */
    @Converter
    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        DOMSource domSrc = toDOMSource(source);
        return domSrc != null ? domSrc.getNode() :  null;
    }

    /**
     * Create a DOM element from the given source.
     *
     * @param source
     * @return
     * @throws TransformerException
     * @throws ParserConfigurationException
     * @throws IOException
     * @throws SAXException
     */
    @Converter
    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMElement(node);
    }

    /**
     * Create a DOM element from the DOM node.
     * Simply cast if the node is an Element, or
     * return the root element if it is a Document.
     *
     * @param node
     * @return
     * @throws TransformerException
     */
    @Converter
    public Element toDOMElement(Node node) throws TransformerException {
        // If the node is an document, return the root element
        if (node instanceof Document) {
            return ((Document) node).getDocumentElement();
        // If the node is an element, just cast it
        } else if (node instanceof Element) {
            return (Element) node;
        // Other node types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to an Element"");
        }
    }

    /**
     * Converts the given data to a DOM document
     *
     * @param data is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(new ByteArrayInputStream(data));
    }

    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }

    /**
     * Converts the given {@link InputSource} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }

    /**
     * Converts the given {@link String} to a DOM document
     *
     * @param text is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(text.getBytes());
    }

    /**
     * Converts the given {@link File} to a DOM document
     *
     * @param file is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(file);
    }


    /**
     * Create a DOM document from the given source.
     *
     * @param source
     * @return
     * @throws TransformerException
     * @throws ParserConfigurationException
     * @throws IOException
     * @throws SAXException
     */
    @Converter
    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMDocument(node);
    }

    /**
     * Create a DOM document from the given Node.
     * If the node is an document, just cast it,
     * if the node is an root element, retrieve its
     * owner element or create a new document and import
     * the node.
     *
     * @param node
     * @return
     * @throws ParserConfigurationException
     * @throws TransformerException
     */
    @Converter
    public Document toDOMDocument(Node node) throws ParserConfigurationException, TransformerException {
        // If the node is the document, just cast it
        if (node instanceof Document) {
            return (Document) node;
        // If the node is an element
        } else if (node instanceof Element) {
            Element elem = (Element) node;
            // If this is the root element, return its owner document
            if (elem.getOwnerDocument().getDocumentElement() == elem) {
                return elem.getOwnerDocument();
            // else, create a new doc and copy the element inside it
            } else {
                Document doc = createDocument();
                doc.appendChild(doc.importNode(node, true));
                return doc;
            }
        // other element types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to a Document"");
        }
    }

    // Properties
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory getDocumentBuilderFactory() {
        if (documentBuilderFactory == null) {
            documentBuilderFactory = createDocumentBuilderFactory();
        }
        return documentBuilderFactory;
    }

    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }


    // Helper methods
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory createDocumentBuilderFactory() {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setIgnoringElementContentWhitespace(true);
        factory.setIgnoringComments(true);
        return factory;
    }


    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = getDocumentBuilderFactory();
        return factory.newDocumentBuilder();
    }

    public Document createDocument() throws ParserConfigurationException {
        DocumentBuilder builder = createDocumentBuilder();
        return builder.newDocument();
    }

    public TransformerFactory getTransformerFactory() {
        if (transformerFactory == null) {
            transformerFactory = createTransformerFactory();
        }
        return transformerFactory;
    }

    public void setTransformerFactory(TransformerFactory transformerFactory) {
        this.transformerFactory = transformerFactory;
    }

    public Transformer createTransfomer() throws TransformerConfigurationException {
        TransformerFactory factory = getTransformerFactory();
        return factory.newTransformer();
    }

    public TransformerFactory createTransformerFactory() {
        TransformerFactory answer = TransformerFactory.newInstance();
        return answer;
    }

}"
org/apache/camel/NoSuchEndpointException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import org.apache.camel.processor.RecipientList;

/**
 * A runtime exception thrown if a routing processor such as a {@link RecipientList} is unable to resolve
 * an {@link Endpoint} from a URI.
 *
 * @version $Revision$
 */
public class NoSuchEndpointException extends RuntimeCamelException {
	private static final long serialVersionUID = -8721487431101572630L;
	private final String uri;

    public NoSuchEndpointException(String uri) {
        super(""No endpoint could be found for: "" + uri);
        this.uri = uri;
    }

    public String getUri() {
        return uri;
    }
}
"
org/apache/camel/impl/NoRouteBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.builder.RouteBuilder;

/**
 * A helper class, usually used for testing which does not create any routes.
 *
 * @version $Revision: 1.1 $
 */
public class NoRouteBuilder extends RouteBuilder {
    private static final NoRouteBuilder instance = new NoRouteBuilder();

    public static NoRouteBuilder getInstance() {
        return instance;
    }

    public void configure() throws Exception {
    }
}
"
org/apache/camel/Body.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Marks a parameter as being the body of an inbound {@link Message}
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Body {
}
"
org/apache/camel/impl/DefaultExchangeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Exchange;
import org.apache.camel.spi.ExchangeConverter;

/**
 * @version $Revision$
 */
public class DefaultExchangeConverter implements ExchangeConverter {
    public <T> T convertTo(Class<T> type, Exchange exchange) {
        // TODO use some kinda introspection to find available exchange conversions
        return null;
    }
}
"
org/apache/camel/builder/ChoiceBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.util.ArrayList;
import java.util.List;

import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.FilterProcessor;

/**
 * @version $Revision$
 */
public class ChoiceBuilder extends FromBuilder {

    private final FromBuilder parent;
    private List<WhenBuilder> predicateBuilders = new ArrayList<WhenBuilder>();
    private FromBuilder otherwise;

    public ChoiceBuilder(FromBuilder parent) {
        super(parent);
        this.parent = parent;
    }

    /**
     * Adds a predicate which if it is true then the message exchange is sent to the given destination
     *
     * @return a builder for creating a when predicate clause and action
     */
    @Fluent(nestedActions=true)
    public WhenBuilder when(
    		@FluentArg(value=""predicate"",element=true) 
    		Predicate predicate) {
        WhenBuilder answer = new WhenBuilder(this, predicate);
        predicateBuilders.add(answer);
        return answer;
    }

    @Fluent(nestedActions=true)
    public FromBuilder otherwise() {
        this.otherwise = new FromBuilder(parent);
        return otherwise;
    }

    public List<WhenBuilder> getPredicateBuilders() {
        return predicateBuilders;
    }

    public FromBuilder getOtherwise() {
        return otherwise;
    }

    @Override
    public Processor createProcessor() throws Exception {
        List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
        for (WhenBuilder predicateBuilder : predicateBuilders) {
            filters.add(predicateBuilder.createProcessor());
        }
        Processor otherwiseProcessor = null;
        if (otherwise != null) {
            otherwiseProcessor = otherwise.createProcessor();
        }
        return new ChoiceProcessor(filters, otherwiseProcessor);
    }
}
"
org/apache/camel/converter/NIOConverter.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;

import org.apache.camel.Converter;

import java.io.*;
import java.nio.ByteBuffer;

/**
 * Some core java.nio based 
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public class NIOConverter {

    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        return buffer.array();
    }

    @Converter
    public static ByteBuffer toByteBuffer(byte[] data) {
        return ByteBuffer.wrap(data);
    }
    
    @Converter
    public static ByteBuffer toByteBuffer(String value) {
        ByteBuffer buf = ByteBuffer.allocate(value.length());
        byte[] bytes = value.getBytes();
        buf.put(bytes);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Long value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putLong(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Float value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putFloat(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Double value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putDouble(value);
        return buf;
    }
}
"
org/apache/camel/Service.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Represents the core lifecycle API for POJOs which can be started and stopped
 *
 * @version $Revision$
 */
public interface Service {

    /**
     * Starts the service
     *
     * @throws Exception
     */
    void start() throws Exception;

    /**
     * Stops the service
     *
     * @throws Exception
     */
    void stop() throws Exception;
}
"
org/apache/camel/impl/EventDrivenConsumerRoute.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Route;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;

import java.util.List;

/**
 * A {@link Route} which starts with an
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
 *
 * @version $Revision: 1.1 $
 */
public class EventDrivenConsumerRoute<E extends Exchange> extends Route<E> {
    private Processor processor;

    public EventDrivenConsumerRoute(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }

    @Override
    public String toString() {
        return ""EventDrivenConsumerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
    }

    public Processor getProcessor() {
        return processor;
    }

    public void setProcessor(Processor processor) {
        this.processor = processor;
    }

    /**
     * Factory method to lazily create the complete list of services required for this route
     * such as adding the processor or consumer
     */
    protected void addServices(List<Service> services) throws Exception {
        Processor processor = getProcessor();
        if (processor instanceof Service) {
            Service service = (Service) processor;
            services.add(service);
        }
        Endpoint<E> endpoint = getEndpoint();
        Consumer<E> consumer = endpoint.createConsumer(processor);
        if (consumer != null) {
            services.add(consumer);
        }
    }
}
"
org/apache/camel/processor/LoggingErrorHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * An {@link ErrorHandler} which uses commons-logging to dump the error
 *
 * @version $Revision$
 */
public class LoggingErrorHandler extends ServiceSupport implements ErrorHandler {
    private Processor output;
    private Log log;
    private LoggingLevel level;

    public LoggingErrorHandler(Processor output) {
        this(output, LogFactory.getLog(LoggingErrorHandler.class), LoggingLevel.INFO);
    }

    public LoggingErrorHandler(Processor output, Log log, LoggingLevel level) {
        this.output = output;
        this.log = log;
        this.level = level;
    }

    @Override
    public String toString() {
        return ""LoggingErrorHandler["" + output + ""]"";
    }

    public void process(Exchange exchange) throws Exception {
        try {
            output.process(exchange);
        }
        catch (RuntimeException e) {
            logError(exchange, e);
        }
    }

    // Properties
    //-------------------------------------------------------------------------

    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }

    public LoggingLevel getLevel() {
        return level;
    }

    public void setLevel(LoggingLevel level) {
        this.level = level;
    }

    public Log getLog() {
        return log;
    }

    public void setLog(Log log) {
        this.log = log;
    }

    // Implementation methods
    //-------------------------------------------------------------------------
    protected void logError(Exchange exchange, RuntimeException e) {
        switch (level) {
            case DEBUG:
                if (log.isDebugEnabled()) {
                    log.debug(logMessage(exchange, e), e);
                }
                break;
            case ERROR:
                if (log.isErrorEnabled()) {
                    log.error(logMessage(exchange, e), e);
                }
                break;
            case FATAL:
                if (log.isFatalEnabled()) {
                    log.fatal(logMessage(exchange, e), e);
                }
                break;
            case INFO:
                if (log.isInfoEnabled()) {
                    log.debug(logMessage(exchange, e), e);
                }
                break;
            case TRACE:
                if (log.isTraceEnabled()) {
                    log.trace(logMessage(exchange, e), e);
                }
                break;
            case WARN:
                if (log.isWarnEnabled()) {
                    log.warn(logMessage(exchange, e), e);
                }
                break;
            default:
                log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange, e), e);
        }
    }

    protected Object logMessage(Exchange exchange, RuntimeException e) {
        return e + "" while processing exchange: "" + exchange;
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(output);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(output);
    }
}
"
org/apache/camel/processor/RecipientList.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExchangeHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.apache.camel.util.ProducerCache;

import java.util.Iterator;

/**
 * Implements a dynamic <a href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a> pattern
 * where the list of actual endpoints to send a message exchange to are dependent on some dynamic expression.
 *
 * @version $Revision$
 */
public class RecipientList extends ServiceSupport implements Processor {
    private final Expression<Exchange> expression;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();

    public RecipientList(Expression<Exchange> expression) {
        notNull(expression, ""expression"");
        this.expression = expression;
    }

    @Override
    public String toString() {
        return ""RecipientList["" + expression + ""]"";
    }

    public void process(Exchange exchange) throws Exception {
        Object receipientList = expression.evaluate(exchange);
        Iterator iter = ObjectConverter.iterator(receipientList);
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, recipient);
            producerCache.getProducer(endpoint).process(exchange);
        }
    }

    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }

    protected void doStop() throws Exception {
        producerCache.stop();
    }

    protected void doStart() throws Exception {
    }
}
"
org/apache/camel/impl/converter/AnnotationTypeConverterLoader.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.Converter;
import org.apache.camel.impl.CachingInjector;
import org.apache.camel.util.ResolverUtil;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import static java.lang.reflect.Modifier.*;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

/**
 * A class which will auto-discover converter objects and methods to pre-load
 * the registry of converters on startup
 *
 * @version $Revision$
 */
public class AnnotationTypeConverterLoader implements TypeConverterLoader {
    public static final String META_INF_SERVICES = ""META-INF/services/org/apache/camel/TypeConverter"";
    private static final transient Log log = LogFactory.getLog(AnnotationTypeConverterLoader.class);
    private ResolverUtil resolver = new ResolverUtil();
    private Set<Class> visitedClasses = new HashSet<Class>();

    public void load(TypeConverterRegistry registry) throws Exception {
        String[] packageNames = findPackageNames();
        resolver.findAnnotated(Converter.class, packageNames);
        Set<Class> classes = resolver.getClasses();
        for (Class type : classes) {
            if (log.isDebugEnabled()) {
                log.debug(""Loading converter class: "" + ObjectHelper.name(type));
            }
            loadConverterMethods(registry, type);
        }
    }

    /**
     * Finds the names of the packages to search for on the classpath looking for text files on the classpath
     * at the  @{link #META_INF_SERVICES} location
     *
     * @return a collection of packages to search for
     * @throws IOException
     */
    protected String[] findPackageNames() throws IOException {
        Set<String> packages = new HashSet<String>();
        findPackages(packages, Thread.currentThread().getContextClassLoader());
        findPackages(packages, getClass().getClassLoader());
        return packages.toArray(new String[packages.size()]);
    }

    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {
        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);
        while (resources.hasMoreElements()) {
            URL url = resources.nextElement();
            if (url != null) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                try {
                    while (true) {
                        String line = reader.readLine();
                        if (line == null) {
                            break;
                        }
                        line = line.trim();
                        if (line.startsWith(""#"") || line.length() == 0) {
                            continue;
                        }
                        tokenize(packages, line);
                    }
                }
                finally {
                    try {
                        reader.close();
                    }
                    catch (IOException e) {
                        log.warn(""Caught exception closing stream: "" + e, e);
                    }
                }
            }
        }
    }

    /**
     * Tokenizes the line from the META-IN/services file using commas and ignoring whitespace between packages
     */
    protected void tokenize(Set<String> packages, String line) {
        StringTokenizer iter = new StringTokenizer(line, "","");
        while (iter.hasMoreTokens()) {
            String name = iter.nextToken().trim();
            if (name.length() > 0) {
                packages.add(name);
            }
        }
    }

    /**
     * Loads all of the converter methods for the given type
     */
    protected void loadConverterMethods(TypeConverterRegistry registry, Class type) {
        if (visitedClasses.contains(type)) {
            return;
        }
        visitedClasses.add(type);
        Method[] methods = type.getDeclaredMethods();
        CachingInjector injector = null;

        for (Method method : methods) {
            Converter annotation = method.getAnnotation(Converter.class);
            if (annotation != null) {
                Class<?>[] parameterTypes = method.getParameterTypes();
                if (parameterTypes == null || parameterTypes.length != 1) {
                    log.warn(""Ignoring bad converter on type: "" + type.getName()
                            + "" method: "" + method + "" as a converter method should have one parameter"");
                }
                else {
                    int modifiers = method.getModifiers();
                    if (isAbstract(modifiers) || !isPublic(modifiers)) {
                        log.warn(""Ignoring bad converter on type: "" + type.getName()
                                + "" method: "" + method + "" as a converter method is not a public and concrete method"");
                    }
                    else {
                        Class toType = method.getReturnType();
                        if (toType.equals(Void.class)) {
                            log.warn(""Ignoring bad converter on type: "" + type.getName()
                                    + "" method: "" + method + "" as a converter method returns a void method"");
                        }
                        else {
                            Class fromType = parameterTypes[0];
                            if (isStatic(modifiers)) {
                                registry.addTypeConverter(toType, fromType, new StaticMethodTypeConverter(method));
                            }
                            else {
                                if (injector == null) {
                                    injector = new CachingInjector(registry, type);
                                }
                                registry.addTypeConverter(toType, fromType, new InstanceMethodTypeConverter(injector, method));
                            }
                        }
                    }
                }
            }
        }
        Class superclass = type.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            loadConverterMethods(registry, superclass);
        }
    }
}
"
org/apache/camel/converter/HasAnnotation.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Used to indicate that the actual type of a parameter on a converter method must have the given annotation class
 * to be applicable. e.g. this annotation could be used on a JAXB converter which only applies to objects with a
 * JAXB annotation on them
 *
 * @version $Revision$
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface HasAnnotation {

    Class value();
}
"
org/apache/camel/processor/ErrorHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * An interface used to represent an error handler
 *
 * @version $Revision$
 */
public interface ErrorHandler extends Processor {
}
"
org/apache/camel/impl/BinaryPredicateSupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Predicate;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;

/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision: 1.1 $
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {

    private final Expression<E> left;
    private final Expression<E> right;

    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");

        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }

    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }

    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }

    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);

    protected abstract String getOperationText();

    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <"" + rightValue + "">"";
    }
}
"
org/apache/camel/spi/Unmarshaller.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import java.io.IOException;
import java.io.InputStream;

/**
 * @version $Revision: 520124 $
 */
public interface Unmarshaller {
	
	/**
     * Unmarshals the given stream into an object.
     */
    Object unmarshal(InputStream stream) throws IOException;

}
"
org/apache/camel/component/pojo/PojoComponent.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.spi.Provider;
import org.apache.camel.impl.DefaultComponent;

/**
 * Represents the component that manages {@link PojoEndpoint}.  It holds the
 * list of named pojos that queue endpoints reference.
 *
 * @version $Revision: 519973 $
 */
public class PojoComponent extends DefaultComponent<PojoExchange> {
    protected final HashMap<String, Object> services = new HashMap<String, Object>();

    public void addService(String uri, Object pojo) {
        services.put(uri, pojo);
    }

    public void removeService(String uri) {
        services.remove(uri);
    }

    public Object getService(String uri) {
        return services.get(uri);
    }

    @Override
    protected Endpoint<PojoExchange> createEndpoint(String uri, final String remaining, Map parameters) throws Exception {
        Object pojo = getService(remaining);
        return new PojoEndpoint(uri, this, pojo);
    }
    
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * @throws Exception 
     */
    static public Object createProxy(final Endpoint endpoint, ClassLoader cl, Class interfaces[]) throws Exception {
    	final Producer producer = endpoint.createProducer();
        return Proxy.newProxyInstance(cl, interfaces, new InvocationHandler() {        	
        	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                PojoInvocation invocation = new PojoInvocation(proxy, method, args);
                PojoExchange exchange = new PojoExchange(endpoint.getContext());                
                exchange.setInvocation(invocation);
                producer.process(exchange);                
                Throwable fault = exchange.getException();
                if (fault != null) {
                    throw new InvocationTargetException(fault);
                }
                return exchange.getOut().getBody();
        	}
        });
    }
    
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * @throws Exception 
     */
    static public Object createProxy(Endpoint endpoint, Class interfaces[]) throws Exception {
    	if( interfaces.length < 1 ) {
    		throw new IllegalArgumentException(""You must provide at least 1 interface class."");
    	}
        return createProxy(endpoint, interfaces[0].getClassLoader(), interfaces);
    }    
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * @throws Exception 
     */
    @SuppressWarnings(""unchecked"")
	static public <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class<T> interfaceClass) throws Exception {
        return (T) createProxy(endpoint, cl, new Class[]{interfaceClass});
    }
    
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * @throws Exception 
     */
    @SuppressWarnings(""unchecked"")
	static public <T> T createProxy(Endpoint endpoint, Class<T> interfaceClass) throws Exception {
        return (T) createProxy(endpoint, new Class[]{interfaceClass});
    }



}
"
org/apache/camel/builder/xml/StreamResultHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Message;

import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayOutputStream;

/**
 * Processes the XSLT result as a byte[]
 *
 * @version $Revision: 1.1 $
 */
public class StreamResultHandler implements ResultHandler {
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    StreamResult result = new StreamResult(buffer);

    public Result getResult() {
        return result;
    }

    public void setBody(Message in) {
        in.setBody(buffer.toByteArray());
    }
}
"
org/apache/camel/processor/loadbalancer/TopicLoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.Pipeline;

import java.util.List;

/**
 * A {@link LoadBalancer} implementations which sends to all destinations (rather like JMS Topics)
 *
 * @version $Revision: 1.1 $
 */
public class TopicLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        for (Processor processor : list) {
            Exchange copy = copyExchangeStrategy(processor, exchange);
            processor.process(copy);
        }
    }

    /**
     * Strategy method to copy the exchange before sending to another endpoint. Derived classes such as the
     * {@link Pipeline} will not clone the exchange
     *
     * @param processor the processor that will send the exchange
     * @param exchange @return the current exchange if no copying is required such as for a pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {
        return exchange.copy();
    }
}
"
org/apache/camel/builder/xml/StringResultHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Message;

import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.Result;
import java.io.StringWriter;

/**
 * Processes the XSLT result as a String
 *
 * @version $Revision: 1.1 $
 */
public class StringResultHandler implements ResultHandler {
    StringWriter buffer = new StringWriter();
    StreamResult result = new StreamResult(buffer);

    public Result getResult() {
        return result;
    }

    public void setBody(Message in) {
        in.setBody(buffer.toString());
    }
}
"
org/apache/camel/Predicate.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Evaluates a binary <a href=""http://activemq.apache.org/camel/predicate.html"">predicate</a>
 * on the message exchange to support things like
 * <a href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting languages</a>,
 * <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well
 * as any arbitrary Java expression.
 *
 * @version $Revision$
 */
public interface Predicate<E> {

    /**
     * Evaluates the predicate on the message exchange and returns true
     * if this exchange matches the predicate
     *
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(E exchange);

    /**
     * Allows this predicate to be used nicely in testing to generate
     * a nicely formatted exception and message if this predicate does not
     * match for the given exchange.
     *
     * @param text the description to use in the exception message
     * @param exchange the exchange to evaluate the expression on
     * @throws AssertionError if the predicate does not match
     */
    void assertMatches(String text, E exchange) throws AssertionError;

}
"
org/apache/camel/util/ResolverUtil.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.lang.annotation.Annotation;
import java.util.Set;
import java.util.HashSet;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.net.URL;
import java.net.URLDecoder;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

/**
 * <p>ResolverUtil is used to locate classes that are available in the/a class path and meet
 * arbitrary conditions. The two most common conditions are that a class implements/extends
 * another class, or that is it annotated with a specific annotation. However, through the use
 * of the {@link Test} class it is possible to search using arbitrary conditions.</p>
 *
 * <p>A ClassLoader is used to locate all locations (directories and jar files) in the class
 * path that contain classes within certain packages, and then to load those classes and
 * check them. By default the ClassLoader returned by
 *  {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden
 * by calling {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()}
 * methods.</p>
 *
 * <p>General searches are initiated by calling the
 * {@link #find(ResolverUtil.Test, String)} ()} method and supplying
 * a package name and a Test instance. This will cause the named package <b>and all sub-packages</b>
 * to be scanned for classes that meet the test. There are also utility methods for the common
 * use cases of scanning multiple packages for extensions of particular classes, or classes
 * annotated with a specific annotation.</p>
 *
 * <p>The standard usage pattern for the ResolverUtil class is as follows:</p>
 *
 *<pre>
 *ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();
 *resolver.findImplementation(ActionBean.class, pkg1, pkg2);
 *resolver.find(new CustomTest(), pkg1);
 *resolver.find(new CustomTest(), pkg2);
 *Collection&lt;ActionBean&gt; beans = resolver.getClasses();
 *</pre>
 *
 * @author Tim Fennell
 */
public class ResolverUtil<T> {
    private static final transient Log log = LogFactory.getLog(ResolverUtil.class);

    /**
     * A simple interface that specifies how to test classes to determine if they
     * are to be included in the results produced by the ResolverUtil.
     */
    public static interface Test {
        /**
         * Will be called repeatedly with candidate classes. Must return True if a class
         * is to be included in the results, false otherwise.
         */
        boolean matches(Class type);
    }

    /**
     * A Test that checks to see if each class is assignable to the provided class. Note
     * that this test will match the parent type itself if it is presented for matching.
     */
    public static class IsA implements Test {
        private Class parent;

        /** Constructs an IsA test using the supplied Class as the parent class/interface. */
        public IsA(Class parentType) { this.parent = parentType; }

        /** Returns true if type is assignable to the parent type supplied in the constructor. */
        public boolean matches(Class type) {
            return type != null && parent.isAssignableFrom(type);
        }

        @Override public String toString() {
            return ""is assignable to "" + parent.getSimpleName();
        }
    }

    /**
     * A Test that checks to see if each class is annotated with a specific annotation. If it
     * is, then the test returns true, otherwise false.
     */
    public static class AnnotatedWith implements Test {
        private Class<? extends Annotation> annotation;

        /** Construts an AnnotatedWith test for the specified annotation type. */
        public AnnotatedWith(Class<? extends Annotation> annotation) { this.annotation = annotation; }

        /** Returns true if the type is annotated with the class provided to the constructor. */
        public boolean matches(Class type) {
            return type != null && type.isAnnotationPresent(annotation);
        }

        @Override public String toString() {
            return ""annotated with @"" + annotation.getSimpleName();
        }
    }

    /** The set of matches being accumulated. */
    private Set<Class<? extends T>> matches = new HashSet<Class<?extends T>>();

    /**
     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned
     * by Thread.currentThread().getContextClassLoader() will be used.
     */
    private ClassLoader classloader;

    /**
     * Provides access to the classes discovered so far. If no calls have been made to
     * any of the {@code find()} methods, this set will be empty.
     *
     * @return the set of classes that have been discovered.
     */
    public Set<Class<? extends T>> getClasses() {
        return matches;
    }

    /**
     * Returns the classloader that will be used for scanning for classes. If no explicit
     * ClassLoader has been set by the calling, the context class loader will be used.
     *
     * @return the ClassLoader that will be used to scan for classes
     */
    public ClassLoader getClassLoader() {
        return classloader == null ? Thread.currentThread().getContextClassLoader() : classloader;
    }

    /**
     * Sets an explicit ClassLoader that should be used when scanning for classes. If none
     * is set then the context classloader will be used.
     *
     * @param classloader a ClassLoader to use when scanning for classes
     */
    public void setClassLoader(ClassLoader classloader) { this.classloader = classloader; }

    /**
     * Attempts to discover classes that are assignable to the type provided. In the case
     * that an interface is provided this method will collect implementations. In the case
     * of a non-interface class, subclasses will be collected.  Accumulated classes can be
     * accessed by calling {@link #getClasses()}.
     *
     * @param parent the class of interface to find subclasses or implementations of
     * @param packageNames one or more package names to scan (including subpackages) for classes
     */
    public void findImplementations(Class parent, String... packageNames) {
        if (packageNames == null) return;

        Test test = new IsA(parent);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
    }

    /**
     * Attempts to discover classes that are annotated with to the annotation. Accumulated
     * classes can be accessed by calling {@link #getClasses()}.
     *
     * @param annotation the annotation that should be present on matching classes
     * @param packageNames one or more package names to scan (including subpackages) for classes
     */
    public void findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {
        if (packageNames == null) return;

        Test test = new AnnotatedWith(annotation);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
    }

    /**
     * Scans for classes starting at the package provided and descending into subpackages.
     * Each class is offered up to the Test as it is discovered, and if the Test returns
     * true the class is retained.  Accumulated classes can be fetched by calling
     * {@link #getClasses()}.
     *
     * @param test an instance of {@link Test} that will be used to filter classes
     * @param packageName the name of the package from which to start scanning for
     *        classes, e.g. {@code net.sourceforge.stripes}
     */
    public void find(Test test, String packageName) {
        packageName = packageName.replace('.', '/');
        ClassLoader loader = getClassLoader();
        Enumeration<URL> urls;

        try {
            urls = loader.getResources(packageName);
        }
        catch (IOException ioe) {
            log.warn(""Could not read package: "" + packageName, ioe);
            return;
        }

        while (urls.hasMoreElements()) {
            try {
                String urlPath = urls.nextElement().getFile();
                urlPath = URLDecoder.decode(urlPath, ""UTF-8"");

                // If it's a file in a directory, trim the stupid file: spec
                if ( urlPath.startsWith(""file:"") ) {
                    urlPath = urlPath.substring(5);
                }

                // Else it's in a JAR, grab the path to the jar
                if (urlPath.indexOf('!') > 0) {
                    urlPath = urlPath.substring(0, urlPath.indexOf('!'));
                }

                log.debug(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
                File file = new File(urlPath);
                if ( file.isDirectory() ) {
                    loadImplementationsInDirectory(test, packageName, file);
                }
                else {
                    loadImplementationsInJar(test, packageName, file);
                }
            }
            catch (IOException ioe) {
                log.warn(""could not read entries"", ioe);
            }
        }
    }


    /**
     * Finds matches in a physical directory on a filesystem.  Examines all
     * files within a directory - if the File object is not a directory, and ends with <i>.class</i>
     * the file is loaded and tested to see if it is acceptable according to the Test.  Operates
     * recursively to find classes within a folder structure matching the package structure.
     *
     * @param test a Test used to filter the classes that are discovered
     * @param parent the package name up to this directory in the package hierarchy.  E.g. if
     *        /classes is in the classpath and we wish to examine files in /classes/org/apache then
     *        the values of <i>parent</i> would be <i>org/apache</i>
     * @param location a File object representing a directory
     */
    private void loadImplementationsInDirectory(Test test, String parent, File location) {
        File[] files = location.listFiles();
        StringBuilder builder = null;

        for (File file : files) {
            builder = new StringBuilder(100);
            builder.append(parent).append(""/"").append(file.getName());
            String packageOrClass = ( parent == null ? file.getName() : builder.toString() );

            if (file.isDirectory()) {
                loadImplementationsInDirectory(test, packageOrClass, file);
            }
            else if (file.getName().endsWith("".class"")) {
                addIfMatching(test, packageOrClass);
            }
        }
    }

    /**
     * Finds matching classes within a jar files that contains a folder structure
     * matching the package structure.  If the File is not a JarFile or does not exist a warning
     * will be logged, but no error will be raised.
     *
     * @param test a Test used to filter the classes that are discovered
     * @param parent the parent package under which classes must be in order to be considered
     * @param jarfile the jar file to be examined for classes
     */
    private void loadImplementationsInJar(Test test, String parent, File jarfile) {

        try {
            JarEntry entry;
            JarInputStream jarStream = new JarInputStream(new FileInputStream(jarfile));

            while ( (entry = jarStream.getNextJarEntry() ) != null) {
                String name = entry.getName();
                if (!entry.isDirectory() && name.startsWith(parent) && name.endsWith("".class"")) {
                    addIfMatching(test, name);
                }
            }
        }
        catch (IOException ioe) {
            log.error(""Could not search jar file '"" + jarfile + ""' for classes matching criteria: "" +
                      test + ""due to an IOException: "" + ioe.getMessage());
        }
    }

    /**
     * Add the class designated by the fully qualified class name provided to the set of
     * resolved classes if and only if it is approved by the Test supplied.
     *
     * @param test the test used to determine if the class matches
     * @param fqn the fully qualified name of a class
     */
    protected void addIfMatching(Test test, String fqn) {
        try {
            String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            ClassLoader loader = getClassLoader();
            log.trace(""Checking to see if class "" + externalName + "" matches criteria ["" + test+ ""]"");

            Class type = loader.loadClass(externalName);
            if (test.matches(type) ) {
                matches.add( (Class<T>) type);
            }
        }
        catch (Throwable t) {
            log.warn(""Could not examine class '""+ fqn + ""' due to a "" +
                     t.getClass().getName()+ "" with message: "" + t.getMessage());
        }
    }
}
"
org/apache/camel/Property.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Marks a parameter as being a property on an {@link Exchange}
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Property {
    String name();
}
"
org/apache/camel/impl/NoPolicy.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.spi.Policy;
import org.apache.camel.Processor;

/**
 * Represents an {@link Policy} which adds no interceptors.
 *
 * @version $Revision: 1.1 $
 */
public class NoPolicy<E> implements Policy<E> {

    public Processor wrap(Processor processor) {
        return processor;
    }
}
"
org/apache/camel/util/ServiceHelper.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Service;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Collection;

/**
 * A collection of helper methods for working with {@link Service} objects
 *
 * @version $Revision$
 */
public class ServiceHelper {
    private static final transient Log log = LogFactory.getLog(ServiceHelper.class);


    /**
     * Starts all of the given services
     */
    public static void startServices(Object... services) throws Exception {
        for (Object value : services) {
            startService(value);
        }
    }

    /**
     * Starts all of the given services
     */
    public static void startServices(Collection services) throws Exception {
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service) value;
                service.start();
            }
        }
    }

    public static void startService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service) value;
            service.start();
        }
        else if (value instanceof Collection) {
            startServices((Collection) value);
        }
    }

    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Object... services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service) value;
                try {
                    service.stop();
                }
                catch (Exception e) {
                    log.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Collection services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service) value;
                try {
                    service.stop();
                }
                catch (Exception e) {
                    log.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
}
"
org/apache/camel/component/processor/ProcessorEndpointConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;

/**
 * @version $Revision: 1.1 $
*/
public class ProcessorEndpointConsumer extends DefaultConsumer<Exchange> {
    private final ProcessorEndpoint endpoint;

    public ProcessorEndpointConsumer(ProcessorEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }

    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.getLoadBalancer().addProcessor(getProcessor());
    }

    @Override
    protected void doStop() throws Exception {
        endpoint.getLoadBalancer().removeProcessor(getProcessor());
        super.doStop();
    }
}
"
org/apache/camel/impl/DefaultEndpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.util.ObjectHelper;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;

/**
 * A default endpoint useful for implementation inheritance
 *
 * @version $Revision$
 */
public abstract class DefaultEndpoint<E extends Exchange> implements Endpoint<E> {
    private String endpointUri;
    private final Component component;
    private CamelContext context;
    private ScheduledExecutorService executorService;

    protected DefaultEndpoint(String endpointUri, Component component) {
        this.endpointUri = endpointUri;
        this.component = component;
        this.context = component.getCamelContext();
    }

    public int hashCode() {
        return endpointUri.hashCode() * 37 + 1;
    }

    @Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint) object;
            return ObjectHelper.equals(this.endpointUri, that.endpointUri);
        }
        return false;
    }

    @Override
    public String toString() {
        return ""Endpoint["" + endpointUri + ""]"";
    }

    public String getEndpointUri() {
        return endpointUri;
    }

    public CamelContext getContext() {
        return context;
    }

    public Component getComponent() {
        return component;
    }

    /**
     * @return the executor
     */
    public synchronized ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            Component c = getComponent();
            if (c != null && c instanceof DefaultComponent) {
                DefaultComponent dc = (DefaultComponent) c;
                executorService = dc.getExecutorService();
            }
            if (executorService == null) {
                executorService = createExecutorService();
            }
        }
        return executorService;
    }

    /**
     * @param executorService the executor to set
     */
    public synchronized void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }

    public PollingConsumer<E> createPollingConsumer() throws Exception {
        return new DefaultPollingConsumer<E>(this);
    }

    /**
     * Converts the given exchange to the specified exchange type
     */
    public E convertTo(Class<E> type, Exchange exchange) {
        // TODO we could infer type parameter
        if (type.isInstance(exchange)) {
            return type.cast(exchange);
        }
        return getContext().getExchangeConverter().convertTo(type, exchange);
    }

    public E createExchange(Exchange exchange) {
        Class<E> exchangeType = getExchangeType();
        if (exchangeType != null) {
            if (exchangeType.isInstance(exchange)) {
                return exchangeType.cast(exchange);
            }
        }
        E answer = createExchange();
        answer.copyFrom(exchange);
        return answer;
    }

    public E toExchangeType(Exchange exchange) {
        // TODO avoid cloning exchanges if E == Exchange!
        return createExchange(exchange);
    }

    /**
     * Returns the type of the exchange which is generated by this component
     */
    public Class<E> getExchangeType() {
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    return (Class<E>) argumentType;
                }
            }
        }
        return null;
    }

    protected ScheduledThreadPoolExecutor createExecutorService() {
        return new ScheduledThreadPoolExecutor(10);
    }
}
"
org/apache/camel/Component.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;


/**
 * A <a href=""http://activemq.apache.org/camel/component.html"">component</a> is a factory of {@link Endpoint} objects.
 *
 * @version $Revision: 519901 $
 */
public interface Component<E extends Exchange>  {
    
    /**
     * Returns the context
     *
     * @return the context of this component
     */
    CamelContext getCamelContext();

    /**
     * The {@link CamelContext} is injected into the component when it is added to it
     */
    void setCamelContext(CamelContext context);

    /**
     * Attempt to resolve an endpoint for the given URI if the component is capable of handling the URI
     *
     * @param uri the URI to create
     * @return a newly created endpoint or null if this component cannot create instances of the given
     * uri
     */
    Endpoint<E> createEndpoint(String uri) throws Exception;
}
"
org/apache/camel/builder/BuilderSupport.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.util.ArrayList;
import java.util.List;

import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.SendProcessor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Base class for implementation inheritance for different clauses in the 
 * <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 *
 * @version $Revision: $
 */
public abstract class BuilderSupport {
    private CamelContext context;
    private ErrorHandlerBuilder errorHandlerBuilder;
    private boolean inheritErrorHandler = true;

    protected BuilderSupport(CamelContext context) {
        this.context = context;
    }

    protected BuilderSupport(BuilderSupport parent) {
        this.context = parent.getContext();
        this.inheritErrorHandler = parent.inheritErrorHandler;
        if (inheritErrorHandler && parent.errorHandlerBuilder != null) {
            this.errorHandlerBuilder = parent.errorHandlerBuilder.copy();
        }
    }

    // Builder methods
    //-------------------------------------------------------------------------

    /**
     * Returns a value builder for the given header
     */
    @Fluent
    public ValueBuilder header(@FluentArg(""name"")String name) {
        return Builder.header(name);
    }

    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    @Fluent
    public ValueBuilder body() {
        return Builder.body();
    }

    /**
     * Returns a predicate and value builder for the inbound message body as a specific type
     */
    @Fluent
    public <T> ValueBuilder bodyAs(@FluentArg(""class"")Class<T> type) {
        return Builder.bodyAs(type);
    }

    /**
     * Returns a predicate and value builder for the outbound body on an exchange
     */
    @Fluent
    public ValueBuilder outBody() {
        return Builder.outBody();
    }

    /**
     * Returns a predicate and value builder for the outbound message body as a specific type
     */
    @Fluent
    public <T> ValueBuilder outBody(@FluentArg(""class"")Class<T> type) {
        return Builder.outBody(type);
    }

    /**
     * Returns a value builder for the given system property
     */
    @Fluent
    public ValueBuilder systemProperty(@FluentArg(""name"")String name) {
        return Builder.systemProperty(name);
    }

    /**
     * Returns a value builder for the given system property
     */
    @Fluent
    public ValueBuilder systemProperty(
            @FluentArg(""name"")String name, @FluentArg(""defaultValue"")String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }

    /**
     * Resolves the given URI to an endpoint
     */
    @Fluent
    public Endpoint endpoint(@FluentArg(""uri"")String uri) {
        return getContext().getEndpoint(uri);
    }

    /**
     * Resolves the list of URIs into a list of {@link Endpoint} instances
     */
    @Fluent
    public List<Endpoint> endpoints(@FluentArg(""uris"")String... uris) {
        List<Endpoint> endpoints = new ArrayList<Endpoint>();
        for (String uri : uris) {
            endpoints.add(endpoint(uri));
        }
        return endpoints;
    }

    /**
     * Helper method to create a list of {@link Endpoint} instances
     */
    @Fluent
    public List<Endpoint> endpoints(@FluentArg(""endpoints"")Endpoint... endpoints) {
        List<Endpoint> answer = new ArrayList<Endpoint>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint);
        }
        return answer;
    }

    /**
     * Creates a disabled error handler for removing the default error handler
     */
    @Fluent
    public NoErrorHandlerBuilder noErrorHandler() {
        return new NoErrorHandlerBuilder();
    }

    /**
     * Creates an error handler which just logs errors
     */
    @Fluent
    public LoggingErrorHandlerBuilder loggingErrorHandler() {
        return new LoggingErrorHandlerBuilder();
    }

    /**
     * Creates an error handler which just logs errors
     */
    @Fluent
    public LoggingErrorHandlerBuilder loggingErrorHandler(@FluentArg(""log"")String log) {
        return loggingErrorHandler(LogFactory.getLog(log));
    }

    /**
     * Creates an error handler which just logs errors
     */
    @Fluent
    public LoggingErrorHandlerBuilder loggingErrorHandler(@FluentArg(""log"")Log log) {
        return new LoggingErrorHandlerBuilder(log);
    }

    /**
     * Creates an error handler which just logs errors
     */
    @Fluent
    public LoggingErrorHandlerBuilder loggingErrorHandler(
            @FluentArg(""log"")Log log, @FluentArg(""level"")LoggingLevel level) {
        return new LoggingErrorHandlerBuilder(log, level);
    }

    @Fluent
    public DeadLetterChannelBuilder deadLetterChannel() {
        return new DeadLetterChannelBuilder();
    }

    @Fluent
    public DeadLetterChannelBuilder deadLetterChannel(@FluentArg(""uri"")String deadLetterUri) {
        return deadLetterChannel(endpoint(deadLetterUri));
    }

    @Fluent
    public DeadLetterChannelBuilder deadLetterChannel(@FluentArg(""ref"")Endpoint deadLetterEndpoint) {
        return new DeadLetterChannelBuilder(new SendProcessor(deadLetterEndpoint));
    }

    // Properties
    //-------------------------------------------------------------------------
    public CamelContext getContext() {
        return context;
    }

    public void setContext(CamelContext context) {
        this.context = context;
    }

    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }

    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        }
        else {
            return new NoErrorHandlerBuilder();
        }
    }

    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }

    public boolean isInheritErrorHandler() {
        return inheritErrorHandler;
    }

    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        this.inheritErrorHandler = inheritErrorHandler;
    }
}
"
org/apache/camel/processor/loadbalancer/QueueLoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.List;

/**
 * A base class for {@link LoadBalancer} implementations which choose a single destination for each exchange
 * (rather like JMS Queues)
 *
 * @version $Revision: 1.1 $
 */
public abstract class QueueLoadBalancer extends LoadBalancerSupport {

    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        if (list.isEmpty()) {
            throw new IllegalStateException(""No processors available to process "" + exchange);
        }
        Processor processor = chooseProcessor(list, exchange);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
        }
        else {
            processor.process(exchange);
        }
    }

    protected abstract Processor chooseProcessor(List<Processor> processors, Exchange exchange);
}
"
org/apache/camel/component/pojo/timer/TimerConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo.timer;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Timer;
import java.util.TimerTask;

import org.apache.camel.Processor;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.component.pojo.PojoInvocation;
import org.apache.camel.impl.DefaultConsumer;

/**
 * @version $Revision: 523047 $
 */
public class TimerConsumer extends DefaultConsumer<PojoExchange> implements InvocationHandler {

    private final TimerEndpoint endpoint;
    private Timer timer;
    

	public TimerConsumer(TimerEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
		this.endpoint = endpoint;
    }
    
    @Override
    protected void doStart() throws Exception {
    	TimerComponent component = endpoint.getComponent();
    	component.addConsumer(this);    	
        timer=createTimerAndTask();
    }

    @Override
    protected void doStop() throws Exception {
        if(timer!=null){
            timer.cancel();
        }
    	TimerComponent component = endpoint.getComponent();
    	component.removeConsumer(this);    	
    }
    
    private Timer createTimerAndTask(){
    	
    	final Runnable proxy = createProxy();
        TimerTask task=new TimerTask(){
            @Override public void run(){
            	proxy.run();
            }
        };
        
        Timer result=new Timer(endpoint.getTimerName(),endpoint.isDaemon());
        if(endpoint.isFixedRate()){
            if(endpoint.getTime()!=null){
                result.scheduleAtFixedRate(task,endpoint.getTime(),endpoint.getPeriod());
            }else{
                result.scheduleAtFixedRate(task,endpoint.getDelay(),endpoint.getPeriod());
            }
        }else{
            if(endpoint.getTime()!=null){
                if(endpoint.getPeriod()>=0){
                    result.schedule(task,endpoint.getTime(),endpoint.getPeriod());
                }else{
                    result.schedule(task,endpoint.getTime());
                }
            }else{
                if(endpoint.getPeriod()>=0){
                    result.schedule(task,endpoint.getDelay(),endpoint.getPeriod());
                }else{
                    result.schedule(task,endpoint.getDelay());
                }
            }
        }
        return result;
    }
    
    /**
     * Creates a Proxy which generates the inbound PojoExchanges
     */
    public Runnable createProxy() {
        return (Runnable) Proxy.newProxyInstance(Runnable.class.getClassLoader(), new Class[]{Runnable.class}, this);
    }
    
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (!isStarted()) {
            throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
        }
        PojoInvocation invocation = new PojoInvocation(proxy, method, args);
        PojoExchange exchange = getEndpoint().createExchange();
        exchange.setInvocation(invocation);
        getProcessor().process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
	}
  


}
"
org/apache/camel/component/pojo/PojoExchange.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;

import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;

/**
 * @version $Revision: 519901 $
 */
public class PojoExchange extends DefaultExchange {

    public PojoExchange(CamelContext context) {
        super(context);
    }

    public PojoInvocation getInvocation() {
        return getIn().getBody(PojoInvocation.class);
    }

    public void setInvocation(PojoInvocation invocation) {
        getIn().setBody(invocation);
    }

    @Override
    public Exchange newInstance() {
        return new PojoExchange(getContext());
    }
}
"
org/apache/camel/util/ExpressionComparator.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;

import java.util.Comparator;

/**
 * An implementation of {@link Comparator} which takes an {@link Expression} which is evaluated
 * on each exchange to compare
 *  
 * @version $Revision: 1.1 $
 */
public class ExpressionComparator<E extends Exchange> implements Comparator<E> {
    private final Expression<E> expression;

    public ExpressionComparator(Expression<E> expression) {
        this.expression = expression;
    }

    public int compare(E e1, E e2) {
        Object o1 = expression.evaluate(e1);
        Object o2 = expression.evaluate(e2);
        return ObjectHelper.compare(o1, o2);
    }
}
"
org/apache/camel/component/file/FileConsumer.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;

import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;

/**
 * @version $Revision: 523016 $
 */
public class FileConsumer extends ScheduledPollConsumer<FileExchange> {
    private static final transient Log log = LogFactory.getLog(FileConsumer.class);
    private final FileEndpoint endpoint;
    private boolean recursive = true;
    private boolean attemptFileLock = false;
    private String regexPattern = """";
    private long lastPollTime = 0l;

    public FileConsumer(final FileEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }

    protected void poll() throws Exception {
        pollFileOrDirectory(endpoint.getFile(), isRecursive());
        lastPollTime = System.currentTimeMillis();
    }

    protected void pollFileOrDirectory(File fileOrDirectory, boolean processDir) {
        if (!fileOrDirectory.isDirectory()) {
            pollFile(fileOrDirectory); // process the file
        }
        else if (processDir) {
            log.debug(""Polling directory "" + fileOrDirectory);
            File[] files = fileOrDirectory.listFiles();
            for (int i = 0; i < files.length; i++) {
                pollFileOrDirectory(files[i], isRecursive()); // self-recursion
            }
        }
        else {
            log.debug(""Skipping directory "" + fileOrDirectory);
        }
    }

    protected void pollFile(final File file) {
        if (file.exists() && file.lastModified() > lastPollTime) {
            if (isValidFile(file)) {
                processFile(file);
            }
        }
    }

    protected void processFile(File file) {
        try {
			getProcessor().process(endpoint.createExchange(file));
		} catch (Throwable e) {
			handleException(e);
		}
    }

    protected boolean isValidFile(File file) {
        boolean result = false;
        if (file != null && file.exists()) {
            if (isMatched(file)) {
                if (isAttemptFileLock()) {
                    FileChannel fc = null;
                    try {
                        fc = new RandomAccessFile(file, ""rw"").getChannel();
                        fc.lock();
                        result = true;
                    }
                    catch (Throwable e) {
                        log.debug(""Failed to get the lock on file: "" + file, e);
                    }
                    finally {
                        if (fc != null) {
                            try {
                                fc.close();
                            }
                            catch (IOException e) {
                            }
                        }
                    }
                }
                else {
                    result = true;
                }
            }
        }
        return result;
    }

    protected boolean isMatched(File file) {
        boolean result = true;
        if (regexPattern != null && regexPattern.length() > 0) {
            result = file.getName().matches(getRegexPattern());
        }
        return result;
    }

    /**
     * @return the recursive
     */
    public boolean isRecursive() {
        return this.recursive;
    }

    /**
     * @param recursive the recursive to set
     */
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }

    /**
     * @return the attemptFileLock
     */
    public boolean isAttemptFileLock() {
        return this.attemptFileLock;
    }

    /**
     * @param attemptFileLock the attemptFileLock to set
     */
    public void setAttemptFileLock(boolean attemptFileLock) {
        this.attemptFileLock = attemptFileLock;
    }

    /**
     * @return the regexPattern
     */
    public String getRegexPattern() {
        return this.regexPattern;
    }

    /**
     * @param regexPattern the regexPattern to set
     */
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
}
"
org/apache/camel/component/jmx/JMXEndpoint.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;

import javax.management.MBeanServer;
import javax.management.Notification;
import javax.management.ObjectName;
import javax.management.monitor.CounterMonitor;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Creates a CounterMonitor for jmx attributes
 *
 * @version $Revision: 523016 $
 */
public class JMXEndpoint extends DefaultEndpoint<JMXExchange> {

	private static final Log log=LogFactory.getLog(JMXEndpoint.class);
	private String name;
	private ObjectName ourName;
	private String observedObjectName;
	private String attributeName;
	private long granularityPeriod=5000;
	private Number threshold;
	private Number offset;
	private MBeanServer mbeanServer;
	private CounterMonitor counterMonitor=new CounterMonitor();

	protected JMXEndpoint(String endpointUri,JMXComponent component){
		super(endpointUri,component);
		observedObjectName=endpointUri;
	}

	/**
	 * @return a Producer
	 * @throws Exception
	 * @see org.apache.camel.Endpoint#createProducer()
	 */
	public Producer<JMXExchange> createProducer() throws Exception{
		throw new RuntimeException(""Not supported"");
	}

	/**
	 * @param proc
	 * @return a Consumer
	 * @throws Exception
	 * @see org.apache.camel.Endpoint#createConsumer(org.apache.camel.Processor)
	 */
	public Consumer<JMXExchange> createConsumer(Processor proc)
	        throws Exception{
		ObjectName observedName=new ObjectName(observedObjectName);
		if(name==null){
			String type=observedName.getKeyProperty(""type"");
			type=type!=null?type:""UNKNOWN"";
			name=mbeanServer.getDefaultDomain()+"":type=CounterMonitor_""+type;
		}
		JMXConsumer result=new JMXConsumer(this,proc);
		ourName=new ObjectName(name);
		counterMonitor.setNotify(true);
		counterMonitor.addObservedObject(observedName);
		counterMonitor.setObservedAttribute(attributeName);
		counterMonitor.setGranularityPeriod(granularityPeriod);
		counterMonitor.setDifferenceMode(false);
		counterMonitor.setInitThreshold(threshold);
		counterMonitor.setOffset(offset);
		mbeanServer.registerMBean(counterMonitor,ourName);
		mbeanServer.addNotificationListener(ourName,result,null,new Object());
		return result;
	}

	public boolean isSingleton(){
		return true;
	}

	public JMXExchange createExchange(Notification notification){
		return new JMXExchange(getContext(),notification);
	}

	public JMXExchange createExchange(){
		return new JMXExchange(getContext(),null);
	}

	
    public String getAttributeName(){
    	return attributeName;
    }

	
    public void setAttributeName(String attributeName){
    	this.attributeName=attributeName;
    }

	
    public long getGranularityPeriod(){
    	return granularityPeriod;
    }

	
    public void setGranularityPeriod(long granularityPeriod){
    	this.granularityPeriod=granularityPeriod;
    }

	
    public String getName(){
    	return name;
    }

	
    public void setName(String name){
    	this.name=name;
    }

	
    public Number getOffset(){
    	return offset;
    }

	
    public void setOffset(Number offset){
    	this.offset=offset;
    }

	
    public Number getThreshold(){
    	return threshold;
    }

	
    public void setThreshold(Number threshold){
    	this.threshold=threshold;
    }

	
    public MBeanServer getMbeanServer(){
    	return mbeanServer;
    }

	
    public void setMbeanServer(MBeanServer mbeanServer){
    	this.mbeanServer=mbeanServer;
    }
}
"
org/apache/camel/impl/ServiceSupport.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.camel.Service;

/**
 * A useful base class which ensures that a service is only initialized once and provides some helper methods for
 * enquiring of its status
 * 
 * @version $Revision$
 */
public abstract class ServiceSupport implements Service {
    private AtomicBoolean started = new AtomicBoolean(false);
    private AtomicBoolean stopping = new AtomicBoolean(false);
    private AtomicBoolean stopped = new AtomicBoolean(false);

    public void start() throws Exception {
        if (started.compareAndSet(false, true)) {
            doStart();
        }
    }

    public void stop() throws Exception {
        if (stopped.compareAndSet(false, true)) {
            stopping.set(true);
            try {
                doStop();
            }
            finally {
                stopped.set(true);
                started.set(false);
                stopping.set(false);
            }
        }
    }

    /**
     * @return true if this service has been started
     */
    public boolean isStarted() {
        return started.get();
    }

    /**
     * @return true if this service is in the process of closing
     */
    public boolean isStopping() {
        return stopping.get();
    }


    /**
     * @return true if this service is closed
     */
    public boolean isStopped() {
        return stopped.get();
    }

    protected abstract void doStart() throws Exception;
    
    protected abstract void doStop() throws Exception;

}
"
org/apache/camel/builder/xml/DomResultHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.apache.camel.Message;

import javax.xml.transform.Result;
import javax.xml.transform.dom.DOMResult;

/**
 * Uses DOM to handle results of the transformation
 * 
 * @version $Revision: 1.1 $
 */
public class DomResultHandler implements ResultHandler {
    private DOMResult result = new DOMResult();

    public Result getResult() {
        return result;
    }

    public void setBody(Message in) {
        in.setBody(result.getNode());
    }
}
"
org/apache/camel/converter/jaxp/BytesSource.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

/**
 * A helper class which provides a JAXP {@link Source} from a byte[]
 * which can be read as many times as required.
 *
 * @version $Revision$
 */
public class BytesSource extends StreamSource {
    private byte[] data;

    public BytesSource(byte[] data) {
        this.data = data;
    }

    public BytesSource(byte[] data, String systemId) {
        this.data = data;
        setSystemId(systemId);
    }

    public InputStream getInputStream() {
        return new ByteArrayInputStream(data);
    }

    public Reader getReader() {
        return new InputStreamReader(getInputStream());
    }

    public byte[] getData() {
        return data;
    }

    public String toString() {
        return ""BytesSource["" + new String(data) + ""]"";
    }

}
"
org/apache/camel/builder/RouteBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.DefaultCamelContext;

/**
 * A <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 * which is used to build {@link Route} instances in a @{link CamelContext} for smart routing.
 *
 * @version $Revision$
 */
public abstract class RouteBuilder extends BuilderSupport {
    private List<FromBuilder> fromBuilders = new ArrayList<FromBuilder>();
    private AtomicBoolean initalized = new AtomicBoolean(false);
    private List<Route> routes = new ArrayList<Route>();

    protected RouteBuilder() {
        this(null);
    }

    protected RouteBuilder(CamelContext context) {
        super(context);
    }

    /**
     * Called on initialization to to build the required destinationBuilders
     */
    public abstract void configure() throws Exception;

    @Fluent
    public FromBuilder from( @FluentArg(""uri"") String uri) {
    	if( uri == null ) {
    		throw new IllegalArgumentException(""uri parameter cannot be null"");
    	}
    	Endpoint endpoint = endpoint(uri);
    	if( endpoint == null ) {
    		throw new IllegalArgumentException(""uri '""+uri+""' could not be resolved."");
    	}
        return from(endpoint);
    }

    @Fluent
    public FromBuilder from( @FluentArg(""ref"") Endpoint endpoint) {
        FromBuilder answer = new FromBuilder(this, endpoint);
        addFromBuilder(answer);
        return answer;
    }

    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for all child routes
     * @return the current builder with the error handler configured
     */
    public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }

    /**
     * Configures whether or not the error handler is inherited by every processing node (or just the top most one)
     *
     * @param value the flag as to whether error handlers should be inherited or not
     * @return the current builder
     */
    public RouteBuilder inheritErrorHandler(boolean value) {
        setInheritErrorHandler(value);
        return this;
    }

    // Properties
    //-----------------------------------------------------------------------
    public CamelContext getContext() {
        CamelContext context = super.getContext();
        if (context == null) {
            context = createContainer();
            setContext(context);
        }
        return context;
    }

    /**
     * Returns the routing map from inbound endpoints to processors
     */
    public List<Route> getRouteList() throws Exception {
        checkInitialized();
        return routes;
    }

    /**
     * Returns the builders which have been created
     */
    public List<FromBuilder> getFromBuilders() throws Exception {
        checkInitialized();
        return fromBuilders;
    }

    // Implementation methods
    //-----------------------------------------------------------------------
    public void addFromBuilder(FromBuilder answer) {
        fromBuilders.add(answer);
    }

    protected void checkInitialized() throws Exception {
        if (initalized.compareAndSet(false, true)) {
            configure();
            populateRoutes(routes);
        }
    }

    protected void populateRoutes(List<Route> routes) throws Exception {
        for (FromBuilder builder : fromBuilders) {
            Route route = builder.createRoute();
            routes.add(route);
        }
    }

    /**
     * Factory method
     */
    protected CamelContext createContainer() {
        return new DefaultCamelContext();
    }
}
"
org/apache/camel/NoTypeConversionAvailableException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * An exception thrown if a value could not be converted to the required type
 *
 * @version $Revision$
 */
public class NoTypeConversionAvailableException extends RuntimeCamelException {
    private final Object value;
    private final Class type;

    public NoTypeConversionAvailableException(Object value, Class type) {
        super(""No converter available to convert value: "" + value + "" to the required type: "" + type.getName());
        this.value = value;
        this.type = type;
    }

    /**
     * Returns the value which could not be converted
     *
     * @return the value that could not be converted
     */
    public Object getValue() {
        return value;
    }

    /**
     * Returns the required type
     *
     * @return the required type
     */
    public Class getType() {
        return type;
    }
}
"
org/apache/camel/builder/UndefinedDestinationException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.RuntimeCamelException;

/**
 * @version $Revision$
 */
public class UndefinedDestinationException extends RuntimeCamelException {
	private static final long serialVersionUID = -5980888207885995222L;

	public UndefinedDestinationException() {
        super(""No destination defined for this routing rule"");
    }
}
"
org/apache/camel/util/ProducerCache.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.HashMap;
import java.util.Map;

/**
 * @version $Revision$
 */
public class ProducerCache<E extends Exchange> extends ServiceSupport {
    private static final Log log = LogFactory.getLog(ProducerCache.class);

    private Map<String, Producer<E>> producers = new HashMap<String, Producer<E>>();

    public synchronized Producer<E> getProducer(Endpoint<E> endpoint) {
        String key = endpoint.getEndpointUri();
        Producer<E> answer = producers.get(key);
        if (answer == null) {
            try {
                answer = endpoint.createProducer();
                answer.start();
            }
            catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            }
            producers.put(key, answer);
        }
        return answer;
    }

    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public void send(Endpoint<E> endpoint, E exchange) {
        try {
            Producer<E> producer = getProducer(endpoint);
            producer.process(exchange);
        }
        catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }

    /**
     * Sends an exchange to an endpoint using a supplied @{link Processor} to populate the exchange
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();

            // lets populate using the processor callback
            processor.process(exchange);

            // now lets dispatch
            if (log.isDebugEnabled()) {
                log.debug("">>>> "" + endpoint + "" "" + exchange);
            }
            producer.process(exchange);
            return exchange;
        }
        catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producers.values());
    }

    protected void doStart() throws Exception {
    }
}
"
org/apache/camel/builder/DeadLetterChannelBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A builder of a <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a>
 *
 * @version $Revision$
 */
public class DeadLetterChannelBuilder implements ErrorHandlerBuilder {
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    private ProcessorFactory deadLetterFactory;
    private Processor defaultDeadLetterEndpoint;
    private Expression defaultDeadLetterEndpointExpression;
    private String defaultDeadLetterEndpointUri = ""log:org.apache.camel.DeadLetterChannel:error"";
    private Logger logger = DeadLetterChannel.createDefaultLogger();

    public DeadLetterChannelBuilder() {
    }

    public DeadLetterChannelBuilder(Processor processor) {
        this(new ConstantProcessorBuilder(processor));
    }

    public DeadLetterChannelBuilder(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }

    public ErrorHandlerBuilder copy() {
        DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder(deadLetterFactory);
        answer.setRedeliveryPolicy(getRedeliveryPolicy().copy());
        return answer;
    }

    public Processor createErrorHandler(Processor processor) throws Exception {
        Processor deadLetter = getDeadLetterFactory().createProcessor();
        return new DeadLetterChannel(processor, deadLetter, getRedeliveryPolicy(), getLogger());
    }

    // Builder methods
    //-------------------------------------------------------------------------
    public DeadLetterChannelBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }

    public DeadLetterChannelBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }

    public DeadLetterChannelBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }

    public DeadLetterChannelBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }

    public DeadLetterChannelBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }

    public DeadLetterChannelBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }

    /**
     * Sets the logger used for caught exceptions
     */
    public DeadLetterChannelBuilder logger(Logger logger) {
        setLogger(logger);
        return this;
    }

    /**
     * Sets the logging level of exceptions caught
     */
    public DeadLetterChannelBuilder loggingLevel(LoggingLevel level) {
        getLogger().setLevel(level);
        return this;
    }

    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Log log) {
        getLogger().setLog(log);
        return this;
    }

    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(String log) {
        return log(LogFactory.getLog(log));
    }

    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Class log) {
        return log(LogFactory.getLog(log));
    }

    // Properties
    //-------------------------------------------------------------------------
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }

    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }

    public ProcessorFactory getDeadLetterFactory() {
        if (deadLetterFactory == null) {
            deadLetterFactory = new ProcessorFactory() {
                public Processor createProcessor() {
                    return getDefaultDeadLetterEndpoint();
                }
            };
        }
        return deadLetterFactory;
    }

    /**
     * Sets the default dead letter queue factory
     */
    public void setDeadLetterFactory(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }

    public Processor getDefaultDeadLetterEndpoint() {
        if (defaultDeadLetterEndpoint == null) {
            defaultDeadLetterEndpoint = new RecipientList(getDefaultDeadLetterEndpointExpression());
        }
        return defaultDeadLetterEndpoint;
    }

    /**
     * Sets the default dead letter endpoint used
     */
    public void setDefaultDeadLetterEndpoint(Processor defaultDeadLetterEndpoint) {
        this.defaultDeadLetterEndpoint = defaultDeadLetterEndpoint;
    }

    public Expression getDefaultDeadLetterEndpointExpression() {
        if (defaultDeadLetterEndpointExpression == null) {
            defaultDeadLetterEndpointExpression = ExpressionBuilder.constantExpression(getDefaultDeadLetterEndpointUri());
        }
        return defaultDeadLetterEndpointExpression;
    }

    /**
     * Sets the expression used to decide the dead letter channel endpoint for an exchange
     * if no factory is provided via {@link #setDeadLetterFactory(ProcessorFactory)}
     */
    public void setDefaultDeadLetterEndpointExpression(Expression defaultDeadLetterEndpointExpression) {
        this.defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression;
    }

    public String getDefaultDeadLetterEndpointUri() {
        return defaultDeadLetterEndpointUri;
    }

    /**
     * Sets the default dead letter endpoint URI used if no factory is provided via {@link #setDeadLetterFactory(ProcessorFactory)}
     * and no expression is provided via {@link #setDefaultDeadLetterEndpointExpression(Expression)}
     *
     * @param defaultDeadLetterEndpointUri the default URI if no deadletter factory or expression is provided
     */
    public void setDefaultDeadLetterEndpointUri(String defaultDeadLetterEndpointUri) {
        this.defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri;
    }

    public Logger getLogger() {
        return logger;
    }

    public void setLogger(Logger logger) {
        this.logger = logger;
    }
}
"
org/apache/camel/builder/ErrorHandlerBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * @version $Revision$
 */
public interface ErrorHandlerBuilder<E extends Exchange> {
    /**
     * Creates a copy of this builder
     */
    ErrorHandlerBuilder<E> copy();

    /**
     * Creates the error handler interceptor
     */
    Processor createErrorHandler(Processor processor) throws Exception;
}
"
org/apache/camel/Producer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Provides a channel on which clients can create and invoke message exchanges on an {@link Endpoint}
 *
 * @version $Revision$
 */
public interface Producer<E extends Exchange> extends Processor, Service {

    Endpoint<E> getEndpoint();

    /**
     * Creates a new exchange to send to this endpoint
     *
     * @return a newly created exchange
     */
    E createExchange();

    /**
     * Creates a new exchange for communicating with this exchange using the given exchange to pre-populate the values
     * of the headers and messages
     */
    E createExchange(E exchange);
}
"
org/apache/camel/impl/converter/StaticMethodTypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.TypeConverter;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * A {@link TypeConverter} implementation which invokes a static method to convert from a type to another type
 *
 * @version $Revision$
 */
public class StaticMethodTypeConverter implements TypeConverter {
    private final Method method;

    public StaticMethodTypeConverter(Method method) {
        this.method = method;
    }

    @Override
    public String toString() {
        return ""StaticMethodTypeConverter: "" + method;
    }

    public <T> T convertTo(Class<T> type, Object value) {
        return (T) ObjectHelper.invokeMethod(method, null, value);
    }
}
"
org/apache/camel/builder/xml/DefaultNamespaceContext.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;

import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.Attr;

import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPathFactory;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * An implementation of {@link NamespaceContext} which uses a simple Map where
 * the keys are the prefixes and the values are the URIs
 *
 * @version $Revision: $
 */
public class DefaultNamespaceContext implements NamespaceContext {

    private final Map map;
    private final NamespaceContext parent;

    public DefaultNamespaceContext() {
        this(XPathFactory.newInstance());
    }

    public DefaultNamespaceContext(XPathFactory factory) {
        this.parent = factory.newXPath().getNamespaceContext();
        this.map = new HashMap();
    }

    public DefaultNamespaceContext(NamespaceContext parent, Map map) {
        this.parent = parent;
        this.map = map;
    }

    /**
     * A helper method to make it easy to create newly populated instances
     */
    public DefaultNamespaceContext add(String prefix, String uri) {
        map.put(prefix, uri);
        return this;
    }

    public String getNamespaceURI(String prefix) {
        String answer = (String) map.get(prefix);
        if (answer == null && parent != null) {
            return parent.getNamespaceURI(prefix);
        }
        return answer;
    }

    public String getPrefix(String namespaceURI) {
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                return (String) entry.getKey();
            }
        }
        if (parent != null) {
            return parent.getPrefix(namespaceURI);
        }
        return null;
    }

    public Iterator getPrefixes(String namespaceURI) {
        Set set = new HashSet();
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                set.add(entry.getKey());
            }
        }
        if (parent != null) {
            Iterator iter = parent.getPrefixes(namespaceURI);
            while (iter.hasNext()) {
                set.add(iter.next());
            }
        }
        return set.iterator();
    }

    public void setNamespacesFromDom(Element element) {
        // lets set the parent first in case we overload a prefix here
        Node parentNode = element.getParentNode();
        if (parentNode instanceof Element) {
            setNamespacesFromDom((Element) parentNode);
        }
        NamedNodeMap attributes = element.getAttributes();
        for (int i = 0, size = attributes.getLength(); i < size; i++) {
            Attr node = (Attr) attributes.item(i);
            String name = node.getName();
            if (name.startsWith(""xmlns:"")) {
                String prefix = name.substring(""xmlns:"".length());
                String uri = node.getValue();
                add(prefix, uri);
            }
        }
    }
}
"
org/apache/camel/builder/FluentArg.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/** 
 * Used to annotate the parameter of a {@see Fluent} method.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface FluentArg {
	String value();
	boolean attribute() default true;
	boolean element() default false;
    boolean reference() default false;
}
"
org/apache/camel/builder/NoErrorHandlerBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

/**
 * A builder to disable the use of an error handler so that any exceptions are thrown.
 * This not recommended in general, the
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a> should be used
 * if you are unsure; however it can be useful sometimes to disable an error handler inside a complex route
 * so that exceptions bubble up to the parent {@link Processor}
 *
 * @version $Revision$
 */
public class NoErrorHandlerBuilder<E extends Exchange> implements ErrorHandlerBuilder<E> {
    public ErrorHandlerBuilder<E> copy() {
        return this;
    }

    public Processor createErrorHandler(Processor processor) {
        return processor;
    }
}
"
org/apache/camel/processor/idempotent/MemoryMessageIdRepository.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;

import org.apache.camel.util.LRUCache;

import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;

/**
 * A memory based implementation of {@link MessageIdRepository}.
 * Care should be taken to use a suitable underlying {@link Map} to avoid this class being a memory leak
 *
 * @version $Revision: 1.1 $
 */
public class MemoryMessageIdRepository implements MessageIdRepository {
    private Map cache;

    /**
     * Creates a new MemoryMessageIdRepository with a memory based respository. <b>Warning</b> this
     * method should only really be used for testing as it will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository() {
        return memoryMessageIdRepository(new HashMap());
    }

    /**
     * Creates a new MemoryMessageIdRepository with a memory based respository. <b>Warning</b> this
     * method should only really be used for testing as it will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository(int cacheSize) {
        return memoryMessageIdRepository(new LRUCache(cacheSize));
    }

    /**
     * Creates a new MemoryMessageIdRepository using the given {@link Map} to use to store the
     * processed Message ID objects. Warning be cafeful of the implementation of Map you use as
     * if you are not careful it could be a memory leak.
     */
    public static MessageIdRepository memoryMessageIdRepository(Map cache) {
        return new MemoryMessageIdRepository(cache);
    }

    public MemoryMessageIdRepository(Map set) {
        this.cache = set;
    }

    public boolean contains(String messageId) {
        synchronized (cache) {
            if (cache.containsKey(messageId)) {
                return true;
            }
            else {
                cache.put(messageId, messageId);
                return false;
            }
        }
    }
}
"
org/apache/camel/InvalidHeaderTypeException.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * @version $Revision$
 */
public class InvalidHeaderTypeException extends RuntimeCamelException {

	private static final long serialVersionUID = -8417806626073055262L;
	private Object headerValue;

    public InvalidHeaderTypeException(Throwable cause, Object headerValue) {
        super(cause.getMessage() + "" headerValue is: "" + headerValue + "" of type: ""
                + typeName(headerValue), cause);
        this.headerValue = headerValue;
    }

    public InvalidHeaderTypeException(String message, Object headerValue) {
        super(message);
        this.headerValue = headerValue;
    }


    /**
     * Returns the actual header value
     */
    public Object getHeaderValue() {
        return headerValue;
    }

    protected static String typeName(Object headerValue) {
        return (headerValue != null) ? headerValue.getClass().getName() : ""null"";
    }
}
"
org/apache/camel/Exchange.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.util.Map;

/**
 * The base message exchange interface providing access to the request, response and fault {@link Message} instances.
 * Different providers such as JMS, JBI, CXF and HTTP can provide their own derived API to expose the underlying transport
 * semantics to avoid the leaky abstractions of generic APIs.
 *
 * @version $Revision$
 */
public interface Exchange  {
    
    /**
     * Returns the exchange id
     * @return the unique id of the exchange
     */
    String getExchangeId();
    
    /**
     * Set the exchange id
     * @param id
     */
    void setExchangeId(String id);


    /**
     * Returns a property associated with this exchange by name
     *
     * @param name the name of the property
     * @return the value of the given header or null if there is no property for the given name
     */
    Object getProperty(String name);


    /**
     * Returns a property associated with this exchange by name and specifying the type required
     *
     * @param name the name of the property
     * @param type the type of the property
     * @return the value of the given header or null if there is no property for the given name or
     * null if it cannot be converted to the given type
     */
    <T> T getProperty(String name, Class<T> type);

    /**
     * Sets a property on the exchange
     *
     * @param name of the property
     * @param value to associate with the name
     */
    void setProperty(String name, Object value);

    /**
     * Returns all of the properties associated with the exchange
     *
     * @return all the headers in a Map
     */
    Map<String, Object> getProperties();

    
    /**
     * Returns the inbound request message
     * @return the message
     */
    Message getIn();

    /**
     * Returns the outbound message, lazily creating one if one has not already been associated with this exchange.
     * If you want to inspect this property but not force lazy creation then invoke the {@link #getOut(boolean)} method
     * passing in null
     * 
     * @return the response
     */
    Message getOut();

    /**
     * Returns the outbound message; optionally lazily creating one if one has not been associated with this exchange
     * @return the response
     */
    Message getOut(boolean lazyCreate);

    /**
     * Returns the fault message
     * @return the fault
     */
    Message getFault();

    /**
     * Returns the exception associated with this exchange
     * @return the exception (or null if no faults)
     */
    Throwable getException();

    /**
     * Sets the exception associated with this exchange
     * @param e
     */
    void setException(Throwable e);

    /**
     * Returns the container so that a processor can resolve endpoints from URIs
     *
     * @return the container which owns this exchange
     */
    CamelContext getContext();

    /**
     * Creates a copy of the current message exchange so that it can be forwarded to another
     * destination
     */
    Exchange copy();

    /**
     * Copies the data into this exchange from the given exchange
     *
     * #param source is the source from which headers and messages will be copied 
     */
    void copyFrom(Exchange source);
}
"
org/apache/camel/processor/DeadLetterChannel.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Message;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Implements a
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a>
 * after attempting to redeliver the message using the {@link RedeliveryPolicy}
 *
 * @version $Revision$
 */
public class DeadLetterChannel extends ServiceSupport implements ErrorHandler {
    public static final String REDELIVERY_COUNTER = ""org.apache.camel.RedeliveryCounter"";
    public static final String REDELIVERED = ""org.apache.camel.Redelivered"";

    private static final transient Log log = LogFactory.getLog(DeadLetterChannel.class);
    private Processor output;
    private Processor deadLetter;
    private RedeliveryPolicy redeliveryPolicy;
    private Logger logger;

    public static <E extends Exchange> Logger createDefaultLogger() {
        return new Logger(log, LoggingLevel.ERROR);
    }

    public DeadLetterChannel(Processor output, Processor deadLetter) {
        this(output, deadLetter, new RedeliveryPolicy(), DeadLetterChannel.createDefaultLogger());
    }

    public DeadLetterChannel(Processor output, Processor deadLetter, RedeliveryPolicy redeliveryPolicy, Logger logger) {
        this.deadLetter = deadLetter;
        this.output = output;
        this.redeliveryPolicy = redeliveryPolicy;
        this.logger = logger;
    }

    @Override
    public String toString() {
        return ""DeadLetterChannel["" + output + "", "" + deadLetter + "", "" + redeliveryPolicy + ""]"";
    }

    public void process(Exchange exchange) throws Exception {
        int redeliveryCounter = 0;
        long redeliveryDelay = 0;

        do {
            if (redeliveryCounter > 0) {
                // Figure out how long we should wait to resend this message.
                redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
                sleep(redeliveryDelay);
            }

            try {
                output.process(exchange);
                return;
            }
            catch (RuntimeException e) {
                logger.log(""On delivery attempt: "" + redeliveryCounter + "" caught: "" + e, e);
            }
            redeliveryCounter = incrementRedeliveryCounter(exchange);
        }
        while (redeliveryPolicy.shouldRedeliver(redeliveryCounter));

        // now lets send to the dead letter queue
        deadLetter.process(exchange);
    }

    // Properties
    //-------------------------------------------------------------------------

    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }

    /**
     * Returns the dead letter that message exchanges will be sent to if the redelivery attempts fail
     */
    public Processor getDeadLetter() {
        return deadLetter;
    }

    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }

    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }

    public Logger getLogger() {
        return logger;
    }

    /**
     * Sets the logger strategy; which {@link Log} to use and which {@link LoggingLevel} to use
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    // Implementation methods
    //-------------------------------------------------------------------------

    /**
     * Increments the redelivery counter and adds the redelivered flag if the message has been redelivered
     */
    protected int incrementRedeliveryCounter(Exchange exchange) {
        Message in = exchange.getIn();
        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);
        int next = 1;
        if (counter != null) {
            next = counter + 1;
        }
        in.setHeader(REDELIVERY_COUNTER, next);
            in.setHeader(REDELIVERED, true);
        return next;
    }

    protected void sleep(long redeliveryDelay) {
        if (redeliveryDelay > 0) {
            if (log.isDebugEnabled()) {
                log.debug(""Sleeping for: "" + redeliveryDelay + "" until attempting redelivery"");
            }
            try {
                Thread.sleep(redeliveryDelay);
            }
            catch (InterruptedException e) {
                if (log.isDebugEnabled()) {
                    log.debug(""Thread interupted: "" + e, e);
                }
            }
        }
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(output, deadLetter);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(deadLetter, output);
    }
}
"
org/apache/camel/builder/InterceptorBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import java.util.ArrayList;
import java.util.List;

import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;

/**
 * @version $Revision: 519943 $
 */
public class InterceptorBuilder implements ProcessorFactory {
    private final List<DelegateProcessor> intercepts = new ArrayList<DelegateProcessor>();
	private final FromBuilder parent;
	private FromBuilder target;

	public InterceptorBuilder(FromBuilder parent) {
        this.parent = parent;
	}
	
	@Fluent(""interceptor"")
	public InterceptorBuilder add(@FluentArg(""ref"") DelegateProcessor interceptor) {
		intercepts.add(interceptor);
		return this;
	}
	
	@Fluent(callOnElementEnd=true)
    public FromBuilder target() {
        this.target = new FromBuilder(parent);
        return target;
    }

    public Processor createProcessor() throws Exception {
    	
    	// The target is required.
    	if( target == null ) 
    		throw new RuntimeCamelException(""target provided."");
    	
    	// Interceptors are optional
    	DelegateProcessor first=null;
    	DelegateProcessor last=null;
        for (DelegateProcessor p : intercepts) {
            if( first == null ) {
            	first = p;
            }
            if( last != null ) {
            	last.setNext(p);
            }
            last = p;
        }
        
        Processor p = target.createProcessor();
        if( last != null ) {
        	last.setNext(p);
        }
        return first == null ? p : first;
    }
}
"
org/apache/camel/component/pojo/NoPojoAvailableException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;

import org.apache.camel.CamelException;

/**
 * @version $Revision: 1.1 $
 */
public class NoPojoAvailableException extends CamelException {
    private final PojoEndpoint endpoint;

    public NoPojoAvailableException(PojoEndpoint endpoint) {
        super(""No POJO available for endpoint: "" + endpoint);
        this.endpoint = endpoint;
    }

    public PojoEndpoint getEndpoint() {
        return endpoint;
    }
}
"
org/apache/camel/component/pojo/PojoEndpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;

import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Component;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.spi.Provider;

import java.lang.reflect.InvocationTargetException;

/**
 * Represents a pojo endpoint that uses reflection
 * to send messages around.
 *
 * @version $Revision: 519973 $
 */
public class PojoEndpoint extends DefaultEndpoint<PojoExchange> {
    private Object pojo;

    public PojoEndpoint(String uri, Component component, Object pojo) {
        super(uri, component);
        this.pojo = pojo;
    }

    public Producer<PojoExchange> createProducer() throws Exception {
        final Object pojo = getPojo();
        if (pojo == null) {
            throw new NoPojoAvailableException(this);
        }

        return new DefaultProducer(this) {
            public void process(Exchange exchange) {
                PojoExchange pojoExchange = toExchangeType(exchange);
                invoke(pojo, pojoExchange);
                exchange.copyFrom(pojoExchange);
            }
        };
    }

    public Consumer<PojoExchange> createConsumer(Processor processor) throws Exception {
        throw new Exception(""You cannot consume from pojo endpoints."");
    }

    /**
     * This causes us to invoke the endpoint Pojo using reflection.
     *
     * @param pojo
     */
    public static void invoke(Object pojo, PojoExchange exchange) {
        PojoInvocation invocation = exchange.getInvocation();
        try {
            Object response = invocation.getMethod().invoke(pojo, invocation.getArgs());
            exchange.getOut().setBody(response);
        }
        catch (InvocationTargetException e) {
            exchange.setException(e.getCause());
        }
        catch (RuntimeException e) {
            throw e;
        }
        catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    public PojoExchange createExchange() {
        return new PojoExchange(getContext());
    }

    public boolean isSingleton() {
        return true;
    }

    public Object getPojo() {
        return pojo;
    }

    public void setPojo(Object pojo) {
        this.pojo = pojo;
    }
}
"
org/apache/camel/impl/DefaultProducer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Producer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;

/**
 * A default implementation of @{link Producer} for implementation inheritence
 *
 * @version $Revision$
 */
public abstract class DefaultProducer<E extends Exchange> extends ServiceSupport implements Producer<E> {
    private Endpoint<E> endpoint;

    public DefaultProducer(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }

    public Endpoint<E> getEndpoint() {
        return endpoint;
    }

    public E createExchange() {
        return endpoint.createExchange();
    }

    public E createExchange(E exchange) {
        return endpoint.createExchange(exchange);
    }

    protected void doStart() throws Exception {
    }

    protected void doStop() throws Exception {
    }
}
"
org/apache/camel/Endpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;


/**
 * An <a href=""http://activemq.apache.org/camel/endpoint.html"">endpoint</a> implements the 
 * <a href=""http://activemq.apache.org/camel/message-endpoint.html"">Message Endpoint</a>
 * pattern and represents an endpoint that can send and receive message exchanges
 *
 * @see Exchange, Message
 * @version $Revision$
 */
public interface Endpoint<E extends Exchange> {

    /**
     * Returns if the endpoint should be a CamelContext singleton.  If the endpoint is a Singleton,
     * then a single Endpoint instance will be shared by all routes with the same URI.  Because the endpoint
     * is shared, it should be treated as an immutable.
     */
    boolean isSingleton();

    /**
     * Returns the string representation of the endpoint URI
     */
    String getEndpointUri();
    
    /**
     * Create a new exchange for communicating with this endpoint
     */
    E createExchange();

    /**
     * Creates a new exchange for communicating with this exchange using the given exchange to pre-populate the values
     * of the headers and messages
     */
    E createExchange(Exchange exchange);

    /**
     * Converts the given exchange to this endpoints required type
     */
    E toExchangeType(Exchange exchange);

    /**
     * Returns the context which created the endpoint
     *
     * @return the context which created the endpoint
     */
    CamelContext getContext();

    /**
     * Creates a new producer which is used send messages into the endpoint
     *
     * @return a newly created producer
     */
    Producer<E> createProducer() throws Exception;

    /**
     * Creates a new <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
     * which consumes messages from the endpoint using the given processor
     *
     * @return a newly created consumer
     */
    Consumer<E> createConsumer(Processor processor) throws Exception;

    /**
     * Creates a new <a href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling Consumer</a>
     * so that the caller can poll message exchanges from the consumer
     * using {@link PollingConsumer#receive()}, {@link PollingConsumer#receiveNoWait()} or {@link PollingConsumer#receive(long)}
     * whenever it is ready to do so rather than using the
     * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Based Consumer</a>
     * returned by {@link #createConsumer(Processor)}
     *
     * @return a newly created pull consumer
     * @throws Exception if the pull consumer could not be created
     */
    PollingConsumer<E> createPollingConsumer() throws Exception;
}
"
org/apache/camel/processor/Logger.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A {@link Processor} which just logs to a {@link Log} object which can be used as an exception
 * handler instead of using a dead letter queue.
 *
 * @version $Revision$
 */
public class Logger implements Processor {
    private Log log;
    private LoggingLevel level;

    public Logger() {
        this(LogFactory.getLog(Logger.class));
    }

    public Logger(Log log) {
        this(log, LoggingLevel.INFO);
    }

    public Logger(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }

    @Override
    public String toString() {
        return ""Logger["" + log + ""]"";
    }

    public void process(Exchange exchange) {
        switch (level) {
            case DEBUG:
                if (log.isDebugEnabled()) {
                    log.debug(logMessage(exchange));
                }
                break;
            case ERROR:
                if (log.isErrorEnabled()) {
                    log.error(logMessage(exchange));
                }
                break;
            case FATAL:
                if (log.isFatalEnabled()) {
                    log.fatal(logMessage(exchange));
                }
                break;
            case INFO:
                if (log.isInfoEnabled()) {
                    log.debug(logMessage(exchange));
                }
                break;
            case TRACE:
                if (log.isTraceEnabled()) {
                    log.trace(logMessage(exchange));
                }
                break;
            case WARN:
                if (log.isWarnEnabled()) {
                    log.warn(logMessage(exchange));
                }
                break;
            default:
                log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }

    public void log(String message) {
        switch (level) {
            case DEBUG:
                if (log.isDebugEnabled()) {
                    log.debug(message);
                }
                break;
            case ERROR:
                if (log.isErrorEnabled()) {
                    log.error(message);
                }
                break;
            case FATAL:
                if (log.isFatalEnabled()) {
                    log.fatal(message);
                }
                break;
            case INFO:
                if (log.isInfoEnabled()) {
                    log.debug(message);
                }
                break;
            case TRACE:
                if (log.isTraceEnabled()) {
                    log.trace(message);
                }
                break;
            case WARN:
                if (log.isWarnEnabled()) {
                    log.warn(message);
                }
                break;
            default:
                log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message);
        }
    }

    public void log(String message, Throwable exception) {
        switch (level) {
            case DEBUG:
                if (log.isDebugEnabled()) {
                    log.debug(message, exception);
                }
                break;
            case ERROR:
                if (log.isErrorEnabled()) {
                    log.error(message, exception);
                }
                break;
            case FATAL:
                if (log.isFatalEnabled()) {
                    log.fatal(message, exception);
                }
                break;
            case INFO:
                if (log.isInfoEnabled()) {
                    log.debug(message, exception);
                }
                break;
            case TRACE:
                if (log.isTraceEnabled()) {
                    log.trace(message, exception);
                }
                break;
            case WARN:
                if (log.isWarnEnabled()) {
                    log.warn(message, exception);
                }
                break;
            default:
                log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message, exception);
        }
    }

    protected Object logMessage(Exchange exchange) {
        return exchange;
    }

    public Log getLog() {
        return log;
    }

    public void setLog(Log log) {
        this.log = log;
    }

    public LoggingLevel getLevel() {
        return level;
    }

    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
}
"
org/apache/camel/processor/Pipeline.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;

import java.util.Collection;

/**
 * Creates a Pipeline pattern where the output of the previous step is sent as input to the next step when working
 * with request/response message exchanges.
 *
 * @version $Revision$
 */
public class Pipeline extends MulticastProcessor implements Processor {
    public Pipeline(Collection<Endpoint> endpoints) throws Exception {
        super(endpoints);
    }

    public void process(Exchange exchange) throws Exception {
        Exchange nextExchange = exchange;
        boolean first = true;
        for (Producer producer : getProducers()) {
            if (first) {
                first = false;
            }
            else {
                nextExchange = createNextExchange(producer, nextExchange);
            }
            producer.process(nextExchange);
        }
    }

    /**
     * Strategy method to create the next exchange from the
     *
     * @param producer         the producer used to send to the endpoint
     * @param previousExchange the previous exchange
     * @return a new exchange
     */
    protected Exchange createNextExchange(Producer producer, Exchange previousExchange) {
        Exchange answer = producer.createExchange(previousExchange);

        // now lets set the input of the next exchange to the output of the previous message if it is not null
        Object output = previousExchange.getOut().getBody();
        if (output != null) {
            answer.getIn().setBody(output);
        }
        return answer;
    }

    /**
     * Strategy method to copy the exchange before sending to another endpoint. Derived classes such as the
     * {@link Pipeline} will not clone the exchange
     *
     * @param exchange
     * @return the current exchange if no copying is required such as for a pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Exchange exchange) {
        return exchange.copy();
    }

    @Override
    public String toString() {
        return ""Pipeline"" + getEndpoints();
    }
}
"
org/apache/camel/component/jmx/JMXComponent.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;

import java.util.Map;
import javax.management.MBeanServer;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;

/**
 * The <a href=""http://activemq.apache.org/camel/jmx.html"">JMX Component</a> for monitoring jmx attributes
 *
 * @version $Revision: 523772 $
 */
public class JMXComponent extends DefaultComponent <JMXExchange>{
	private MBeanServer mbeanServer;
	
    public JMXComponent() {
    }

    public JMXComponent(CamelContext context) {
        super(context);
    }

    protected Endpoint<JMXExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
       
        JMXEndpoint result = new JMXEndpoint(remaining, this);
        IntrospectionSupport.setProperties(result, parameters);
        result.setMbeanServer(getMbeanServer());
        return result;
    }

	
    public MBeanServer getMbeanServer(){
    	return mbeanServer;
    }

	
    public void setMbeanServer(MBeanServer mbeanServer){
    	this.mbeanServer=mbeanServer;
    }
}
"
org/apache/camel/util/NoFactoryAvailableException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.io.IOException;

/**
 * Thrown if no factory resource is available for the given URI
 *
 * @version $Revision$
 */
public class NoFactoryAvailableException extends IOException {
    private final String uri;

    public NoFactoryAvailableException(String uri) {
        super(""Could not find factory class for resource: "" + uri);
        this.uri = uri;
    }

    public String getUri() {
        return uri;
    }
}
"
org/apache/camel/builder/ToBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.SendProcessor;

/**
 * @version $Revision$
 */
public class ToBuilder<E extends Exchange> extends FromBuilder {
    private Endpoint destination;

    public ToBuilder(FromBuilder parent, Endpoint endpoint) {
        super(parent);
        this.destination = endpoint;
    }

    @Override
    public Processor createProcessor() {
        return new SendProcessor(destination);
    }
}
"
org/apache/camel/impl/ScheduledPollEndpoint.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Exchange;
import org.apache.camel.Endpoint;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.util.IntrospectionSupport;

import java.util.Map;

/**
 * A base class for {@link Endpoint} which creates a {@link ScheduledPollConsumer}
 *
 * @version $Revision: 1.1 $
 */
public abstract class ScheduledPollEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private Map consumerProperties;

    protected ScheduledPollEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }

    public Map getConsumerProperties() {
        return consumerProperties;
    }

    public void setConsumerProperties(Map consumerProperties) {
        this.consumerProperties = consumerProperties;
    }

    protected void configureConsumer(Consumer<E> consumer) {
        if (consumerProperties != null) {
            IntrospectionSupport.setProperties(consumer, consumerProperties);
        }
    }

    public void configureProperties(Map options) {
        Map consumerProperties = IntrospectionSupport.extractProperties(options, ""consumer."");
        if (consumerProperties != null) {
            setConsumerProperties(consumerProperties);
        }
    }

}
"
org/apache/camel/component/jmx/JMXConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;

import javax.management.Notification;
import javax.management.NotificationListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;

/**
 * Generate an Exchange after getting a JMX Notification
 * @version $Revision: 523016 $
 */
public class JMXConsumer extends DefaultConsumer implements
        NotificationListener {

	JMXEndpoint jmxEndpoint;

	public JMXConsumer(JMXEndpoint endpoint,Processor processor){
		super(endpoint,processor);
		this.jmxEndpoint=endpoint;
	}

	public void handleNotification(Notification notification,Object handback){
		try{
			getProcessor().process(jmxEndpoint.createExchange(notification));
		}catch(Throwable e){
			handleException(e);
		}
	}
}
"
org/apache/camel/util/IntrospectionSupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class IntrospectionSupport {
        
	
    static public boolean getProperties(Object target, Map props, String optionPrefix) {
    	
        boolean rc = false;
        if( target == null )
            throw new IllegalArgumentException(""target was null."");
        if( props == null )
            throw new IllegalArgumentException(""props was null."");
        
        if( optionPrefix == null )
        	optionPrefix="""";
        
        Class clazz = target.getClass();
        Method[] methods = clazz.getMethods();
        for (int i = 0; i < methods.length; i++) {
            Method method = methods[i];
            String name = method.getName();
            Class type = method.getReturnType();
            Class params[] = method.getParameterTypes();
            if( name.startsWith(""get"") && params.length==0 && 
            		type!=null && isSettableType(type)) {

            	try {
            		
            		Object value = method.invoke(target, new Object[]{});
            		if( value == null )
            			continue;
            		
            		String strValue = convertToString(value, type);
            		if( strValue ==null )
            			continue;
            		
                    name = name.substring(3,4).toLowerCase()+name.substring(4);
                    props.put(optionPrefix+name, strValue);
                    rc = true;
                    
            	} catch ( Throwable ignore) {
            	}
            	
            }
        }
        
        return rc;
    }
	
	
	
    static public boolean setProperties(Object target, Map props, String optionPrefix) {
        boolean rc = false;
        if( target == null )
            throw new IllegalArgumentException(""target was null."");
        if( props == null )
            throw new IllegalArgumentException(""props was null."");
        
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String) iter.next();
            if( name.startsWith(optionPrefix) ) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                if( setProperty(target, name, value) ) {
                    iter.remove();
                    rc = true;
                }
            }
        }
        return rc;
    }
    
    public static Map extractProperties(Map props, String optionPrefix) {
        if( props == null )
            throw new IllegalArgumentException(""props was null."");

        HashMap rc = new HashMap(props.size());
        
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String) iter.next();
            if( name.startsWith(optionPrefix) ) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                rc.put(name, value);
                iter.remove();
            }
        }
        
        return rc;
    }
          
    public static boolean setProperties(Object target, Map props) {
    	boolean rc = false;
    	
        if( target == null )
            throw new IllegalArgumentException(""target was null."");
        if( props == null )
            throw new IllegalArgumentException(""props was null."");
        
        for (Iterator iter = props.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Entry) iter.next();
            if( setProperty(target, (String) entry.getKey(), entry.getValue()) ) {
                iter.remove();
                rc=true;
            }
        }
        
        return rc;
    }

    public static boolean setProperty(Object target, String name, Object value) {
        try {
            Class clazz = target.getClass();
            Method setter = findSetterMethod(clazz, name);
            if( setter == null )
                return false;
            
            // If the type is null or it matches the needed type, just use the value directly
            if( value == null || value.getClass()==setter.getParameterTypes()[0] ) {
                setter.invoke(target, new Object[]{value});
            } else {
                // We need to convert it
                setter.invoke(target, new Object[]{ convert(value, setter.getParameterTypes()[0]) });
            }
            return true;
        } catch (Throwable ignore) {
            return false;
        }
    }

    private static Object convert(Object value, Class type) throws URISyntaxException {
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if( editor != null ) { 
            editor.setAsText(value.toString());
            return editor.getValue();
        }
        if( type == URI.class ) {
            return new URI(value.toString());
        }
        return null;
    }

    private static String convertToString(Object value, Class type) throws URISyntaxException {
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if( editor != null ) { 
            editor.setValue(value);
            return editor.getAsText();
        }
        if( type == URI.class ) {
            return ((URI)value).toString();
        }
        return null;
    }

    private static Method findSetterMethod(Class clazz, String name) {
        // Build the method name.
        name = ""set""+name.substring(0,1).toUpperCase()+name.substring(1);
        Method[] methods = clazz.getMethods();
        for (int i = 0; i < methods.length; i++) {
            Method method = methods[i];
            Class params[] = method.getParameterTypes();
            if( method.getName().equals(name) 
                    && params.length==1
                    && isSettableType(params[0])) {
                return method;
            }
        }
        return null;
    }

    private static boolean isSettableType(Class clazz) {
        if( PropertyEditorManager.findEditor(clazz)!=null )
            return true;
        if( clazz == URI.class )
            return true;
        if( clazz == Boolean.class )
            return true;
        return false;
    }

    static public String toString(Object target) {
        return toString(target, Object.class);
    }

    static public String toString(Object target, Class stopClass) {
        LinkedHashMap map = new LinkedHashMap();
        addFields(target, target.getClass(), stopClass, map);
        StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
        buffer.append("" {"");
        Set entrySet = map.entrySet();
        boolean first = true;
        for (Iterator iter = entrySet.iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (first) {
                first = false;
            }
            else {
                buffer.append("", "");
            }
            buffer.append(entry.getKey());
            buffer.append("" = "");
            appendToString(buffer, entry.getValue());
        }
        buffer.append(""}"");
        return buffer.toString();
    }

    protected static void appendToString(StringBuffer buffer, Object value) {
//        if (value instanceof ActiveMQDestination) {
//            ActiveMQDestination destination = (ActiveMQDestination) value;
//            buffer.append(destination.getQualifiedName());
//        }
//        else {
            buffer.append(value);
//        }
    }

    static public String simpleName(Class clazz) {
        String name = clazz.getName();
        int p = name.lastIndexOf(""."");
        if( p >= 0 ) {
            name = name.substring(p+1);
        }
        return name;
    }
    

    static private void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
        
        if( startClass!=stopClass ) 
            addFields( target, startClass.getSuperclass(), stopClass, map );
        
        Field[] fields = startClass.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            if( Modifier.isStatic(field.getModifiers()) || 
                Modifier.isTransient(field.getModifiers()) ||
                Modifier.isPrivate(field.getModifiers())  ) {
                continue;
            }
            
            try {
                field.setAccessible(true);
                Object o = field.get(target);
                if( o!=null && o.getClass().isArray() ) {
                    try {
                        o = Arrays.asList((Object[]) o);
                    } catch (Throwable e) {
                    }
                }
                map.put(field.getName(), o);
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
        
    }

    
}
"
org/apache/camel/util/ObjectHelper.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.RuntimeCamelException;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

/**
 * @version $Revision$
 */
public class ObjectHelper {
    private static final transient Log log = LogFactory.getLog(ObjectHelper.class);

    /**
     * A helper method for comparing objects for equality while handling nulls
     */
    public static boolean equals(Object a, Object b) {
        if (a == b) {
            return true;
        }
        return a != null && b != null && a.equals(b);
    }

    /**
     * A helper method for performing an ordered comparsion on the objects
     * handling nulls and objects which do not
     * handle sorting gracefully
     */
    public static int compare(Object a, Object b) {
        if (a == b) {
            return 0;
        }
        if (a == null) {
            return -1;
        }
        if (b == null) {
            return 1;
        }
        if (a instanceof Comparable) {
            Comparable comparable = (Comparable) a;
            return comparable.compareTo(b);
        }
        else {
            int answer = a.getClass().getName().compareTo(b.getClass().getName());
            if (answer == 0) {
                answer = a.hashCode() - b.hashCode();
            }
            return answer;
        }
    }

    public static void notNull(Object value, String name) {
        if (value == null) {
            throw new IllegalArgumentException(""No "" + name + "" specified"");
        }
    }

    public static String[] splitOnCharacter(String value, String needle, int count) {
        String rc[] = new String[count];
        rc[0] = value;
        for (int i = 1; i < count; i++) {
            String v = rc[i - 1];
            int p = v.indexOf(needle);
            if (p < 0) {
                return rc;
            }
            rc[i - 1] = v.substring(0, p);
            rc[i] = v.substring(p + 1);
        }
        return rc;
    }

    /**
     * Removes any starting characters on the given text which match the given character
     *
     * @param text the string
     * @param ch   the initial characters to remove
     * @return either the original string or the new substring
     */
    public static String removeStartingCharacters(String text, char ch) {
        int idx = 0;
        while (text.charAt(idx) == ch) {
            idx++;
        }
        if (idx > 0) {
            return text.substring(idx);
        }
        return text;
    }

    /**
     * Returns true if the collection contains the specified value
     */
    public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection) collectionOrArray;
            return collection.contains(value);
        }
        else {
            Iterator iter = ObjectConverter.iterator(value);
            while (iter.hasNext()) {
                if (equals(value, iter.next())) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Returns the predicate matching boolean on a {@link List} result set
     * where if the first element is a boolean its value is used
     * otherwise this method returns true if the collection is not empty
     *
     * @returns true if the first element is a boolean and its value is true or if the list is non empty
     */
    public static boolean matches(List list) {
        if (!list.isEmpty()) {
            Object value = list.get(0);
            if (value instanceof Boolean) {
                Boolean flag = (Boolean) value;
                return flag.booleanValue();
            }
            else {
                // lets assume non-empty results are true
                return true;
            }
        }
        return false;
    }

    public static boolean isNotNullOrBlank(String text) {
        return text != null && text.trim().length() > 0;
    }

    /**
     * A helper method to access a system property, catching any security exceptions
     *
     * @param name         the name of the system property required
     * @param defaultValue the default value to use if the property is not available or a security exception prevents access
     * @return the system property value or the default value if the property is not available or security does not allow its access
     */
    public static String getSystemProperty(String name, String defaultValue) {
        try {
            return System.getProperty(name, defaultValue);
        }
        catch (Exception e) {
            if (log.isDebugEnabled()) {
                log.debug(""Caught security exception accessing system property: "" + name + "". Reason: "" + e, e);
            }
            return defaultValue;
        }
    }

    /**
     * Returns the type name of the given type or null if the type variable is null
     */
    public static String name(Class type) {
        return type != null ? type.getName() : null;
    }

    /**
     * Returns the type name of the given value
     */
    public static String className(Object value) {
        return name(value != null ? value.getClass() : null);
    }

    /**
     * Attempts to load the given class name using the thread context class loader
     * or the class loader used to load this class
     *
     * @param name the name of the class to load
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name) {
        return loadClass(name, ObjectHelper.class.getClassLoader());
    }

    /**
     * Attempts to load the given class name using the thread context class loader or the given class loader
     *
     * @param name   the name of the class to load
     * @param loader the class loader to use after the thread context class loader
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name, ClassLoader loader) {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if (contextClassLoader != null) {
            try {
                return contextClassLoader.loadClass(name);
            }
            catch (ClassNotFoundException e) {
                try {
                    return loader.loadClass(name);
                }
                catch (ClassNotFoundException e1) {
                    log.debug(""Could not find class: "" + name + "". Reason: "" + e);
                }
            }
        }
        return null;
    }

    /**
     * A helper method to invoke a method via reflection and wrap any exceptions
     * as {@link RuntimeCamelException} instances
     *
     * @param method     the method to invoke
     * @param instance   the object instance (or null for static methods)
     * @param parameters the parameters to the method
     * @return the result of the method invocation
     */
    public static Object invokeMethod(Method method, Object instance, Object... parameters) {
        try {
            return method.invoke(instance, parameters);
        }
        catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
        catch (InvocationTargetException e) {
            throw new RuntimeCamelException(e.getCause());
        }
    }

    /**
     * Returns a list of methods which are annotated with the given annotation
     *
     * @param type           the type to reflect on
     * @param annotationType the annotation type
     * @return a list of the methods found
     */
    public static List<Method> findMethodsWithAnnotation(Class<?> type, Class<? extends Annotation> annotationType) {
        List<Method> answer = new ArrayList<Method>();
        do {
            Method[] methods = type.getDeclaredMethods();
            for (Method method : methods) {
                if (method.getAnnotation(annotationType) != null) {
                    answer.add(method);
                }
            }
            type = type.getSuperclass();
        }
        while (type != null);
        return answer;
    }

    /**
     * Turns the given object arrays into a meaningful string
     *
     * @param objects an array of objects or null
     * @return a meaningful string
     */
    public static String asString(Object[] objects) {
        if (objects == null) {
            return ""null"";
        }
        else {
            StringBuffer buffer = new StringBuffer(""{"");
            int counter = 0;
            for (Object object : objects) {
                if (counter++ > 0) {
                    buffer.append("", "");
                }
                String text = (object == null) ? ""null"" : object.toString();
                buffer.append(text);
            }
            buffer.append(""}"");
            return buffer.toString();
        }
    }
}
"
org/apache/camel/processor/Resequencer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.LoggingExceptionHandler;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ExpressionListComparator;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
 *
 * @version $Revision: 1.1 $
 */
public class Resequencer extends ServiceSupport implements Runnable {
    private static final transient Log log = LogFactory.getLog(Resequencer.class);
    private Endpoint endpoint;
    private Processor processor;
    private Set<Exchange> set;
    private long batchTimeout = 1000L;
    private int batchSize = 100;
    private PollingConsumer consumer;
    private ExceptionHandler exceptionHandler;

    public Resequencer(Endpoint endpoint, Processor processor, Expression<Exchange> expression) {
        this(endpoint, processor, createSet(expression));
    }

    public Resequencer(Endpoint endpoint, Processor processor, List<Expression<Exchange>> expressions) {
        this(endpoint, processor, createSet(expressions));
    }

    public Resequencer(Endpoint endpoint, Processor processor, Set<Exchange> set) {
        this.endpoint = endpoint;
        this.processor = processor;
        this.set = set;
    }

    @Override
    public String toString() {
        return ""Resequencer[to: "" + processor + ""]"";
    }

    public void run() {
        log.debug(""Starting thread for "" + this);
        while (!isStopped() && !isStopping()) {
            try {
                processBatch();
            }
            catch (Exception e) {
                getExceptionHandler().handleException(e);
            }
        }
        set.clear();
    }

    // Properties
    //-------------------------------------------------------------------------
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }

    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    public int getBatchSize() {
        return batchSize;
    }

    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }

    public long getBatchTimeout() {
        return batchTimeout;
    }

    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }

    // Implementation methods
    //-------------------------------------------------------------------------

    /**
     * A transactional method to process a batch of messages up to a timeout period
     * or number of messages reached.
     */
    protected synchronized void processBatch() throws Exception {
        long start = System.currentTimeMillis();
        long end = start + batchTimeout;
        for (int i = 0; i < batchSize; i++) {
            long timeout = end - System.currentTimeMillis();

            Exchange exchange = consumer.receive(timeout);
            if (exchange == null) {
                break;
            }
            set.add(exchange);
        }

        if (log.isDebugEnabled()) {
            log.debug(""Finsihed batch size: "" + batchSize + "" timeout: "" + batchTimeout + "" so sending set: "" + set);
        }

        // lets send the batch
        Iterator<Exchange> iter = set.iterator();
        while (iter.hasNext()) {
            Exchange exchange = iter.next();
            iter.remove();
            processor.process(exchange);
        }
    }

    protected void doStart() throws Exception {
        consumer = endpoint.createPollingConsumer();

        ServiceHelper.startServices(processor, consumer);

        Thread thread = new Thread(this, this + "" Polling Thread"");
        thread.start();
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(consumer, processor);
        consumer = null;
    }

    protected static Set<Exchange> createSet(Expression<Exchange> expression) {
        return createSet(new ExpressionComparator<Exchange>(expression));
    }

    protected static Set<Exchange> createSet(List<Expression<Exchange>> expressions) {
        if (expressions.size() == 1) {
            return createSet(expressions.get(0));
        }
        return createSet(new ExpressionListComparator<Exchange>(expressions));
    }

    protected static Set<Exchange> createSet(Comparator<? super Exchange> comparator) {
        return new TreeSet<Exchange>(comparator);
    }
}
"
org/apache/camel/spi/Injector.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

/**
 * A pluggable strategy for creating and possibly dependency injecting objects
 * which could be implemented using straight forward reflection or using Spring or Guice to perform dependency injection.
 *
 * @version $Revision$
 */
public interface Injector<T> {
    /**
     * Instantiates a new instance of the given type possibly injecting values into the object in the process
     *
     * @param type the type of object to create
     * @return a newly created instance
     */
    T newInstance(Class<T> type);
}
"
org/apache/camel/impl/PollingConsumerSupport.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.spi.ExceptionHandler;

/**
 * A useful base class for implementations of {@link PollingConsumer}
 *
 * @version $Revision: 1.1 $
 */
public abstract class PollingConsumerSupport<E extends Exchange> extends ServiceSupport implements PollingConsumer<E> {
    private final Endpoint<E> endpoint;
    private ExceptionHandler exceptionHandler;

    public PollingConsumerSupport(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }

    @Override
    public String toString() {
        return ""PullConsumer on "" + endpoint;
    }

    public Endpoint<E> getEndpoint() {
        return endpoint;
    }

    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }

    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     *
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org/apache/camel/component/pojo/timer/TimerEndpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo.timer;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Date;
import java.util.Map;

import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;

/**
 * Represents a timer endpoint that can generate periodic inbound PojoExchanges. 
 *
 * @version $Revision: 519973 $
 */
public class TimerEndpoint extends DefaultEndpoint<PojoExchange> {
	
    private final TimerComponent component;
	private final String timerName;
    private Date time;
    private long period=-1;
    private long delay=-1;
    private boolean fixedRate;
    private boolean daemon=true;


    public TimerEndpoint(String fullURI, TimerComponent component, String timerPartURI) throws URISyntaxException {
        super(fullURI, component);
        this.component = component;
		
        // Use a URI to extract query so they can be set as properties on the endpoint.
        URI u = new URI(timerPartURI);
        Map options = URISupport.parseParamters(u);
		IntrospectionSupport.setProperties(this, options);
		this.timerName = u.getPath();
		
    }

    public Producer<PojoExchange> createProducer() throws Exception {
    	throw new RuntimeCamelException(""Cannot produce to a TimerEndpoint: ""+getEndpointUri());
    }

    public Consumer<PojoExchange> createConsumer(Processor processor) throws Exception {    	
        return new TimerConsumer(this, processor);
    }

    public PojoExchange createExchange() {
        return new PojoExchange(getContext());
    }

	public TimerComponent getComponent() {
		return component;
	}

	public String getTimerName() {
		return timerName;
	}

	public boolean isDaemon() {
		return daemon;
	}

	public void setDaemon(boolean daemon) {
		this.daemon = daemon;
	}

	public long getDelay() {
		return delay;
	}

	public void setDelay(long delay) {
		this.delay = delay;
	}

	public boolean isFixedRate() {
		return fixedRate;
	}

	public void setFixedRate(boolean fixedRate) {
		this.fixedRate = fixedRate;
	}

	public long getPeriod() {
		return period;
	}

	public void setPeriod(long period) {
		this.period = period;
	}

	public Date getTime() {
		return time;
	}

	public void setTime(Date time) {
		this.time = time;
	}

	public boolean isSingleton() {
		return true;
	}

}
"
org/apache/camel/component/jmx/JMXMessage.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;

import javax.management.Notification;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultMessage;

/**
 * A {@link Message} for a JMX Notification
 * 
 * @version $Revision: 520985 $
 */
public class JMXMessage extends DefaultMessage {

	private Notification notification;

	public JMXMessage() {
        this(null);
    }

	public JMXMessage(Notification notification){
		this.notification=notification;
	}

	@Override public String toString(){
		return ""JMXMessage: ""+notification;
	}

	@Override public JMXExchange getExchange(){
		return (JMXExchange)super.getExchange();
	}

	@Override public JMXMessage newInstance(){
		return new JMXMessage();
	}

	
    public Notification getNotification(){
    	return notification;
    }
}
"
org/apache/camel/spi/XmlMarshaller.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import java.io.IOException;
import java.io.OutputStream;

import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;

/**
 * Marshallers that marshall to XML should extend this base class.
 *
 * @version $Revision: 520124 $
 */
public abstract class XmlMarshaller implements Marshaller{
	
	/**
     * Marshals the object to the given Stream.
     */
	public void marshal(Object object, OutputStream result) throws IOException {
		marshal(object, new StreamResult(result));
	}

	abstract public void marshal(Object object, Result result);
}
"
org/apache/camel/PollingConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Represents a <a href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling Consumer</a> where the caller
 * polls for messages when it is ready.
 * 
 * @version $Revision: 1.1 $
 */
public interface PollingConsumer<E extends Exchange> extends Consumer<E> {
    
    /**
     * Waits until a message is available and then returns it. Warning that this method
     * could block indefinitely if no messages are available.
     *
     * @return the message exchange received.
     */
    E receive();

    /**
     * Attempts to receive a message exchange immediately without waiting
     * and returning null if a message exchange is not available yet.
     *
     * @return the message exchange if one is immediately available otherwise null
     */
    E receiveNoWait();

    /**
     * Attempts to receive a message exchange, waiting up to the given timeout to expire
     * if a message is not yet available
     *
     * @param timeout the amount of time in milliseconds to wait for a message before timing out and
     * returning null
     *
     * @return the message exchange if one iwas available within the timeout period, or null if the timeout expired
     */
    E receive(long timeout);

}
"
org/apache/camel/converter/ObjectConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;

import org.apache.camel.Converter;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;

/**
 * Some core java.lang based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public class ObjectConverter {
    public static boolean isCollection(Object value) {
        // TODO we should handle primitive array types?
        return value instanceof Collection || (value != null && value.getClass().isArray());
    }

    /**
     * Creates an iterator over the value if the value is a collection, an Object[] or a primitive type array; otherwise
     * to simplify the caller's code, we just create a singleton collection iterator over a single value
     */
    @Converter
    public static Iterator iterator(Object value) {
        if (value == null) {
            return Collections.EMPTY_LIST.iterator();
        }
        else if (value instanceof Collection) {
            Collection collection = (Collection) value;
            return collection.iterator();
        }
        else if (value.getClass().isArray()) {
            // TODO we should handle primitive array types?
            return Arrays.asList(value).iterator();
        }
        else {
            return Collections.singletonList(value).iterator();
        }
    }

    /**
     * Converts the given value to a boolean, handling strings or Boolean objects;
     * otherwise returning false if the value could not be converted to a boolean
     */
    @Converter
    public static boolean toBool(Object value) {
        Boolean answer = toBoolean(value);
        if (answer != null) {
            return answer.booleanValue();
        }
        return false;
    }

    /**
     * Converts the given value to a Boolean, handling strings or Boolean objects;
     * otherwise returning null if the value cannot be converted to a boolean
     */
    @Converter
    public static Boolean toBoolean(Object value) {
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        if (value instanceof String) {
            return ""true"".equalsIgnoreCase(value.toString()) ? Boolean.TRUE : Boolean.FALSE;
        }
        return null;
    }
}
"
org/apache/camel/component/queue/QueueEndpoint.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.queue;

import java.util.concurrent.BlockingQueue;

import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;

/**
 * Represents a queue endpoint that uses a {@link BlockingQueue}
 * object to process inbound exchanges.
 *
 * @org.apache.xbean.XBean
 * @version $Revision: 519973 $
 */
public class QueueEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private BlockingQueue<E> queue;

    public QueueEndpoint(String uri, QueueComponent<E> component) {
        super(uri, component);
        this.queue = component.createQueue();
    }

    public Producer<E> createProducer() throws Exception {
        return new DefaultProducer(this) {
            public void process(Exchange exchange) {
                queue.add(toExchangeType(exchange));
            }
        };
    }

    public Consumer<E> createConsumer(Processor processor) throws Exception {
        return new QueueEndpointConsumer<E>(this, processor);
    }

    public E createExchange() {
    	// How can we create a specific Exchange if we are generic??
    	// perhaps it would be better if we did not implement this. 
        return (E) new DefaultExchange(getContext());
    }

    public BlockingQueue<E> getQueue() {
        return queue;
    }
    
	public boolean isSingleton() {
		return true;
	}


}
"
org/apache/camel/impl/ReflectionInjector.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Injector;

/**
 * A simple implementation of {@link Injector} which just uses reflection to instantiate new objects
 * using their zero argument constructor. For more complex implementations try the Spring or Guice implementations.
 *
 * @version $Revision$
 */
public class ReflectionInjector<T> implements Injector<T> {
    
    public T newInstance(Class<T> type) {
        try {
            return type.newInstance();
        }
        catch (InstantiationException e) {
            throw new RuntimeCamelException(e.getCause());
        }
        catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
}
"
org/apache/camel/component/pojo/timer/TimerComponent.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo.timer;

import org.apache.camel.component.pojo.PojoExchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.Endpoint;

import java.util.ArrayList;
import java.util.Map;

/**
 * Represents the component that manages {@link TimerEndpoint}.  It holds the
 * list of {@link TimerConsumer} objects that are started.
 *
 * @version $Revision: 519973 $
 */
public class TimerComponent extends DefaultComponent<PojoExchange> {
    protected final ArrayList<TimerConsumer> timers = new ArrayList<TimerConsumer>();

    boolean addConsumer(TimerConsumer consumer) {
        return timers.add(consumer);
    }

    boolean removeConsumer(TimerConsumer consumer) {
        return timers.remove(consumer);
    }

    @Override
    protected Endpoint<PojoExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new TimerEndpoint(uri, this, remaining);
    }
}
"
org/apache/camel/converter/IOConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;

import org.apache.camel.Converter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.*;
import java.nio.ByteBuffer;

/**
 * Some core java.io based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public class IOConverter {
    private static final transient Log log = LogFactory.getLog(IOConverter.class);

    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }

    @Converter
    public static BufferedReader toReader(File file) throws FileNotFoundException {
        return new BufferedReader(new FileReader(file));
    }

    @Converter
    public static OutputStream toOutputStream(File file) throws FileNotFoundException {
        return new BufferedOutputStream(new FileOutputStream(file));
    }

    @Converter
    public static BufferedWriter toWriter(File file) throws IOException {
        return new BufferedWriter(new FileWriter(file));
    }

    @Converter
    public static Reader toReader(InputStream in) throws FileNotFoundException {
        return new InputStreamReader(in);
    }

    @Converter
    public static Writer toWriter(OutputStream out) throws FileNotFoundException {
        return new OutputStreamWriter(out);
    }


    @Converter
    public static StringReader toReader(String text) {
        // TODO could we automatically find this?
        return new StringReader(text);
    }

    @Converter
    public static InputStream toInputStream(String text) {
        return toInputStream(text.getBytes());
    }

    @Converter
    public static byte[] toByteArray(String text) {
        // TODO could we automatically find this?
        return text.getBytes();
    }

    @Converter
    public static String toString(byte[] data) {
        return new String(data);
    }

    @Converter
    public static String toString(Reader reader) throws IOException {
        if (reader instanceof BufferedReader) {
            return toString((BufferedReader) reader);
        }
        else {
            return toString(new BufferedReader(reader));
        }
    }

    @Converter
    public static String toString(BufferedReader reader) throws IOException {
        if (reader == null) {
            return null;
        }
        try {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    return builder.toString();
                }
                if (first) {
                    first = false;
                }
                else {
                    builder.append(""\n"");
                }
                builder.append(line);
            }
        }
        finally {
            try {
                reader.close();
            }
            catch (IOException e) {
                log.warn(""Failed to close stream: ""+ e, e);
            }
        }
    }
    
    @Converter
    public static String toString(InputStream in) throws IOException {
        return toString(toReader(in));
    }

    @Converter
    public static InputStream toInputStream(byte[] data) {
        return new ByteArrayInputStream(data);
    }
}
"
org/apache/camel/processor/DelegateProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.spi.Policy;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;

/**
 * A Delegate pattern which delegates processing to a nested processor which can be useful for implementation inheritence
 * when writing an {@link Policy}
 *
 * @version $Revision: 519941 $
 */
public class DelegateProcessor extends ServiceSupport implements Processor {
    protected Processor next;

    public DelegateProcessor() {
    }

    public DelegateProcessor(Processor next) {
        this.next = next;
    }

    public void process(Exchange exchange) throws Exception {
        processNext(exchange);
    }

    protected void processNext(Exchange exchange) throws Exception {
        if (next != null) {
            next.process(exchange);
        }
    }

    @Override
    public String toString() {
        return ""delegate("" + next + "")"";
    }

    public Processor getNext() {
        return next;
    }

    public void setNext(Processor next) {
        this.next = next;
    }

    protected void doStart() throws Exception {
        ServiceHelper.startServices(next);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(next);
    }
}
"
org/apache/camel/Header.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Marks a parameter as being a header on an inbound {@link Message}
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER})
public @interface Header {
    String name();
}
"
org/apache/camel/processor/idempotent/IdempotentConsumer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExpressionHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * An implementation of the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 1.1 $
 */
public class IdempotentConsumer extends ServiceSupport implements Processor {
    private static final transient Log log = LogFactory.getLog(IdempotentConsumer.class);
    private Expression<Exchange> messageIdExpression;
    private Processor nextProcessor;
    private MessageIdRepository messageIdRepository;

    public IdempotentConsumer(Expression<Exchange> messageIdExpression, MessageIdRepository messageIdRepository, Processor nextProcessor) {
        this.messageIdExpression = messageIdExpression;
        this.messageIdRepository = messageIdRepository;
        this.nextProcessor = nextProcessor;
    }

    @Override
    public String toString() {
        return ""IdempotentConsumer[expression="" + messageIdExpression + "", repository="" + messageIdRepository + "", processor="" + nextProcessor + ""]"";
    }

    public void process(Exchange exchange) throws Exception {
        String messageId = ExpressionHelper.evaluateAsString(messageIdExpression, exchange);
        if (messageId == null) {
            throw new NoMessageIdException(exchange, messageIdExpression);
        }
        if (!messageIdRepository.contains(messageId)) {
            nextProcessor.process(exchange);
        }
        else {
            onDuplicateMessage(exchange, messageId);
        }
    }

    // Properties
    //-------------------------------------------------------------------------
    public Expression<Exchange> getMessageIdExpression() {
        return messageIdExpression;
    }

    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }

    public Processor getNextProcessor() {
        return nextProcessor;
    }


    // Implementation methods
    //-------------------------------------------------------------------------

    protected void doStart() throws Exception {
        ServiceHelper.startServices(nextProcessor);
    }

    protected void doStop() throws Exception {
        ServiceHelper.stopServices(nextProcessor);
    }

    /**
     * A strategy method to allow derived classes to overload the behaviour of processing a duplicate message
     *
     * @param exchange the exchange
     * @param messageId the message ID of this exchange
     */
    protected void onDuplicateMessage(Exchange exchange, String messageId) {
        if (log.isDebugEnabled()) {
            log.debug(""Ignoring duplicate message with id: "" + messageId + "" for exchange: "" + exchange);
        }
    }
}
"
org/apache/camel/component/queue/QueueComponent.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.queue;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Represents the component that manages {@link QueueEndpoint}.  It holds the 
 * list of named queues that queue endpoints reference.
 *
 * @org.apache.xbean.XBean
 * @version $Revision: 519973 $
 */
public class QueueComponent<E extends Exchange> extends DefaultComponent<E> {
	
	public BlockingQueue<E> createQueue() {
		return new LinkedBlockingQueue<E>();
	}

    @Override
    protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new QueueEndpoint<E>(uri, this);
    }
}
"
org/apache/camel/component/direct/DirectComponent.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;

import java.net.URI;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.URISupport;

/**
 * Represents the component that manages {@link DirectEndpoint}.  It holds the 
 * list of named direct endpoints.
 *
 * @org.apache.xbean.XBean
 * @version $Revision: 519973 $
 */
public class DirectComponent<E extends Exchange> implements Component<E> {

	private CamelContext context;

	public CamelContext getCamelContext() {
		return context;
	}

	public ScheduledExecutorService getExecutorService() {
		return null;
	}

	public Endpoint<E> createEndpoint(String uri) throws Exception {

        ObjectHelper.notNull(getCamelContext(), ""camelContext"");        
        URI u = new URI(uri);
        Map parameters = URISupport.parseParamters(u);

        Endpoint<E> endpoint = new DirectEndpoint<E>(uri,this);
        if (parameters != null) {
            IntrospectionSupport.setProperties(endpoint, parameters);
        }
        return endpoint;
	}

	public void setCamelContext(CamelContext context) {
		this.context = context;
	}	

}
"
org/apache/camel/impl/converter/ToStringTypeConverter.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.TypeConverter;

/**
 * A simple converter that can convert any object to a String type by using the toString() method of the
 * object.
 * 
 * @version $Revision: 523731 $
 */
public class ToStringTypeConverter implements TypeConverter {

	public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(String.class)) {
                return (T) value.toString();
            }
        }
        return null;
	}

}
"
org/apache/camel/processor/MulticastProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.impl.ServiceSupport;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Implements the Multicast pattern to send a message exchange to a number of endpoints, each endpoint receiving a copy of
 * the message exchange.
 *
 * @version $Revision$
 */
public class MulticastProcessor extends ServiceSupport implements Processor {
    private Collection<Producer> producers;

    /**
     * A helper method to convert a list of endpoints into a list of processors
     */
    public static <E extends Exchange> Collection<Producer> toProducers(Collection<Endpoint> endpoints) throws Exception {
        Collection<Producer> answer = new ArrayList<Producer>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint.createProducer());
        }
        return answer;
    }

    public MulticastProcessor(Collection<Endpoint> endpoints) throws Exception {
        this.producers = toProducers(endpoints);
    }

    @Override
    public String toString() {
        return ""Multicast"" + getEndpoints();
    }

    public void process(Exchange exchange) throws Exception {
        for (Producer producer : producers) {
            Exchange copy = copyExchangeStrategy(producer, exchange);
            producer.process(copy);
        }
    }

    protected void doStop() throws Exception {
        for (Producer producer : producers) {
            producer.stop();
        }
    }

    protected void doStart() throws Exception {
        for (Producer producer : producers) {
            producer.start();
        }
    }

    /**
     * Returns the producers to multicast to
     */
    public Collection<Producer> getProducers() {
        return producers;
    }

    /**
     * Returns the list of endpoints
     */
    public Collection<Endpoint> getEndpoints() {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        for (Producer producer : producers) {
            answer.add(producer.getEndpoint());
        }
        return answer;
    }

    /**
     * Strategy method to copy the exchange before sending to another endpoint. Derived classes such as the
     * {@link Pipeline} will not clone the exchange
     *
     * @param producer the producer that will send the exchange
     * @param exchange @return the current exchange if no copying is required such as for a pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Producer producer, Exchange exchange) {
        return producer.createExchange(exchange);
    }
}
"
org/apache/camel/impl/DefaultCamelContext.java,true,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.Route;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Service;
import org.apache.camel.TypeConverter;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

/**
 * Represents the context used to configure routes and the policies to use.
 *
 * @version $Revision: 520517 $
 * @org.apache.xbean.XBean element=""container"" rootElement=""true""
 */
public class DefaultCamelContext extends ServiceSupport implements CamelContext, Service {
    private Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
    private Map<String, Component> components = new HashMap<String, Component>();
    private List<Route> routes;
    private List<Service> servicesToClose = new ArrayList<Service>();
    private TypeConverter typeConverter;
    private ExchangeConverter exchangeConverter;
    private Injector injector;
    private ComponentResolver componentResolver;
    private boolean autoCreateComponents = true;

    /**
     * Adds a component to the container.
     */
    public void addComponent(String componentName, final Component component) {
        if (component == null) {
            throw new IllegalArgumentException(""Component cannot be null"");
        }
        synchronized (components) {
            if (components.containsKey(componentName)) {
                throw new IllegalArgumentException(""Component previously added: "" + componentName);
            }
            component.setCamelContext(this);
            components.put(componentName, component);
        }
    }

    public Component getComponent(String name) {
        // synchronize the look up and auto create so that 2 threads can't
        // concurrently auto create the same component.
        synchronized (components) {
            Component component = components.get(name);
            if (component == null && autoCreateComponents) {
                try {
                    component = getComponentResolver().resolveComponent(name, this);
                    if (component != null) {
                        addComponent(name, component);
                        if (isStarted()) {
                            // If the component is looked up after the context is started,
                            // lets start it up.
                            startServices(component);
                        }
                    }
                }
                catch (Exception e) {
                    throw new RuntimeCamelException(""Could not auto create component: "" + name, e);
                }
            }
            return component;
        }
    }

    public <T extends Component> T getComponent(String name, Class<T> componentType) {
        Component component = getComponent(name);
        if (componentType.isInstance(component)) {
            return componentType.cast(component);
        }
        else {
            throw new IllegalArgumentException(""The component is not of type: "" + componentType + "" but is: "" + component);
        }
    }

    /**
     * Removes a previously added component.
     *
     * @param componentName
     * @return the previously added component or null if it had not been previously added.
     */
    public Component removeComponent(String componentName) {
        synchronized (components) {
            return components.remove(componentName);
        }
    }

    /**
     * Gets the a previously added component by name or lazily creates the component
     * using the factory Callback.
     *
     * @param componentName
     * @param factory       used to create a new component instance if the component was not previously added.
     * @return
     */
    public Component getOrCreateComponent(String componentName, Callable<Component> factory) {
        synchronized (components) {
            Component component = components.get(componentName);
            if (component == null) {
                try {
                    component = factory.call();
                    if (component == null) {
                        throw new RuntimeCamelException(""Factory failed to create the "" + componentName + "" component, it returned null."");
                    }
                    components.put(componentName, component);
                    component.setCamelContext(this);
                }
                catch (Exception e) {
                    throw new RuntimeCamelException(""Factory failed to create the "" + componentName + "" component"", e);
                }
            }
            return component;
        }
    }

    // Endpoint Management Methods
    //-----------------------------------------------------------------------

    public Collection<Endpoint> getSingletonEndpoints() {
        synchronized (endpoints) {
            return new ArrayList<Endpoint>(endpoints.values());
        }
    }

    public Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            startServices(endpoint);
            oldEndpoint = endpoints.remove(uri);
            endpoints.put(uri, endpoint);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }

    public Endpoint removeSingletonEndpoint(String uri) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            oldEndpoint = endpoints.remove(uri);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }

    /**
     * Resolves the given URI to an endpoint
     */
    public Endpoint getEndpoint(String uri) {
        Endpoint answer;
        synchronized (endpoints) {
            answer = endpoints.get(uri);
            if (answer == null) {
                try {

                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] == null) {
                        throw new IllegalArgumentException(""Invalid URI, it did not contain a scheme: "" + uri);
                    }
                    String scheme = splitURI[0];
                    Component component = getComponent(scheme);

                    // Ask the component to resolve the endpoint.
                    if (component != null) {

                        // Have the component create the endpoint if it can.
                        answer = component.createEndpoint(uri);

                        // If it's a singleton then auto register it.
                        if (answer != null && answer.isSingleton()) {
                            if (answer != null) {
                                startServices(answer);
                                endpoints.put(uri, answer);
                            }
                        }
                    }
                }
                catch (Exception e) {
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }
        return answer;
    }

    public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
        Endpoint endpoint = getEndpoint(name);
        if (endpointType.isInstance(endpoint)) {
            return endpointType.cast(endpoint);
        }
        else {
            throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: "" + endpoint);
        }
    }

    // Route Management Methods
    //-----------------------------------------------------------------------
    public List<Route> getRoutes() {
        return routes;
    }

    public void setRoutes(List<Route> routes) {
        this.routes = routes;
    }

    public void addRoutes(Collection<Route> routes) throws Exception {
        if (this.routes == null) {
            this.routes = new ArrayList<Route>(routes);
        }
        else {
            this.routes.addAll(routes);
        }
        if (isStarted()) {
            startRoutes(routes);
        }
    }

    public void addRoutes(RouteBuilder builder) throws Exception {
        // lets now add the routes from the builder
        builder.setContext(this);
        addRoutes(builder.getRouteList());
    }

    // Properties
    //-----------------------------------------------------------------------
    public ExchangeConverter getExchangeConverter() {
        if (exchangeConverter == null) {
            exchangeConverter = createExchangeConverter();
        }
        return exchangeConverter;
    }

    public void setExchangeConverter(ExchangeConverter exchangeConverter) {
        this.exchangeConverter = exchangeConverter;
    }

    public TypeConverter getTypeConverter() {
        if (typeConverter == null) {
            typeConverter = createTypeConverter();
        }
        return typeConverter;
    }

    public void setTypeConverter(TypeConverter typeConverter) {
        this.typeConverter = typeConverter;
    }

    public Injector getInjector() {
        if (injector == null) {
            injector = createInjector();
        }
        return injector;
    }

    public void setInjector(Injector injector) {
        this.injector = injector;
    }

    public ComponentResolver getComponentResolver() {
        if (componentResolver == null) {
            componentResolver = createComponentResolver();
        }
        return componentResolver;
    }

    public void setComponentResolver(ComponentResolver componentResolver) {
        this.componentResolver = componentResolver;
    }

    // Implementation methods
    //-----------------------------------------------------------------------

    protected void doStart() throws Exception {
        if (components != null) {
            for (Component component : components.values()) {
                startServices(component);
            }
        }
        startRoutes(routes);
    }

    protected void doStop() throws Exception {
        stopServices(servicesToClose);
        if (components != null) {
            for (Component component : components.values()) {
                stopServices(component);
            }
        }
    }

    protected void startRoutes(Collection<Route> routeList) throws Exception {
        if (routeList != null) {
            for (Route<Exchange> route : routeList) {
                List<Service> services = route.getServicesForRoute();
                servicesToClose.addAll(services);
                startServices(services);
            }
        }
    }

    /**
     * Lazily create a default implementation
     */
    protected ExchangeConverter createExchangeConverter() {
        return new DefaultExchangeConverter();
    }

    /**
     * Lazily create a default implementation
     */
    protected TypeConverter createTypeConverter() {
        return new DefaultTypeConverter();
    }

    /**
     * Lazily create a default implementation
     */
    protected Injector createInjector() {
        FactoryFinder finder = new FactoryFinder();
        try {
            return (Injector) finder.newInstance(""Injector"");
        }
        catch (NoFactoryAvailableException e) {
            // lets use the default
            return new ReflectionInjector();
        }
        catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
        catch (InstantiationException e) {
            throw new RuntimeCamelException(e);
        }
        catch (IOException e) {
            throw new RuntimeCamelException(e);
        }
        catch (ClassNotFoundException e) {
            throw new RuntimeCamelException(e);
        }
    }

    /**
     * Lazily create a default implementation
     */
    protected ComponentResolver createComponentResolver() {
        return new DefaultComponentResolver();
    }

    public boolean isAutoCreateComponents() {
        return autoCreateComponents;
    }

    public void setAutoCreateComponents(boolean autoCreateComponents) {
        this.autoCreateComponents = autoCreateComponents;
    }
}
"
org/apache/camel/spi/ExceptionHandler.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

/**
 * A Strategy pattern for handling exceptions; particularly in asynchronous processes such as consumers
 *
 * @version $Revision: 1.1 $
 */
public interface ExceptionHandler {
    
    /**
     * Handles the given exception
     *
     * @param exception the exception
     */
    void handleException(Throwable exception);
}
"
org/apache/camel/component/mock/MockComponent.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;

import org.apache.camel.Exchange;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;

import java.util.Map;

/**
 * A factory of {@link MockEndpoint} instances
 *
 * @version $Revision: 1.1 $
 */
public class MockComponent extends DefaultComponent<Exchange> {

    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new MockEndpoint(uri, this);
    }
}
"
org/apache/camel/CamelException.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Base class for all Camel checked exceptions typically thrown by a
 * {@link Processor}
 *
 * @version $Revision: $
 */
public class CamelException extends Exception {

    public CamelException() {
    }

    public CamelException(String message) {
        super(message);
    }

    public CamelException(String message, Throwable cause) {
        super(message, cause);
    }

    public CamelException(Throwable cause) {
        super(cause);
    }
}
"
org/apache/camel/processor/loadbalancer/RoundRobinLoadBalancer.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.List;

/**
 * Implements the round robin load balancing policy
 *
 * @version $Revision: 1.1 $
 */
public class RoundRobinLoadBalancer extends QueueLoadBalancer {
    private int counter = -1;

    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        if (++counter >= size) {
            counter = 0;
        }
        return processors.get(counter);
    }
}
"
org/apache/camel/processor/SendProcessor.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;

/**
 * @version $Revision$
 */
public class SendProcessor extends ServiceSupport implements Processor, Service {
    private Endpoint destination;
    private Producer producer;

    public SendProcessor(Endpoint destination) {
        this.destination = destination;
    }

    protected void doStop() throws Exception {
        if (producer != null) {
            try {
                producer.stop();
            }
            finally {
                producer = null;
            }
        }
    }

    protected void doStart() throws Exception {
        this.producer = destination.createProducer();
    }

    public void process(Exchange exchange) throws Exception {
        if (producer == null) {
            throw new IllegalStateException(""No producer, this processor has not been started!"");
        }
        producer.process(exchange);
    }

    public Endpoint getDestination() {
        return destination;
    }

    @Override
    public String toString() {
        return ""sendTo("" + destination + "")"";
    }
}
"
org/apache/camel/processor/LoggingLevel.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

/**
 * Used to configure the logging levels
 *
 * @version $Revision$
 */
public enum LoggingLevel {
    DEBUG, ERROR, FATAL, INFO, TRACE, WARN;
}
"
org/apache/camel/util/LRUCache.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A Least Recently Used Cache
 *
 * @version $Revision: 1.1 $
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final long serialVersionUID = -342098639681884413L;
    private int maxCacheSize = 10000;

    public LRUCache(int maximumCacheSize) {
        this(maximumCacheSize, maximumCacheSize, 0.75f, true);
    }

    /**
     * Constructs an empty <tt>LRUCache</tt> instance with the
     * specified initial capacity, maximumCacheSize,load factor and ordering mode.
     *
     * @param initialCapacity  the initial capacity.
     * @param maximumCacheSize
     * @param loadFactor       the load factor.
     * @param accessOrder      the ordering mode - <tt>true</tt> for
     *                         access-order, <tt>false</tt> for insertion-order.
     * @throws IllegalArgumentException if the initial capacity is negative
     *                                  or the load factor is nonpositive.
     */
    public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor, accessOrder);
        this.maxCacheSize = maximumCacheSize;
    }

    /**
     * @return Returns the maxCacheSize.
     */
    public int getMaxCacheSize() {
        return maxCacheSize;
    }

    protected boolean removeEldestEntry(Map.Entry entry) {
        return size() > maxCacheSize;
    }
}"
org/apache/camel/EndpointInject.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

/**
 * Used to indicate an injection point of an {@link Endpoint} or {@link Producer} in a POJO.
 * Either a <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an endpoint
 * should be configured, or a name of an endpoint
 * which refers to a Spring bean name in your Spring ApplicationContext.
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface EndpointInject {
    String uri() default """";
    String name() default """";
}
"
org/apache/camel/builder/PredicateBuilder.java,true,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import static org.apache.camel.util.ObjectHelper.compare;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.impl.PredicateSupport;
import org.apache.camel.impl.BinaryPredicateSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.notNull;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A helper class for working with predicates
 *
 * @version $Revision: 520261 $
 */
public class PredicateBuilder {
    /**
     * A helper method to combine multiple predicates by a logical AND
     */
    public static <E extends Exchange> Predicate<E> and(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) && right.matches(exchange);
            }

            @Override
            public String toString() {
                return ""("" + left + "") and ("" + right + "")"";
            }
        };
    }

    /**
     * A helper method to combine multiple predicates by a logical OR
     */
    public static <E extends Exchange> Predicate<E> or(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) || right.matches(exchange);
            }

            @Override
            public String toString() {
                return ""("" + left + "") or ("" + right + "")"";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isEqualTo(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.equals(leftValue, rightValue);
            }

            protected String getOperationText() {
                return ""=="";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isNotEqualTo(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return !ObjectHelper.equals(leftValue, rightValue);
            }

            protected String getOperationText() {
                return ""=="";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isLessThan(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) < 0;
            }

            protected String getOperationText() {
                return ""<"";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isLessThanOrEqualTo(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) <= 0;
            }

            protected String getOperationText() {
                return ""<="";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isGreaterThan(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) > 0;
            }

            protected String getOperationText() {
                return "">"";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isGreaterThanOrEqualTo(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) < 0;
            }

            protected String getOperationText() {
                return "">="";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> contains(final Expression<E> left, final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {

            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.contains(leftValue, rightValue);
            }

            protected String getOperationText() {
                return ""contains"";
            }
        };
    }

    public static <E extends Exchange> Predicate<E> isNull(final Expression<E> expression) {
        return isEqualTo(expression, ExpressionBuilder.<E>constantExpression(null));
    }

    public static <E extends Exchange> Predicate<E> isNotNull(final Expression<E> expression) {
        return isNotEqualTo(expression, ExpressionBuilder.<E>constantExpression(null));
    }

    public static <E extends Exchange> Predicate<E> isInstanceOf(final Expression<E> expression, final Class type) {
        notNull(expression, ""expression"");
        notNull(type, ""type"");

        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return type.isInstance(value);
            }

            @Override
            public String toString() {
                return expression + "" instanceof "" + type.getName();
            }

            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange) + "">"";
            }
        };
    }


    /**
     * Returns a predicate which is true if the expression matches the given regular expression
     *
     * @param expression the expression to evaluate
     * @param regex the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final String regex) {
        return regex(expression, Pattern.compile(regex));
    }

    /**
     * Returns a predicate which is true if the expression matches the given regular expression
     *
     * @param expression the expression to evaluate
     * @param pattern the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final Pattern pattern) {
        notNull(expression, ""expression"");
        notNull(pattern, ""pattern"");

        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                if (value != null) {
                    Matcher matcher = pattern.matcher(value.toString());
                    return matcher.matches();
                }
                return false;
            }

            @Override
            public String toString() {
                return expression + "".matches("" + pattern + "")"";
            }

            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange) + "">"";
            }

        };
    }

}
"
org/apache/camel/impl/converter/TypeConverterRegistry.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;

/**
 * @version $Revision$
 */
public interface TypeConverterRegistry {
    /**
     * Allows a new type converter to be bregistered
     *
     * @param toType        the type to convert to
     * @param fromType      the type to convert from
     * @param typeConverter the type converter to use
     */
    void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter);

    Injector getInjector();
}
"
org/apache/camel/spi/ExchangeConverter.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;

import org.apache.camel.Exchange;

/**
 * This converter is capable of converting from an exchange to another type
 *
 * @version $Revision$
 */
public interface ExchangeConverter {

     <T> T  convertTo(Class<T> type, Exchange exchange);
}
"
org/apache/camel/builder/FromBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.processor.CompositeProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.Policy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @version $Revision$
 */
public class FromBuilder extends BuilderSupport implements ProcessorFactory {
    public static final String DEFAULT_TRACE_CATEGORY = ""org.apache.camel.TRACE"";
    private RouteBuilder builder;
    private Endpoint from;
    private List<Processor> processors = new ArrayList<Processor>();
    private List<ProcessorFactory> processFactories = new ArrayList<ProcessorFactory>();
    private FromBuilder routeBuilder;

    public FromBuilder(RouteBuilder builder, Endpoint from) {
        super(builder);
        this.builder = builder;
        this.from = from;
    }

    public FromBuilder(FromBuilder parent) {
        super(parent);
        this.builder = parent.getBuilder();
        this.from = parent.getFrom();
    }

    /**
     * Sends the exchange to the given endpoint URI
     */
    @Fluent
    public ProcessorFactory to(@FluentArg(""uri"")String uri) {
        return to(endpoint(uri));
    }

    /**
     * Sends the exchange to the given endpoint
     */
    @Fluent
    public ProcessorFactory to(@FluentArg(""ref"")Endpoint endpoint) {
        ToBuilder answer = new ToBuilder(this, endpoint);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * Sends the exchange to a list of endpoints using the {@link MulticastProcessor} pattern
     */
    @Fluent
    public ProcessorFactory to(String... uris) {
        return to(endpoints(uris));
    }

    /**
     * Sends the exchange to a list of endpoints using the {@link MulticastProcessor} pattern
     */
    @Fluent
    public ProcessorFactory to(
            @FluentArg(value = ""endpoint"", attribute = false, element = true)
            Endpoint... endpoints) {
        return to(endpoints(endpoints));
    }

    /**
     * Sends the exchange to a list of endpoint using the {@link MulticastProcessor} pattern
     */
    @Fluent
    public ProcessorFactory to(@FluentArg(value = ""endpoint"", attribute = false, element = true)
    Collection<Endpoint> endpoints) {
        return addProcessBuilder(new MulticastBuilder(this, endpoints));
    }

    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message will get processed by each endpoint in turn
     * and for request/response the output of one endpoint will be the input of the next endpoint
     */
    @Fluent
    public ProcessorFactory pipeline(@FluentArg(""uris"")String... uris) {
        return pipeline(endpoints(uris));
    }

    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message will get processed by each endpoint in turn
     * and for request/response the output of one endpoint will be the input of the next endpoint
     */
    @Fluent
    public ProcessorFactory pipeline(@FluentArg(""endpoints"")Endpoint... endpoints) {
        return pipeline(endpoints(endpoints));
    }

    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message will get processed by each endpoint in turn
     * and for request/response the output of one endpoint will be the input of the next endpoint
     */
    @Fluent
    public ProcessorFactory pipeline(@FluentArg(""endpoints"")Collection<Endpoint> endpoints) {
        return addProcessBuilder(new PipelineBuilder(this, endpoints));
    }

    /**
     * Creates an {@link IdempotentConsumer} to avoid duplicate messages
     */
    @Fluent
    public IdempotentConsumerBuilder idempotentConsumer(
            @FluentArg(""messageIdExpression"")Expression messageIdExpression,
            @FluentArg(""MessageIdRepository"")MessageIdRepository messageIdRepository) {
        return (IdempotentConsumerBuilder) addProcessBuilder(new IdempotentConsumerBuilder(this, messageIdExpression, messageIdRepository));
    }

    /**
     * Creates a predicate which is applied and only if it is true then
     * the exchange is forwarded to the destination
     *
     * @return the builder for a predicate
     */
    @Fluent
    public FilterBuilder filter(
            @FluentArg(value = ""predicate"", element = true)
            Predicate predicate) {
        FilterBuilder answer = new FilterBuilder(this, predicate);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * Creates a choice of one or more predicates with an otherwise clause
     *
     * @return the builder for a choice expression
     */
    @Fluent(nestedActions = true)
    public ChoiceBuilder choice() {
        ChoiceBuilder answer = new ChoiceBuilder(this);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * Creates a dynamic <a href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a> pattern.
     *
     * @param receipients is the builder of the expression used in the {@link RecipientList} to decide the destinations
     */
    @Fluent
    public RecipientListBuilder recipientList(
            @FluentArg(value = ""recipients"", element = true)
            Expression receipients) {
        RecipientListBuilder answer = new RecipientListBuilder(this, receipients);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * A builder for the <a href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
     * where an expression is evaluated to iterate through each of the parts of a message and then each part is then send to some endpoint.
     *
     * @param receipients the expression on which to split
     * @return the builder
     */
    @Fluent
    public SplitterBuilder splitter(@FluentArg(value = ""recipients"", element = true)Expression receipients) {
        SplitterBuilder answer = new SplitterBuilder(this, receipients);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * A builder for the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a> pattern
     * where an expression is evaluated to be able to compare the message exchanges to reorder them. e.g. you
     * may wish to sort by some header
     *
     * @param expression the expression on which to compare messages in order
     * @return the builder
     */
    public ResequencerBuilder resequencer(Expression<Exchange> expression) {
        return resequencer(Collections.<Expression<Exchange>>singletonList(expression));
    }

    /**
     * A builder for the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a> pattern
     * where a list of expressions are evaluated to be able to compare the message exchanges to reorder them. e.g. you
     * may wish to sort by some headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    @Fluent
    public ResequencerBuilder resequencer(@FluentArg(value = ""expressions"")List<Expression<Exchange>> expressions) {
        ResequencerBuilder answer = new ResequencerBuilder(this, expressions);
        setRouteBuilder(answer);
        return answer;
    }

    /**
     * A builder for the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a> pattern
     * where a list of expressions are evaluated to be able to compare the message exchanges to reorder them. e.g. you
     * may wish to sort by some headers
     *
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    @Fluent
    public ResequencerBuilder resequencer(Expression<Exchange>... expressions) {
        List<Expression<Exchange>> list = new ArrayList<Expression<Exchange>>();
        for (Expression<Exchange> expression : expressions) {
            list.add(expression);
        }
        return resequencer(list);
    }

    /**
     * Installs the given error handler builder
     *
     * @param errorHandlerBuilder the error handler to be used by default for all child routes
     * @return the current builder with the error handler configured
     */
    @Fluent
    public FromBuilder errorHandler(@FluentArg(""handler"")ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }

    /**
     * Configures whether or not the error handler is inherited by every processing node (or just the top most one)
     *
     * @param condition the falg as to whether error handlers should be inherited or not
     * @return the current builder
     */
    @Fluent
    public FromBuilder inheritErrorHandler(@FluentArg(""condition"")boolean condition) {
        setInheritErrorHandler(condition);
        return this;
    }

    @Fluent(nestedActions = true)
    public InterceptorBuilder intercept() {
        InterceptorBuilder answer = new InterceptorBuilder(this);
        addProcessBuilder(answer);
        return answer;
    }

    /**
     * Trace logs the exchange before it goes to the next processing step using the {@link #DEFAULT_TRACE_CATEGORY} logging
     * category.
     *
     * @return
     */
    @Fluent
    public FromBuilder trace() {
        return trace(DEFAULT_TRACE_CATEGORY);
    }

    /**
     * Trace logs the exchange before it goes to the next processing step using the specified logging
     * category.
     *
     * @param category the logging category trace messages will sent to.
     * @return
     */
    @Fluent
    public FromBuilder trace(@FluentArg(""category"")String category) {
        final Log log = LogFactory.getLog(category);
        return intercept(new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                log.trace(exchange);
                processNext(exchange);
            }
        });
    }

    @Fluent
    public FromBuilder intercept(@FluentArg(""interceptor"")DelegateProcessor interceptor) {
        InterceptorBuilder answer = new InterceptorBuilder(this);
        answer.add(interceptor);
        addProcessBuilder(answer);
        return answer.target();
    }

    @Fluent(nestedActions = true)
    public PolicyBuilder policies() {
        PolicyBuilder answer = new PolicyBuilder(this);
        addProcessBuilder(answer);
        return answer;
    }

    @Fluent
    public FromBuilder policy(@FluentArg(""policy"")Policy policy) {
        PolicyBuilder answer = new PolicyBuilder(this);
        answer.add(policy);
        addProcessBuilder(answer);
        return answer.target();
    }

    // Transformers
    //-------------------------------------------------------------------------

    /**
     * Adds the custom processor to this destination which could be a final destination, or could be a transformation in a pipeline
     */
    @Fluent
    public FromBuilder process(@FluentArg(""ref"")Processor processor) {
        addProcessorBuilder(processor);
        return this;
    }

    /**
     * Adds a processor which sets the body on the IN message
     */
    @Fluent
    public FromBuilder setBody(Expression expression) {
        addProcessorBuilder(ProcessorBuilder.setBody(expression));
        return this;
    }

    /**
     * Adds a processor which sets the body on the OUT message
     */
    @Fluent
    public FromBuilder setOutBody(Expression expression) {
        addProcessorBuilder(ProcessorBuilder.setOutBody(expression));
        return this;
    }

    /**
     * Adds a processor which sets the header on the IN message
     */
    @Fluent
    public FromBuilder setHeader(String name, Expression expression) {
        addProcessorBuilder(ProcessorBuilder.setHeader(name, expression));
        return this;
    }

    /**
     * Adds a processor which sets the header on the OUT message
     */
    @Fluent
    public FromBuilder setOutHeader(String name, Expression expression) {
        addProcessorBuilder(ProcessorBuilder.setOutHeader(name, expression));
        return this;
    }

    /**
     * Adds a processor which sets the exchange property
     */
    @Fluent
    public FromBuilder setProperty(String name, Expression expression) {
        addProcessorBuilder(ProcessorBuilder.setProperty(name, expression));
        return this;
    }

    /**
     * Converts the IN message body to the specified type
     */
    @Fluent
    public FromBuilder convertBodyTo(Class type) {
        addProcessorBuilder(ProcessorBuilder.setBody(Builder.body().convertTo(type)));
        return this;
    }

    /**
     * Converts the OUT message body to the specified type
     */
    @Fluent
    public FromBuilder convertOutBodyTo(Class type) {
        addProcessorBuilder(ProcessorBuilder.setOutBody(Builder.outBody().convertTo(type)));
        return this;
    }

    // Properties
    //-------------------------------------------------------------------------
    public RouteBuilder getBuilder() {
        return builder;
    }

    public Endpoint getFrom() {
        return from;
    }

    public List<Processor> getProcessors() {
        return processors;
    }

    public ProcessorFactory addProcessBuilder(ProcessorFactory processFactory) {
        processFactories.add(processFactory);
        return processFactory;
    }

    protected void addProcessorBuilder(Processor processor) {
        addProcessBuilder(new ConstantProcessorBuilder(processor));
    }

    public void addProcessor(Processor processor) {
        processors.add(processor);
    }

    public Route createRoute() throws Exception {
        if (routeBuilder != null) {
            return routeBuilder.createRoute();
        }
        Processor processor = createProcessor();
        if (processor == null) {
            throw new IllegalArgumentException(""No processor created for: "" + this);
        }
        return new EventDrivenConsumerRoute(getFrom(), processor);
    }

    public Processor createProcessor() throws Exception {
        List<Processor> answer = new ArrayList<Processor>();

        for (ProcessorFactory processFactory : processFactories) {
            Processor processor = makeProcessor(processFactory);
            if (processor == null) {
                throw new IllegalArgumentException(""No processor created for processBuilder: "" + processFactory);
            }
            answer.add(processor);
        }
        if (answer.size() == 0) {
            return null;
        }
        Processor processor = null;
        if (answer.size() == 1) {
            processor = answer.get(0);
        }
        else {
            processor = new CompositeProcessor(answer);
        }
        return processor;
    }

    /**
     * Creates the processor and wraps it in any necessary interceptors and error handlers
     */
    protected Processor makeProcessor(ProcessorFactory processFactory) throws Exception {
        Processor processor = processFactory.createProcessor();
        processor = wrapProcessor(processor);
        return wrapInErrorHandler(processor);
    }

    /**
     * A strategy method to allow newly created processors to be wrapped in an error handler. This feature
     * could be disabled for child builders such as {@link IdempotentConsumerBuilder} which will rely on the
     * {@link FromBuilder} to perform the error handling to avoid doubly-wrapped processors with 2 nested error handlers
     */
    protected Processor wrapInErrorHandler(Processor processor) throws Exception {
        return getErrorHandlerBuilder().createErrorHandler(processor);
    }

    /**
     * A strategy method which allows derived classes to wrap the child processor in some kind of interceptor such as
     * a filter for the {@link IdempotentConsumerBuilder}.
     *
     * @param processor the processor which can be wrapped
     * @return the original processor or a new wrapped interceptor
     */
    protected Processor wrapProcessor(Processor processor) {
        return processor;
    }

    protected FromBuilder getRouteBuilder() {
        return routeBuilder;
    }

    protected void setRouteBuilder(FromBuilder routeBuilder) {
        this.routeBuilder = routeBuilder;
    }
}
"
org/apache/camel/Expression.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * An <a href=""http://activemq.apache.org/camel/expression.html"">expression</a>
 * provides a plugin strategy for evaluating expressions on a message exchange to support things like
 * <a href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting languages</a>,
 * <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well
 * as any arbitrary Java expression.
 *
 *
 * @version $Revision: $
 */
public interface Expression<E extends Exchange> {

    /**
     * Returns the value of the expression on the given exchange
     *
     * @param exchange the message exchange on which to evaluate the expression
     * @return the value of the expression
     */
    Object evaluate(E exchange);
}
"
org/apache/camel/builder/PredicateFactory.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Predicate;

/**
 * A Factory of {@link Predicate} objects typically implemented by a builder such as @{XPathBuilder}
 * 
 * @version $Revision$
 */
public interface PredicateFactory<E extends Exchange> {

    /**
     * Creates a predicate object
     *
     * @return the newly created expression object
     */
    public Predicate<E> createPredicate();
}
"
org/apache/camel/processor/RedeliveryPolicy.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import java.io.Serializable;
import java.util.Random;

// Code taken from the ActiveMQ codebase

/**
 * The policy used to decide how many times to redeliver and the time between the redeliveries before being sent to a
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a>
 *
 * @version $Revision$
 */
public class RedeliveryPolicy implements Cloneable, Serializable {
    protected static transient Random randomNumberGenerator;
    protected int maximumRedeliveries = 6;
    protected long initialRedeliveryDelay = 1000L;
    protected double backOffMultiplier = 2;
    protected boolean useExponentialBackOff = false;
    // +/-15% for a 30% spread -cgs
    protected double collisionAvoidanceFactor = 0.15d;
    protected boolean useCollisionAvoidance = false;

    public RedeliveryPolicy() {
    }

    @Override
    public String toString() {
        return ""RedeliveryPolicy[maximumRedeliveries="" + maximumRedeliveries + ""]"";
    }

    public RedeliveryPolicy copy() {
        try {
            return (RedeliveryPolicy) clone();
        }
        catch (CloneNotSupportedException e) {
            throw new RuntimeException(""Could not clone: "" + e, e);
        }
    }

    /**
     * Returns true if the policy decides that the message exchange should be redelivered
     */
    public boolean shouldRedeliver(int redeliveryCounter) {
        return redeliveryCounter < getMaximumRedeliveries();
    }

    // Builder methods
    //-------------------------------------------------------------------------

    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }

    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public RedeliveryPolicy initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }

    /**
     * Enables collision avoidence which adds some randomization to the backoff timings to reduce contention probability
     */
    public RedeliveryPolicy useCollisionAvoidance() {
        setUseCollisionAvoidance(true);
        return this;
    }

    /**
     * Enables exponential backof using the {@link #getBackOffMultiplier()} to increase the time between retries
     */
    public RedeliveryPolicy useExponentialBackOff() {
        setUseExponentialBackOff(true);
        return this;
    }

    /**
     * Enables exponential backoff and sets the multiplier used to increase the delay between redeliveries
     */
    public RedeliveryPolicy backOffMultiplier(double backOffMultiplier) {
        useExponentialBackOff();
        setBackOffMultiplier(backOffMultiplier);
        return this;
    }

    /**
     * Enables collision avoidence and sets the percentage used
     */
    public RedeliveryPolicy collisionAvoidancePercent(short collisionAvoidancePercent) {
        useCollisionAvoidance();
        setCollisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }

    // Properties
    //-------------------------------------------------------------------------
    public double getBackOffMultiplier() {
        return backOffMultiplier;
    }

    /**
     * Sets the multiplier used to increase the delay between redeliveries if {@link #setUseExponentialBackOff(boolean)} is enabled
     */
    public void setBackOffMultiplier(double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }

    public short getCollisionAvoidancePercent() {
        return (short) Math.round(collisionAvoidanceFactor * 100);
    }

    /**
     * Sets the percentage used for collision avoidence if enabled via {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidancePercent(short collisionAvoidancePercent) {
        this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d;
    }

    public double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }

    /**
     * Sets the factor used for collision avoidence if enabled via {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }

    public long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }

    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public void setInitialRedeliveryDelay(long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }

    public int getMaximumRedeliveries() {
        return maximumRedeliveries;
    }

    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public void setMaximumRedeliveries(int maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }

    public long getRedeliveryDelay(long previousDelay) {
        long redeliveryDelay;

        if (previousDelay == 0) {
            redeliveryDelay = initialRedeliveryDelay;
        }
        else if (useExponentialBackOff && backOffMultiplier > 1) {
            redeliveryDelay = Math.round(backOffMultiplier * previousDelay);
        }
        else {
            redeliveryDelay = previousDelay;
        }

        if (useCollisionAvoidance) {

            /*
             * First random determines +/-, second random determines how far to
             * go in that direction. -cgs
             */
            Random random = getRandomNumberGenerator();
            double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor) * random.nextDouble();
            redeliveryDelay += redeliveryDelay * variance;
        }

        return redeliveryDelay;
    }

    public boolean isUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }

    /**
     * Enables/disables collision avoidence which adds some randomization to the backoff timings to reduce contention probability
     */
    public void setUseCollisionAvoidance(boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }

    public boolean isUseExponentialBackOff() {
        return useExponentialBackOff;
    }

    /**
     * Enables/disables exponential backof using the {@link #getBackOffMultiplier()} to increase the time between retries
     */
    public void setUseExponentialBackOff(boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }

    protected static synchronized Random getRandomNumberGenerator() {
        if (randomNumberGenerator == null) {
            randomNumberGenerator = new Random();
        }
        return randomNumberGenerator;
    }
}
"
org/apache/camel/builder/WhenBuilder.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;

/**
 * @version $Revision$
 */
public class WhenBuilder extends FilterBuilder {
    private final ChoiceBuilder parent;

    public WhenBuilder(ChoiceBuilder parent, Predicate predicate) {
        super(parent, predicate);
        this.parent = parent;
    }

    @Override
    @Fluent
    public ChoiceBuilder to(@FluentArg(""ref"")Endpoint endpoint) {
        super.to(endpoint);
        return parent;
    }

    @Override
    @Fluent
    public ChoiceBuilder to(@FluentArg(""uri"")String uri) {
        super.to(uri);
        return parent;
    }

    @Override
    @Fluent
    public ChoiceBuilder process(@FluentArg(""ref"")Processor processor) {
        super.process(processor);   
        return parent;
    }
}
"
org/apache/camel/util/ExchangeHelper.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.NoSuchEndpointException;

/**
 * Some helper methods for working with {@link Exchange} objects
 *
 * @version $Revision$
 */
public class ExchangeHelper {

    /**
     * Attempts to resolve the endpoint for the given value
     *
     * @param exchange the message exchange being processed
     * @param value the value which can be an {@link Endpoint} or an object which provides a String representation
     * of an endpoint via {@link #toString()}
     *
     * @return the endpoint
     * @throws NoSuchEndpointException if the endpoint cannot be resolved
     */
    @SuppressWarnings({""unchecked""})
    public static <E extends Exchange> Endpoint<E> resolveEndpoint(E exchange, Object value) throws NoSuchEndpointException {
        Endpoint<E> endpoint;
        if (value instanceof Endpoint) {
            endpoint = (Endpoint<E>) value;
        }
        else {
            String uri = value.toString();
            endpoint = (Endpoint<E>) exchange.getContext().getEndpoint(uri);
            if (endpoint == null) {
                throw new NoSuchEndpointException(uri);
            }
        }
        return endpoint;
    }
}
"
org/apache/camel/RuntimeExpressionException.java,false,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

/**
 * Thrown if an expression evaluation fails
 * 
 * @version $Revision$
 */
public class RuntimeExpressionException extends RuntimeCamelException {

	private static final long serialVersionUID = -8417806626073055262L;

    public RuntimeExpressionException(String message) {
        super(message);
    }

    public RuntimeExpressionException(String message, Throwable cause) {
        super(message, cause);
    }

    public RuntimeExpressionException(Throwable cause) {
        super(cause);
    }
}
"
org/apache/camel/builder/ExpressionBuilder.java,false,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;

import org.apache.camel.Exchange;
import org.apache.camel.Expression;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.regex.Pattern;

/**
 * @version $Revision: $
 */
public class ExpressionBuilder {


    /**
     * Returns an expression for the header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> headerExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object header = exchange.getIn().getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            

            @Override
            public String toString() {
                return ""header("" + headerName + "")"";
            }
        };
    }

    /**
     * Returns an expression for the property value with the given name
     *
     * @param propertyName the name of the property the expression will return
     * @return an expression object which will return the property value
     */
    public static <E extends Exchange> Expression<E> propertyExpression(final String propertyName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperty(propertyName);
            }

            @Override
            public String toString() {
                return ""property("" + propertyName + "")"";
            }
        };
    }

    /**
     * Returns an expression for the contant value
     *
     * @param value the value the expression will return
     * @return an expression object which will return the constant value
     */
    public static <E extends Exchange> Expression<E> constantExpression(final Object value) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return value;
            }

            @Override
            public String toString() {
                return """" + value;
            }
        };
    }

    /**
     * Returns the expression for the exchanges inbound message body
     */
    public static <E extends Exchange> Expression<E> bodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody();
            }

            @Override
            public String toString() {
                return ""body"";
            }
        };
    }


    /**
     * Returns the expression for the exchanges inbound message body converted to the given type
     */
    public static <E extends Exchange, T> Expression<E> bodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody(type);
            }

            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }

    /**
     * Returns the expression for the out messages body
     */
    public static <E extends Exchange> Expression<E> outBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut().getBody();
            }

            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }

    /**
     * Returns the expression for the exchange
     */
    public static <E extends Exchange> Expression<E> exchangeExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange;
            }

            @Override
            public String toString() {
                return ""exchange"";
            }
        };
    }

    /**
     * Returns the expression for the IN message
     */
    public static <E extends Exchange> Expression<E> inMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn();
            }

            @Override
            public String toString() {
                return ""inMessage"";
            }
        };
    }

    /**
     * Returns an expression which converts the given expression to the given type
     */
    public static <E extends Exchange> Expression<E> convertTo(final Expression expression, final Class type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                return exchange.getContext().getTypeConverter().convertTo(type, value);
            }

            @Override
            public String toString() {
                return ""convertTo("" + expression + "", "" + type + "")"";
            }
        };
    }

    /**
     * Returns a tokenize expression which will tokenize the string with the given token
     */
    public static <E extends Exchange> Expression<E> tokenizeExpression(final Expression<E> expression, final String token) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                StringTokenizer iter = new StringTokenizer(text, token);
                List<String> answer = new ArrayList<String>();
                while (iter.hasMoreTokens()) {
                    answer.add(iter.nextToken());
                }
                return answer;
            }

            @Override
            public String toString() {
                return ""tokenize("" + expression + "", "" + token + "")"";
            }
        };
    }

    /**
     * Returns a tokenize expression which will tokenize the string with the given regex
     */
    public static <E extends Exchange> Expression<E> regexTokenize(final Expression<E> expression, String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return Arrays.asList(pattern.split(text));
            }

            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }

    /**
     * Transforms the expression into a String then performs the regex replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression, String regex, final String replacement) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }

            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }

    /**
     * Transforms the expression into a String then performs the regex replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression, String regex, final Expression<E> replacementExpression) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                String replacement = evaluateStringExpression(replacementExpression, exchange);;
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }

            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }


    /**
     * Appends the String evaluations of the two expressions together
     */
    public static <E extends Exchange> Expression<E> append(final Expression<E> left, final Expression<E> right) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return evaluateStringExpression(left, exchange) + evaluateStringExpression(right, exchange);
            }

            @Override
            public String toString() {
                return ""append("" + left + "", "" + right + "")"";
            }
        };
    }

    /**
     * Evaluates the expression on the given exchange and returns the String representation
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the String representation of the expression or null if it could not be evaluated
     */
    public static <E extends Exchange> String evaluateStringExpression(Expression<E> expression, E exchange) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }

    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }

    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name, final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(name, defaultValue);
            }
        };
    }
}
"
