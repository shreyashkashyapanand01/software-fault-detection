File,Bug,SRC
org/apache/synapse/registry/AbstractRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;

/**
 * Implements the core Registry lookup algorithm
 */
public abstract class AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(AbstractRegistry.class);

    /** The list of configuration properties */
    protected Map properties = new HashMap();

    /**
     * Get the resource for the given key from this registry
     * @param entry
     * @return the matching resultant object
     */
    public Object getResource(Entry entry) {

        OMNode omNode = null;
        RegistryEntry re = null;

        // we are dealing with a dynamic resource. Have we seen this before and processed
        // it at least once and have it cached already?

        // if we have an unexpired cached copy, return the cached object
        if (entry.isCached() && !entry.isExpired()) {
            return entry.getValue();

        // if we have not cached the referenced object, fetch it and its RegistryEntry
        } else if (!entry.isCached()) {
            omNode = lookup(entry.getKey());
            if (omNode == null) {
                return null;
            } else {
                re = getRegistryEntry(entry.getKey());
            }

        // if we have cached it before, and now the cache has expired
        // get its *new* registry entry and compare versions and pick new cache duration
        } else if (entry.isExpired()) {
            if (log.isDebugEnabled()) {
                log.debug(""Cached object has expired for key : "" + entry.getKey());
            }
            re = getRegistryEntry(entry.getKey());

            if (re.getVersion() != Long.MIN_VALUE &&
                re.getVersion() == entry.getVersion()) {
                if (log.isDebugEnabled()) {
                    log.debug(""Expired version number is same as current version in registry"");
                }

                // renew cache lease for another cachable duration (as returned by the
                // new getRegistryEntry() call
                if (re.getCachableDuration() > 0) {
                    entry.setExpiryTime(
                            System.currentTimeMillis() + re.getCachableDuration());
                } else {
                    entry.setExpiryTime(-1);
                }
                if (log.isDebugEnabled()) {
                    log.debug(""Renew cache lease for another "" + re.getCachableDuration() / 1000 + ""s"");
                }

                // return cached object
                return entry.getValue();

            } else {
                omNode = lookup(entry.getKey());
            }
        }

        // if we get here, we have received the raw omNode from the
        // registry and our previous copy (if we had one) has expired or is not valid

        // if we have a XMLToObjectMapper for this entry, use it to convert this
        // resource into the appropriate object - e.g. sequence or endpoint
        if (entry.getMapper() != null) {
            entry.setValue(entry.getMapper().getObjectFromOMNode(omNode));

            if (entry.getValue() instanceof SequenceMediator) {
                SequenceMediator seq = (SequenceMediator) entry.getValue();
                seq.setDynamic(true);
                seq.setRegistryKey(entry.getKey());
            } else if (entry.getValue() instanceof Endpoint) {
                Endpoint ep = (Endpoint) entry.getValue();
            }

        } else {
            // if the type of the object is known to have a mapper, create the
            // resultant Object using the known mapper, and cache this Object
            // else cache the raw OMNode
            if (re != null && re.getType() != null) {

                XMLToObjectMapper mapper = getMapper(re.getType());
                if (mapper != null) {
                    entry.setMapper(mapper);
                    entry.setValue(mapper.getObjectFromOMNode(omNode));

                } else {
                    entry.setValue(omNode);
                }
            }
        }

        // increment cache expiry time as specified by the last getRegistryEntry() call
        if (re != null) {
            if (re.getCachableDuration() > 0) {
                entry.setExpiryTime(System.currentTimeMillis() + re.getCachableDuration());
            } else {
                entry.setExpiryTime(-1);
            }
            entry.setVersion(re.getVersion());
        }

        return entry.getValue();
    }

    private XMLToObjectMapper getMapper(URI type) {
        return null;
    }

    public String getProviderClass() {
        return this.getClass().getName();
    }

    public Map getConfigProperties() {
        return properties;
    }

    public void addConfigProperty(String name, String value) {
        properties.put(name, value);
    }
}
"
org/apache/synapse/core/SynapseEnvironment.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core;

import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.StatisticsCollector;

import java.util.concurrent.ExecutorService;

/**
 * The SynapseEnvironment allows access into the the host SOAP engine. It allows
 * the sending of messages, classloader access etc.
 */
public interface SynapseEnvironment {

    /**
     * This method injects a new message into the Synapse engine. This is used by
     * the underlying SOAP engine to inject messages into Synapse for mediation.
     * e.g. The SynapseMessageReceiver used by Axis2 invokes this to inject new messages
     *
     * @param smc - Synapse MessageContext to be injected
     * @return boolean true if the message processing should be continued
     *  and false if it should be aborted
     */
    public boolean injectMessage(MessageContext smc);

    /**
     * This method injects a new message into the synapse engine for the mediation
     * by the specified sequence. This is used by custom mediation tasks like splitting message
     * in EIP mediations. This method will do the mediation asynchronouslly using a separate
     * thread from the environment thread pool
     *
     * @param smc - Synapse message context to be injected
     * @param seq - Sequence to be used for mediation
     */
    public void injectAsync(MessageContext smc, SequenceMediator seq);

    /**
     * This method allows a message to be sent through the underlying SOAP engine. This will
     * send request messages on (forward), and send the response messages back to the client
     *
     * @param endpoint  - Endpoint to be used for sending
     * @param smc       - Synapse MessageContext to be sent
     */
    public void send(EndpointDefinition endpoint, MessageContext smc);

    /**
     * Creates a new Synapse <code>MessageContext</code> instance.
     *
     * @return a MessageContext
     */
    public MessageContext createMessageContext();

    /**
     * This method returns the StatisticsCollector
     *
     * @return Returns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector();

    /**
     * To set the StatisticsCollector to the environment
     *
     * @param statisticsCollector - StatisticsCollector to be set
     */
    public void setStatisticsCollector(StatisticsCollector statisticsCollector);

    /**
     * This is used by anyone who needs access to a SynapseThreadPool.
     * It offers the ability to start work.
     * 
     * @return Returns the ExecutorService
     */
     public ExecutorService getExecutorService();

    /**
     * Has the Synapse Environment properly initialized?
     * @return true if the environment is ready for processing
     */
    public boolean isInitialized();

    /**
     * Set the environment as ready for message processing
     * @param state true means ready for processing
     */
    public void setInitialized(boolean state);
}
"
org/apache/synapse/config/xml/XSLTMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.config.xml.AbstractMediatorSerializer;

import java.util.Iterator;
import java.util.List;

/**
 * <pre>
 * &lt;xslt key=""property-key"" [source=""xpath""]&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/transform&gt;
 * </pre>
 */
public class XSLTMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof XSLTMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        XSLTMediator mediator = (XSLTMediator) m;
        OMElement xslt = fac.createOMElement(""xslt"", synNS);

        if (mediator.getXsltKey() != null) {
            xslt.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, mediator.getXsltKey()));
        } else {
            handleException(""Invalid XSLT mediator. XSLT registry key is required"");
        }
        saveTracingState(xslt,mediator);

        if (mediator.getSource() != null &&
            !XSLTMediator.DEFAULT_XPATH.toString().equals(mediator.getSource().toString())) {
            xslt.addAttribute(fac.createOMAttribute(
                ""source"", nullNS, mediator.getSource().toString()));
            serializeNamespaces(xslt, mediator.getSource());
        }
        serializeProperties(xslt, mediator.getProperties());
        List features = mediator.getFeatures();
        if (!features.isEmpty()) {
            for (Iterator iter = features.iterator(); iter.hasNext();) {
                MediatorProperty mp = (MediatorProperty) iter.next();
                OMElement prop = fac.createOMElement(""feature"", synNS, xslt);
                if (mp.getName() != null) {
                    prop.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
                } else {
                    handleException(""The Feature name is missing"");
                }
                if (mp.getValue() != null) {
                    prop.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));
                }  else {
                    handleException(""The Feature value is missing"");
                }
            }
        }
        if (parent != null) {
            parent.addChild(xslt);
        }
        return xslt;
    }

    public String getMediatorClassName() {
        return XSLTMediator.class.getName();
    }
}
"
org/apache/synapse/metrics/GlobalRequestCountHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.handlers.AbstractHandler;

/*
 * This information is published using WS-Management.
 * Access from any location with XXContext.getParameter(Constants.GLOBAL_REQUEST_COUNTER);
 */

public class GlobalRequestCountHandler extends AbstractHandler {

    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
        msgContext
                .setProperty(MetricsConstants.REQUEST_RECEIVED_TIME, new Long(System.currentTimeMillis()));
        // global increment
        ((Counter) msgContext.getParameter(MetricsConstants.GLOBAL_REQUEST_COUNTER).getValue())
                .increment();
        return InvocationResponse.CONTINUE;
    }
}
"
org/apache/synapse/mediators/builtin/PropertyMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * The property mediator would save(or remove) a named property as a local property of
 * the Synapse Message Context or as a property of the Axis2 Message Context or
 * as a Transport Header.
 * Properties set this way could be extracted through the XPath extension function
 * ""synapse:get-property(scope,prop-name)""
 */

public class PropertyMediator extends AbstractMediator {

    /** The Name of the property  */
    private String name = null;
    /** The Value to be set*/
    private String value = null;
    /** The XPath expr. to get value  */
    private AXIOMXPath expression = null;
    /** The scope for which decide properties where to go*/
    private String scope = null;
    /** The Action - set or remove */
    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;
    /** Set the property (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;

    /**
     * Sets a property into the current (local) Synapse Context or into the Axis Message Context
     * or into Transports Header
     * And Removes above properties from the corresspounding locations
     *
     * @param synCtx the message context
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Property mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (action == ACTION_SET) {

            String resultValue = (value != null ? value :
                Axis2MessageContext.getStringValue(expression, synCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting property : "" + name + "" at scope : "" +
                    (scope == null ? ""default"" : scope) + "" to : "" + resultValue + "" (i.e. "" +
                    (value != null ? ""constant : "" + value :
                          ""result of expression : "" + expression) + "")"");
            }

            if (scope == null || XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {
                //Setting property into the  Synapse Context
                synCtx.setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_AXIS2.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting property into the  Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_CLIENT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting property into the  Axis2 Message Context client options
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.getOptions().setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting Transport Headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.put(name, resultValue);
                }
                if (headers == null) {
                    Map headersMap = new HashMap();
                    headersMap.put(name, resultValue);
                    axis2MessageCtx.setProperty(
                            org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
                            headersMap);
                }
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Removing property : "" + name +
                    "" (scope:"" + (scope == null ? ""default"" : scope) + "")"");
            }

            if (scope == null || XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {
                //Removing property from the  Synapse Context
                Set pros = synCtx.getPropertyKeySet();
                if (pros != null) {
                    pros.remove(name);
                }

            } else if ((XMLConfigConstants.SCOPE_AXIS2.equals(scope) ||
                XMLConfigConstants.SCOPE_CLIENT.equals(scope))
                && synCtx instanceof Axis2MessageContext) {
                
                //Removing property from the Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.removeProperty(name);

            } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                // Removing transport headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.remove(name);
                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""No transport headers found for the message"");
                    }
                }
            }
        }
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Property mediator"");
        }
        return true;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    public String getScope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;

import java.util.List;

/**
 * Serializes FailoverEndpoint to XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <failover>
 *       <endpoint>+
 *    </failover>
 * </endpoint>
 */
public class FailoverEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof FailoverEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        FailoverEndpoint failoverEndpoint = (FailoverEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        OMElement failoverElement = fac.createOMElement(""failover"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(failoverElement);

        String name = failoverEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        List endpoints = failoverEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            failoverElement.addChild(aeElement);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.config.xml.endpoints.utils.WSDL11EndpointBuilder;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axis2.description.WSDL2Constants;
import org.apache.synapse.config.SynapseConfigUtils;

import javax.xml.namespace.QName;
import java.net.URL;

/**
 * Creates an WSDL based endpoint from a XML configuration.
 *
 * <wsdl [uri=""wsdl-uri""] service=""qname"" port/endpoint=""qname"">
 *   <wsdl:definition>...</wsdl:definition>?
 *   <wsdl20:description>...</wsdl20:description>?
 *   <enableRM [policy=""key""]/>?
 *   <enableSec [policy=""key""]/>?
 *   <enableAddressing/>?
 *   <suspendDurationOnFailure>suspend-duration</suspendDurationOnFailure>?
 *   <timeout>
 *     <duration>timeout-duration</duration>
 *     <action>discard|fault</action>
 *   </timeout>?
 * </wsdl>
 */
public class WSDLEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(WSDLEndpointFactory.class);

    private static WSDLEndpointFactory instance = new WSDLEndpointFactory();

    private WSDLEndpointFactory() {}

    public static WSDLEndpointFactory getInstance() {
        return instance;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        WSDLEndpoint wsdlEndpoint = new WSDLEndpoint();

        if (!anonymousEndpoint) {
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                wsdlEndpoint.setName(name.getAttributeValue());
            }
        }

        OMElement wsdlElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""wsdl""));

        if (wsdlElement != null) {

            // set the suspend on fail duration.
            OMElement suspendElement = wsdlElement.getFirstChildWithName(new QName(
                    SynapseConstants.SYNAPSE_NAMESPACE,
                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE));

            if (suspendElement != null) {
                String suspend = suspendElement.getText();

                try {
                    if (suspend != null) {
                        long suspendDuration = Long.parseLong(suspend.trim());
                        wsdlEndpoint.setSuspendOnFailDuration(suspendDuration * 1000);
                    }

                } catch (NumberFormatException e) {
                    handleException(""suspendDurationOnFailure should be valid number."");
                }
            }

            EndpointDefinition endpoint = null;

            // get the service name and port name. at this point we should not worry about the presence
            // of those parameters. they are handled by corresponding WSDL builders.
            String serviceName = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE,""service""));

            String portName = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE,""port""));

            // check if wsdl is supplied as a URI
            String wsdlURI = wsdlElement.getAttributeValue
                    (new QName(org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE,""uri""));

            // set serviceName and portName in the endpoint. it does not matter if these are
            // null at this point. we are setting them only for serialization purpose.
            wsdlEndpoint.setServiceName(serviceName);
            wsdlEndpoint.setPortName(portName);

            if (wsdlURI != null) {

                wsdlEndpoint.setWsdlURI(wsdlURI.trim());
                try {
                    OMElement wsdlOM = SynapseConfigUtils.getOMElementFromURL(
                        new URL(wsdlURI).toString());
                    if (wsdlOM != null) {
                        OMNamespace ns = wsdlOM.getNamespace();
                        if (ns != null) {
                            String nsUri = wsdlOM.getNamespace().getNamespaceURI();
                            if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.equals(nsUri)) {
                                endpoint = new WSDL11EndpointBuilder().
                                    createEndpointDefinitionFromWSDL(wsdlOM, serviceName, portName);

                            } else if (WSDL2Constants.WSDL_NAMESPACE.equals(nsUri)) {
                                //endpoint = new WSDL20EndpointBuilder().
                                //        createEndpointDefinitionFromWSDL(wsdlURI, serviceName, portName);

                                handleException(""WSDL 2.0 Endpoints are currently not supported"");
                            }
                        }
                    }
                } catch (Exception e) {
                    handleException(""Couldn't create endpoint from the given WSDL URI : ""
                        + e.getMessage(), e);
                }
            }

            // check if the wsdl 1.1 document is suppled inline
            OMElement definitionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""definitions""));
            if (endpoint == null && definitionElement != null) {
                wsdlEndpoint.setWsdlDoc(definitionElement);

                endpoint = new WSDL11EndpointBuilder().
                        createEndpointDefinitionFromWSDL(definitionElement, serviceName, portName);
            }

            // check if a wsdl 2.0 document is supplied inline
            OMElement descriptionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""description""));
            if (endpoint == null && descriptionElement != null) {
                wsdlEndpoint.setWsdlDoc(descriptionElement);
                handleException(""WSDL 2.0 Endpoints are currently not supported."");
            }
            if (endpoint != null) {
                // for now, QOS information has to be provided explicitly.
                extractQOSInformation(endpoint, wsdlElement);
                OMAttribute statistics = epConfig.getAttribute(
                        new QName(org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE,
                                org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ATTRIB_NAME));
                if (statistics != null) {
                    String statisticsValue = statistics.getAttributeValue();
                    if (statisticsValue != null) {
                        if (org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ENABLE.equals(
                                statisticsValue)) {
                            endpoint.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_ON);
                        } else if (org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_DISABLE.equals(
                                statisticsValue)) {
                            endpoint.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                        }
                    }
                }
                wsdlEndpoint.setEndpoint(endpoint);
            } else {
                handleException(""WSDL is not specified for WSDL endpoint."");
            }
        }

        return wsdlEndpoint;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void extractQOSInformation(EndpointDefinition endpointDefinition, OMElement wsdlElement) {

        OMAttribute format = wsdlElement.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""format""));
        OMAttribute optimize = wsdlElement.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""optimize""));

        if (format != null)
        {
            String forceValue = format.getAttributeValue().trim().toLowerCase();
            if (SynapseConstants.FORMAT_POX.equals(forceValue)) {
                endpointDefinition.setForcePOX(true);
                endpointDefinition.setFormat(SynapseConstants.FORMAT_POX);

            } else if (SynapseConstants.FORMAT_SOAP11.equals(forceValue)) {
                endpointDefinition.setForceSOAP11(true);
                endpointDefinition.setFormat(SynapseConstants.FORMAT_SOAP11);
                
            } else if (SynapseConstants.FORMAT_SOAP12.equals(forceValue)) {
                endpointDefinition.setForceSOAP12(true);
                endpointDefinition.setFormat(SynapseConstants.FORMAT_SOAP12);
                
            } else {
                handleException(""force value -\""""+forceValue+""\"" not yet implemented"");
            }
        }

        if (optimize != null && optimize.getAttributeValue().length() > 0) {
            String method = optimize.getAttributeValue().trim();
            if (""mtom"".equalsIgnoreCase(method)) {
                endpointDefinition.setUseMTOM(true);
            } else if (""swa"".equalsIgnoreCase(method)) {
                endpointDefinition.setUseSwa(true);
            }
        }

        OMElement wsAddr = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableAddressing""));
        if (wsAddr != null) {
            endpointDefinition.setAddressingOn(true);
            String useSepList = wsAddr.getAttributeValue(new QName(
                    ""separateListener""));
            if (useSepList != null) {
                if (useSepList.trim().toLowerCase().startsWith(""tr"")
                        || useSepList.trim().startsWith(""1"")) {
                    endpointDefinition.setUseSeparateListener(true);
                }
            }
        }

        OMElement wsSec = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableSec""));
        if (wsSec != null) {
            endpointDefinition.setSecurityOn(true);
            OMAttribute policy = wsSec.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpointDefinition.setWsSecPolicyKey(policy.getAttributeValue());
            }
        }
        OMElement wsRm = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableRM""));
        if (wsRm != null) {
            endpointDefinition.setReliableMessagingOn(true);
            OMAttribute policy = wsRm.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpointDefinition.setWsRMPolicyKey(policy.getAttributeValue());
            }
        }

        // set the timeout configuration
        OMElement timeout = wsdlElement.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""timeout""));
        if (timeout != null) {
            OMElement duration = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""duration""));
            if (duration != null) {
                String d = duration.getText();
                if (d != null) {
                    long timeoutSeconds = new Long(d.trim()).longValue();
                    endpointDefinition.setTimeoutDuration(timeoutSeconds * 1000);
                }
            }

            OMElement action = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""action""));
            if (action != null) {
                String a = action.getText();
                if (a != null) {
                    if ((a.trim()).equalsIgnoreCase(""discard"")) {
                        endpointDefinition.setTimeoutAction(SynapseConstants.DISCARD);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpointDefinition.getTimeoutDuration() == 0) {
                            endpointDefinition.setTimeoutDuration(30000);
                        }
                    } else if ((a.trim()).equalsIgnoreCase(""fault"")) {
                        endpointDefinition.setTimeoutAction(SynapseConstants.DISCARD_AND_FAULT);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpointDefinition.getTimeoutDuration() == 0) {
                            endpointDefinition.setTimeoutDuration(30000);
                        }
                    }
                }
            }
        }
    }
}
"
org/apache/synapse/config/xml/OutMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

public class OutMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof OutMediator)) {
            handleException(""Unsupported mediator passed out for serialization : "" + m.getType());
        }

        OutMediator mediator = (OutMediator) m;
        OMElement out = fac.createOMElement(""out"", synNS);
        saveTracingState(out,mediator);
        serializeChildren(out, mediator.getList());

        if (parent != null) {
            parent.addChild(out);
        }
        return out;
    }

    public String getMediatorClassName() {
        return OutMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/db/DBLookupMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.synapse.MessageContext;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Iterator;

/**
 * Simple database table lookup mediator. Designed only for read/lookup
 */
public class DBLookupMediator extends AbstractDBMediator {

    protected void processStatement(Statement stmnt, MessageContext msgCtx) {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        // execute the prepared statement, and extract the first result row and
        // set as message context properties, any results that have been specified
        try {
            PreparedStatement ps = getPreparedStatement(stmnt, msgCtx);
            ResultSet rs = ps.executeQuery();

            if (rs.next()) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Processing the first row returned : "" + stmnt.getRawStatement());
                }

                Iterator propNameIter = stmnt.getResultsMap().keySet().iterator();
                while (propNameIter.hasNext()) {

                    String propName = (String) propNameIter.next();
                    String columnStr = (String) stmnt.getResultsMap().get(propName);

                    Object obj = null;
                    try {
                        int colNum = Integer.parseInt(columnStr);
                        obj = rs.getObject(colNum);
                    } catch (NumberFormatException ignore) {
                        obj = rs.getObject(columnStr);
                    }

                    if (obj != null) {
                        if (traceOrDebugOn) {
                            traceOrDebug(traceOn, ""Column : "" + columnStr +
                                "" returned value : "" + obj +
                                "" Setting this as the message property : "" + propName);
                        }
                        msgCtx.setProperty(propName, obj.toString());
                    } else {
                        if (traceOrDebugOn) {
                            traceOrDebugWarn(traceOn, ""Column : "" + columnStr +
                                "" returned null Skip setting message property : "" + propName);
                        }
                    }
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Statement : ""
                        + stmnt.getRawStatement() + "" returned 0 rows"");
                }
            }
            
        } catch (SQLException e) {
            handleException(""Error executing statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName(), e, msgCtx);
        }
    }

}
"
org/apache/synapse/statistics/Statistics.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 * The statistics data structure
 */

public class Statistics {

    /**  Maximum Processing time for a one way flow  */
    private long maxProcessingTime = 0;
    /** Minmum Processing time for a one way flow   */
    private long minProcessingTime = -1;
    /** Avarage Processing time for a one way flow */
    private double avgProcessingTime = 0;
    /** Total Processing time for a one way flow  */
    private double totalProcessingTime;
    /** The number of access count for a one way flow  */
    private int count = 0;
    /** The number of fault count for a one way flow  */
    private int faultCount = 0;

    /**
     * Update the statistics
     *
     * @param inTime  - The processing start time
     * @param outTime - The processing end time
     * @param isFault - A boolean value that indicate whether falut has occured or not
     */
    public void update(long inTime, long outTime, boolean isFault) {
        count++;
        if (isFault) {
            faultCount++;
        }
        long responseTime = outTime - inTime;
        if (maxProcessingTime < responseTime) {
            maxProcessingTime = responseTime;
        }
        if (minProcessingTime > responseTime) {
            minProcessingTime = responseTime;
        }
        if (minProcessingTime == -1) {
            minProcessingTime = responseTime;
        }
        totalProcessingTime = totalProcessingTime + responseTime;
        avgProcessingTime = totalProcessingTime / count;
    }

    /**
     * @return Returns the Maximum processing time
     */
    public long getMaxProcessingTime() {
        return maxProcessingTime;
    }

    /**
     * @return Returns the Avarage processing time
     */
    public double getAvgProcessingTime() {
        return avgProcessingTime;
    }

    /**
     * @return Returns the minimum processing time
     */
    public long getMinProcessingTime() {
        return minProcessingTime;
    }

    /**
     * @return Returns the fault count
     */
    public int getFaultCount() {
        return faultCount;
    }

    /**
     * @return Returns the total count that represents number of access in a one way flow
     */
    public int getCount() {
        return count;
    }
}
"
org/apache/synapse/mediators/AbstractListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * This is the base class for all List mediators
 *
 * @see ListMediator
 */
public abstract class AbstractListMediator extends AbstractMediator
    implements ListMediator, ManagedLifecycle {

    /** the list of child mediators held. These are executed sequentially */
    protected List mediators = new ArrayList();

    public boolean mediate(MessageContext synCtx) {

        int parentsEffectiveTraceState = synCtx.getTracingState();
        // if I have been explicitly asked to enable or disable tracing, set it to the message
        // to pass it on; else, do nothing -> i.e. let the parents state flow
        setEffectiveTraceState(synCtx);
        int myEffectiveTraceState = synCtx.getTracingState();

        try {
            if (isTraceOrDebugOn(isTraceOn(synCtx))) {
                traceOrDebug(isTraceOn(synCtx), ""Sequence <"" + getType() + ""> :: mediate()"");
            }

            for (Iterator it = mediators.iterator(); it.hasNext();) {
                Mediator m = (Mediator) it.next();

                // ensure correct trace state after each invocation of a mediator
                synCtx.setTracingState(myEffectiveTraceState);
                if (!m.mediate(synCtx)) {
                    return false;
                }
            }
        } finally {
            synCtx.setTracingState(parentsEffectiveTraceState);
        }
        return true;
    }

    public List getList() {
        return mediators;
    }

    public boolean addChild(Mediator m) {
        return mediators.add(m);
    }

    public boolean addAll(List c) {
        return mediators.addAll(c);
    }

    public Mediator getChild(int pos) {
        return (Mediator) mediators.get(pos);
    }

    public boolean removeChild(Mediator m) {
        return mediators.remove(m);
    }

    public Mediator removeChild(int pos) {
        return (Mediator) mediators.remove(pos);
    }

    /**
     * Initialize child mediators recursively
     * @param se synapse environment
     */
    public void init(SynapseEnvironment se) {
        if (log.isDebugEnabled()) {
            log.debug(""Initializing child mediators"");
        }

        for (Iterator it = mediators.iterator(); it.hasNext();) {
            Mediator m = (Mediator) it.next();

            if (m instanceof ManagedLifecycle) {
            	((ManagedLifecycle) m).init(se);
            }
        } 
    }

    /**
     * Destroy child mediators recursively
     */
    public void destroy() {
        if (log.isDebugEnabled()) {
            log.debug(""Destroying child mediators"");
        }

        for (Iterator it = mediators.iterator(); it.hasNext();) {
            Mediator m = (Mediator) it.next();

            if (m instanceof ManagedLifecycle) {
            	((ManagedLifecycle) m).destroy();
            }
        } 
    }
}
"
org/apache/synapse/mediators/eip/EIPUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jaxen.JaxenException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Utility methods for the EIP implementations
 */
public class EIPUtils {

    /**
     * This will be used for logging purposes
     */
    private static final Log log = LogFactory.getLog(EIPUtils.class);

    /**
     * This static util method will be used to extract out the set of all elements described by the
     * given XPath over the given SOAPEnvelope
     *
     * @param envelope   SOAPEnvelope from which the the elements will be extracted
     * @param expression AXIOMXPath expression describing the elements
     * @return List of OMElements in the envelope matching the expression
     * @throws JaxenException if the XPath expression evaluation fails for some reason
     */
    public static List getMatchingElements(SOAPEnvelope envelope, AXIOMXPath expression)
        throws JaxenException {

        Object o = expression.evaluate(envelope);
        if (o instanceof OMNode) {
            List list = new ArrayList();
            list.add(o);
            return list;
        } else if (o instanceof List) {
            return (List) o;
        } else {
            return null;
        }
    }

    /**
     * @param envelope
     * @param expression
     * @return
     * @throws JaxenException
     */
    public static List getDetachedMatchingElements(SOAPEnvelope envelope, AXIOMXPath expression)
        throws JaxenException {

        List elementList = new ArrayList();
        Object o = expression.evaluate(envelope);
        if (o instanceof OMNode) {
            elementList.add(((OMNode) o).detach());
        } else if (o instanceof List) {
            for (Iterator itr = ((List) o).iterator(); itr.hasNext();) {
                Object elem = itr.next();
                if (elem instanceof OMNode) {
                    elementList.add(((OMNode) elem).detach());
                }
            }
        }
        return elementList;
    }

    /**
     * This static util method will be used to enrich the envelope passed, by the element described
     * by the XPath over the enricher envelope
     *
     * @param envelope   SOAPEnvelope to be enriched with the content
     * @param enricher   SOAPEnvelope from which the enriching element will be extracted
     * @param expression AXIOMXPath describing the enriching element
     */
    public static void enrichEnvelope(SOAPEnvelope envelope, SOAPEnvelope enricher,
        AXIOMXPath expression) throws JaxenException {
        OMElement enrichingElement;
        Object o = getMatchingElements(envelope, expression).get(0);
        if (o instanceof OMElement && ((OMElement) o).getParent() instanceof OMElement) {
            enrichingElement = (OMElement) ((OMElement) o).getParent();
        } else {
            enrichingElement = envelope.getBody();
        }

        Iterator itr = getMatchingElements(enricher, expression).iterator();
        while (itr.hasNext()) {
            o = itr.next();
            if (o != null && o instanceof OMElement) {
                enrichingElement.addChild((OMElement) o);
            }
        }

    }
    
}
"
org/apache/synapse/ManagedLifecycle.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.synapse.core.SynapseEnvironment;

/**
 * This interface defines all the manged statefull parts of Synapse
 * including the configuration itself
 */
public interface ManagedLifecycle {

    /**
     * This method should implement the initialization of the
     * implemented parts of the configuraiton
     *
     * @param se SynapseEnvironment to be used for initialization
     */
    public void init(SynapseEnvironment se);

    /**
     * This method should implement the destroying of the
     * implemented parts of the configuration
     */
    public void destroy();
}
"
org/apache/synapse/statistics/StatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 *  This interface need to be implemented by each of the entry that
 *  need to collect statistics
 *
 */

public interface StatisticsStack {

    /**
     * This method is used to put current statistics
     * @param key
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key,long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault);

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault);

    /**
     * Report the particular statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name);

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault);

}
"
org/apache/synapse/config/SynapseConfigurationBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.XMLConfigurationBuilder;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * Builds a Synapse Configuration model with a given input
 * (e.g. XML, programmatic creation, default etc)
 */
public class SynapseConfigurationBuilder {

    private static Log log = LogFactory.getLog(SynapseConfigurationBuilder.class);

    /**
     * Return the default Synapse Configuration
     * @return the default configuration to be used
     */
    public static SynapseConfiguration getDefaultConfiguration() {
        // programatically create an empty configuration which just log and drop the messages 
        SynapseConfiguration config = new SynapseConfiguration();
        SequenceMediator mainmediator = new SequenceMediator();
        mainmediator.addChild(new LogMediator());
        mainmediator.addChild(new DropMediator());
        config.addSequence(SynapseConstants.MAIN_SEQUENCE_KEY, mainmediator);
        SequenceMediator faultmediator = new SequenceMediator();
        LogMediator fault = new LogMediator();
        fault.setLogLevel(LogMediator.FULL);
        faultmediator.addChild(fault);
        config.addSequence(SynapseConstants.FAULT_SEQUENCE_KEY, faultmediator);
        return config;
    }

    /**
     * Build a Synapse configuration from a given XML configuration file
     *
     * @param configFile the XML configuration
     * @return the Synapse configuration model
     */
    public static SynapseConfiguration getConfiguration(String configFile) {

        // build the Synapse configuration parsing the XML config file
        try {
            SynapseConfiguration synCfg
                = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));
            log.info(""Loaded Synapse configuration from : "" + configFile);
            synCfg.setPathToConfigFile(new File(configFile).getAbsolutePath());
            loadSynapseProperties(synCfg);
            return synCfg;

        } catch (FileNotFoundException fnf) {
            handleException(""Cannot load Synapse configuration from : "" + configFile, fnf);
        } catch (Exception e) {
            handleException(""Could not initialize Synapse : "" + e.getMessage(), e);
        }
        return null;
    }

    private static void loadSynapseProperties(SynapseConfiguration synCfg) {
        String props = System.getProperty(SynapseConstants.SYNAPSE_PROPERTIES);
        if (props == null) {
            props = SynapseConstants.DEFAULT_PROP_PATH;
        }
        try {
            synCfg.getProperties().load(Thread.currentThread().getContextClassLoader().getResourceAsStream(props));
        } catch (Exception e) {
            if (log.isDebugEnabled()) {
                log.debug(""Unable to load synapse properties : Using the default tunning parameters for Synapse"");
            }
        }
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.woden.WSDLFactory;
import org.apache.woden.WSDLReader;
import org.apache.woden.WSDLException;
import org.apache.woden.types.NCName;
import org.apache.woden.wsdl20.xml.DescriptionElement;
import org.apache.woden.wsdl20.Description;
import org.apache.woden.wsdl20.Service;
import org.apache.woden.wsdl20.Endpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Currently this class is not used as woden is dependent on xerces, which is not included in the
 * current release.
 *  
 * Builder for WSDL 2.0 endpoints. This class extracts endpoint information from the given WSDL 2.0
 * documents.
 */
public class WSDL20EndpointBuilder {

/*  COMMENT DUE TO BUILD FAILURE - TO BE FIXED LATER WHEN WSDL 2.0 SUPPORT IS OFFICIALLY IN 
    private static Log log = LogFactory.getLog(WSDL20EndpointBuilder.class);

    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String serviceName, String portName) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            reader.setFeature(WSDLReader.FEATURE_VALIDATION, false);

            DescriptionElement descriptionElement = reader.readWSDL(wsdlURI);
            return createEndpointDefinitionFromWSDL(descriptionElement, serviceName, portName);

        } catch (WSDLException e) {
            handleException(""Couldn't process the given WSDL document."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (DescriptionElement dElement, String serviceName, String portName) {

        if (dElement == null) {
            throw new SynapseException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            throw new SynapseException(""Service is not specified."");
        }

        if (portName == null) {
            throw new SynapseException(""Port is not specified."");
        }

        Description description = dElement.toComponent();
        String tns = dElement.getTargetNamespace().toString();
        Service service = description.getService(new QName(tns, serviceName));
        if (service != null) {
            Endpoint wsdlEndpoint = service.getEndpoint(new NCName(portName));
            if (wsdlEndpoint != null) {
                String serviceURL = wsdlEndpoint.getAddress().toString();

                EndpointDefinition endpointDefinition = new EndpointDefinition();
                endpointDefinition.setAddress(serviceURL);

                return endpointDefinition;
            } else {
                handleException(""Specified port is not defined in the given WSDL."");
            }
        } else {
            handleException(""Specified service is not defined in the given WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }*/
}
"
org/apache/synapse/config/Entry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import java.net.URL;

/**
 * Represents an Entry contained in the local registry used by Synapse
 *
 * @see org.apache.synapse.config.SynapseConfiguration#localRegistry
 */
public class Entry {

    private static final Log log = LogFactory.getLog(Entry.class);

    /** The key of the entry */
    private String key;
    /** The type of the entry */
    private int type;
    /** Source URL of the entry if it is a URL_SRC */
    private URL src;
    /** The value of the entry. This can be either an OMElement or an String */
    private Object value;
    /** An XML to Object mapper - if one is available */
    private XMLToObjectMapper mapper;
    /** The version of the cached resource */
    private long version;
    /** The local expiry time for the cached resource */
    private long expiryTime;

    public Entry() {}
    
    public Entry(String key) {
        this.key = key;
    }

    public int getType() {
        return type;
    }

    public boolean isRemote() {
        return type == REMOTE_ENTRY;
    }

    public boolean isURLSource() {
        return type == URL_SRC;
    }

    public boolean isInlineXML() {
        return type == INLINE_XML;
    }

    public boolean isInlineText() {
        return type == INLINE_TEXT;
    }

    public void setType(int type) {
        if (type <= 4 && type >= 0) {
            this.type = type;
        } else {
            handleException(""Invalid entry type for the static entry"");
        }
    }

    public URL getSrc() {
        return src;
    }

    public void setSrc(URL src) {
        this.src = src;
    }

    public String getKey() {
        return this.key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * Gets the value of the entry. String if the type is INLINE_TEXT or VALUE_TYPE,
     * OMElement otherwise.
     * @return Either an OMElement or a String
     */
    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    /**
     *
     * @return mapper
     */
    public XMLToObjectMapper getMapper() {
        return mapper;
    }

    /**
     *
     * @param mapper
     */
    public void setMapper(XMLToObjectMapper mapper) {
        this.mapper = mapper;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public long getExpiryTime() {
        return expiryTime;
    }

    public void setExpiryTime(long expiryTime) {
        this.expiryTime = expiryTime;
    }

    public boolean isExpired() {
        if (getType() == REMOTE_ENTRY && getExpiryTime() > 0) {
            return System.currentTimeMillis() > expiryTime;
        } else {
            return false;
        }
    }

    public boolean isCached() {
        return value != null;
    }

    public void clearCache() {
        if (this.isDynamic()) {
            value = null;
            expiryTime = System.currentTimeMillis();
        }
    }

    public boolean isDynamic() {
        return type == REMOTE_ENTRY;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public static final int INLINE_TEXT = 0;
    public static final int INLINE_XML = 1;
    public static final int URL_SRC = 2;
    public static final int REMOTE_ENTRY = 3;
}
"
org/apache/synapse/config/xml/SequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

/**
 * <pre>
 * &lt;sequence name=""string"" [onError=""string""]&gt;
 *   mediator+
 * &lt;/sequence&gt;
 * </pre>
 * <p/>
 * OR
 * <p/>
 * <pre>
 * &lt;sequence key=""name""/&gt;
 * </pre>
 */
public class SequenceMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeAnonymousSequence(OMElement parent, SequenceMediator mediator) {
        OMElement sequence = fac.createOMElement(""sequence"", synNS);
        int isEnableStatistics = mediator.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }
        if (mediator.getErrorHandler() != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""onError"", nullNS, mediator.getErrorHandler()));
        }
        saveTracingState(sequence, mediator);
        serializeChildren(sequence, mediator.getList());
        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SequenceMediator mediator = (SequenceMediator) m;
        OMElement sequence = fac.createOMElement(""sequence"", synNS);

        // is this a dynamic sequence we loaded from a registry? if so we have no work to here
        // except make sure that we refer back to the registry key used when we loaded ourself
        if (mediator.isDynamic()) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
            sequence.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, mediator.getRegistryKey()));

        } else {

            int isEnableStatistics = mediator.getStatisticsState();
            String statisticsValue = null;
            if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
                statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
            } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
                statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
            }
            if (statisticsValue != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
            }

            if (mediator.getKey() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""key"", nullNS, mediator.getKey()));
            } else if (mediator.getName() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""name"", nullNS, mediator.getName()));

                if (mediator.getErrorHandler() != null) {
                    sequence.addAttribute(fac.createOMAttribute(
                            ""onError"", nullNS, mediator.getErrorHandler()));
                }
                saveTracingState(sequence, mediator);
                serializeChildren(sequence, mediator.getList());
            }
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return SequenceMediator.class.getName();
    }
}
"
org/apache/synapse/util/SimpleMap.java,false,"package org.apache.synapse.util;

import java.util.Map;
/*
 * This interface is a helper for dealing with a restriction on Map messages 
 * The key MUST be a String
 * and the value MUST be one of
 * boolean, char, String, int, double, float, long, short, byte, byte[] (Consider adding DataHandler in future)
 * or the equivalent Object
 * The simple type putters are equivalent to using an Object
 * so 
 * put(""paul"", new Integer(38));
 * getInt(""paul""); returns 38
 */

public interface SimpleMap extends Map {
	
	public Object get(String name);
	public void put(String name, Object value);
	public boolean getBoolean(String name);
	public void putBoolean(String name, boolean b);
	public String getString(String value);
	public void putString(String name, String value);
	public char getChar(String name);
	public void putChar(String name, char c);
	public int getInt(String name);
	public void putInt(String name, int i);
	public short getShort(String name);
	public void putShort(String name, short s);
	public float getFloat(String name);
	public void putFloat(String name, float fl);
	public double getDouble(String name);
	public void putDouble(String name, double d);
	public long getLong(String name);
	public void putLong(String name, long l);
	public byte getByte(String name);
	public void putByte(String name, byte b);
	public byte[] getBytes(String name);
	public void putBytes(String name, byte[] bytes);
	

}
"
org/apache/synapse/config/xml/MediatorPropertyFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * A utility class capable of creating instances of MediatorProperty objects by reading
 * through a given XML configuration
 *
 * <pre>
 * &lt;element&gt;
 *    &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/element&gt;
 * </pre>
 */
public class MediatorPropertyFactory {

    private static final Log log = LogFactory.getLog(MediatorPropertyFactory.class);

    public static List getMediatorProperties(OMElement elem) {

        List propertyList = new ArrayList();

        Iterator iter = elem.getChildrenWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property""));
        while (iter.hasNext()) {

            OMElement propEle = (OMElement) iter.next();
            OMAttribute attName  = propEle.getAttribute(MediatorProperty.ATT_NAME_Q);
            OMAttribute attValue = propEle.getAttribute(MediatorProperty.ATT_VALUE_Q);
            OMAttribute attExpr  = propEle.getAttribute(MediatorProperty.ATT_EXPR_Q);

            MediatorProperty prop = new MediatorProperty();

            if (attName == null || attName.getAttributeValue() == null ||
                attName.getAttributeValue().trim().length() == 0) {
                String msg = ""Entry name is a required attribute for a Log property"";
                log.error(msg);
                throw new SynapseException(msg);
            } else {
                prop.setName(attName.getAttributeValue());
            }

            // if a value is specified, use it, else look for an expression
            if (attValue != null) {
                if (attValue.getAttributeValue() == null || attValue.getAttributeValue().trim().length() == 0) {
                    String msg = ""Entry attribute value (if specified) is required for a Log property"";
                    log.error(msg);
                    throw new SynapseException(msg);
                } else {
                    prop.setValue(attValue.getAttributeValue());
                }

            } else if (attExpr != null) {

                if (attExpr.getAttributeValue() == null || attExpr.getAttributeValue().trim().length() == 0) {
                    String msg = ""Entry attribute expression (if specified) is required for a mediator property"";
                    log.error(msg);
                    throw new SynapseException(msg);

                } else {
                    try {
                        AXIOMXPath xp = new AXIOMXPath(attExpr.getAttributeValue());
                        OMElementUtils.addNameSpaces(xp, propEle, log);
                        prop.setExpression(xp);

                    } catch (JaxenException e) {
                        String msg = ""Invalid XPapth expression : "" + attExpr.getAttributeValue();
                        log.error(msg);
                        throw new SynapseException(msg, e);
                    }
                }

            } else {
                String msg = ""Entry attribute value OR expression must be specified for a mediator property"";
                log.error(msg);
                throw new SynapseException(msg);
            }

            propertyList.add(prop);
        }

        return propertyList;
    }
}
"
org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;

import javax.xml.namespace.QName;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;

/**
 * This dispatcher is implemented to demonstrate a sample client session. It will detect sessions
 * based on the <syn:ClientID xmlns:syn=""http://ws.apache.org/namespaces/synapse""> soap header of the
 * request message. Therefore, above header has to be included in the request soap messages by the
 * client who wants to initiate and maintain a session.
 */
public class SimpleClientSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    private Map sessionMap = Collections.synchronizedMap(new HashMap());

    public Endpoint getEndpoint(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                Object o = sessionMap.get(csID.getText());
                if (o != null) {
                    return (Endpoint) o;
                }
            }
        }

        return null;
    }

    public void updateSession(MessageContext synCtx, Endpoint endpoint) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                // synchronized to avoid possible replacement of sessions
                synchronized(sessionMap) {
                    if (!sessionMap.containsKey(csID.getText())) {
                        sessionMap.put(csID.getText(), endpoint);
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement csID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/synapse"", ""ClientID"", ""syn""));
            if(csID != null && csID.getText() != null) {
                sessionMap.remove(csID.getText());
            }
        }
    }

    public boolean isServerInitiatedSession() {
        return false;
    }
}
"
org/apache/synapse/mediators/filters/SwitchMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.SwitchCase;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The switch mediator implements the functionality of the ""switch"" contruct. It first
 * evaluates the given XPath expression into a String value, and performs a match against
 * the given list of cases. This is actually a list of sequences, and depending on the
 * selected case, the selected sequence gets executed.
 */
public class SwitchMediator extends AbstractMediator {

    /** The XPath expression specifying the source element to apply the switch case expressions against   */
    private AXIOMXPath source = null;
    /** The list of switch cases    */
    private List cases = new ArrayList();
    /** The default switch case, if any */
    private SwitchCase defaultCase = null;

    /**
     * Iterate over switch cases and find match and execute selected sequence
     *
     * @param synCtx current context
     * @return as per standard semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Switch mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        int parentsEffectiveTraceState = synCtx.getTracingState();
        // if I have been explicitly asked to enable or disable tracing, set it to the message
        // to pass it on; else, do nothing -> i.e. let the parents state flow
        setEffectiveTraceState(synCtx);
        int myEffectiveTraceState = synCtx.getTracingState();

        String sourceText = Axis2MessageContext.getStringValue(source, synCtx);
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""XPath : "" + source + "" evaluates to : "" + sourceText);
        }

        try {
            if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Source XPath evaluated to : null or no switch "" +
                        ""cases found. Executing the default case"");
                }

                return defaultCase.mediate(synCtx);

            } else {
                for (Iterator iter = cases.iterator(); iter.hasNext();) {
                    SwitchCase swCase = (SwitchCase) iter.next();

                    if (swCase != null) {
                        if (swCase.matches(sourceText)) {
                            if (traceOrDebugOn) {
                                traceOrDebug(traceOn, ""Matching case found : "" + swCase.getRegex());
                            }
                            return swCase.mediate(synCtx);
                        }
                    }
                }

                if (defaultCase != null) {
                    // if any of the switch cases did not match
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""None of the switch cases matched - executing default"");
                    }
                    return defaultCase.mediate(synCtx);
                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""None of the switch cases matched - no default case"");
                    }
                }
            }

        } finally {
            synCtx.setTracingState(parentsEffectiveTraceState);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Switch mediator"");
        }
        return true;
    }

    /**
     * Adds the given mediator (Should be a SwitchCaseMediator) to the list of cases
     * of this Switch mediator
     *
     * @param m the SwitchCaseMediator instance to be added
     */
    public void addCase(SwitchCase m) {
        cases.add(m);
    }

    /**
     * Get the list of cases
     *
     * @return the cases list
     */
    public List getCases() {
        return cases;
    }

    /**
     * Return the source XPath expression set
     *
     * @return thje source XPath expression
     */
    public AXIOMXPath getSource() {
        return source;
    }

    /**
     * Sets the source XPath expression
     *
     * @param source the XPath expression to be used as the source
     */
    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    /**
     * Get default case
     *
     * @return the default csae
     */
    public SwitchCase getDefaultCase() {
        return defaultCase;
    }

    /**
     * setting the default case ...which contains mediators to invoke when no case condition satisfy
     * @param defaultCase
     */
    public void setDefaultCase(SwitchCase defaultCase) {
        this.defaultCase = defaultCase;
    }
}
"
org/apache/synapse/metrics/Counter.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;
/*
 * This is the basic unit to get Global, Proxy Service or
 * Proxy Opertaion Level hit count. 
 */

public class Counter {

    private long count = 0;

    public synchronized void increment(){
        count++;
    }

    public long getCount() {
        return count;
    }
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates FailoverEndpoint using a XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <failover>
 *       <endpoint>+
 *    </failover>
 * </endpoint>
 */
public class FailoverEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(FailoverEndpointFactory.class);

    private static FailoverEndpointFactory instance = new FailoverEndpointFactory();

    private FailoverEndpointFactory() {}

    public static FailoverEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        OMElement failoverElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""failover""));
        if (failoverElement != null) {

            FailoverEndpoint failoverEndpoint = new FailoverEndpoint();

            // set endpoint name
            String name = epConfig.getAttributeValue(new QName(""name""));
            if (name != null) {
                failoverEndpoint.setName(name);
            }

            // set endpoints
            ArrayList endpoints = getEndpoints(failoverElement, failoverEndpoint);
            failoverEndpoint.setEndpoints(endpoints);

            return failoverEndpoint;
        }

        return null;
    }

    public Object getObjectFromOMNode(OMNode om) {
         if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement failoverElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = failoverElement.getChildrenWithName
                (org.apache.synapse.config.xml.XMLConfigConstants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/mediators/eip/aggregator/Aggregate.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.aggregator;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.List;
import java.util.ArrayList;

/**
 * This holds the Aggregate properties and the list of messages which participate in the aggregation
 */
public class Aggregate {

    /**
     *
     */
    private static final Log log = LogFactory.getLog(Aggregate.class);

    /**
     *
     */
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     *
     */
    private long timeout = 0;

    /**
     *
     */
    private long expireTime = 0;

    /**
     *
     */
    private int minCount = -1;

    /**
     *
     */
    private int maxCount = -1;

    /**
     *
     */
    private String corelation = null;

    /**
     *
     */
    private List messages = new ArrayList();

    /**
     * This is the constructor of the Aggregate which will set the timeout depending on the
     * timeout for the aggregate
     *
     * @param corelation - String representing the corelation name of the messages in the aggregate
     * @param timeout -
     * @param min -
     * @param max -
     */
    public Aggregate(String corelation, long timeout, int min, int max) {
        this.corelation = corelation;
        if (timeout > 0) {
            this.timeout = System.currentTimeMillis() + expireTime;
        }
        if (min > 0) {
            this.minCount = min;
        }
        if (max > 0) {
            this.maxCount = max;
        }
    }

    /**
     * @param synCtx -
     * @return true if the message was added and false if not
     */
    public boolean addMessage(MessageContext synCtx) {
        if (this.maxCount > 0 && this.messages.size() < this.maxCount || this.maxCount <= 0) {
            this.messages.add(synCtx);
            return true;
        } else {
            return false;
        }
    }

    /**
     * @return boolean stating the completeness of the corelation
     */
    public boolean isComplete() {

        boolean completed = false;
        if (!messages.isEmpty()) {

            Object o = messages.get(0);
            if (o instanceof MessageContext) {

                Object prop = ((MessageContext) o).getProperty(EIPConstants.MESSAGE_SEQUENCE);
                if (prop instanceof String) {

                    String[] msgSequence
                            = prop.toString().split(EIPConstants.MESSAGE_SEQUENCE_DELEMITER);
                    if (messages.size() >= Integer.parseInt(msgSequence[1])) {
                        completed = true;
                    }
                }
            }
        }

        if (!completed && this.minCount > 0) {
            completed = this.messages.size() >= this.minCount
                    || this.timeout < System.currentTimeMillis();
        }

        return completed;
    }

    public long getTimeout() {
        return timeout;
    }

    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }

    public int getMinCount() {
        return minCount;
    }

    public void setMinCount(int minCount) {
        this.minCount = minCount;
    }

    public int getMaxCount() {
        return maxCount;
    }

    public void setMaxCount(int maxCount) {
        this.maxCount = maxCount;
    }

    public String getCorelation() {
        return corelation;
    }

    public void setCorelation(String corelation) {
        this.corelation = corelation;
    }

    public List getMessages() {
        return messages;
    }

    public void setMessages(List messages) {
        this.messages = messages;
    }

    public long getExpireTime() {
        return expireTime;
    }

    public void setExpireTime(long expireTime) {
        this.expireTime = expireTime;
    }

}
"
org/apache/synapse/SynapseServer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.File;

/**
 * Starts all transports as specified on the axis2.xml
 */
public class SynapseServer {

    private static final Log log = LogFactory.getLog(SynapseServer.class);

    public static void printUsage() {
        System.out.println(""Usage: SynapseServer <repository>"");
        System.out.println("" Opts: -? this message"");
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {

        // first check if we should print usage
        if (args.length != 1 || !new File(args[0]).exists()) {
            printUsage();
        }

        ServerManager serverManager = ServerManager.getInstance();
        serverManager.setAxis2Repolocation(args[0]);
        serverManager.start();
        addShutdownHook();

    }

    private static void addShutdownHook() {
        Thread shutdownHook = new Thread() {
            public void run() {
                log.info(""Shutting down Apache Synapse ..."");
                try {
                    ServerManager.getInstance().stop();
                    log.info(""Shutdown complete"");
                    log.info(""Halting JVM"");
                } catch (Exception e) {
                    log.warn(""Error occurred while shutting down Apache Synapse : "" + e);
                }
            }
        };
        Runtime.getRuntime().addShutdownHook(shutdownHook);
    }
}
"
org/apache/synapse/config/xml/EntryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMText;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.net.URL;
import java.net.MalformedURLException;

public class EntryFactory implements XMLToObjectMapper {

    private static Log log = LogFactory.getLog(EntryFactory.class);

    public static Entry createEntry(OMElement elem) {

        OMAttribute key = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
        if (key == null) {
            handleException(""The 'key' attribute is required for a local registry entry"");
            return null;

        } else {

            Entry entry = new Entry(key.getAttributeValue());
            String src  = elem.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, ""src""));

            // if a src attribute is present, this is a URL source resource,
            // it would now be loaded from the URL source, as all static properties
            // are initialized at startup
            if (src != null) {
                try {
                    entry.setSrc(new URL(src.trim()));
                    entry.setType(Entry.URL_SRC);
                    entry.setValue(
                        org.apache.synapse.config.SynapseConfigUtils.getObject(entry.getSrc()));
                } catch (MalformedURLException e) {
                    handleException(""The entry with key : "" + key + "" refers to an invalid URL"");
                }

            } else {
                OMNode    nodeValue = elem.getFirstOMChild();
                OMElement elemValue = elem.getFirstElement();

                if (elemValue != null) {
                    entry.setType(Entry.INLINE_XML);
                    entry.setValue(elemValue);
                } else if (nodeValue != null && nodeValue instanceof OMText) {
                    entry.setType(Entry.INLINE_TEXT);
                    entry.setValue(((OMText) nodeValue).getText().trim());
                }
            }
            return entry;
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEntry((OMElement) om);
        } else {
            handleException(""Invalid XML configuration for an Entry. OMElement expected"");
        }
        return null;
    }
}
"
org/apache/synapse/statistics/StatisticsCollector.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.SynapseConstants;

import java.util.*;

/**
 * To collect statistics
 */

public class StatisticsCollector {

    /**  A synchronized map for holding sequence statistics  */
    private Map sequenceStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding end point statistics */
    private Map endpointStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding proxy services statistics */
    private Map proxyServicesStatistics = Collections.synchronizedMap(new HashMap());

    /**
     * To report the statistics related to a  EndPonit
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForEndPoint(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) endpointStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.ENDPOINT_STATISTICS);
            endpointStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);

    }

    /**
     * To report the statistics related to a  ProxyService
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForProxyService(String keyOfStatistic, boolean isResponse, long inTime,
                                      long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) proxyServicesStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.PROXYSERVICE_STATISTICS);
            proxyServicesStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To report the statistics related to a  Sequence
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForSequence(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) sequenceStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.SEQUENCE_STATISTICS);
            sequenceStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To access all sequence statistics
     *
     * @return all sequence statistics
     */
    public Map getSequenceStatistics() {
        return sequenceStatistics;
    }

    /**
     * To access all proxy services statistics
     *
     * @return all proxy services statistics
     */
    public Map getProxyServiceStatistics() {
        return proxyServicesStatistics;
    }

    /**
     * To access all endpoint statistics
     *
     * @return all endpoint statistics
     */
    public Map getEndPointStatistics() {
        return endpointStatistics;
    }

    /**
     * To reset the sequence statistics
     */
    public void resetSequenceStatistics() {
        this.sequenceStatistics = Collections.synchronizedMap(new HashMap());
    }

    /**
     * To reset the proxy service statistics
     */
    public void resetProxyServiceStatistics() {
        this.proxyServicesStatistics = Collections.synchronizedMap(new HashMap());
    }

    /**
     * To reset the endpoint statistics
     */
    public void resetEndPointStatistics() {
        this.endpointStatistics = Collections.synchronizedMap(new HashMap());
    }
}
"
org/apache/synapse/config/xml/MediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

/**
 * Interface which should be implemented by mediator serializers. Does the
 * reverse of the MediatorFactory
 */
public interface MediatorSerializer {

    /**
     * Return the XML representation of this mediator
     * @param m mediator to be serialized
     * @param parent the OMElement to which the serialization should be attached
     * @return the serialized mediator XML
     */
    public OMElement serializeMediator(OMElement parent, Mediator m);

    /**
     * Return the class name of the mediator which can be serialized
     * @return the class name 
     */
    public String getMediatorClassName();
}
"
org/apache/synapse/config/xml/endpoints/EndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.axiom.om.OMElement;

/**
 * All endpoint factories should implement this interface. Use EndpointAbstractFactory to obtain the
 * correct endpoint fatory for particular endpoint configuration. As endpoints can be nested inside
 * each other, EndpointFactory implementations may call other EndpointFactory implementations recursively
 * to obtain the required endpoint hierachy.
 *
 * This also serves as the XMLToObjactMapper implementation for specific endpoint implementations.
 * If the endpoint type is not known use XMLToEndpointMapper as the generic XMLToObjectMapper for
 * all endpoints.
 */
public interface EndpointFactory extends XMLToObjectMapper {

    /**
     * Creates the Endpoint implementation for the given XML endpoint configuration. If the endpoint
     * configuration is an inline one, it should be anonymous endpoint. If it is defined as an immediate
     * child element of the <definitions> it should have a name, which is used as the key in local registry.
     *
     * @param epConfig OMElement conatining the endpoint configuration.
     * @param anonymousEndpoint false if the endpoint has a name. true otherwise.
     * @return Endpoint implementation for the given configuration.
     */
    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint);
}
"
org/apache/synapse/mediators/ListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.Mediator;

import java.util.List;

/**
 * The List mediator executes a given sequence/list of child mediators
 */
public interface ListMediator extends Mediator {

    /**
     * Appends the specified mediator to the end of this mediator's (children) list
     * @param m the mediator to be added
     * @return true (as per the general contract of the Collection.add method)
     */
    public boolean addChild(Mediator m);

    /**
     * Appends all of the mediators in the specified collection to the end of this mediator's (children)
     * list, in the order that they are returned by the specified collection's iterator
     * @param c the list of mediators to be added
     * @return true if this list changed as a result of the call
     */
    public boolean addAll(List c);

    /**
     * Returns the mediator at the specified position
     * @param pos index of mediator to return
     * @return the mediator at the specified position in this list
     */
    public Mediator getChild(int pos);

    /**
     * Removes the first occurrence in this list of the specified mediator
     * @param m mediator to be removed from this list, if present
     * @return true if this list contained the specified mediator
     */
    public boolean removeChild(Mediator m);

    /**
     * Removes the mediator at the specified position in this list
     * @param pos the index of the mediator to remove
     * @return the mediator previously at the specified position
     */
    public Mediator removeChild(int pos);

    /**
     * Return the list of mediators of this List mediator instance
     * @return the child/sub mediator list
     */
    public List getList();
}
"
org/apache/synapse/config/xml/SequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

import javax.xml.namespace.QName;

/**
 * Builds an instance of a Sequence mediator through the Synapse configuration.
 * It follows the following configuration;
 *
 * <pre>
 * &lt;sequence name=""string"" [onError=""string""] [trace=""enable|disable""]&gt;
 *   mediator+
 * &lt;/sequence&gt;
 * </pre>
 *
 * OR
 *
 * <pre>
 * &lt;sequence key=""name""/&gt;
 * </pre>
 */
public class SequenceMediatorFactory extends AbstractListMediatorFactory {

    private static final QName SEQUENCE_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sequence"");

    public QName getTagQName() {
        return SEQUENCE_Q;
    }

    public SequenceMediator createAnonymousSequence(OMElement elem) {
        SequenceMediator seqMediator = new SequenceMediator();
        OMAttribute e = elem.getAttribute(ATT_ONERROR);
        if (e != null) {
            seqMediator.setErrorHandler(e.getAttributeValue());
        }
        processTraceState(seqMediator, elem);
        addChildren(elem, seqMediator);
        OMAttribute statistics = elem.getAttribute(ATT_STATS);
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }
        return seqMediator;
    }
    
    public Mediator createMediator(OMElement elem) {

        SequenceMediator seqMediator = new SequenceMediator();

        OMAttribute n = elem.getAttribute(ATT_NAME);
        OMAttribute e = elem.getAttribute(ATT_ONERROR);
        if (n != null) {
            seqMediator.setName(n.getAttributeValue());
            if (e != null) {
                seqMediator.setErrorHandler(e.getAttributeValue());
            }
            processTraceState(seqMediator, elem);
            addChildren(elem, seqMediator);

        } else {
            n = elem.getAttribute(ATT_KEY);
            if (n != null) {
                seqMediator.setKey(n.getAttributeValue());
                if (e != null) {
                    String msg = ""A sequence mediator with a reference to another "" +
                        ""sequence can not have 'ErrorHandler'"";
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            } else {
                String msg = ""A sequence mediator should be a named sequence or a reference "" +
                    ""to another sequence (i.e. a name attribute or key attribute is required)"";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMAttribute statistics = elem.getAttribute(ATT_STATS);
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }

        return seqMediator;
    }
}
"
org/apache/synapse/statistics/impl/SequenceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The data structure to hold statistics related to Sequences
 *
 */

public class SequenceStatisticsStack implements StatisticsStack {

    /** The list to hols SequenceStatistics */
    private List sequenceStatisticsList = new ArrayList();

    /**
     * To put a statistics
     *
     * @param sequenceName       - The name of the sequence
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String sequenceName, long initTime, boolean isInFlow,
                    boolean isStatisticsEnable, boolean isFault) {
        sequenceStatisticsList.add(new SequenceStatistics(sequenceName, initTime,
                isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        int top = sequenceStatisticsList.size();
        if (top > 0) {
            popSequenceStatistics(sequenceStatisticsList.size() - 1, statisticsCollector);
        }
    }

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (!sequenceStatisticsList.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator seqIterator = sequenceStatisticsList.iterator();
                 seqIterator.hasNext();) {
                SequenceStatistics sequenceStatistics =
                        (SequenceStatistics) seqIterator.next();
                if (sequenceStatistics != null) {
                    if (sequenceStatistics.isStatisticsEnable &&
                            sequenceStatistics.sequenceName != null &&
                            sequenceStatistics.sequenceName.equals(name)
                            ) {
                        statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                                !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                                System.currentTimeMillis(), sequenceStatistics.isFault);
                    }
                    tobeRemoved.add(sequenceStatistics);
                }
            }
            sequenceStatisticsList.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        int i = sequenceStatisticsList.size() - 1;
        for (; i >= 0; i--) {
            popSequenceStatistics(i, statisticsCollector);
        }
    }

    /**
     * A helper method to pop a SequenceStatistics
     * @param index
     * @param statisticsCollector
     */
    private void popSequenceStatistics(int index, StatisticsCollector statisticsCollector) {
        if (index >= 0) {
            SequenceStatistics sequenceStatistics =
                    (SequenceStatistics) sequenceStatisticsList.get(index);
            if (sequenceStatistics != null) {
                if (sequenceStatistics.isStatisticsEnable &&
                        sequenceStatistics.sequenceName != null) {
                    statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                            !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                            System.currentTimeMillis(), sequenceStatistics.isFault);
                }
                sequenceStatisticsList.remove(index);
            }
        }
    }

    /**
     * The SequenceStatistics data structure
     */
    class SequenceStatistics {

        /** The name of the Sequence */
        String sequenceName;
        /** The time which starts to collect statistics */
        long initTime;
        /** To check whether IN message flow or not */
        boolean isInFlow;
        /** To check whether statistics is enabled or not */
        boolean isStatisticsEnable;
        /** To indicate whether this is fault or not*/
        private boolean isFault;

        public SequenceStatistics(String sequenceName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean isFault) {
            this.sequenceName = sequenceName;
            this.initTime = initTime;
            isInFlow = inFlow;
            isStatisticsEnable = statisticsEnable;
            this.isFault = isFault;
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            final SequenceStatistics that = (SequenceStatistics) o;

            if (!sequenceName.equals(that.sequenceName)) return false;

            return true;
        }

        public int hashCode() {
            return sequenceName.hashCode();
        }
    }

}
"
org/apache/synapse/config/xml/CacheMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CacheMediator;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.wso2.caching.CachingConstants;
import org.wso2.caching.digest.DigestGenerator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Cache mediator using XML configuration specified
 * 
 * &lt;cache (id=""string"")? hashGenerator=""class"" scope=""string"" timeout=""mili-seconds""&gt;
 *  &lt;onCacheHit (sequence=""key"")?&gt;
 *   (mediator)+
 *  &lt;/onCacheHit&gt;
 *  &lt;implementation type=(memory | disk) maxSize=""int""/&gt;
 * &lt;/cache&gt;
 */
public class CacheMediatorFactory extends AbstractMediatorFactory {

    private static final QName CACHE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""cache"");
    private static final QName ATT_ID  = new QName(""id"");
    private static final QName ATT_HASH_GENERATOR = new QName(""hashGenerator"");
    private static final QName ATT_TIMEOUT        = new QName(""timeout"");
    private static final QName ATT_SCOPE          = new QName(""scope"");
    private static final QName ATT_SEQUENCE       = new QName(""sequence"");
    private static final QName ATT_TYPE           = new QName(""type"");
    private static final QName ATT_SIZE           = new QName(""maxSize"");
    private static final QName ON_CACHE_HIT_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""onCacheHit"");
    private static final QName IMPLEMENTATION_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""implementation"");
    private static final long DEFAULT_TIMEOUT = 5000L;
    private static final int DEFAULT_DISK_CACHE_SIZE = 200;

    public Mediator createMediator(OMElement elem) {

        if (!CACHE_Q.equals(elem.getQName())) {
            handleException(""Unable to create the cache mediator. "" +
                ""Unexpected element as the cache mediator configuration"");
        }
        
        CacheMediator cache = new CacheMediator();

        OMAttribute idAttr = elem.getAttribute(ATT_ID);
        if (idAttr != null && idAttr.getAttributeValue() != null){
            cache.setId(idAttr.getAttributeValue());
        }

        OMAttribute hashGeneratorAttr = elem.getAttribute(ATT_HASH_GENERATOR);
        if (hashGeneratorAttr != null && hashGeneratorAttr.getAttributeValue() != null) {
            try {
                Class generator = Class.forName(hashGeneratorAttr.getAttributeValue());
                Object o = generator.newInstance();
                if (o instanceof DigestGenerator) {
                    cache.setDigestGenerator((DigestGenerator) o);
                } else {
                    handleException(""Specified class for the hashGenerator is not a "" +
                        ""DigestGenerator. It *must* implement "" +
                        ""org.wso2.caching.digest.DigestGenerator interface"");
                }
            } catch (ClassNotFoundException e) {
                handleException(""Unable to load the hash generator class"", e);
            } catch (IllegalAccessException e) {
                handleException(""Unable to access the hash generator class"", e);
            } catch (InstantiationException e) {
                handleException(""Unable to instantiate the hash generator class"", e);
            }
        }

        OMAttribute timeoutAttr = elem.getAttribute(ATT_TIMEOUT);
        if (timeoutAttr != null && timeoutAttr.getAttributeValue() != null) {
            cache.setTimeout(Long.parseLong(timeoutAttr.getAttributeValue()));
        } else {
            cache.setTimeout(DEFAULT_TIMEOUT);
        }

        OMAttribute scopeAttr = elem.getAttribute(ATT_SCOPE);
        if (scopeAttr != null && scopeAttr.getAttributeValue() != null
            && isValidScope(scopeAttr.getAttributeValue())) {
            cache.setScope(scopeAttr.getAttributeValue());
        } else {
            cache.setScope(CachingConstants.SCOPE_PER_HOST);
        }

        OMElement onCacheHitElem = elem.getFirstChildWithName(ON_CACHE_HIT_Q);
        if (onCacheHitElem != null) {
            OMAttribute sequenceAttr = onCacheHitElem.getAttribute(ATT_SEQUENCE);
            if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {
                cache.setOnCacheHitRef(sequenceAttr.getAttributeValue());
            } else {
                cache.setOnCacheHitSequence(
                    new SequenceMediatorFactory().createAnonymousSequence(onCacheHitElem));
            }
        }

        for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {
            OMElement implElem = (OMElement) itr.next();
            OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);
            OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);
            if (typeAttr != null && typeAttr.getAttributeValue() != null) {
                String type = typeAttr.getAttributeValue();
                if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null
                    && sizeAttr.getAttributeValue() != null) {
                    cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));
                } else if (CachingConstants.TYPE_DISK.equals(type)) {
                    log.warn(""Disk based and hirearchycal caching is not implemented yet"");
                    if (sizeAttr != null && sizeAttr.getAttributeValue() != null) {
                        cache.setDiskCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));
                    } else {
                        cache.setDiskCacheSize(DEFAULT_DISK_CACHE_SIZE);
                    }
                } else {
                    handleException(""unknown implementation type for the Cache mediator"");
                }
            }
        }


        return cache;
    }

    private boolean isValidScope(String scope) {
        if (CachingConstants.SCOPE_PER_HOST.equals(scope)) {
            return true;
        } else if (CachingConstants.SCOPE_PER_MEDIATOR.equals(scope)) {
            return true;
        } else if (CachingConstants.SCOPE_DISTRIBUTED.equals(scope)) {
            handleException(""Scope distributed is not supported yet by the Cache mediator"");
            return false;
        } else {
            handleException(""Unknown scope "" + scope + "" for the Cache mediator"");
            return false;
        }
    }

    public QName getTagQName() {
        return CACHE_Q;
    }
}
"
org/apache/synapse/config/xml/ValidateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.Iterator;
import java.util.List;

/**
 * <validate [source=""xpath""]>
 *   <schema key=""string"">+
 *   <property name=""<validation-feature-name>"" value=""true|false""/>
 *   <on-fail>
 *     mediator+
 *   </on-fail>
 * </validate>
 */
public class ValidateMediatorSerializer extends AbstractListMediatorSerializer
    implements MediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ValidateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        ValidateMediator mediator = (ValidateMediator) m;
        OMElement validate = fac.createOMElement(""validate"", synNS);
        saveTracingState(validate, mediator);

        if (mediator.getSource() != null) {
            validate.addAttribute(fac.createOMAttribute(
                    ""source"", nullNS, mediator.getSource().toString()));
            serializeNamespaces(validate, mediator.getSource());
        }

        Iterator iterator = mediator.getSchemaKeys().iterator();
        while (iterator.hasNext()) {
            String key = (String) iterator.next();
            OMElement schema = fac.createOMElement(""schema"", synNS, validate);
            schema.addAttribute(fac.createOMAttribute(""key"", nullNS, key));
        }

        List features = mediator.getFeatures();
        if (!features.isEmpty()) {
            for (Iterator iter = features.iterator(); iter.hasNext();) {
                MediatorProperty mp = (MediatorProperty) iter.next();
                OMElement feature = fac.createOMElement(""feature"", synNS, validate);
                if (mp.getName() != null) {
                    feature.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
                } else {
                    handleException(""The Feature name is missing"");
                }
                if (mp.getValue() != null) {
                    feature.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));
                } else {
                    handleException(""The Feature value is missing"");
                }
            }
        }
        OMElement onFail = fac.createOMElement(""on-fail"", synNS, validate);
        serializeChildren(onFail, mediator.getList());

        if (parent != null) {
            parent.addChild(validate);
        }
        return validate;
    }

    public String getMediatorClassName() {
        return ValidateMediator.class.getName();
    }

}
"
org/apache/synapse/util/concurrent/SynapseThreadPool.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.concurrent;

import org.apache.synapse.config.SynapseConfiguration;

import java.util.concurrent.*;

/**
 * This is the executor service that will be returned by the env
 */
public class SynapseThreadPool extends ThreadPoolExecutor {

    // default values
    public static final int SYNAPSE_CORE_THREADS  = 20;
    public static final int SYNAPSE_MAX_THREADS   = 100;
    public static final int SYNAPSE_KEEP_ALIVE    = 5;
    public static final int SYNAPSE_THREAD_QLEN   = 10;
    public static final String SYNAPSE_THREAD_GROUP     = ""synapse-thread-group"";
    public static final String SYNAPSE_THREAD_ID_PREFIX = ""SynapseWorker"";

    // property keys
    public static final String SYN_THREAD_CORE     = ""synapse.threads.core"";
    public static final String SYN_THREAD_MAX      = ""synapse.threads.max"";
    public static final String SYN_THREAD_ALIVE    = ""synapse.threads.keepalive"";
    public static final String SYN_THREAD_QLEN     = ""synapse.threads.qlen"";
    public static final String SYN_THREAD_GROUP    = ""synapse.threads.group"";
    public static final String SYN_THREAD_IDPREFIX = ""synapse.threads.idprefix"";

    /**
     * Constructor for the Synapse thread poll
     * 
     * @param corePoolSize    - number of threads to keep in the pool, even if they are idle
     * @param maximumPoolSize - the maximum number of threads to allow in the pool
     * @param keepAliveTime   - this is the maximum time that excess idle threads will wait
     *  for new tasks before terminating.
     * @param unit            - the time unit for the keepAliveTime argument.
     * @param workQueue       - the queue to use for holding tasks before they are executed.
     */
    public SynapseThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
        TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            new SynapseThreadFactory(
                new ThreadGroup(SYNAPSE_THREAD_GROUP), SYNAPSE_THREAD_ID_PREFIX));
    }

    /**
     * Default Constructor for the thread pool and will use all the values as default
     */
    public SynapseThreadPool() {
        this(SYNAPSE_CORE_THREADS, SYNAPSE_MAX_THREADS, SYNAPSE_KEEP_ALIVE,
            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
    }

    /**
     * Constructor for the SynapseThreadPool
     * 
     * @param corePoolSize  - number of threads to keep in the pool, even if they are idle
     * @param maxPoolSize   - the maximum number of threads to allow in the pool
     * @param keepAliveTime - this is the maximum time that excess idle threads will wait
     *  for new tasks before terminating.
     * @param qlen          - Thread Blocking Queue length
     * @param threadGroup    - ThreadGroup name
     * @param threadIdPrefix - Thread id prefix
     */
    public SynapseThreadPool(int corePoolSize, int maxPoolSize, long keepAliveTime, int qlen,
        String threadGroup, String threadIdPrefix) {
        super(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.SECONDS,
            new LinkedBlockingQueue<Runnable>(qlen),
            new SynapseThreadFactory(new ThreadGroup(threadGroup), threadIdPrefix));
    }
}
"
org/apache/synapse/core/axis2/ProxyService.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMElement;
import org.apache.axis2.AxisFault;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.SynapseConfigUtils;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.io.IOException;
import java.io.InputStream;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.util.*;
import java.net.*;

/**
 * <proxy-service name=""string"" [transports=""(http |https |jms )+|all""] [trace=""enable|disable""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <enableSec/>?
 *    <enableRM/>?
 *    <policy key=""string"">?
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxy-service>
 */
public class ProxyService {

    private static final Log log = LogFactory.getLog(ProxyService.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
    private final Log serviceLog;
    /**
     * The name of the proxy service
     */
    private String name;
    /**
     * The proxy service description. This could be optional informative text about the service
     */
    private String description;
    /**
     * The transport/s over which this service should be exposed, or defaults to all available
     */
    private ArrayList transports;
    /**
     * The target endpoint key
     */
    private String targetEndpoint = null;
    /**
     * The target inSequence key
     */
    private String targetInSequence = null;
    /**
     * The target outSequence key
     */
    private String targetOutSequence = null;
    /**
     * The target faultSequence key
     */
    private String targetFaultSequence = null;
    /**
     * The inlined definition of the target endpoint, if defined
     */
    private Endpoint targetInLineEndpoint = null;
    /**
     * The inlined definition of the target in-sequence, if defined
     */
    private SequenceMediator targetInLineInSequence = null;
    /**
     * The inlined definition of the target out-sequence, if defined
     */
    private SequenceMediator targetInLineOutSequence = null;
    /**
     * The inlined definition of the target fault-sequence, if defined
     */
    private SequenceMediator targetInLineFaultSequence = null;
    /**
     * A list of any service parameters (e.g. JMS parameters etc)
     */
    private Map parameters = new HashMap();
    /**
     * The key for the base WSDL
     */
    private String wsdlKey;
    /**
     * The URI for the base WSDL, if defined as a URL
     */
    private URI wsdlURI;
    /**
     * The inlined representation of the service WSDL, if defined inline
     */
    private Object inLineWSDL;
    /**
     * The keys for any supplied policies that would apply at the service level
     */
    private List serviceLevelPolicies = new ArrayList();
    /**
     * Should WS RM be engaged on this service
     */
    private boolean wsRMEnabled = false;
    /**
     * Should WS Sec be engaged on this service
     */
    private boolean wsSecEnabled = false;
    /**
     * Should this service be started by default on initialization?
     */
    private boolean startOnLoad = true;
    /**
     * Is this service running now?
     */
    private boolean running = false;

    public static final String ALL_TRANSPORTS = ""all"";

    /**
     * To decide to whether statistics should have collected or not
     */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;
    /**
     * The variable that indicate tracing on or off for the current mediator
     */
    protected int traceState = SynapseConstants.TRACING_UNSET;


    /**
     * Constructor
     *
     * @param name the name of the Proxy service
     */
    public ProxyService(String name) {
        this.name = name;
        serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX + name);
    }

    /**
     * Build the underlying Axis2 service from the Proxy service definition
     *
     * @param synCfg the Synapse configuration
     * @param axisCfg the Axis2 configuration
     * @return the Axis2 service for the Proxy
     */
    public AxisService buildAxisService(SynapseConfiguration synCfg, AxisConfiguration axisCfg) {

        auditInfo(""Building Axis service for Proxy service : "" + name);
        AxisService proxyService = null;

        // get the wsdlElement as an OMElement
        if (trace()) {
            trace.info(""Loading the WSDL : "" +
                (wsdlKey != null ? "" key = "" + wsdlKey :
                (wsdlURI != null ? "" URI = "" + wsdlURI : "" <Inlined>"")));
        }

        InputStream wsdlInputStream = null;
        OMElement wsdlElement = null;

        if (wsdlKey != null) {
            synCfg.getEntryDefinition(wsdlKey);
            Object keyObject = synCfg.getEntry(wsdlKey);
            if (keyObject instanceof OMElement) {
                wsdlElement = (OMElement) keyObject;
            }
        } else if (inLineWSDL != null) {
            wsdlElement = (OMElement) inLineWSDL;
        } else if (wsdlURI != null) {
            try {
                URL url = wsdlURI.toURL();
                wsdlElement = SynapseConfigUtils.getOMElementFromURL(url.toString());
            } catch (MalformedURLException e) {
                handleException(""Malformed URI for wsdl"", e);
            } catch (IOException e) {
                handleException(""Error reading from wsdl URI"", e);
            }
        }

        // if a WSDL was found
        if (wsdlElement != null) {
            OMNamespace wsdlNamespace = wsdlElement.getNamespace();

            // serialize and create an inputstream to read WSDL
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                if (trace()) trace.info(""Serializing wsdlElement found to build an Axis2 service"");
                wsdlElement.serialize(baos);
                wsdlInputStream = new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

            if (wsdlInputStream != null) {

                try {
                    // detect version of the WSDL 1.1 or 2.0
                    if (trace()) trace.info(""WSDL Namespace is : "" + wsdlNamespace.getNamespaceURI());

                    if (wsdlNamespace != null) {
                        boolean isWSDL11 = false;
                        WSDLToAxisServiceBuilder wsdlToAxisServiceBuilder = null;

                        if (WSDL2Constants.WSDL_NAMESPACE.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL20ToAxisServiceBuilder(wsdlInputStream, null, null);
                            wsdlToAxisServiceBuilder.setBaseUri(wsdlURI != null ? wsdlURI.toString() : """");

                        } else if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL11ToAxisServiceBuilder(wsdlInputStream, null, null);
                            isWSDL11 = true;
                        } else {
                            handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                        }

                        if (wsdlToAxisServiceBuilder == null) {
                            throw new SynapseException(
                                    ""Could not get the WSDL to Axis Service Builder"");
                        }

                        if (trace()) {
                            trace.info(""Populating Axis2 service using WSDL"");
                            if (trace.isTraceEnabled()) {
                                trace.trace(""WSDL : "" + wsdlElement.toString());
                            }
                        }
                        proxyService = wsdlToAxisServiceBuilder.populateService();
                        List schemaList = proxyService.getSchema();
                        if (schemaList != null && schemaList.size() > 0) {
                            // just pick the first schema's target namespace as Axis2's
                            // HTTPTransportUtils code already contains a bug where it uses the
                            // services' schema target NS for each operation
                            proxyService.setSchemaTargetNamespace(
                                proxyService.getSchema(0).getTargetNamespace());
                        }
                        proxyService.setWsdlFound(true);

                        if (isWSDL11) {
                            // workaround to support WSDL 2.0 generation when only a WSDL 1.1
                            // is supplied
                            Collection endpoints = proxyService.getEndpoints().values();
                            Iterator iter = endpoints.iterator();
                            while (iter.hasNext()) {
                                AxisEndpoint endpoint = (AxisEndpoint) iter.next();
                                Iterator children = endpoint.getBinding().getChildren();
                                while (children.hasNext()) {
                                    AxisBindingOperation axisBindingOperation =
                                        (AxisBindingOperation) children.next();
                                    axisBindingOperation.setProperty(
                                        WSDL2Constants.ATTR_WHTTP_IGNORE_UNCITED, new Boolean(false));
                                }
                            }
                        }

                    } else {
                        handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                    }

                } catch (AxisFault af) {
                    handleException(""Error building service from WSDL"", af);
                } catch (IOException ioe) {
                    handleException(""Error reading WSDL"", ioe);
                }
            }
        } else {
            // this is for POX... create a dummy service and an operation for which
            // our SynapseDispatcher will properly dispatch to
            if (trace()) trace.info(""Did not find a WSDL. Assuming a POX or Legacy service"");
            proxyService = new AxisService();
            AxisOperation mediateOperation = new InOutAxisOperation(new QName(""mediate""));
            proxyService.addOperation(mediateOperation);
        }

        // Set the name and description. Currently Axis2 uses the name as the
        // default Service destination
        if (proxyService == null) {
            throw new SynapseException(""Could not create a proxy service"");
        }
        proxyService.setName(name);
        if (description != null) {
            proxyService.setDocumentation(description);
        }

        // process transports and expose over requested transports. If none
        // is specified, default to all transports using service name as
        // destination
        if (transports == null || transports.size() == 0) {
            // default to all transports using service name as destination
        } else {
            if (trace()) trace.info(""Exposing transports : "" + transports);
            proxyService.setExposedTransports(transports);
        }

        // process parameters
        if (trace()) trace.info(""Setting service parameters : "" + parameters);
        Iterator iter = parameters.keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            Object value = parameters.get(name);

            Parameter p = new Parameter();
            p.setName(name);
            p.setValue(value);

            try {
                proxyService.addParameter(p);
            } catch (AxisFault af) {
                handleException(""Error setting parameter : "" + name + """" +
                        ""to proxy service as a Parameter"", af);
            }
        }

        if (trace()) trace.info(""Setting service level policies : "" + serviceLevelPolicies);
        // if service level policies are specified, apply them

        if (!serviceLevelPolicies.isEmpty()) {
            Policy svcEffectivePolicy = null;
            iter = serviceLevelPolicies.iterator();

            while (iter.hasNext()) {
                String policyKey = (String) iter.next();
                synCfg.getEntryDefinition(policyKey);
                Object policyProp = synCfg.getEntry(policyKey);
                if (policyProp != null) {
                    if (svcEffectivePolicy == null) {
                        svcEffectivePolicy = PolicyEngine.getPolicy(
                            SynapseConfigUtils.getStreamSource(policyProp).getInputStream());
                    } else {
                        svcEffectivePolicy = (Policy) svcEffectivePolicy.merge(
                            PolicyEngine.getPolicy(SynapseConfigUtils.getStreamSource(policyProp).getInputStream()));
                    }
                }
            }
            PolicyInclude pi = proxyService.getPolicyInclude();
            if (pi != null && svcEffectivePolicy != null) {
                if (trace()) {
                    if (trace.isTraceEnabled()) {
                        trace.trace(""Effective policy applied : "" + svcEffectivePolicy);
                    }
                }
                pi.addPolicyElement(PolicyInclude.AXIS_SERVICE_POLICY, svcEffectivePolicy);
            }
        }

        // create a custom message receiver for this proxy service 
        ProxyServiceMessageReceiver msgRcvr = new ProxyServiceMessageReceiver();
        msgRcvr.setName(name);
        msgRcvr.setProxy(this);

        iter = proxyService.getOperations();
        while (iter.hasNext()) {
            AxisOperation op = (AxisOperation) iter.next();
            op.setMessageReceiver(msgRcvr);
        }

        try {
            auditInfo(""Adding service "" + name + "" to the Axis2 configuration"");
            axisCfg.addService(proxyService);
            this.setRunning(true);
        } catch (AxisFault axisFault) {
            try {
                if (axisCfg.getService(proxyService.getName()) != null) {
                    if (trace()) trace.info(""Removing service "" + name + "" due to error : ""
                        + axisFault.getMessage());
                    axisCfg.removeService(proxyService.getName());
                }
            } catch (AxisFault ignore) {}
            handleException(""Error adding Proxy service to the Axis2 engine"", axisFault);
        }

        // todo: need to remove this and engage modules by looking at policies
        // should RM be engaged on this service?
        if (wsRMEnabled) {
            auditInfo(""WS-Reliable messaging is enabled for service : "" + name);
            try {
                proxyService.engageModule(axisCfg.getModule(
                    SynapseConstants.SANDESHA2_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS RM module on proxy service : "" + name, axisFault);
            }
        }

        // should Security be engaged on this service?
        if (wsSecEnabled) {
            auditInfo(""WS-Security is enabled for service : "" + name);
            try {
                proxyService.engageModule(axisCfg.getModule(
                    SynapseConstants.RAMPART_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS Sec module on proxy service : ""
                        + name, axisFault);
            }
        }

        auditInfo(""Successfully created the Axis2 service for Proxy service : "" + name);
        return proxyService;
    }

    /**
     * Start the proxy service
     * @param synCfg the synapse configuration
     */
    public void start(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration();
        if (axisConfig != null) {
            axisConfig.getServiceForActivation(this.getName()).setActive(true);
            this.setRunning(true);
            auditInfo(""Started the proxy service : "" + name);
        } else {
            auditWarn(""Unable to start proxy service : "" + name + 
                "". Couldn't access Axis configuration"");
        }
    }

    /**
     * Stop the proxy service
     * @param synCfg the synapse configuration
     */
    public void stop(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration();
        if (axisConfig != null) {
            try {
                AxisService as = axisConfig.getService(this.getName());
                if (as != null) {
                    as.setActive(false);
                }
                this.setRunning(false);
                auditInfo(""Started the proxy service : "" + name);
            } catch (AxisFault axisFault) {
                handleException(""Error stopping the proxy service : "" + name, axisFault);
            }
        } else {
            auditWarn(""Unable to stop proxy service : "" + name +
                "". Couldn't access Axis configuration"");
        }
    }

    private void handleException(String msg) {
        serviceLog.error(msg);
        log.error(msg);
        if (trace()) trace.error(msg);
        throw new SynapseException(msg);
    }

    private void handleException(String msg, Exception e) {
        serviceLog.error(msg);
        log.error(msg, e);
        if (trace()) trace.error(msg + "" :: "" + e.getMessage());
        throw new SynapseException(msg, e);
    }

    /**
     * Write to the general log, as well as any service specific logs the audit message at INFO
     * @param message the INFO level audit message
     */
    private void auditInfo(String message) {
        log.info(message);
        serviceLog.info(message);
        if (trace()) {
            trace.info(message);
        }
    }

    /**
     * Write to the general log, as well as any service specific logs the audit message at WARN
     * @param message the WARN level audit message
     */
    private void auditWarn(String message) {
        log.warn(message);
        serviceLog.warn(message);
        if (trace()) {
            trace.warn(message);
        }
    }

    /**
     * Return true if tracing should be enabled
     * @return true if tracing is enabled for this service
     */
    private boolean trace() {
        return traceState == SynapseConstants.TRACING_ON;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public ArrayList getTransports() {
        return transports;
    }

    public void addParameter(String name, Object value) {
        parameters.put(name, value);
    }

    public Map getParameterMap() {
        return this.parameters;
    }

    public void setTransports(ArrayList transports) {
        this.transports = transports;
    }

    public String getTargetEndpoint() {
        return targetEndpoint;
    }

    public void setTargetEndpoint(String targetEndpoint) {
        this.targetEndpoint = targetEndpoint;
    }

    public String getTargetInSequence() {
        return targetInSequence;
    }

    public void setTargetInSequence(String targetInSequence) {
        this.targetInSequence = targetInSequence;
    }

    public String getTargetOutSequence() {
        return targetOutSequence;
    }

    public void setTargetOutSequence(String targetOutSequence) {
        this.targetOutSequence = targetOutSequence;
    }

    public String getWSDLKey() {
        return wsdlKey;
    }

    public void setWSDLKey(String wsdlKey) {
        this.wsdlKey = wsdlKey;
    }

    public List getServiceLevelPolicies() {
        return serviceLevelPolicies;
    }

    public void addServiceLevelPolicy(String serviceLevelPolicy) {
        this.serviceLevelPolicies.add(serviceLevelPolicy);
    }

    public boolean isWsRMEnabled() {
        return wsRMEnabled;
    }

    public void setWsRMEnabled(boolean wsRMEnabled) {
        this.wsRMEnabled = wsRMEnabled;
    }

    public boolean isWsSecEnabled() {
        return wsSecEnabled;
    }

    public void setWsSecEnabled(boolean wsSecEnabled) {
        this.wsSecEnabled = wsSecEnabled;
    }

    public boolean isStartOnLoad() {
        return startOnLoad;
    }

    public void setStartOnLoad(boolean startOnLoad) {
        this.startOnLoad = startOnLoad;
    }

    public boolean isRunning() {
        return running;
    }

    public void setRunning(boolean running) {
        this.running = running;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    /**
     * Returns the int value that indicate the tracing state
     *
     * @return Returns the int value that indicate the tracing state
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing State variable
     *
     * @param traceState
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    public String getTargetFaultSequence() {
        return targetFaultSequence;
    }

    public void setTargetFaultSequence(String targetFaultSequence) {
        this.targetFaultSequence = targetFaultSequence;
    }

    public Object getInLineWSDL() {
        return inLineWSDL;
    }

    public void setInLineWSDL(Object inLineWSDL) {
        this.inLineWSDL = inLineWSDL;
    }

    public URI getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(URI wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public Endpoint getTargetInLineEndpoint() {
        return targetInLineEndpoint;
    }

    public void setTargetInLineEndpoint(Endpoint targetInLineEndpoint) {
        this.targetInLineEndpoint = targetInLineEndpoint;
    }

    public SequenceMediator getTargetInLineInSequence() {
        return targetInLineInSequence;
    }

    public void setTargetInLineInSequence(SequenceMediator targetInLineInSequence) {
        this.targetInLineInSequence = targetInLineInSequence;
    }

    public SequenceMediator getTargetInLineOutSequence() {
        return targetInLineOutSequence;
    }

    public void setTargetInLineOutSequence(SequenceMediator targetInLineOutSequence) {
        this.targetInLineOutSequence = targetInLineOutSequence;
    }

    public SequenceMediator getTargetInLineFaultSequence() {
        return targetInLineFaultSequence;
    }

    public void setTargetInLineFaultSequence(SequenceMediator targetInLineFaultSequence) {
        this.targetInLineFaultSequence = targetInLineFaultSequence;
    }

}
"
org/apache/synapse/config/xml/FaultMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.FaultMediator;

/**
 * <pre>
 * &lt;makefault [version=""soap11|soap12""]&gt;
 *   &lt;code (value=""literal"" | expression=""xpath"")/&gt;
 *   &lt;reason (value=""literal"" | expression=""xpath"")&gt;
 *   &lt;node&gt;?
 *   &lt;role&gt;?
 *   &lt;detail&gt;?
 * &lt;/makefault&gt;
 * </pre>
 */
public class FaultMediatorSerializer extends AbstractMediatorSerializer {

    private static final String SOAP11 = ""soap11"";

    private static final String SOAP12 = ""soap12"";

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FaultMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FaultMediator mediator = (FaultMediator) m;
        OMElement fault = fac.createOMElement(""makefault"", synNS);
        saveTracingState(fault,mediator);

        if(mediator.getSoapVersion()==FaultMediator.SOAP11) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP11));
        }else if(mediator.getSoapVersion()==FaultMediator.SOAP12) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP12));
        }

        OMElement code = fac.createOMElement(""code"", synNS, fault);
        if (mediator.getFaultCodeValue() != null) {
            code.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultCodeValue().getPrefix() + "":""
                    + mediator.getFaultCodeValue().getLocalPart()));
            code.declareNamespace(mediator.getFaultCodeValue().getNamespaceURI(),
                    mediator.getFaultCodeValue().getPrefix());

        } else if (mediator.getFaultCodeExpr() != null) {
            code.addAttribute(fac.createOMAttribute(
                ""expression"", nullNS, mediator.getFaultCodeExpr().toString()));
            super.serializeNamespaces(code, mediator.getFaultCodeExpr());

        } else {
            handleException(""Fault code is required for a fault mediator"");
        }

        OMElement reason = fac.createOMElement(""reason"", synNS, fault);
        if (mediator.getFaultReasonValue() != null) {
            reason.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultReasonValue()));

        } else if (mediator.getFaultReasonExpr() != null) {
            reason.addAttribute(fac.createOMAttribute(
                ""expression"", nullNS, mediator.getFaultReasonExpr().toString()));
            super.serializeNamespaces(code, mediator.getFaultReasonExpr());

        } else {
            handleException(""Fault reason is required for a fault mediator"");
        }


        if (mediator.getFaultNode() != null) {
            OMElement node = fac.createOMElement(""node"", synNS, fault);
            node.setText(mediator.getFaultNode().toString());
        }

        if (mediator.getFaultRole() != null) {
            OMElement role = fac.createOMElement(""role"", synNS, fault);
            role.setText(mediator.getFaultRole().toString());
        }

        if (mediator.getFaultDetail() != null) {
            OMElement detail = fac.createOMElement(""detail"", synNS, fault);
            detail.setText(mediator.getFaultDetail());
        }

        if (parent != null) {
            parent.addChild(fault);
        }
        return fault;
    }

    public String getMediatorClassName() {
        return FaultMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

public abstract class AbstractMediatorFactory implements MediatorFactory {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected static Log log;
    protected static final QName ATT_NAME    = new QName(""name"");
    protected static final QName ATT_VALUE   = new QName(""value"");
    protected static final QName ATT_XPATH   = new QName(""xpath"");
    protected static final QName ATT_REGEX   = new QName(""regex"");
    protected static final QName ATT_EXPRN   = new QName(""expression"");
    protected static final QName ATT_KEY     = new QName(""key"");
    protected static final QName ATT_SOURCE  = new QName(""source"");    
    protected static final QName ATT_ONERROR = new QName(""onError"");
    protected static final QName ATT_STATS
        = new QName(XMLConfigConstants.STATISTICS_ATTRIB_NAME);
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");
    protected static final QName FEATURE_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""feature"");
    protected static final QName TARGET_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediatorFactory() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * This is to Initialize the mediator with the default attributes
     *
     * @param mediator
     * @param mediatorOmElement
     */
    protected void processTraceState(Mediator mediator, OMElement mediatorOmElement) {

        OMAttribute trace = mediatorOmElement.getAttribute(
            new QName(XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.TRACE_ATTRIB_NAME));

        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(XMLConfigConstants.TRACE_ENABLE)) {
                    mediator.setTraceState(org.apache.synapse.SynapseConstants.TRACING_ON);
                } else if (traceValue.equals(XMLConfigConstants.TRACE_DISABLE)) {
                    mediator.setTraceState(org.apache.synapse.SynapseConstants.TRACING_OFF);
                }
            }
        }
    }

    protected void handleException(String message, Exception e) {
        LogFactory.getLog(this.getClass()).error(message, e);
        throw new SynapseException(message, e);
    }

    protected void handleException(String message) {
        LogFactory.getLog(this.getClass()).error(message);
        throw new SynapseException(message);
    }
}
"
org/apache/synapse/mediators/eip/Target.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.axis2.addressing.EndpointReference;

/**
 * This class will be a bean which carries the target information for most of the EIP mediators
 */
public class Target {

    /**
     * Holds the to address of the target endpoint
     */
    private String to = null;

    /**
     * Holds the soapAction of the target service
     */
    private String soapAction = null;

    /**
     * Holds the target mediation sequence as an annonymous sequence
     */
    private SequenceMediator sequence = null;

    /**
     * Holds the target mediation sequence as a sequence reference
     */
    private String sequenceRef = null;

    /**
     * Holds the target endpoint to which the message will be sent
     */
    private Endpoint endpoint = null;

    /**
     * Holds the reference to the target endpoint to which the message will be sent
     */
    private String endpointRef = null;

    /**
     * This method will be called by the EIP mediators to mediated the target (may be to mediate
     * using the target sequence, send message to the target endpoint or both)
     *
     * @param synCtx - MessageContext to be mediated
     */
    public void mediate(MessageContext synCtx) {

        if (soapAction != null) {
            synCtx.setSoapAction(soapAction);
        }

        if (to != null) {
            if (synCtx.getTo() != null) {
                synCtx.getTo().setAddress(to);
            } else {
                synCtx.setTo(new EndpointReference(to));
            }
        }

        if (sequence != null) {
            synCtx.getEnvironment().injectAsync(synCtx, sequence);
        } else if (sequenceRef != null) {
            SequenceMediator refSequence = (SequenceMediator) synCtx.getConfiguration().getSequence(sequenceRef);
            if (refSequence != null) {
                synCtx.getEnvironment().injectAsync(synCtx, refSequence);
            }
        }

        if (endpoint != null) {
            endpoint.send(synCtx);
        } else if (endpointRef != null) {
            Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);
            if (epr != null) {
                epr.send(synCtx);
            }
        }

    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public String getSoapAction() {
        return soapAction;
    }

    public void setSoapAction(String soapAction) {
        this.soapAction = soapAction;
    }

    public SequenceMediator getSequence() {
        return sequence;
    }

    public void setSequence(SequenceMediator sequence) {
        this.sequence = sequence;
    }

    public String getSequenceRef() {
        return sequenceRef;
    }

    public void setSequenceRef(String sequenceRef) {
        this.sequenceRef = sequenceRef;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }

    public String getEndpointRef() {
        return endpointRef;
    }

    public void setEndpointRef(String endpointRef) {
        this.endpointRef = endpointRef;
    }
}"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.ArrayList;

/**
 * Creates LoadbalanceEndpoint using an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <loadbalance policy=""load balance algorithm"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class LoadbalanceEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(LoadbalanceEndpointFactory.class);

    private static LoadbalanceEndpointFactory instance = new LoadbalanceEndpointFactory();

    private LoadbalanceEndpointFactory() {}

    public static LoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms

        OMElement loadbalanceElement =  null;
        loadbalanceElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            LoadbalanceEndpoint loadbalanceEndpoint = new LoadbalanceEndpoint();

            // set endpoint name
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                loadbalanceEndpoint.setName(name.getAttributeValue());
            }

            // set endpoints
            ArrayList endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set if failover is turned off
            String failover = loadbalanceElement.getAttributeValue(new QName(""failover""));
            if (failover != null && failover.equalsIgnoreCase(""false"")) {
                loadbalanceEndpoint.setFailover(false);
            }

            return loadbalanceEndpoint;
        }

        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement loadbalanceElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = loadbalanceElement.getChildrenWithName
                (org.apache.synapse.config.xml.XMLConfigConstants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/XMLConfigConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.SynapseConstants;
import javax.xml.namespace.QName;

/**
 * Constants used in the processing of XML configuration language
 */
public class XMLConfigConstants {

    // re-definition of the Synapse NS here to make things easier for the XML config lang code
    public static final String SYNAPSE_NAMESPACE = SynapseConstants.SYNAPSE_NAMESPACE;

    //- Mediators -
    //-- PropertyMediator --
    /** The scope name for synapse message context properties */
    public static final String SCOPE_DEFAULT = ""default"";
    /** The scope name for axis2 message context properties */
    public static final String SCOPE_AXIS2 = ""axis2"";
    /** The scope name for axis2 message context client options properties */
    public static final String SCOPE_CLIENT = ""axis2-client"";
    /** The scope name for transport header properties */
    public static final String SCOPE_TRANSPORT = ""transport"";

    //-- WS-RM sequence mediator --
    /** WS-RM version 1.0*/
    public static final String SEQUENCE_VERSION_1_0 = ""1.0"";
    /** WS-RM version 1.1*/
    public static final String SEQUENCE_VERSION_1_1 = ""1.1"";

    //- configuration language constants -
    public static final QName DEFINITIONS_ELT = new QName(SYNAPSE_NAMESPACE, ""definitions"");
    public static final QName SEQUENCE_ELT    = new QName(SYNAPSE_NAMESPACE, ""sequence"");
    public static final QName ENDPOINT_ELT    = new QName(SYNAPSE_NAMESPACE, ""endpoint"");
    public static final QName ENTRY_ELT       = new QName(SYNAPSE_NAMESPACE, ""localEntry"");
    public static final QName REGISTRY_ELT    = new QName(SYNAPSE_NAMESPACE, ""registry"");
    public static final QName TASK_ELT        = new QName(SYNAPSE_NAMESPACE, ""task"");
    public static final QName PROXY_ELT       = new QName(SYNAPSE_NAMESPACE, ""proxy"");
    public static final String NULL_NAMESPACE = """";
    public static final Object QUARTZ_QNAME   =
        new QName(""http://www.opensymphony.com/quartz/JobSchedulingData"", ""quartz"");

	/** The Trace attribute name, for proxy services, sequences */
	public static final String TRACE_ATTRIB_NAME = ""trace"";
	/** The Trace value 'enable' */
	public static final String TRACE_ENABLE = ""enable"";
	/** The Trace value 'disable' */
	public static final String TRACE_DISABLE = ""disable"";

	/** The statistics attribute name */
	public static final String STATISTICS_ATTRIB_NAME = ""statistics"";
	/** The statistics value 'enable' */
	public static final String STATISTICS_ENABLE = ""enable"";
	/** The statistics value 'disable' */
	public static final String STATISTICS_DISABLE = ""disable"";

	public static final String SUSPEND_DURATION_ON_FAILURE = ""suspendDurationOnFailure"";
	public static final String ALGORITHM_NAME = ""policy"";

    public static final String ONREJECT = ""onReject"";
	public static final String ONACCEPT = ""onAccept"";
}
"
org/apache/synapse/util/UUIDGenerator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

/**
 * This is a thread-safe version of the Axiom UUIDGenerator
 * to be used until it is fixed in the next Axiom release
 */
public class UUIDGenerator {
    /** This class will give UUIDs for axis2. */

    private static String baseUUID = null;
    private static long incrementingValue = 0;

    private static Random myRand = null;
    private static boolean useNano = false;

    /**
     * MD5 a random string with localhost/date etc will return 128 bits construct a string of 18
     * characters from those bits.
     *
     * @return string
     */
    public static String getUUID() {
        if (baseUUID == null) {
            baseUUID = getInitialUUID();
            baseUUID = ""urn:uuid:"" + baseUUID;
        }
        if (++incrementingValue >= Long.MAX_VALUE) {
            incrementingValue = 0;
        }

        if (useNano) {
            return baseUUID + (System.nanoTime() + incrementingValue) +
                Integer.toString(myRand.nextInt());
        } else {

            return baseUUID + (System.currentTimeMillis() + incrementingValue +
                Integer.toString(myRand.nextInt()));
        }

    }

    protected static String getInitialUUID() {

        try {
            if (System.class.getMethod(""nanoTime"", new Class[0]) != null) {
                useNano = true;
            }
        } catch (NoSuchMethodException ignore) {}

        if (myRand == null) {
            myRand = new Random();
        }
        long rand = myRand.nextLong();
        String sid;
        try {
            sid = InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            sid = Thread.currentThread().getName();
        }
        StringBuffer sb = new StringBuffer();
        sb.append(sid);
        sb.append("":"");
        sb.append(Long.toString(rand));
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            //System.out.println(""Error: "" + e);
            //todo heve to be properly handle
        }
        md5.update(sb.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb2 = new StringBuffer();
        for (int j = 0; j < array.length; ++j) {
            int b = array[j] & 0xFF;
            sb2.append(Integer.toHexString(b));
        }
        int begin = myRand.nextInt();
        if (begin < 0) begin = begin * -1;
        begin = begin % 8;
        return sb2.toString().substring(begin, begin + 18).toUpperCase();
    }
}
"
org/apache/synapse/config/xml/AbstractDBMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.db.AbstractDBMediator;
import org.apache.synapse.mediators.db.Statement;

import javax.xml.namespace.QName;
import java.sql.Types;
import java.util.Iterator;

/**
 * <dbreport | dblookup | .. etc>
 *   <connection>
 *     <pool>
 *     (
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     |
 *       <dsName/>
 *       <icClass/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     )
 *       <property name=""name"" value=""value""/>*
 *     </pool>
 *   </connection>
 *   <statement>
 *     <sql>insert into table values (?, ?, ..) OR select target from destinations where src = ?</sql>
 *     <parameter (value=""const"" | expression=""xpath"") type=""INTEGER|VARCHAR|...""/>*
 *     <result name=""propName"" column=""target | number""/>*
 *   </statement>+
 * </dbreport | dblookup | .. etc>
 *
 * Supported properties
 * autocommit = true | false
 * isolation = Connection.TRANSACTION_NONE
 *           | Connection.TRANSACTION_READ_COMMITTED
 *           | Connection.TRANSACTION_READ_UNCOMMITTED
 *           | Connection.TRANSACTION_REPEATABLE_READ
 *           | Connection.TRANSACTION_SERIALIZABLE
 * initialsize = int
 * maxactive = int
 * maxidle = int
 * maxopenstatements = int
 * maxwait = long
 * minidle = int
 * poolstatements = true | false
 * testonborrow = true | false
 * testonreturn = true | false
 * testwhileidle = true | false
 * validationquery = String
 */
public abstract class AbstractDBMediatorSerializer extends AbstractMediatorSerializer {

    protected void serializeDBInformation(AbstractDBMediator mediator, OMElement dbParent) {

        OMElement connElt = fac.createOMElement(""connection"", synNS);
        OMElement poolElt = fac.createOMElement(""pool"", synNS);

        Iterator iter = mediator.getDataSourceProps().keySet().iterator();
        while (iter.hasNext()) {

            Object o = iter.next();
            String value = (String) mediator.getDataSourceProps().get(o);

            if (o instanceof QName) {
                QName name = (QName) o;
                OMElement elt = fac.createOMElement(name.getLocalPart(), synNS);
                elt.setText(value);
                poolElt.addChild(elt);

            } else if (o instanceof String) {
                OMElement elt = fac.createOMElement(
                    AbstractDBMediatorFactory.PROP_Q.getLocalPart(), synNS);
                elt.addAttribute(fac.createOMAttribute(""name"", nullNS, (String) o));
                elt.addAttribute(fac.createOMAttribute(""value"", nullNS, value));
                poolElt.addChild(elt);
            }
        }

        connElt.addChild(poolElt);
        dbParent.addChild(connElt);

        // process statements
        Iterator statementIter = mediator.getStatementList().iterator();
        while (statementIter.hasNext()) {

            Statement statement = (Statement) statementIter.next();
            OMElement stmntElt = fac.createOMElement(
                AbstractDBMediatorFactory.STMNT_Q.getLocalPart(), synNS);

            OMElement sqlElt = fac.createOMElement(
                AbstractDBMediatorFactory.SQL_Q.getLocalPart(), synNS);
            sqlElt.setText(statement.getRawStatement());
            stmntElt.addChild(sqlElt);

            // serialize parameters of the statement
            for (Iterator it = statement.getParameters().iterator(); it.hasNext(); ) {

                Statement.Parameter param = (Statement.Parameter) it.next();
                OMElement paramElt = fac.createOMElement(
                    AbstractDBMediatorFactory.PARAM_Q.getLocalPart(), synNS);

                if (param.getPropertyName() != null) {
                    paramElt.addAttribute(
                        fac.createOMAttribute(""value"", nullNS, param.getPropertyName()));
                }
                if (param.getXpath() != null) {
                    paramElt.addAttribute(
                        fac.createOMAttribute(""expression"", nullNS, param.getXpath().toString()));
                    serializeNamespaces(paramElt, param.getXpath());
                }

                switch (param.getType()) {
                    case Types.CHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""CHAR""));
                        break;
                    }
                    case Types.VARCHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""VARCHAR""));
                        break;
                    }
                    case Types.LONGVARCHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""LONGVARCHAR""));
                        break;
                    }
                    case Types.NUMERIC: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""NUMERIC""));
                        break;
                    }
                    case Types.DECIMAL: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DECIMAL""));
                        break;
                    }
                    case Types.BIT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""BIT""));
                        break;
                    }
                    case Types.TINYINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TINYINT""));
                        break;
                    }
                    case Types.SMALLINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""SMALLINT""));
                        break;
                    }
                    case Types.INTEGER: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""INTEGER""));
                        break;
                    }
                    case Types.BIGINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""BIGINT""));
                        break;
                    }
                    case Types.REAL: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""REAL""));
                        break;
                    }
                    case Types.FLOAT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""FLOAT""));
                        break;
                    }
                    case Types.DOUBLE: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DOUBLE""));
                        break;
                    }
                    case Types.DATE: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DATE""));
                        break;
                    }
                    case Types.TIME: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TIME""));
                        break;
                    }
                    case Types.TIMESTAMP: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TIMESTAMP""));
                        break;
                    }
                    default: {
                        throw new SynapseException(""Unknown or unsupported JDBC type : "" +
                            param.getType());                            
                    }
                }

                stmntElt.addChild(paramElt);
            }

            // serialize any optional results of the statement
            for (Iterator it = statement.getResultsMap().keySet().iterator(); it.hasNext(); ) {

                String name = (String) it.next();
                String columnStr = (String) statement.getResultsMap().get(name);

                OMElement resultElt = fac.createOMElement(
                    AbstractDBMediatorFactory.RESULT_Q.getLocalPart(), synNS);

                resultElt.addAttribute(
                    fac.createOMAttribute(""name"", nullNS, name));
                resultElt.addAttribute(
                    fac.createOMAttribute(""column"", nullNS, columnStr));

                stmntElt.addChild(resultElt);
            }

            dbParent.addChild(stmntElt);
        }
    }
}
"
org/apache/synapse/core/axis2/SynapseMessageReceiver.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.MessageReceiver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This message receiver should be configured in the Axis2 configuration as the
 * default message receiver, which will handle all incoming messages through the
 * synapse mediation
 */
public class SynapseMessageReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseMessageReceiver.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);

        boolean traceOn = synCtx.getMainSequence().getTraceState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Synapse received a new message for message mediation..."");
            traceOrDebug(traceOn, ""Received To: "" +
                (mc.getTo() != null ? mc.getTo().getAddress() : ""null""));
            traceOrDebug(traceOn, ""SOAPAction: "" +
                (mc.getSoapAction() != null ? mc.getSoapAction() : ""null""));
            traceOrDebug(traceOn, ""WSA-Action: "" +
                (mc.getWSAAction() != null ? mc.getWSAAction() : ""null""));

            if (traceOn && trace.isTraceEnabled()) {
                String[] cids = mc.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (int i=0; i<cids.length; i++) {
                        trace.trace(""Attachment : "" + cids[i]);
                    }
                }
                trace.trace(""Envelope : "" + mc.getEnvelope());
            }
        }

        // get service log for this message and attach to the message context
        Log serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX +
            SynapseConstants.SYNAPSE_SERVICE_NAME);
        ((Axis2MessageContext) synCtx).setServiceLog(serviceLog);

        try {
            // set the statistics collection stack for this message
            StatisticsStack synapseServiceStack = new ProxyServiceStatisticsStack();
            boolean isFault = synCtx.getEnvelope().getBody().hasFault();
            synapseServiceStack.put(SynapseConstants.SYNAPSE_SERVICE_NAME,
                System.currentTimeMillis(), !synCtx.isResponse(), true, isFault);
            synCtx.setProperty(SynapseConstants.SERVICE_STATS, synapseServiceStack);

            // set default fault handler
            synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(SynapseConstants.FAULT_SEQUENCE_KEY)));

            // invoke synapse message mediation through the main sequence
            synCtx.getEnvironment().injectMessage(synCtx);

        } catch (SynapseException syne) {

            if (!synCtx.getFaultStack().isEmpty()) {
                warn(traceOn, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(traceOn, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }
}
"
org/apache/synapse/core/axis2/SynapseStartUpServlet.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.core.axis2;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.ServerManager;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;

/**
 * This servlet will start and stop all the listeners.
 */

public class SynapseStartUpServlet extends HttpServlet {

    private static Log log = LogFactory.getLog(SynapseStartUpServlet.class);

    public void init() throws ServletException {
        super.init();
    }

    public void init(ServletConfig servletConfig) throws ServletException {
        ServerManager serverManager = ServerManager.getInstance();
        ServletContext servletContext = servletConfig.getServletContext();
        if (""true"".equals(servletContext.getAttribute(""hasAlreadyInit""))) {
            return;
        }
        String synapseHome = resolveSynapseHome(servletConfig);
        //Setting the all required system properties
        if (synapseHome != null) {
            if (synapseHome.endsWith(""/"")) {
                synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
            }
            System.setProperty(SynapseConstants.SYNAPSE_HOME, synapseHome);
            //setting axis2 repository location
            String axis2Repo = System.getProperty(org.apache.axis2.Constants.AXIS2_REPO);
            if (axis2Repo == null) {
                ServerManager.getInstance().setAxis2Repolocation(synapseHome + ""/WEB-INF"" +
                    File.separator + ""repository"");
                System.setProperty(org.apache.axis2.Constants.AXIS2_REPO,
                    synapseHome + ""/WEB-INF"" +
                        File.separator + ""repository"");
            }
            //setting axis2 configuration location
            String axis2Xml = System.getProperty(org.apache.axis2.Constants.AXIS2_CONF);
            if (axis2Xml == null) {
                System.setProperty(org.apache.axis2.Constants.AXIS2_CONF,
                    synapseHome + File.separator
                        + ""WEB-INF/conf""
                        + File.separator + org.apache.axis2.Constants.AXIS2_CONF);
            }
            //setting synapse configuration location
            String synapseXml = System.getProperty(org.apache.synapse.SynapseConstants.SYNAPSE_XML);
            if (synapseXml == null) {
                System.setProperty(org.apache.synapse.SynapseConstants.SYNAPSE_XML,
                    synapseHome + File.separator
                        + ""WEB-INF/conf""
                        + File.separator + org.apache.synapse.SynapseConstants.SYNAPSE_XML);

            }
        } else {
            log.fatal(""Can not resolve synapse home  : startup failed"");
            return;
        }
        serverManager.start();
        servletContext.setAttribute(""hasAlreadyInit"", ""true"");
    }


    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response) throws ServletException,
        IOException {
    }

    protected void doPost(HttpServletRequest request,
                          HttpServletResponse response) throws ServletException,
        IOException {
    }

    public void destroy() {
        try {
            ServerManager serverManager = ServerManager.getInstance();
            serverManager.stop(); // will stop all started  listeners
        } catch (Exception ignored) {
        }
    }

    private String resolveSynapseHome(ServletConfig servletConfig) {
        // If synapse.home has provided as init-param,the it will take as synapse home
        String synapseHomeAsParam = servletConfig.getInitParameter(SynapseConstants.SYNAPSE_HOME);
        if (synapseHomeAsParam != null) {
            if (synapseHomeAsParam.endsWith(""/"")) {
                return synapseHomeAsParam.substring(0, synapseHomeAsParam.lastIndexOf(""/""));
            }
        }
        //if synapse.home has set as a system property , then use it
        String synapseHome = System.getProperty(SynapseConstants.SYNAPSE_HOME);
        //Setting the all required system properties
        if (synapseHome == null || """".equals(synapseHome)) {
            ServletContext servletContext = servletConfig.getServletContext();
            //if synapse.home stil can not find ,then resolve it using real path of the WEB-INF
            String webinfPath = servletContext.getRealPath(""WEB-INF"");
            if (webinfPath != null) {
                synapseHome = webinfPath.substring(0, webinfPath.lastIndexOf(""WEB-INF""));
                if (synapseHome != null) {
                    if (synapseHome.endsWith(""/"")) {
                        synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
                    }
                }
            }
        }
        return synapseHome;
    }
}
"
org/apache/synapse/config/xml/OutMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

import javax.xml.namespace.QName;

/**
 * Creates an Out mediator instance
 *
 * <pre>
 * &lt;out&gt;
 *    mediator+
 * &lt;/out&gt;
 * </pre>
 */
public class OutMediatorFactory extends AbstractListMediatorFactory {

    private static final QName OUT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""out"");

    public Mediator createMediator(OMElement elem) {
        OutMediator filter = new OutMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);

        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return OUT_Q;
    }
}
"
org/apache/synapse/core/axis2/AnonymousServiceFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.description.OutOnlyAxisOperation;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;

import javax.xml.namespace.QName;

/**
 * Returns an anonymous service for the given QoS. If an instance does not already
 * exist, create one and set it to the Axis configuration
 */
public class AnonymousServiceFactory {

    private static final Log log = LogFactory.getLog(AnonymousServiceFactory.class);

    private static final String NONE            = ""__NONE__"";
    private static final String ADDR_ONLY       = ""__ADDR_ONLY__"";
    private static final String RM_AND_ADDR     = ""__RM_AND_ADDR__"";
    private static final String SEC_AND_ADDR    = ""__SEC_AND_ADDR__"";
    private static final String RM_SEC_AND_ADDR = ""__RM_SEC_AND_ADDR__"";

    public static final String OUT_IN_OPERATION   = ""__OUT_IN_OPERATION__"";
    public static final String OUT_ONLY_OPERATION = ""__OUT_ONLY_OPERATION__"";

    private static SynapseCallbackReceiver synapseCallbackReceiver = null;

    /**
     * Creates an AxisService for the requested QoS for sending out messages
     * Callers must guarantee that if wsRMon or wsSecOn is required, that wsAddrOn is also set
     * @param axisCfg Axis2 configuration
     * @param wsAddrOn
     * @param wsRMOn
     * @param wsSecOn
     * @return An Axis service for the requested QoS
     */
    public static AxisService getAnonymousService(SynapseConfiguration synCfg,
                                                  AxisConfiguration axisCfg, boolean wsAddrOn,
                                                  boolean wsRMOn, boolean wsSecOn) {

        String servicekey = null;
        if (!wsAddrOn) {
            servicekey = NONE;
        } else {
            if (!wsSecOn && !wsRMOn) {
                servicekey = ADDR_ONLY;
            } else if (wsRMOn && !wsSecOn) {
                servicekey = RM_AND_ADDR;
            } else if (wsSecOn && !wsRMOn) {
                servicekey = SEC_AND_ADDR;
            } else {
                servicekey = RM_SEC_AND_ADDR;
            }
        }

        try {
            AxisService service = axisCfg.getService(servicekey);
            if (service == null) {
                synchronized (AnonymousServiceFactory.class) {

                    // fix with double locking, issue found on performance test
                    service = axisCfg.getService(servicekey);
                    if (service != null) {
                        return service;
                    }

                    service = createAnonymousService(synCfg, axisCfg, servicekey);

                    if (wsAddrOn) {
                        service.engageModule(axisCfg.getModule(
                            SynapseConstants.ADDRESSING_MODULE_NAME), axisCfg);

                        if (wsRMOn) {
                            service.engageModule(axisCfg.getModule(
                                SynapseConstants.SANDESHA2_MODULE_NAME), axisCfg);
                        }
                        if (wsSecOn) {
                            service.engageModule(axisCfg.getModule(
                                SynapseConstants.RAMPART_MODULE_NAME), axisCfg);
                        }
                    }
                    // if WS-A is off, WS-Sec and WS-RM should be too
                }
            }
            return service;
        } catch (AxisFault e) {
            handleException(""Error retrieving anonymous service for QoS : "" + servicekey, e);
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Create a new Anonymous Axis service for OUT-IN as default MEP
     * @param axisCfg the Axis2 configuration
     * @return an anonymous service named with the given QoS key
     */
    private static AxisService createAnonymousService(SynapseConfiguration synCfg,
        AxisConfiguration axisCfg, String serviceKey) {

        try {
            DynamicAxisOperation dynamicOperation =
                new DynamicAxisOperation(new QName(OUT_IN_OPERATION));
            dynamicOperation.setMessageReceiver(getCallbackReceiver(synCfg));
            AxisMessage inMsg = new AxisMessage();
            inMsg.setName(""in-message"");
            inMsg.setParent(dynamicOperation);
            AxisMessage outMsg = new AxisMessage();
            outMsg.setName(""out-message"");
            outMsg.setParent(dynamicOperation);
            dynamicOperation.addMessage(inMsg, WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
            dynamicOperation.addMessage(outMsg, WSDLConstants.MESSAGE_LABEL_IN_VALUE);

            OutOnlyAxisOperation asyncOperation =
                new OutOnlyAxisOperation(new QName(OUT_ONLY_OPERATION));
            asyncOperation.setMessageReceiver(getCallbackReceiver(synCfg));
            AxisMessage outOnlyMsg = new AxisMessage();
            outOnlyMsg.setName(""out-message"");
            outOnlyMsg.setParent(asyncOperation);
            asyncOperation.addMessage(outMsg, WSDLConstants.MESSAGE_LABEL_OUT_VALUE);

            AxisService axisAnonymousService  = new AxisService(serviceKey);
            axisAnonymousService.addOperation(dynamicOperation);
            axisAnonymousService.addOperation(asyncOperation);
            axisCfg.addService(axisAnonymousService);
            axisCfg.getPhasesInfo().setOperationPhases(dynamicOperation);
            return axisAnonymousService;

        } catch (AxisFault e) {
            handleException(
                ""Error occured while creating an anonymous service for QoS : "" +
                 serviceKey, e);
        }
        return null;
    }

    /**
     * Create a single callback receiver if required, and return its reference
     * @param synCfg the Synapse configuration
     * @return the callback receiver thats created or now exists
     */
    private static synchronized SynapseCallbackReceiver getCallbackReceiver(
        SynapseConfiguration synCfg) {

        if (synapseCallbackReceiver == null) {
            synapseCallbackReceiver = new SynapseCallbackReceiver(synCfg);
        }
        return synapseCallbackReceiver;
    }
}
"
org/apache/synapse/MessageContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;


import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.commons.logging.Log;

import java.util.Set;
import java.util.Stack;


/**
 * The Synapse Message Context is available to all mediators through which it flows. It
 * allows one to call to the underlying SynapseEnvironment (i.e. the SOAP engine
 * - such as Axis2) where required. It also allows one to access the current
 * SynapseConfiguration. Additionally it holds per message properties (i.e. local
 * properties valid for the lifetime of the message), and the current SOAPEnvelope
 */
public interface MessageContext {

    /**
     * Get a reference to the current SynapseConfiguration
     *
     * @return the current synapse configuration
     */
    public SynapseConfiguration getConfiguration();

    /**
     * Set or replace the Synapse Configuration instance to be used. May be used to
     * programatically change the configuration at runtime etc.
     *
     * @param cfg The new synapse configuration instance
     */
    public void setConfiguration(SynapseConfiguration cfg);

    /**
     * Returns a reference to the host Synapse Environment
     * @return the Synapse Environment
     */
    public SynapseEnvironment getEnvironment();

    /**
     * Sets the SynapseEnvironment reference to this context
     * @param se the reference to the Synapse Environment
     */
    public void setEnvironment(SynapseEnvironment se);

    /**
     * Return the main sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.MAIN_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the main sequence if the main
     * sequence was dynamic and changed in between at the registry
     * @return the main sequence to be used for mediation
     */
    public Mediator getMainSequence();

    /**
     * Return the fault sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.FAULT_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the fault sequence if the fault
     * sequence was dynamic and changed in between at the registry
     * @return the fault sequence to be used for mediation
     */
    public Mediator getFaultSequence();

    /**
     * Return the sequence with the given key from the configuration, or the local message
     * context. This method looks up for the sequence with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said sequence if it was dynamic and
     * changed in between at the registry
     * @param key the sequence key to be looked up
     * @return the sequence mediator mapped to the key
     */
    public Mediator getSequence(String key);

    /**
     * Return the endpoint with the given key from the configuration, or the local message
     * context. This method looks up for the endpoint with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said endpoint if it was dynamic and
     * changed in between at the registry
     * @param key the endpoint key to be looked up
     * @return the endpoint mapped to the key
     */
    public Endpoint getEndpoint(String key);

    /**
     * Get the value of a custom (local) property set on the message instance
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getProperty(String key);

    /**
     * Get the value of a property set on the message instance, from the local registry
     * or the remote registry - by cascading through
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getEntry(String key);

    /**
     * Set a custom (local) property with the given name on the message instance
     * @param key key to be used
     * @param value value to be saved
     */
    public void setProperty(String key, Object value);

    /**
     * Returns the Set of keys over the properties on this message context
     * @return a Set of keys over message properties
     */
    public Set getPropertyKeySet();

    /**
     * Get the SOAP envelope of this message
     * @return the SOAP envelope of the message
     */
    public SOAPEnvelope getEnvelope();

    /**
     * Sets the given envelope as the current SOAPEnvelope for this message
     * @param envelope the envelope to be set
     * @throws org.apache.axis2.AxisFault on exception
     */
    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault;

    // --- SOAP Message related methods ------
    /** Get the faultTo EPR if available */
    public EndpointReference getFaultTo();

    /** Set the faultTo EPR */
    public void setFaultTo(EndpointReference reference);

    /** Get the from EPR if available */
    public EndpointReference getFrom();

    /** Set the from EPR */
    public void setFrom(EndpointReference reference);

    /** Get the message id if available */
    public String getMessageID();

    /** Set the message id */
    public void setMessageID(String string);

    /** Get the relatesTo of this message */
    public RelatesTo getRelatesTo();

    /**
     * Sets the relatesTo references for this message
     * @param reference the relatesTo references array
     */
    public void setRelatesTo(RelatesTo[] reference);

    /** Set the replyTo EPR */
    public EndpointReference getReplyTo();

    /** Get the replyTo EPR if available */
    public void setReplyTo(EndpointReference reference);

    /** Get the To EPR */
    public EndpointReference getTo();

     /**
     * Set the To EPR
     * @param reference the To EPR
     */
    public void setTo(EndpointReference reference);

    /**
     * Sets the WSAAction
     * @param actionURI the WSAAction
     */
    public void setWSAAction(String actionURI);

    /**
     * Returns the WSAAction
     * @return the WSAAction
     */
    public String getWSAAction();

    /**
     * Returns the SOAPAction of the message
     * @return the SOAPAction
     */
    public String getSoapAction();

    /**
     * Set the SOAPAction
     * @param string the SOAP Action
     */
    public void setSoapAction(String string);

    /**
     * Set the message if
     * @param messageID
     */
    public void setWSAMessageID(String messageID);

    /**
     * Gets the message name
     * @return the WSA MessageID
     */
    public String getWSAMessageID();

    /**
     * If this message using MTOM?
     * @return true if using MTOM
     */
    public boolean isDoingMTOM();

    /**
     * If this message using SWA?
     * @return true if using SWA
     */
    public boolean isDoingSWA();

    /**
     * Marks as using MTOM
     * @param b true to mark as using MTOM
     */
    public void setDoingMTOM(boolean b);

    /**
     * Marks as using SWA
     * @param b true to mark as using SWA
     */
    public void setDoingSWA(boolean b);

    /**
     * Is this message over POX?
     * @return true if over POX
     */
    public boolean isDoingPOX();

    /**
     * Marks this message as over REST
     * @param b true to mark as REST
     */
    public void setDoingPOX(boolean b);

    /**
     * Is this message a SOAP 1.1 message?
     * @return true if this is a SOAP 1.1 message
     */
    public boolean isSOAP11();

    /**
     * Mark this message as a response or not.
     * @see org.apache.synapse.MessageContext#isResponse()
     * @param b true to set this as a response
     */
    public void setResponse(boolean b);

    /**
     * Is this message a response to a synchronous message sent out through Synapse?
     * @return true if this message is a response message
     */
    public boolean isResponse();

    /**
     * Marks this message as a fault response
     * @see org.apache.synapse.MessageContext#isFaultResponse()
     * @param b true to mark this as a fault response
     */
    public void setFaultResponse(boolean b);

    /**
     * Is this message a response to a fault message?
     * @return true if this is a response to a fault message
     */
    public boolean isFaultResponse();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return indicate whether tracing is on, off or unset
     */
    public int getTracingState();

    /**
     * This is used to set the value of tracing enable variable
     * @param tracingState Set whether the tracing is enabled or not
     */
    public void setTracingState(int tracingState);

    public Stack getFaultStack();

    public void pushFaultHandler(FaultHandler fault);

    /**
     * Return the service level Log for this message context or null
     * @return the service level Log for the message
     */
    public Log getServiceLog();
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Creates AddressEndpoint using a XML configuration.
 *
 * <endpoint [name=""name""] [trace=""enable|disable""]>
 *   <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *   <address uri=""url"" [format=""soap11|soap12|pox""] [optimize=""mtom|swa""]>
 *      .. extensibility ..
 *
 *      <timeout>
 *          <duration>duration in milliseconds</duration>
 *          <action>discard | fault</action>
 *      </timeout>?
 *
 *      <enableRM [policy=""key""]/>?
 *      <enableSec [policy=""key""]/>?
 *      <enableAddressing/>?
 *      <suspendDurationOnFailure>suspend-duration</suspendDurationOnFailure>?
 *   </address>
 * </endpoint>
 */
public class AddressEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(AddressEndpointFactory.class);

    private static AddressEndpointFactory instance = new AddressEndpointFactory();

    /**
     * To decide to whether statistics should have collected or not
     */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;
    /**
     * The variable that indicate tracing on or off for the current mediator
     */
    protected int traceState = SynapseConstants.TRACING_UNSET;

    private AddressEndpointFactory() {}

    public static AddressEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        AddressEndpoint addressEndpoint = new AddressEndpoint();

        if (!anonymousEndpoint) {
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                addressEndpoint.setName(name.getAttributeValue());
            }
        }

        OMElement addressElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""address""));

        if (addressElement != null) {
            EndpointDefinition endpoint = createEndpointDefinition(addressElement);
            addressEndpoint.setEndpoint(endpoint);

            // set the suspend on fail duration.
            OMElement suspendElement = addressElement.getFirstChildWithName(new QName(
                    SynapseConstants.SYNAPSE_NAMESPACE,
                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE));

            if (suspendElement != null) {
                String suspend = suspendElement.getText();

                try {
                    if (suspend != null) {
                        long suspendDuration = Long.parseLong(suspend.trim());
                        addressEndpoint.setSuspendOnFailDuration(suspendDuration * 1000);
                    }

                } catch (NumberFormatException e) {
                    handleException(""The suspend duration should be specified as a valid number :: ""
                        + e.getMessage(), e);
                }
            }
        }

        return addressEndpoint;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    /**
     * Creates an EndpointDefinition instance using the XML fragment specification. Configuration for
     * EndpointDefinition always resides inside a configuration of an AddressEndpoint. This factory
     * extracts the details related to the EPR provided for address endpoint.
     *
     * @param elem XML configuration element
     * @return EndpointDefinition object containing the endpoint details.
     */
    public EndpointDefinition createEndpointDefinition(OMElement elem) {

        OMAttribute address = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""uri""));
        OMAttribute format = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""format""));
        OMAttribute optimize = elem.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""optimize""));

        EndpointDefinition endpoint = new EndpointDefinition();
        OMAttribute statistics = elem.getAttribute(
                new QName(org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE,
                        org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ENABLE.equals(
                        statisticsValue)) {
                    endpoint.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_DISABLE.equals(
                        statisticsValue)) {
                    endpoint.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }
        if (address != null) {
            endpoint.setAddress(address.getAttributeValue());
//        } else {
//            handleException(""One of the 'address' or 'ref' attributes are required in an ""
//                    + ""anonymous endpoint"");
        }
        if (format != null)
        {
            String forceValue = format.getAttributeValue().trim().toLowerCase();
            if (forceValue.equals(SynapseConstants.FORMAT_POX)) {
                endpoint.setForcePOX(true);
                endpoint.setFormat(SynapseConstants.FORMAT_POX);
                
            } else if (forceValue.equals(SynapseConstants.FORMAT_SOAP11)) {
            	endpoint.setForceSOAP11(true);
            	endpoint.setFormat(SynapseConstants.FORMAT_SOAP11);
                
            } else if (forceValue.equals(SynapseConstants.FORMAT_SOAP12)) {
            	endpoint.setForceSOAP12(true);
                endpoint.setFormat(SynapseConstants.FORMAT_SOAP12);
                
            } else {
                handleException(""unknown value -\""""+forceValue+""\"". Attribute 'format' accepts only 'pox','soap11','soap12'"");
            }
        }

        if (optimize != null && optimize.getAttributeValue().length() > 0) {
            String method = optimize.getAttributeValue().trim();
            if (""mtom"".equalsIgnoreCase(method)) {
                endpoint.setUseMTOM(true);
            } else if (""swa"".equalsIgnoreCase(method)) {
                endpoint.setUseSwa(true);
            }
        }

        OMElement wsAddr = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableAddressing""));
        if (wsAddr != null) {
            endpoint.setAddressingOn(true);
            String useSepList = wsAddr.getAttributeValue(new QName(
                    ""separateListener""));
            if (useSepList != null) {
                if (useSepList.trim().toLowerCase().startsWith(""tr"")
                        || useSepList.trim().startsWith(""1"")) {
                    endpoint.setUseSeparateListener(true);
                }
            }
        }
        OMElement wsSec = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableSec""));
        if (wsSec != null) {
            endpoint.setSecurityOn(true);
            OMAttribute policy = wsSec.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpoint.setWsSecPolicyKey(policy.getAttributeValue());
            }
        }
        OMElement wsRm = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableRM""));
        if (wsRm != null) {
            endpoint.setReliableMessagingOn(true);
            OMAttribute policy = wsRm.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                endpoint.setWsRMPolicyKey(policy.getAttributeValue());
            }
        }
        // set the timeout configuration
        OMElement timeout = elem.getFirstChildWithName(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""timeout""));
        if (timeout != null) {
            OMElement duration = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""duration""));
            if (duration != null) {
                String d = duration.getText();
                if (d != null) {
                    try {
                        long timeoutSeconds = new Long(d.trim()).longValue();
                        endpoint.setTimeoutDuration(timeoutSeconds * 1000);

                    } catch (NumberFormatException e) {
                        handleException(
                            ""The timeout seconds should be specified as a valid number :: ""
                            + e.getMessage(), e);
                    }
                }
            }

            OMElement action = timeout.getFirstChildWithName(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.SYNAPSE_NAMESPACE, ""action""));
            if (action != null) {
                String a = action.getText();
                if (a != null) {
                    if ((a.trim()).equalsIgnoreCase(""discard"")) {
                        endpoint.setTimeoutAction(SynapseConstants.DISCARD);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpoint.getTimeoutDuration() == 0) {
                            endpoint.setTimeoutDuration(30000);
                        }
                    } else if ((a.trim()).equalsIgnoreCase(""fault"")) {
                        endpoint.setTimeoutAction(SynapseConstants.DISCARD_AND_FAULT);

                        // set timeout duration to 30 seconds, if it is not set explicitly
                        if (endpoint.getTimeoutDuration() == 0) {
                            endpoint.setTimeoutDuration(30000);
                        }
                    }
                }
            }
        }

        return endpoint;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/core/axis2/SynapseAxisServlet.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.core.axis2;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.transport.http.AxisServlet;
import org.apache.synapse.ServerManager;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;

/**
 * Extends axis2 servlet functionality so that  avoid  starting listeners again
 */

public class SynapseAxisServlet extends AxisServlet {


    /**
     * Overrides init method so that avoid  starting listeners again
     *
     * @param config
     * @throws ServletException
     */
    public void init(ServletConfig config) throws ServletException {
        ServletContext servletContext = config.getServletContext();
        this.configContext = ServerManager.getInstance().getConfigurationContext();
        this.axisConfiguration = this.configContext.getAxisConfiguration();
        servletContext.setAttribute(this.getClass().getName(), this);
        this.servletConfig = config;
        initParams();
    }

    public void initContextRoot(HttpServletRequest req) {
        this.configContext.setContextRoot(""/"");
    }
}
"
org/apache/synapse/config/xml/ValidateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.jaxen.JaxenException;
import org.xml.sax.SAXException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Creates a validation mediator from the XML configuration
 * <p/>
 * <validate [source=""xpath""]>
 *   <schema key=""string"">+
 *   <property name=""<validation-feature-name>"" value=""true|false""/>
 *   <on-fail>
 *     mediator+
 *   </on-fail>
 * </validate>
 */
public class ValidateMediatorFactory extends AbstractListMediatorFactory {

    private static final QName VALIDATE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""validate"");
    private static final QName ON_FAIL_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""on-fail"");
    private static final QName SCHEMA_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""schema"");

    public Mediator createMediator(OMElement elem) {

        ValidateMediator validateMediator = new ValidateMediator();

        // process schema element definitions and create DynamicProperties
        List schemaKeys = new ArrayList();
        Iterator schemas = elem.getChildrenWithName(SCHEMA_Q);

        while (schemas.hasNext()) {
            Object o = schemas.next();
            if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                OMAttribute keyAtt = omElem.getAttribute(ATT_KEY);
                if (keyAtt != null) {
                    schemaKeys.add(keyAtt.getAttributeValue());
                } else {
                    handleException(""A 'schema' definition must contain a local property 'key'"");
                }
            } else {
                handleException(""Invalid 'schema' declaration for validate mediator"");
            }
        }

        if (schemaKeys.size() == 0) {
            handleException(""No schemas specified for the validate mediator"");
        } else {
            validateMediator.setSchemaKeys(schemaKeys);
        }

        // process source XPath attribute if present
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);

        if (attSource != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(attSource.getAttributeValue());
                validateMediator.setSource(xp);
                OMElementUtils.addNameSpaces(xp, elem, log);
            } catch (JaxenException e) {
                handleException(""Invalid XPath expression specified for attribute 'source'"", e);
            }
        }

        // process on-fail
        OMElement onFail = null;
        Iterator iterator = elem.getChildrenWithName(ON_FAIL_Q);
        if (iterator.hasNext()) {
            onFail = (OMElement)iterator.next();
        }

        if (onFail != null && onFail.getChildElements().hasNext()) {
            addChildren(onFail, validateMediator);
        } else {
            handleException(""A non-empty <on-fail> child element is required for "" +
                ""the <validate> mediator"");
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(validateMediator,elem);
        // set the features
        Iterator iter = elem.getChildrenWithName(FEATURE_Q);
        while (iter.hasNext()) {
            OMElement featureElem = (OMElement) iter.next();
            OMAttribute attName = featureElem.getAttribute(ATT_NAME);
            OMAttribute attValue = featureElem.getAttribute(ATT_VALUE);
            if (attName != null && attValue != null) {
                String name = attName.getAttributeValue();
                String value = attValue.getAttributeValue();
                if (name != null && value != null) {
                    try {
                        if (""true"".equals(value.trim())) {
                            validateMediator.addFeature(name.trim(), true);
                        } else if (""false"".equals(value.trim())) {
                            validateMediator.addFeature(name.trim(), false);
                        } else {
                            handleException(""The feature must have value true or false"");
                        }
                    } catch (SAXException e) {
                        handleException(""Error setting validation feature : "" + name + "" to : "" + value, e);
                    }
                } else {
                    handleException(""The valid values for both of the name and value are need"");
                }
            } else {
                handleException(""Both of the name and value attribute are required for a feature"");
            }
        }
        return validateMediator;
    }

    public QName getTagQName() {
        return VALIDATE_Q;
    }
}
"
org/apache/synapse/startup/quartz/SimpleQuartzJob.java,false,"package org.apache.synapse.startup.quartz;

import java.util.Iterator;
import java.util.Set;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.startup.Task;
import org.apache.synapse.config.xml.PropertyHelper;
import org.apache.synapse.core.SynapseEnvironment;
import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

public class SimpleQuartzJob implements Job {
    public static final String
        SYNAPSE_ENVIRONMENT = ""SynapseEnvironment"",
        CLASSNAME = ""ClassName"",
        PROPERTIES = ""Properties"";
    private static final Log log = LogFactory.getLog(SimpleQuartzJob.class);

    public void execute(JobExecutionContext ctx) throws JobExecutionException {

        log.debug(""Executing task : "" + ctx.getJobDetail().getFullName());
        JobDataMap jdm = ctx.getMergedJobDataMap();
        String jobClassName = (String) jdm.get(CLASSNAME);
        if (jobClassName == null) {
            handleException(""No "" + CLASSNAME + "" in JobDetails"");
        }

        Task task = null;
        try {
            task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();
        } catch (Exception e) {
            handleException(""Cannot instantiate task : "" + jobClassName, e);
        }

        Set properties = (Set) jdm.get(PROPERTIES);
        Iterator it = properties.iterator();
        while (it.hasNext()) {
            OMElement prop = (OMElement) it.next();
            log.debug(""Found Property : "" + prop.toString());
            PropertyHelper.setStaticProperty(prop, task);
        }

        SynapseEnvironment se = (SynapseEnvironment) jdm.get(""SynapseEnvironment"");
        if (task instanceof ManagedLifecycle) {
            if (se != null) {
                ((ManagedLifecycle) task).init(se);
            }
        }

        if (se.isInitialized()) {
            task.execute();
        }
    }

    private void handleException(String msg) throws JobExecutionException {
        log.error(msg);
        throw new JobExecutionException(msg);
    }

    private void handleException(String msg, Exception e) throws JobExecutionException {
        log.error(msg, e);
        throw new JobExecutionException(msg, e);
    }

}
"
org/apache/synapse/core/axis2/Axis2MessageContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.impl.llom.OMElementImpl;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.GetPropertyFunction;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.jaxen.JaxenException;
import org.jaxen.SimpleFunctionContext;
import org.jaxen.XPathFunctionContext;

import java.util.*;

/**
 * This is the MessageContext implementation that synapse uses almost all the time because Synapse
 * is implemented on top of the Axis2
 */
public class Axis2MessageContext implements MessageContext {

    private static final Log log = LogFactory.getLog(Axis2MessageContext.class);

    /** Holds the reference to the Synapse Message Context */
    private SynapseConfiguration synCfg = null;

    /** Holds the environment on which synapse operates */
    private SynapseEnvironment synEnv = null;

    /** Synapse Message Context properties */
    private Map properties = new HashMap();

    /**
     * Local entries fetched from the configuration or from the registry for the transactional
     * resource access
     */
    private Map localEntries = new HashMap();

    /** Fault Handler stack which will be popped and called the handleFault in error states */
    private Stack faultStack = new Stack();

    /** The Axis2 MessageContext reference */
    private org.apache.axis2.context.MessageContext axis2MessageContext = null;

    /** Attribute of the MC specifying whether this is a response or not */
    private boolean response = false;

    /** Attribute specifying whether this MC corresponds to fault response or not */
    private boolean faultResponse = false;

    /** Attribute of MC stating the tracing state of the message */
    private int tracingState = SynapseConstants.TRACING_UNSET;

    /** The service log for this message */
    private Log serviceLog = null;

    public SynapseConfiguration getConfiguration() {
        return synCfg;
    }

    public void setConfiguration(SynapseConfiguration synCfg) {
        this.synCfg = synCfg;
    }

    public SynapseEnvironment getEnvironment() {
        return synEnv;
    }

    public void setEnvironment(SynapseEnvironment synEnv) {
        this.synEnv = synEnv;
    }

    public Mediator getMainSequence() {
        Object o = localEntries.get(SynapseConstants.MAIN_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator main = getConfiguration().getMainSequence();
            localEntries.put(SynapseConstants.MAIN_SEQUENCE_KEY, main);
            return main;
        }
    }

    public Mediator getFaultSequence() {
        Object o = localEntries.get(SynapseConstants.FAULT_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator fault = getConfiguration().getFaultSequence();
            localEntries.put(SynapseConstants.FAULT_SEQUENCE_KEY, fault);
            return fault;
        }
    }

    public Mediator getSequence(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator m = getConfiguration().getSequence(key);
            localEntries.put(key, m);
            return m;
        }
    }

    public Endpoint getEndpoint(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Endpoint) {
            return (Endpoint) o;
        } else {
            Endpoint e = getConfiguration().getEndpoint(key);
            localEntries.put(key, e);
            return e;
        }
    }

    public Object getEntry(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Entry) {
            return ((Entry) o).getValue();
        } else {
            Object e = getConfiguration().getEntry(key);
            if (e != null) {
                localEntries.put(key, e);
                return e;
            } else {
                getConfiguration().getEntryDefinition(key);
                return getConfiguration().getEntry(key);
            }
        }
    }

    public Object getProperty(String key) {
        return properties.get(key);
    }

    public void setProperty(String key, Object value) {
        properties.put(key, value);

        // do not commit response by default in the server process
        if (SynapseConstants.RESPONSE.equals(key) &&
                getAxis2MessageContext().getOperationContext() != null) {
            getAxis2MessageContext().getOperationContext().setProperty(
                org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");
        }
    }

    public Set getPropertyKeySet() {
        return properties.keySet();
    }

    /**
     * Constructor for the Axis2MessageContext inside Synapse
     *
     * @param axisMsgCtx MessageContext representing the relevant Axis MC
     * @param synCfg SynapseConfiguraion describing Synapse
     * @param synEnv SynapseEnvironment describing the environment of Synapse
     */
    public Axis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx,
                               SynapseConfiguration synCfg, SynapseEnvironment synEnv) {
        setAxis2MessageContext(axisMsgCtx);
        this.synCfg = synCfg;
        this.synEnv = synEnv;
        this.pushFaultHandler(new MediatorFaultHandler(synCfg.getFaultSequence()));
    }

    public EndpointReference getFaultTo() {
        return axis2MessageContext.getFaultTo();
    }

    public void setFaultTo(EndpointReference reference) {
        axis2MessageContext.setFaultTo(reference);
    }

    public EndpointReference getFrom() {
        return axis2MessageContext.getFrom();
    }

    public void setFrom(EndpointReference reference) {
        axis2MessageContext.setFrom(reference);
    }

    public SOAPEnvelope getEnvelope() {
        return axis2MessageContext.getEnvelope();
    }

    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault {
        axis2MessageContext.setEnvelope(envelope);
    }

    public String getMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public void setMessageID(String string) {
        axis2MessageContext.setMessageID(string);
    }

    public RelatesTo getRelatesTo() {
        return axis2MessageContext.getRelatesTo();
    }

    public void setRelatesTo(RelatesTo[] reference) {
        axis2MessageContext.setRelationships(reference);
    }

    public EndpointReference getReplyTo() {
        return axis2MessageContext.getReplyTo();
    }

    public void setReplyTo(EndpointReference reference) {
        axis2MessageContext.setReplyTo(reference);
    }

    public EndpointReference getTo() {
        return axis2MessageContext.getTo();
    }

    public void setTo(EndpointReference reference) {
        axis2MessageContext.setTo(reference);
    }

    public void setWSAAction(String actionURI) {
        axis2MessageContext.setWSAAction(actionURI);
    }

    public String getWSAAction() {
        return axis2MessageContext.getWSAAction();
    }

    public void setWSAMessageID(String messageID) {
        axis2MessageContext.setWSAMessageId(messageID);
    }

    public String getWSAMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public String getSoapAction() {
        return axis2MessageContext.getSoapAction();
    }

    public void setSoapAction(String string) {
        axis2MessageContext.setSoapAction(string);
    }

    public boolean isDoingMTOM() {
        return axis2MessageContext.isDoingMTOM();
    }

    public boolean isDoingSWA() {
        return axis2MessageContext.isDoingSwA();
    }

    public void setDoingMTOM(boolean b) {
        axis2MessageContext.setDoingMTOM(b);
    }

    public void setDoingSWA(boolean b) {
        axis2MessageContext.setDoingSwA(b);
    }

    public boolean isDoingPOX() {
        return axis2MessageContext.isDoingREST();
    }

    public void setDoingPOX(boolean b) {
        axis2MessageContext.setDoingREST(b);
    }

    public boolean isSOAP11() {
        return axis2MessageContext.isSOAP11();
    }

    public void setResponse(boolean b) {
        response = b;
        axis2MessageContext.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, Boolean.valueOf(b));
    }

    public boolean isResponse() {
        Object o = properties.get(SynapseConstants.RESPONSE);
        if (o != null && o instanceof String && ((String) o).equalsIgnoreCase(""true"")) {
            return true;
        }
        return response;
    }

    public void setFaultResponse(boolean b) {
        this.faultResponse = b;
    }

    public boolean isFaultResponse() {
        return this.faultResponse;
    }

    public int getTracingState() {
        return tracingState;
    }

    public void setTracingState(int tracingState) {
        this.tracingState= tracingState;
    }

    public Stack getFaultStack() {
        return this.faultStack;
    }

    public void pushFaultHandler(FaultHandler fault) {
        this.faultStack.push(fault);
    }

    /**
     * Return the service level Log for this message context or null
     * @return the service level Log for the message
     */
    public Log getServiceLog() {

        if (serviceLog != null) {
            return serviceLog;
        } else {
            String serviceName = (String) getProperty(SynapseConstants.PROXY_SERVICE);
            if (serviceName != null && synCfg.getProxyService(serviceName) != null) {
                serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX + serviceName);
                return serviceLog;
            } else {
                serviceLog = LogFactory.getLog(
                    SynapseConstants.SERVICE_LOGGER_PREFIX.substring(0,
                    SynapseConstants.SERVICE_LOGGER_PREFIX.length()-1));
                return serviceLog;
            }
        }
    }

    /**
     * Set the service log
     * @param serviceLog
     */
    public void setServiceLog(Log serviceLog) {
        this.serviceLog = serviceLog;
    }

    public org.apache.axis2.context.MessageContext getAxis2MessageContext() {
        return axis2MessageContext;
    }

    public void setAxis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx) {
        this.axis2MessageContext = axisMsgCtx;
        Boolean resp = (Boolean) axisMsgCtx.getProperty(SynapseConstants.ISRESPONSE_PROPERTY);
        if (resp != null)
            response = resp.booleanValue();
    }

    public void setPaused(boolean value) {
        axis2MessageContext.setPaused(value);
    }

    public boolean isPaused() {
        return axis2MessageContext.isPaused();
    }

    public boolean isServerSide() {
        return axis2MessageContext.isServerSide();
    }

    public void setServerSide(boolean value) {
        axis2MessageContext.setServerSide(value);
    }

    /**
     * Evaluates the given XPath expression against the SOAPEnvelope of the
     * current message and returns a String representation of the result
     * @param xpath the expression to evaluate
     * @param synCtx the source message which holds the SOAP envelope
     * @return a String representation of the result of evaluation
     */
    public static String getStringValue(AXIOMXPath xpath, MessageContext synCtx) {

        synchronized(xpath) {

        if (xpath != null) {
            try {
                // create an instance of a synapse:get-property() function and set it to the xpath
                GetPropertyFunction getPropertyFunc = new GetPropertyFunction();
                getPropertyFunc.setSynCtx(synCtx);

                // set function context into XPath
                SimpleFunctionContext fc = new XPathFunctionContext();
                fc.registerFunction(SynapseConstants.SYNAPSE_NAMESPACE, ""get-property"", getPropertyFunc);
                fc.registerFunction(null, ""get-property"", getPropertyFunc);
                xpath.setFunctionContext(fc);

                // register namespace for XPath extension function
                xpath.addNamespace(""synapse"", SynapseConstants.SYNAPSE_NAMESPACE);
                xpath.addNamespace(""syn"", SynapseConstants.SYNAPSE_NAMESPACE);

            } catch (JaxenException je) {
                handleException(""Error setting up the Synapse XPath "" +
                    ""extension function for XPath : "" + xpath, je);
            }
            try {
                Object result = xpath.evaluate(synCtx.getEnvelope());
                if (result == null) {
                    return null;
                }
                StringBuffer textValue = new StringBuffer();
                if (result instanceof List) {
                    List list = (List) result;
                    Iterator iter = list.iterator();
                    while (iter.hasNext()) {
                        Object o = iter.next();
                        if (o == null && list.size() == 1) {
                            return null;
                        }
                        if (o instanceof OMTextImpl) {
                            textValue.append(((OMTextImpl) o).getText());
                        } else if (o instanceof OMElementImpl) {
                            String s = ((OMElementImpl) o).getText();
                            if (s.trim().length() == 0) {
                                s = o.toString();
                            }
                            textValue.append(s);
                        }
                    }
                } else {
                    textValue.append(result.toString());
                }
                return textValue.toString();

            } catch (JaxenException je) {
                handleException(""Evaluation of the XPath expression "" + xpath.toString() +
                    "" resulted in an error"", je);
            }
        } else {
            handleException(""Invalid (null) XPath expression"");
        }
        return null;
        }
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        String separator = ""\n"";

        if (getTo() != null)
            sb.append(""To: "" + getTo().getAddress());
        else
            sb.append(""To: "");
        if (getFrom() != null)
            sb.append(separator + ""From: "" + getFrom().getAddress());
        if (getWSAAction() != null)
            sb.append(separator + ""WSAction: "" + getWSAAction());
        if (getSoapAction() != null)
            sb.append(separator + ""SOAPAction: "" + getSoapAction());
        if (getReplyTo() != null)
            sb.append(separator + ""ReplyTo: "" + getReplyTo().getAddress());
        if (getMessageID() != null)
            sb.append(separator + ""MessageID: "" + getMessageID());

        SOAPHeader soapHeader = getEnvelope().getHeader();
        if (soapHeader != null) {
            sb.append(separator + ""Headers : "");
            for (Iterator iter = soapHeader.examineAllHeaderBlocks(); iter.hasNext();) {
                Object o = iter.next();
                if (o instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                    sb.append(separator + headerBlock.getLocalName() + "" : "" + headerBlock.getText());
                } else if (o instanceof OMElement) {
                    OMElement headerElem = (OMElement) o;
                    sb.append(separator + headerElem.getLocalName() + "" : "" + headerElem.getText());
                }
            }
        }

        return sb.toString();
    }


}
"
org/apache/synapse/startup/quartz/SimpleQuartz.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.SynapseException;
import org.apache.synapse.startup.AbstractStartup;
import org.quartz.CronTrigger;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerUtils;
import org.quartz.impl.DirectSchedulerFactory;

/*
 * This class is instantiated by SimpleQuartzFactory (or by hand)
 * When it is initialized it creates a Quartz Scheduler with a job and a trigger
 * The class it starts is always an instance of SimpleQuartzJob
 * SimpleQuartzJob is there to set the properties and start the actual business-logic class
 * It wraps up any properties that the job needs as in the JobDetail and JDMap
 */
public class SimpleQuartz extends AbstractStartup {

    private static final Log log = LogFactory.getLog(SimpleQuartz.class);
    private static final int THREADPOOLSIZE = 5;

    private String cron;
    private int repeatCount = -1;
    private long repeatInterval;
    private String className;
    private Scheduler sch;
    Set xmlProperties = new HashSet();

    public QName getTagQName() {
        return SimpleQuartzFactory.TASK;
    }

    public void destroy() {
        if (sch != null) {
            try {
                sch.shutdown();
            } catch (SchedulerException e) {
                log.warn(""Error shutting down scheduler"", e);
                throw new SynapseException(""Error shutting down scheduler"", e);
            }
        }
    }

    public void init(SynapseEnvironment synapseEnvironment) {

        try {
            DirectSchedulerFactory.getInstance().createVolatileScheduler(THREADPOOLSIZE);
            sch = DirectSchedulerFactory.getInstance().getScheduler();

            Trigger trigger = null;
            if (cron == null) {
                if (repeatCount >= 0) {
                    trigger = TriggerUtils.makeImmediateTrigger(repeatCount - 1, repeatInterval);
                } else {
                    trigger = TriggerUtils.makeImmediateTrigger(-1, repeatInterval);
                }

            } else {
                CronTrigger cronTrig = new CronTrigger();
                cronTrig.setCronExpression(cron);
                trigger = cronTrig;
            }

            // give the trigger a random name
            trigger.setName(""Trigger"" + String.valueOf((new Random()).nextLong()));
            trigger.setGroup(""synapse.simple.quartz"");
            trigger.setVolatility(true);
            JobDetail jobDetail = new JobDetail();

            // Give the job a name
            jobDetail.setName(name);
            jobDetail.setGroup(""synapse.simple.quartz"");
            jobDetail.setJobClass(SimpleQuartzJob.class);
            JobDataMap jdm = new JobDataMap();
            jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);
            jdm.put(SimpleQuartzJob.CLASSNAME, className);
            jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);
            jobDetail.setJobDataMap(jdm);

            sch.scheduleJob(jobDetail, trigger);
            sch.start();
            log.info(""Scheduled job "" + jobDetail.getFullName() + "" for class "" + className);

        } catch (Exception e) {
            log.fatal(""Error starting up Scheduler"", e);
            throw new SynapseException(""Error starting up Scheduler"", e);
        }

    }

    public String getJobClass() {
        return className;
    }

    public void setJobClass(String attributeValue) {
        className = attributeValue;

    }

    public void setInterval(long l) {
        repeatInterval = l;

    }

    public long getInterval() {
        return repeatInterval;
    }

    public void setCount(int i) {
        repeatCount = i;
    }

    public int getCount() {
        return repeatCount;
    }

    public void addProperty(OMElement prop) {
        xmlProperties.add(prop);
    }

    public Set getProperties() {
        return xmlProperties;
    }

    public void setCron(String attributeValue) {
        cron = attributeValue;

    }

    public String getCron() {
        return cron;
    }

}
"
org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.OperationContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.description.InOutAxisOperation;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.mediators.MediatorWorker;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.synapse.util.concurrent.SynapseThreadPool;

import java.util.concurrent.ExecutorService;

/**
 * This is the Axis2 implementation of the SynapseEnvironment
 */
public class Axis2SynapseEnvironment implements SynapseEnvironment {

    private static final Log log = LogFactory.getLog(Axis2SynapseEnvironment.class);

    private SynapseConfiguration synapseConfig;
    private ConfigurationContext configContext;
    private ExecutorService executorService;
    private boolean initialized = false;

    /** The StatisticsCollector object */
    private StatisticsCollector statisticsCollector;

    public Axis2SynapseEnvironment(SynapseConfiguration synCfg) {
        
        int coreThreads = SynapseThreadPool.SYNAPSE_CORE_THREADS;
        int maxThreads  = SynapseThreadPool.SYNAPSE_MAX_THREADS;
        long keepAlive  = SynapseThreadPool.SYNAPSE_KEEP_ALIVE;
        int qlength     = SynapseThreadPool.SYNAPSE_THREAD_QLEN;
        
        try {
            qlength = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_QLEN));
        } catch (Exception ignore) {}

        try {
            coreThreads = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_CORE));
        } catch (Exception ignore) {}

        try {
            maxThreads = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_MAX));
        } catch (Exception ignore) {}

        try {
            keepAlive = Long.parseLong(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_ALIVE));
        } catch (Exception ignore) {}
        
        this.executorService = new SynapseThreadPool(coreThreads, maxThreads, keepAlive, qlength,
            synCfg.getProperty(SynapseThreadPool.SYN_THREAD_GROUP,
                SynapseThreadPool.SYNAPSE_THREAD_GROUP),
            synCfg.getProperty(SynapseThreadPool.SYN_THREAD_IDPREFIX,
                SynapseThreadPool.SYNAPSE_THREAD_ID_PREFIX));
    }

    public Axis2SynapseEnvironment(ConfigurationContext cfgCtx,
        SynapseConfiguration synapseConfig) {
        this(synapseConfig);
        this.configContext = cfgCtx;
        this.synapseConfig = synapseConfig;
    }

    public boolean injectMessage(final MessageContext synCtx) {
        if (log.isDebugEnabled()) {
            log.debug(""Injecting MessageContext"");
        }
        synCtx.setEnvironment(this);
        if (synCtx.isResponse()) {
            //Process statistics related to a sequence which has send mediator as a child,end point
            StatisticsUtils.processEndPointStatistics(synCtx);
            StatisticsUtils.processProxyServiceStatistics(synCtx);
            StatisticsUtils.processSequenceStatistics(synCtx);
        }

        // if this is a response to a proxy service
        if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {

            if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {

                String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx.
                        getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();
                Mediator outSequence = synCtx.getSequence(sequenceName);

                if (outSequence != null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Using the sequence named "" + sequenceName
                                + "" for the outgoing message mediation of the proxy service ""
                                + synCtx.getProperty(SynapseConstants.PROXY_SERVICE));
                    }
                    outSequence.mediate(synCtx);
                } else {
                    log.error(""Unable to find the out-sequence "" +
                            ""specified by the name "" + sequenceName);
                    throw new SynapseException(""Unable to find the "" +
                            ""out-sequence specified by the name "" + sequenceName);
                }

            } else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Using the anonymous out-sequence specified in the proxy service ""
                            + synCtx.getProperty(SynapseConstants.PROXY_SERVICE)
                            + "" for outgoing message mediation"");
                }
                synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                        SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Proxy service "" + synCtx.getProperty(SynapseConstants.PROXY_SERVICE)
                            + "" does not specifies an out-sequence - sending the response back"");
                }
                Axis2Sender.sendBack(synCtx);
            }

        } else {
            if (log.isDebugEnabled()) {
                log.debug(""Using Main Sequence for injected message"");
            }
            return synCtx.getMainSequence().mediate(synCtx);
        }
        return true;
    }

    public void injectAsync(final MessageContext synCtx, SequenceMediator seq) {
        if (log.isDebugEnabled()) {
            log.debug(""Injecting MessageContext for asynchronous mediation using the : ""
                + (seq.getName() == null? ""Anonymous"" : seq.getName()) + "" Sequence"");
        }
        synCtx.setEnvironment(this);
        // todo: do we need to have this in here ? ruwan
        if (synCtx.isResponse()) {
            //Process statistics related to a sequence which has send mediator as a child,end point
            StatisticsUtils.processEndPointStatistics(synCtx);
            StatisticsUtils.processProxyServiceStatistics(synCtx);
            StatisticsUtils.processSequenceStatistics(synCtx);
        }

        executorService.execute(new MediatorWorker(seq, synCtx));

    }

    /**
     * This will be used for sending the message provided, to the endpoint specified by the
     * EndpointDefinition using the axis2 environment.
     *
     * @param endpoint - EndpointDefinition to be used to find the endpoint information
     *                      and the properties of the sending process
     * @param synCtx   - Synapse MessageContext to be sent
     */
    public void send(EndpointDefinition endpoint, MessageContext synCtx) {
        if (synCtx.isResponse()) {

            if (endpoint != null) {
                // not sure whether we need to collect statistics here
                StatisticsUtils.processEndPointStatistics(synCtx);
                StatisticsUtils.processProxyServiceStatistics(synCtx);
                StatisticsUtils.processAllSequenceStatistics(synCtx);

                Axis2Sender.sendOn(endpoint, synCtx);

            } else {
                Axis2Sender.sendBack(synCtx);
            }
        } else {
            Axis2Sender.sendOn(endpoint, synCtx);
        }
    }

    /**
     * This method will be used to create a new MessageContext in the Axis2 environment for
     * synapse. This will set all the relevant parts to the messagecontext, but for this message
     * context to be usefull creator has to fill in the data like envelope and operation context
     * and so on. This will set a default envelope of type soap12 and a new messageID for the
     * created message along with the ConfigurationContext is being set in to the message
     * correctly.
     *
     * @return Synapse MessageContext with the underlying axis2 message context set
     */
    public MessageContext createMessageContext() {

        if (log.isDebugEnabled()) {
            log.debug(""Creating Message Context"");
        }

        org.apache.axis2.context.MessageContext axis2MC
                = new org.apache.axis2.context.MessageContext();
        axis2MC.setConfigurationContext(this.configContext);

        ServiceContext svcCtx = new ServiceContext();
        OperationContext opCtx = new OperationContext(new InOutAxisOperation(), svcCtx);
        axis2MC.setServiceContext(svcCtx);
        axis2MC.setOperationContext(opCtx);
        MessageContext mc = new Axis2MessageContext(axis2MC, synapseConfig, this);
        mc.setMessageID(UUIDGenerator.getUUID());
        try {
			mc.setEnvelope(OMAbstractFactory.getSOAP12Factory().createSOAPEnvelope());
			mc.getEnvelope().addChild(OMAbstractFactory.getSOAP12Factory().createSOAPBody());
		} catch (Exception e) {
			e.printStackTrace();
		}

        return mc;
    }

    /**
     * This method returns the StatisticsCollector
     *
     * @return Retruns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector() {
        return statisticsCollector;
    }

    /**
     * To set the StatisticsCollector
     *
     * @param collector - Statistics collector to be set
     */
    public void setStatisticsCollector(StatisticsCollector collector) {
        this.statisticsCollector = collector;
    }

    /**
     * This will give the access to the synapse thread pool for the
     * advanced mediation tasks.
     *
     * @return an ExecutorService to execute the tasks in a new thread from the pool
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Has this environment properly initialized?
     * @return true if ready for processing
     */
    public boolean isInitialized() {
        return initialized;
    }

    /**
     * Mark this environment as ready for processing
     * @param state true means ready for processing
     */
    public void setInitialized(boolean state) {
        this.initialized = state;
    }

}
"
org/apache/synapse/config/xml/OMElementUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMContainer;
import org.apache.axiom.om.OMDocument;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.jaxen.JaxenException;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;

/**
 * Holds Axiom utility methods used by Synapse
 */
public class OMElementUtils {

    private static final Log log = LogFactory.getLog(OMElementUtils.class);

    /**
     * Return the namespace with the given prefix, using the given element
     * @param prefix the prefix looked up
     * @param elem the source element to use
     * @return the namespace which maps to the prefix or null
     */
    public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {
        if (prefix == null || elem == null) {
            log.warn(""Searching for null NS prefix and/or using null OMElement"");
            return null;
        }

        Iterator iter = elem.getAllDeclaredNamespaces();
        while (iter.hasNext()) {
            OMNamespace ns = (OMNamespace) iter.next();
            if (prefix.equals(ns.getPrefix())) {
                return ns.getNamespaceURI();     
            }
        }
        return null;
    }

    /**
     * Add all applicable xmlns NS declarations of element 'elem' into XPath expression
     * @param xpath                                       xmlns:m0=""http://services.samples/xsd""
     * @param elem
     * @param log
     */
    public static void addNameSpaces(AXIOMXPath xpath, OMElement elem, Log log) {

        OMElement currentElem = elem;

        while (currentElem != null) {              
            Iterator it = currentElem.getAllDeclaredNamespaces();
            while (it.hasNext()) {

                OMNamespace n = (OMNamespace) it.next();
                if (n != null) {

                    try {
                        xpath.addNamespace(n.getPrefix(), n.getNamespaceURI());
                    } catch (JaxenException je) {
                        String msg = ""Error adding declared name space with prefix : ""
                            + n.getPrefix() + ""and uri : "" + n.getNamespaceURI()
                            + "" to the XPath : "" + xpath;
                        log.error(msg);
                        throw new SynapseException(msg, je);
                    }
                }
            }

            OMContainer parent = currentElem.getParent();
            //if the parent is a document element or parent is null ,then return
            if (parent == null || parent instanceof OMDocument) {
                return;
            }
            if (parent instanceof OMElement) {
                currentElem = (OMElement) parent;
            }
        }
    }
}
"
org/apache/synapse/config/xml/IterateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.eip.splitter.IterateMediator;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * The &lt;iterate&gt; element is used to split messages in Synapse to smaller messages with only
 * one part of the elements described in the XPATH expression.
 * <p/>
 * <pre>
 *  &lt;iterate continueParent=(true | false) preservePayload=(true | false)
 *                          (attachPath=""XPATH expression"")? expression=""XPATH expression""&gt;
 *   &lt;target to=""TO address"" [soapAction=""urn:Action""] sequence=""sequence ref""
 *                                                         endpoint=""endpoint ref""&gt;
 *    &lt;sequence&gt; (mediator +) &lt;/sequence&gt;
 *    &lt;endpoint&gt; endpoint &lt;/endpoint&gt;
 *   &lt;/target&gt;
 *  &lt;/iterate&gt;
 * </pre>
 */
public class IterateMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(IterateMediatorFactory.class);

    /**
     * Holds the QName for the IterateMeditor xml configuration
     */
    private static final QName ITERATE_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""iterate"");
    private static final QName ATT_CONTPAR = new QName(""continueParent"");
    private static final QName ATT_PREPLD = new QName(""preservePayload"");
    private static final QName ATT_ATTACHPATH = new QName(""attachPath"");

    /**
     * This method will create the IterateMediator by parsing the given xml configuration
     *
     * @param elem OMElement describing the configuration of the IterateMediaotr
     * @return IterateMediator created from the given configuration
     */
    public Mediator createMediator(OMElement elem) {

        IterateMediator mediator = new IterateMediator();
        processTraceState(mediator, elem);

        OMAttribute continueParent = elem.getAttribute(ATT_CONTPAR);
        if (continueParent != null) {
            mediator.setContinueParent(
                Boolean.valueOf(continueParent.getAttributeValue()).booleanValue());
        }

        OMAttribute preservePayload = elem.getAttribute(ATT_PREPLD);
        if (preservePayload != null) {
            mediator.setPreservePayload(
                Boolean.valueOf(preservePayload.getAttributeValue()).booleanValue());
        }

        OMAttribute expression = elem.getAttribute(ATT_EXPRN);
        if (expression != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                mediator.setExpression(xp);
            } catch (JaxenException e) {
                handleException(""Unable to build the IterateMediator. "" + ""Invalid XPATH "" +
                    expression.getAttributeValue(), e);
            }
        } else {
            handleException(""XPATH expression is required "" +
                ""for an IterateMediator under the \""expression\"" attribute"");
        }

        OMAttribute attachPath = elem.getAttribute(ATT_ATTACHPATH);
        String attachPathValue = ""."";
        if (attachPath != null && !mediator.isPreservePayload()) {
            handleException(""Wrong configuration for the iterate mediator :: if the iterator "" +
                ""should not preserve payload, then attachPath can not be present"");
        } else if (attachPath != null) {
            attachPathValue = attachPath.getAttributeValue();
        }
        
        try {
            AXIOMXPath xp = new AXIOMXPath(attachPathValue);
            OMElementUtils.addNameSpaces(xp, elem, log);
            mediator.setAttachPath(xp);
        } catch (JaxenException e) {
            handleException(""Unable to build the IterateMediator. Invalid XPATH "" +
                attachPathValue, e);
        }

        OMElement targetElement = elem.getFirstChildWithName(TARGET_Q);
        if (targetElement != null) {
            mediator.setTarget(TargetFactory.createTarget(targetElement));
        } else {
            handleException(""Target for an iterate mediator is required :: missing target"");
        }

        return mediator;
    }

    /**
     * Get the IterateMediator configuration tag name
     *
     * @return QName specifying the IterateMediator tag name of the xml configuration
     */
    public QName getTagQName() {
        return ITERATE_Q;
    }
}
"
org/apache/synapse/mediators/FilterMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.MessageContext;

/**
 * The filter mediator is a list mediator, which executes the given (sub) list of mediators
 * if the specified condition is satisfied
 *
 * @see FilterMediator#test(org.apache.synapse.MessageContext)
 */
public interface FilterMediator extends ListMediator {

    /**
     * Should return true if the sub/child mediators should execute. i.e. if the filter
     * condition is satisfied
     * @param synCtx
     * @return true if the configured filter condition evaluates to true
     */
    public boolean test(MessageContext synCtx);
}
"
org/apache/synapse/statistics/impl/EndPointStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;

/**
 * The data structure to hold statistics related to the endpoints
 *
 */

public class EndPointStatisticsStack implements StatisticsStack {

    /** list of endpoint statistics */
    private List endpointStatistics;
    /** To decide whether the reporting of the in flow statistics have been completed*/
    private boolean isCompleteInFlowStatisicsReport = false;

    /**
     * To put statistics
     * @param key                   - The name of the End Point
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (endpointStatistics == null) {
            endpointStatistics = new ArrayList();
        }
        endpointStatistics.add(
                new EndPointStatistics(key, initTime, isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            EndPointStatistics statistics =
                    (EndPointStatistics) endpointStatistics.get(
                            endpointStatistics.size() - 1);
            if (statistics != null && statistics.isStatisticsEnable &&
                    statistics.endPointName != null) {
                if (statistics.inTimeForInFlow != -1) {
                    long initTimeForOutFlow = System.currentTimeMillis();
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            false, statistics.inTimeForInFlow,
                            initTimeForOutFlow, isFault);
                    statistics.inTimeForInFlow = -1;
                    statistics.inTimeForOutFlow = initTimeForOutFlow;
                } else if (statistics.inTimeForOutFlow != -1 &&
                        isCompleteInFlowStatisicsReport) {
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            true, statistics.inTimeForOutFlow,
                            System.currentTimeMillis(), isFault);
                    endpointStatistics.remove(statistics);
                }
            }
        }
    }

    /**
     * Report a particular statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null &&
                            statistics.endPointName.equals(name)) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
        isCompleteInFlowStatisicsReport = true;
    }

    class EndPointStatistics {

        /** The name of the endpoint    */
        private String endPointName;
         /** To check whether IN message flow or not   */
        private boolean isStatisticsEnable;
        /** To indicate whether this is fault or not  */
        private boolean isFault;
        /** The time which starts to collect statistics for IN flow */
        private long inTimeForInFlow = -1;
        /** The time which starts to collect statistics for OUT flow */
        private long inTimeForOutFlow = -1;

        public EndPointStatistics(String endPointName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean fault) {
            if (inFlow) {
                this.endPointName = endPointName;
                this.inTimeForInFlow = initTime;
                isStatisticsEnable = statisticsEnable;
                isFault = fault;
            }
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            EndPointStatistics that = (EndPointStatistics) o;

            if (endPointName != null ? !endPointName.equals(that.endPointName) : that.endPointName != null)
                return false;

            return true;
        }

        public int hashCode() {
            return (endPointName != null ? endPointName.hashCode() : 0);
        }
    }
}
"
org/apache/synapse/config/xml/ProxyServiceSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.core.axis2.ProxyService;

import java.util.Iterator;
import java.util.ArrayList;
import java.net.URI;

/**
 * <proxyService name=""string"" [transports=""(http |https |jms )+|all""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <policy key=""string"">
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxyService>
 */
public class ProxyServiceSerializer {

    private static final Log log = LogFactory.getLog(PropertyMediatorSerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    public static OMElement serializeProxy(OMElement parent, ProxyService service) {

        OMElement proxy = fac.createOMElement(""proxy"", synNS);
        if (service.getName() != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, service.getName()));
        } else {
            handleException(""Invalid proxy service. Service name is required"");
        }
        String descriptionStr = service.getDescription();
        if (descriptionStr != null) {
            OMElement description = fac.createOMElement(""description"", synNS);
            description.addChild(fac.createOMText(descriptionStr));
            proxy.addChild(description);
        }
        ArrayList transports = service.getTransports();
        if (transports != null && !transports.isEmpty()) {
            String transportStr = """" + transports.get(0);
            for (int i = 1; i < transports.size(); i++) {
                transportStr = transportStr + "" "" + transports.get(i);
            }
            proxy.addAttribute(fac.createOMAttribute(""transports"", nullNS, transportStr));
        }

        if (service.isStartOnLoad()) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""true""));
        } else {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""false""));
        }
        String endpoint = service.getTargetEndpoint();

        OMElement target = fac.createOMElement(""target"", synNS);
        Endpoint inLineEndpoint = service.getTargetInLineEndpoint();
        if (endpoint != null) {
            target.addAttribute(fac.createOMAttribute(
                    ""endpoint"", nullNS, endpoint));
            proxy.addChild(target);
        } else if (inLineEndpoint != null) {
            EndpointSerializer serializer
                    = EndpointAbstractSerializer.getEndpointSerializer(inLineEndpoint);
            OMElement epElement = serializer.serializeEndpoint(inLineEndpoint);
            target.addChild(epElement);            
            proxy.addChild(target);
        }
            String inSeq = service.getTargetInSequence();
            String outSeq = service.getTargetOutSequence();
            String faultSeq = service.getTargetFaultSequence();
            SequenceMediatorSerializer serializer = new SequenceMediatorSerializer();
            if (inSeq != null) {
                target.addAttribute(fac.createOMAttribute(""inSequence"", nullNS, inSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineInSeq = service.getTargetInLineInSequence();
                if (inLineInSeq != null) {
                    OMElement inSeqElement = serializer.serializeAnonymousSequence(null, inLineInSeq);
                    inSeqElement.setLocalName(""inSequence"");
                    target.addChild(inSeqElement);
                    proxy.addChild(target);
                }
            }
            if (outSeq != null) {
                target.addAttribute(fac.createOMAttribute(""outSequence"", nullNS, outSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineOutSeq = service.getTargetInLineOutSequence();
                if (inLineOutSeq != null) {
                    OMElement outSeqElement = serializer.serializeAnonymousSequence(null, inLineOutSeq);
                    outSeqElement.setLocalName(""outSequence"");
                    target.addChild(outSeqElement);
                    proxy.addChild(target);
                }
            }
            if (faultSeq != null) {
                target.addAttribute(fac.createOMAttribute(""faultSequence"", nullNS, faultSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineFaultSeq = service.getTargetInLineFaultSequence();
                if (inLineFaultSeq != null) {
                    OMElement faultSeqElement = serializer.serializeAnonymousSequence(null, inLineFaultSeq);
                    faultSeqElement.setLocalName(""faultSequence"");
                    target.addChild(faultSeqElement);
                    proxy.addChild(target);
                }
            }

        

        String wsdlKey = service.getWSDLKey();
        URI wsdlUri = service.getWsdlURI();
        Object inLineWSDL = service.getInLineWSDL();
        OMElement wsdl = fac.createOMElement(""publishWSDL"", synNS);
        if (wsdlKey != null) {
            wsdl.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, wsdlKey));
            proxy.addChild(wsdl);
        } else if (inLineWSDL != null) {
            wsdl.addChild((OMNode) inLineWSDL);
            proxy.addChild(wsdl);
        } else if (wsdlUri != null) {
            wsdl.addAttribute(fac.createOMAttribute(
                    ""uri"", nullNS, wsdlUri.toString()));
            proxy.addChild(wsdl);
        }

        // TODO still schemas are not used
        // Iterator iter = service.getSchemas();
        // ....

        Iterator iter = service.getServiceLevelPolicies().iterator();
        while (iter.hasNext()) {
            String policyKey = (String) iter.next();
            OMElement policy = fac.createOMElement(""policy"", synNS);
            policy.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, policyKey));
            proxy.addChild(policy);
        }

        iter = service.getParameterMap().keySet().iterator();
        while (iter.hasNext()) {
            String propertyName = (String) iter.next();
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, propertyName));
            Object value = service.getParameterMap().get(propertyName);
            if (value != null) {
                if (value instanceof String) {
                    property.setText(((String) value).trim());
                    proxy.addChild(property);
                } else if (value instanceof OMNode) {
                    property.addChild((OMNode) value);
                    proxy.addChild(property);
                }
            }
        }

        if (service.isWsRMEnabled()) {
            proxy.addChild(fac.createOMElement(""enableRM"", synNS));
        }
        if (service.isWsSecEnabled()) {
            proxy.addChild(fac.createOMElement(""enableSec"", synNS));
        }

        int isEnableStatistics = service.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }

        int traceState = service.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.SynapseConstants.TRACING_ON) {
            traceValue = XMLConfigConstants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.SynapseConstants.TRACING_OFF) {
            traceValue = XMLConfigConstants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }
        if (parent != null) {
            parent.addChild(proxy);
        }
        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/FaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Stack;
import java.io.StringWriter;
import java.io.Writer;
import java.io.PrintWriter;

/**
 * This is an abstract class that handles an unexpected error during Synapse mediation, but looking
 * at the stack of registered FaultHanders and invoking on them as appropriate. Sequences and
 * Endpoints would be Synapse entities that handles faults. If such an entity is unable to handle
 * an error condition, then a SynapseException should be thrown, which triggers this fault
 * handling logic.
 */
public abstract class FaultHandler {

    private static final Log log = LogFactory.getLog(FaultHandler.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public void handleFault(MessageContext synCtx) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""FaultHandler executing impl: "" + this.getClass().getName());
        }

        try {
            synCtx.getServiceLog().info(""FaultHandler executing impl: "" + this.getClass().getName());
            onFault(synCtx);

        } catch (SynapseException e) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    /**
     * Extract and set ERROR_MESSAGE and ERROR_DETAIL to the message context from the Exception
     * @param synCtx the message context
     * @param e the exception encountered
     */
    public void handleFault(MessageContext synCtx, Exception e) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (synCtx.getProperty(SynapseConstants.ERROR_CODE) == null) {
            synCtx.setProperty(SynapseConstants.ERROR_CODE, ""00000"");
        }
        if (synCtx.getProperty(SynapseConstants.ERROR_MESSAGE) == null) {
            // use only the first line as the message for multiline exception messages (Axis2 has these)
            synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split(""\n"")[0]);
        }
        synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""Fault handler - setting ERROR_MESSAGE : "" +
                synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));
            traceOrDebugWarn(traceOn, ""Fault handler - setting ERROR_DETAIL : "" +
                synCtx.getProperty(SynapseConstants.ERROR_DETAIL));
        }

        synCtx.getServiceLog().warn(""Fault handler - setting ERROR_MESSAGE : "" +
            synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));

        try {
            onFault(synCtx);

        } catch (SynapseException se) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx, se);
            }
        }
    }

    /**
     * This will be executed to handle any Exceptions occured within the Synapse environment.
     * @param synCtx SynapseMessageContext of which the fault occured message comprises
     * @throws SynapseException in case there is a failure in the fault execution
     */
    public abstract void onFault(MessageContext synCtx);

    /**
     * Get the stack trace into a String
     * @param aThrowable
     * @return the stack trace as a string
     */
    public static String getStackTrace(Throwable aThrowable) {
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        aThrowable.printStackTrace(printWriter);
        return result.toString();
    }

    private void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        log.warn(msg);
    }

}
"
org/apache/synapse/mediators/builtin/SendMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.axis2.context.OperationContext;

import java.util.List;

/**
 * SendMediator sends a message using specified semantics. If it contains an endpoint it will send the
 * message to that endpoint. Once a message is sent to the endpoint further sending behaviors are completely
 * governed by that endpoint. If there is no endpoint available, SendMediator will send the message to
 * the implicitly stated destination.
 * */
public class SendMediator extends AbstractMediator {

    private Endpoint endpoint = null;

    /**
     * This is a leaf mediator. i.e. processing stops once send is invoked,
     * as it always returns false
     *
     * @param synCtx the current message to be sent
     * @return false always as this is a leaf mediator
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Send mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // if no endpoints are defined, send where implicitly stated
        if (endpoint == null) {

            if (traceOrDebugOn) {
                StringBuffer sb = new StringBuffer();
                sb.append(""Sending "" + (synCtx.isResponse() ? ""response"" : ""request"")
                    + "" message using implicit message properties.."");
                sb.append(""\nSending To: "" + (synCtx.getTo() != null ?
                        synCtx.getTo().getAddress() : ""null""));
                sb.append(""\nSOAPAction: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));
                traceOrDebug(traceOn, sb.toString());
            }

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Envelope : "" + synCtx.getEnvelope());
            }

            if (synCtx.isResponse()) {
                Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synCtx;
                OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
                Object o = opCtx.getProperty(""endpointList"");
                if (o != null && o instanceof List) {
                    // we are in the response of the first message of a server initiated session
                    // so update all session maps
                    List endpointList = (List) o;
                    Object e = endpointList.remove(0);
                    if (e != null && e instanceof SALoadbalanceEndpoint) {
                        SALoadbalanceEndpoint saLoadbalanceEndpoint = (SALoadbalanceEndpoint) e;
                        saLoadbalanceEndpoint.updateSession(synCtx, endpointList);
                    }
                }
            }
            synCtx.getEnvironment().send(null, synCtx);

        } else {
            endpoint.send(synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Send mediator"");
        }
        return true;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
}
"
org/apache/synapse/mediators/MediatorFaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.*;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This implements the FaultHandler interface as a mediator fault handler. That is the fault handler is
 * specified by a sequence and this handler implements the logic of handling the fault through the set
 * of mediators present in the sequence.
 *
 * @see org.apache.synapse.FaultHandler
 */
public class MediatorFaultHandler extends FaultHandler {

    private static final Log log = LogFactory.getLog(MediatorFaultHandler.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     * This holds the fault sequence for the mediator fault handler
     */
    private Mediator faultMediator = null;

    /**
     * Constructs the FaultHandler object for handling mediator faults
     *
     * @param faultMediator Mediator in which fault sequence is specified
     */
    public MediatorFaultHandler(Mediator faultMediator) {

        this.faultMediator = faultMediator;
    }

    /**
     * Implements the fault handling method for the mediators (basically sequences)
     *
     * @param synCtx Synapse Message Context of which mediation occurs
     * @throws SynapseException in case there is a failure in the fault execution
     * @see org.apache.synapse.FaultHandler#handleFault(org.apache.synapse.MessageContext)
     */
    public void onFault(MessageContext synCtx) throws SynapseException {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        String name = null;
        if (faultMediator instanceof SequenceMediator) {
            name = ((SequenceMediator) faultMediator).getName();
        }
        if (name == null) {
            name = faultMediator.getClass().getName();
        }

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""Executing fault handler mediator : "" + name);
        }

        synCtx.getServiceLog().warn(""Executing fault sequence mediator : "" + name);
        this.faultMediator.mediate(synCtx);
    }

    /**
     * Getter for the mediator describing the fault sequence
     *
     * @return Mediator specifying the fault sequence for mediator fault handler
     */
    public Mediator getFaultMediator() {
        return faultMediator;
    }

    /**
     * Setter of the mediator describing the fault sequence
     *
     * @param faultMediator Mediator specifying the fault sequence to be used by the handler
     */
    public void setFaultMediator(Mediator faultMediator) {
        this.faultMediator = faultMediator;
    }

    private void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        log.warn(msg);
    }

}
"
org/apache/synapse/config/xml/FaultMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.FaultMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Creates a fault mediator instance
 *
 * <pre>
 * &lt;makefault [version=""soap11|soap12""]&gt;
 *   &lt;code (value=""literal"" | expression=""xpath"")/&gt;
 *   &lt;reason (value=""literal"" | expression=""xpath"")&gt;
 *   &lt;node&gt;?
 *   &lt;role&gt;?
 *   &lt;detail&gt;?
 * &lt;/makefault&gt;
 * </pre>
 */
public class FaultMediatorFactory extends AbstractMediatorFactory  {

    private static final QName FAULT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""makefault"");

    private static final QName ATT_VERSION_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""version"");
    private static final QName CODE_Q        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""code"");
    private static final QName REASON_Q      = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""reason"");
    private static final QName NODE_Q        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""node"");
    private static final QName ROLE_Q        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""role"");
    private static final QName DETAIL_Q      = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""detail"");

    private static final String SOAP11 = ""soap11"";
    private static final String SOAP12 = ""soap12"";

    public Mediator createMediator(OMElement elem) {

        FaultMediator faultMediator = new FaultMediator();

        OMAttribute version = elem.getAttribute(ATT_VERSION_Q);
        if (version != null) {
            if (SOAP11.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP11);
            } else if (SOAP12.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP12);
            }else {
                String msg = ""Invalid SOAP version"";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement code = elem.getFirstChildWithName(CODE_Q);
        if (code != null) {
            OMAttribute value = code.getAttribute(ATT_VALUE);
            OMAttribute expression = code.getAttribute(ATT_EXPRN);

            if (value != null) {
                String strValue = value.getAttributeValue();
                String prefix, name;
                if (strValue.indexOf("":"") != -1) {
                    prefix = strValue.substring(0, strValue.indexOf("":""));
                    name = strValue.substring(strValue.indexOf("":"")+1);
                } else {
                    String msg = ""A QName is expected for fault code as prefix:name"";
                    log.error(msg);
                    throw new SynapseException(msg);
                }
                faultMediator.setFaultCodeValue(
                    new QName(OMElementUtils.getNameSpaceWithPrefix(prefix, code), name, prefix));
                
            } else if (expression != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, code, log);
                    faultMediator.setFaultCodeExpr(xp);
                } catch (JaxenException je) {
                    String msg = ""Invalid fault code expression : "" + je.getMessage();
                    log.error(msg);
                    throw new SynapseException(msg, je);
                }
            } else {
                String msg = ""A 'value' or 'expression' attribute must specify the fault code"";
                log.error(msg);
                throw new SynapseException(msg);
            }

        } else {
            String msg = ""The fault code is a required attribute for the makefault mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        OMElement reason = elem.getFirstChildWithName(REASON_Q);
        if (reason != null) {
            OMAttribute value = reason.getAttribute(ATT_VALUE);
            OMAttribute expression = reason.getAttribute(ATT_EXPRN);

            if (value != null) {
                faultMediator.setFaultReasonValue(value.getAttributeValue());
            } else if (expression != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, reason, log);
                    faultMediator.setFaultReasonExpr(xp);

                } catch (JaxenException je) {
                    String msg = ""Invalid fault reason expression : "" + je.getMessage();
                    log.error(msg);
                    throw new SynapseException(msg, je);
                }
            } else {
                String msg = ""A 'value' or 'expression' attribute must specify the fault code"";
                log.error(msg);
                throw new SynapseException(msg);
            }

        } else {
            String msg = ""The fault reason is a required attribute for the makefault mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(faultMediator,elem);

        OMElement node = elem.getFirstChildWithName(NODE_Q);
        if (node != null && node.getText() != null) {
            try {
                faultMediator.setFaultNode(new URI(node.getText()));
            } catch (URISyntaxException e) {
                String msg = ""Invalid URI specified for fault node : "" + node.getText();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement role = elem.getFirstChildWithName(ROLE_Q);
        if (role != null && role.getText() != null) {
            try {
                faultMediator.setFaultRole(new URI(role.getText()));
            } catch (URISyntaxException e) {
                String msg = ""Invalid URI specified for fault role : "" + role.getText();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMElement detail = elem.getFirstChildWithName(DETAIL_Q);
        if (detail != null && detail.getText() != null) {
            faultMediator.setFaultDetail(detail.getText());
        }

        return faultMediator;
    }

    public QName getTagQName() {
        return FAULT_Q;
    }
}
"
org/apache/synapse/mediators/eip/EIPConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

/** Holds all the constants related to the eip mediators */
public final class EIPConstants {

    /** Constant for the corelation property key */
    public static final String AGGREGATE_CORELATION = ""aggregateCorelation"";

    /** Constant for the message sequence property key */
    public static final String MESSAGE_SEQUENCE = ""messageSequence"";

    /** Delimeter for the message sequence value */
    public static final String MESSAGE_SEQUENCE_DELEMITER = ""/"";
}
"
org/apache/synapse/mediators/filters/OutMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The Out Mediator acts only on ""outgoing"" messages from synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class OutMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {
        
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Out mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = true;
        if (test(synCtx)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is outgoing - executing child mediators"");
            }
            result = super.mediate(synCtx);

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is a request - skipping child mediators"");
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Out mediator"");
        }

        return result;
    }

    /**
     * Apply mediation only on response messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return synCtx.isResponse();
    }
}
"
org/apache/synapse/startup/tasks/MessageInjector.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.tasks;

import org.apache.axiom.om.OMElement;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.startup.Task;
import org.apache.synapse.util.PayloadHelper;

/**
 * Injects a Message in to the Synapse environment
 */
public class MessageInjector implements Task, ManagedLifecycle {

    /**
     * Holds the logger for logging purposes
     */
    private Log log = LogFactory.getLog(MessageInjector.class);

    /**
     * Holds the Message to be injected
     */
    private OMElement message = null;

    /**
     * Holds the to address for the message to be injected
     */
    private String to = null;

    private String soapAction = null;

    /**
     * Holds the SynapseEnv to which the message will be injected
     */
    private SynapseEnvironment synapseEnvironment;

    /**
     * Initializes the Injector
     *
     * @param se
     *          SynapseEnvironment of synapse
     */
    public void init(SynapseEnvironment se) {
		synapseEnvironment = se;
	}

    /**
     * Set the message to be injected
     *
     * @param elem
     *          OMElement describing the message
     */
    public void setMessage(OMElement elem) {
		log.debug(""set message "" + elem.toString());
		message = elem;
	}

    /**
     * Set the to address of the message to be injected
     *
     * @param url
     *          String containing the to address
     */
    public void setTo(String url) {
		to = url;
	}

    public void setSoapAction(String soapAction) {
        this.soapAction = soapAction;
    }

    /**
     * This will be invoked by the schedular to inject the message
     * in to the SynapseEnvironment
     */
    public void execute() {
		log.debug(""execute"");
		if (synapseEnvironment == null) {
			log.error(""Synapse Environment not set"");
			return;
		}
		if (message == null) {
			log.error(""message not set"");
			return;

		}
		if (to == null) {
			log.error(""to address not set"");
			return;

		}
        MessageContext mc = synapseEnvironment.createMessageContext();
        mc.setTo(new EndpointReference(to));
        PayloadHelper.setXMLPayload(mc, message.cloneOMElement());
        if (soapAction != null) {
            mc.setSoapAction(soapAction);
        }
        synapseEnvironment.injectMessage(mc);

	}

    /**
     * Destroys the Injector
     */
    public void destroy() {
	}

}
"
org/apache/synapse/config/xml/RMSequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;

/**
 * <pre>
 * &lt;RMSequence (correlation=""xpath"" [last-message=""xpath""]) | single=""true"" [version=""1.0|1.1""]/&gt;
 * </pre>
 */
public class RMSequenceMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof RMSequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        RMSequenceMediator mediator = (RMSequenceMediator) m;
        OMElement sequence = fac.createOMElement(""RMSequence"", synNS);
        saveTracingState(sequence, mediator);
        
        if(mediator.isSingle() && mediator.getCorrelation() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a correlation attribute specified."");
        }
        if(mediator.isSingle() && mediator.getLastMessage() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a last-message attribute specified."");
        }
        
        if (mediator.isSingle()) {
            sequence.addAttribute(fac.createOMAttribute(""single"", nullNS, String.valueOf(mediator.isSingle())));
        } else if (mediator.getCorrelation() != null) {
            sequence.addAttribute(fac.createOMAttribute(""correlation"", nullNS, 
                    mediator.getCorrelation().toString()));
            super.serializeNamespaces(sequence, mediator.getCorrelation());
        } else {
            handleException(""Invalid RMSequence mediator. Specify a single message sequence "" 
                    + ""or a correlation attribute."");
        }
        
        if (mediator.getLastMessage() != null) {
            sequence.addAttribute(fac.createOMAttribute(
                ""last-message"", nullNS, mediator.getLastMessage().toString()));
            super.serializeNamespaces(sequence, mediator.getLastMessage());
        }
        
        if (mediator.getVersion() != null) {
            sequence.addAttribute(fac.createOMAttribute(""version"", nullNS, mediator.getVersion()));
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return RMSequenceMediator.class.getName();
    }
}
"
org/apache/synapse/config/SynapseConfigUtils.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;

public class SynapseConfigUtils {

    private static final Log log = LogFactory.getLog(SynapseConfigUtils.class);

    /**
     * Return a StreamSource for the given Object
     *
     * @param o the object
     * @return the StreamSource
     */
    public static StreamSource getStreamSource(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMNode) {
            OMNode omNode = (OMNode) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omNode.serialize(baos);
                return new StreamSource(new ByteArrayInputStream(baos.toByteArray()));
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else {
            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    public static InputStream getInputStream(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMElement) {
            OMElement omElement = (OMElement) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omElement.serialize(baos);
                return new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else if (o instanceof URI) {
            try {
                return ((URI) (o)).toURL().openStream();
            } catch (IOException e) {
                handleException(""Error opening stream form URI"", e);
            }
        } else {
            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    /**
     * Get an object from a given URL. Will first fetch the content from the
     * URL and depending on the content-type, a suitable XMLToObjectMapper
     * (if available) would be used to transform this content into an Object.
     * If a suitable XMLToObjectMapper cannot be found, the content would be
     * treated as XML and an OMNode would be returned
     *
     * @param url the URL to the resource
     * @return an Object created from the given URL
     */
    public static Object getObject(URL url) {
        try {
            if (url != null && ""file"".equals(url.getProtocol())) {
                try {
                    url.openStream();
                } catch (IOException ignored) {
                    String path = url.getPath();
                    if (log.isDebugEnabled()) {
                        log.debug(""Can not open a connection to the URL with a path :"" +
                                  path);
                    }
                    String synapseHome = System.getProperty(SynapseConstants.SYNAPSE_HOME);
                    if (synapseHome != null) {
                        if (log.isDebugEnabled()) {
                            log.debug(""Trying  to resolve an absolute path of the "" +
                                      "" URL using the synapse.home : "" + synapseHome);
                        }
                        if (synapseHome.endsWith(""/"")) {
                            synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
                        }
                        url = new URL(url.getProtocol() + "":"" + synapseHome + ""/"" + path);
                        try {
                            url.openStream();
                        } catch (IOException e) {
                            if (log.isDebugEnabled()) {
                                log.debug(""Faild to resolve an absolute path of the "" +
                                          "" URL using the synapse.home : "" + synapseHome);
                            }
                            log.warn(""IO Error reading from URL "" + url.getPath() + e);
                        }
                    }
                }
            }
            if (url == null) {
                return null;
            }
            URLConnection urlc = url.openConnection();
            XMLToObjectMapper xmlToObject =
                    getXmlToObjectMapper(urlc.getContentType());

            try {
                XMLStreamReader parser = XMLInputFactory.newInstance().
                        createXMLStreamReader(urlc.getInputStream());
                StAXOMBuilder builder = new StAXOMBuilder(parser);
                OMElement omElem = builder.getDocumentElement();

                // detach from URL connection and keep in memory
                // TODO remove this 
                omElem.build();

                if (xmlToObject != null) {
                    return xmlToObject.getObjectFromOMNode(omElem);
                } else {
                    return omElem;
                }

            } catch (XMLStreamException e) {
                log.warn(""Content at URL : "" + url + "" is non XML.."");
                return urlc.getContent();
            }

        } catch (IOException e) {
            handleException(""Error connecting to URL : "" + url, e);
        }
        return null;
    }

    /**
     * Return an OMElement from a URL source
     *
     * @param urlStr a URL string
     * @return an OMElement of the resource
     * @throws IOException for invalid URL's or IO errors
     */
    public static OMElement getOMElementFromURL(String urlStr) throws IOException {
        URL url = getURLFromPath(urlStr);
        if (url == null) {
            return null;
        }
        URLConnection conn = url.openConnection();
        conn.setReadTimeout(10000);
        conn.setConnectTimeout(2000);
        conn.setRequestProperty(""Connection"", ""close""); // if http is being used
        InputStream urlInStream = conn.getInputStream();

        if (urlInStream != null) {
            try {
                StAXOMBuilder builder = new StAXOMBuilder(urlInStream);
                OMElement doc = builder.getDocumentElement();
                doc.build();
                return doc;
            } catch (Exception e) {
                handleException(""Error parsing resource at URL : "" + url +
                                "" as XML"", e);
            } finally {
                try {
                    urlInStream.close();
                } catch (IOException ignore) {
                }
            }
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.warn(msg, e);
        throw new SynapseException(msg, e);
    }

    private static void handleException(String msg) {
        log.warn(msg);
        throw new SynapseException(msg);
    }

    /**
     * Return a suitable XMLToObjectMapper for the given content type if one
     * is available, else return null;
     *
     * @param contentType the content type for which a mapper is required
     * @return a suitable XMLToObjectMapper or null if none can be found
     */
    public static XMLToObjectMapper getXmlToObjectMapper(String contentType) {
        return null;
    }

    /**
     * Utility method to resolve url(only If need) path using synapse home system property
     *
     * @param path Path to the URL
     * @return Valid URL instance or null(if it is inavalid or can not open a connection to it )
     */
    public static URL getURLFromPath(String path) {
        if (path == null || ""null"".equals(path)) {
            if (log.isDebugEnabled()) {
                log.debug(""Can not create a URL from 'null' "");
            }
            return null;
        }
        URL url = null;
        try {
            url = new URL(path);
            if (""file"".equals(url.getProtocol())) {
                try {
                    url.openStream();
                } catch (MalformedURLException e) {
                    handleException(""Invalid URL reference : "" + path, e);
                } catch (IOException ignored) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Can not open a connection to the URL with a path :"" +
                                  path);
                    }
                    String synapseHome = System.getProperty(SynapseConstants.SYNAPSE_HOME);
                    if (synapseHome != null) {
                        if (synapseHome.endsWith(""/"")) {
                            synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
                        }
                        if (log.isDebugEnabled()) {
                            log.debug(""Trying  to resolve an absolute path of the "" +
                                      "" URL using the synapse.home : "" + synapseHome);
                        }
                        try {
                            url = new URL(url.getProtocol() + "":"" + synapseHome + ""/"" +
                                          url.getPath());
                            url.openStream();
                        } catch (MalformedURLException e) {
                            handleException(""Invalid URL reference "" + url.getPath() + e);
                        } catch (IOException e) {
                            if (log.isDebugEnabled()) {
                                log.debug(""Faild to resolve an absolute path of the "" +
                                          "" URL using the synapse.home : "" + synapseHome);
                            }
                            log.warn(""IO Error reading from URL : "" + url.getPath() + e);
                        }
                    }
                }
            }             
        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference :  "" + path, e);
        } catch (IOException e) {
            handleException(""IO Error reading from URL : "" + path, e);
        }
        return url;
    }
}
"
org/apache/synapse/config/xml/endpoints/IndirectEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Creates an IndirectEndpoint using a XML configuration. Key can be a name of an endpoint defined
 * in the same Synapse configuration or a registry key pointing to an endpoint configuration in the
 * registry (e.g. <endpoint key=""registry/endpoint1.xml"" />).
 *
 * <endpoint key=""key"" />
 */
public class IndirectEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(IndirectEndpointFactory.class);

    private static IndirectEndpointFactory instance = new IndirectEndpointFactory();

    private IndirectEndpointFactory() {}

    public static IndirectEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        IndirectEndpoint indirectEndpoint = new IndirectEndpoint();
        String ref = epConfig.getAttributeValue(new QName(""key""));
        indirectEndpoint.setKey(ref);
        return indirectEndpoint;
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
			return createEndpoint((OMElement) om, false);
		} else {
			handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
		}
		return null;
    }

     private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/SynapseConfiguration.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.config.xml.MediatorFactoryFinder;
import org.apache.synapse.config.xml.endpoints.XMLToEndpointMapper;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.registry.Registry;

import javax.xml.namespace.QName;
import java.io.IOException;
import java.util.*;

/**
 * The SynapseConfiguration holds the global configuration for a Synapse
 * instance.
 */
public class SynapseConfiguration implements ManagedLifecycle {

	private static final Log log = LogFactory.getLog(SynapseConfiguration.class);

	/**
	 * The remote registry made available to the Synapse configuration. Only one
	 * is supported
	 */
	Registry registry = null;

    /**
     * This holds the default QName of the configuraiton
     */
    private QName defaultQName = null;

	/**
     * Holds Proxy services defined through Synapse
     */
	private Map proxyServices = new HashMap();

    /**
     * This holds a Map of ManagedLifecycle objects
     */
    private Map startups = new HashMap();

    /**
	 * The local registry is a simple HashMap and provides the ability to
	 * override definitions of a remote registry for entries defined locally
	 * with the same key
	 */
	private Map localRegistry = new HashMap();

    /** Holds the synapse properties */
    private Properties properties = new Properties();

    /**
     * This will provide the timer deamon object for the sheduled tasks.
     */
    private Timer synapseTimer = new Timer(true);

    /** Hold reference to the Axis2 ConfigurationContext */
	private AxisConfiguration axisConfiguration = null;

	/**
	 * Save the path to the configuration file loaded, to save it later if
	 * required
	 */
	private String pathToConfigFile = null;

    /**
	 * Add a named sequence into the local registry
	 *
	 * @param key
	 *            the name for the sequence
	 * @param mediator
	 *            a Sequence mediator
	 */
	public void addSequence(String key, Mediator mediator) {
		localRegistry.put(key, mediator);
	}

	/**
	 * Allow a dynamic sequence to be cached and made available through the
	 * local registry
	 *
	 * @param key
	 *            the key to lookup the sequence from the remote registry
	 * @param entry
	 *            the Entry object which holds meta information and the cached
	 *            resource
	 */
	public void addSequence(String key, Entry entry) {
		localRegistry.put(key, entry);
	}

	/**
	 * Returns the map of defined sequences in the configuraiton excluding the
	 * fetched sequences from remote registry
	 *
	 * @return Map of SequenceMediators defined in the local configuraion
	 */
	public Map getDefinedSequences() {
		Map definedSequences = new HashMap();
		Iterator itr = localRegistry.values().iterator();
		while (itr.hasNext()) {
			Object o = itr.next();
			if (o instanceof SequenceMediator) {
				definedSequences.put(((SequenceMediator) o).getName(), o);
			}
		}
		return definedSequences;
	}

	/**
	 * Return the sequence specified with the given key
	 *
	 * @param key
	 *            the key being referenced
	 * @return the sequence referenced by the key
	 */
	public Mediator getSequence(String key) {
		Object o = localRegistry.get(key);
		if (o != null && o instanceof Mediator) {
			return (Mediator) o;
		}

		Entry entry = null;
		if (o != null && o instanceof Entry) {
			entry = (Entry) o;
		} else {
			entry = new Entry(key);
			entry.setType(Entry.REMOTE_ENTRY);
			entry.setMapper(MediatorFactoryFinder.getInstance());
		}

		if (registry != null) {
			o = registry.getResource(entry);
			if (o != null && o instanceof Mediator) {
				localRegistry.put(key, entry);
				return (Mediator) o;
			}
		}

		return null;
	}

	/**
	 * Removes a sequence from the local registry
	 *
	 * @param key
	 *            of the sequence to be removed
	 */
	public void removeSequence(String key) {
		localRegistry.remove(key);
	}

	/**
	 * Return the main/default sequence to be executed. This is the sequence
	 * which will execute for all messages when message mediation takes place
	 *
	 * @return the main mediator sequence
	 */
	public Mediator getMainSequence() {
		return getSequence(SynapseConstants.MAIN_SEQUENCE_KEY);
	}

	/**
	 * Return the fault sequence to be executed when Synapse encounters a fault
	 * scenario during processing
	 *
	 * @return the fault sequence
	 */
	public Mediator getFaultSequence() {
		return getSequence(SynapseConstants.FAULT_SEQUENCE_KEY);
	}

	/**
	 * Define a resource to the local registry. All static resources (e.g. URL
	 * source) are loaded during this definition phase, and the inability to
	 * load such a resource will not allow the definition of the resource to the
	 * local registry
	 *
	 * @param key
	 *            the key associated with the resource
	 * @param entry
	 *            the Entry that holds meta information about the resource and
	 *            its contents (or cached contents if the Entry refers to a
	 *            dynamic resource off a remote registry)
	 */
	public void addEntry(String key, Entry entry) {

		if (entry.getType() == Entry.URL_SRC) {
			try {
				entry.setValue(SynapseConfigUtils.getOMElementFromURL(entry.getSrc()
						.toString()));
				localRegistry.put(key, entry);
			} catch (IOException e) {
				handleException(""Can not read from source URL : ""
						+ entry.getSrc());
			}
		} else {
			localRegistry.put(key, entry);
		}
	}

    /**
     * Gives the set of remote entries that are cached in localRegistry as mapping of entry key
     * to the Entry definition
     * 
     * @return Map of locally cached entries
     */
    public Map getCachedEntries() {
        Map cachedEntries = new HashMap();
        for (Iterator itr = localRegistry.values().iterator(); itr.hasNext();) {
            Object o = itr.next();
            if (o != null && o instanceof Entry) {
                Entry entry = (Entry) o;
                if (entry.isDynamic() && entry.isCached()) {
                    cachedEntries.put(entry.getKey(), entry);
                }
            }
        }

        return cachedEntries;
    }

    /**
	 * Returns the map of defined entries in the configuraiton excluding the
	 * fetched entries from remote registry
	 *
	 * @return Map of Entries defined in the local configuraion
	 */
	public Map getDefinedEntries() {
		Map definedEntries = new HashMap();
		Iterator itr = localRegistry.values().iterator();
		while (itr.hasNext()) {
			Object o = itr.next();
			if (o instanceof Entry
					&& ((Entry) o).getType() != Entry.REMOTE_ENTRY) {
				definedEntries.put(((Entry) o).getKey(), o);
			}
		}
		return definedEntries;
	}

	/**
	 * Get the resource with the given key
	 *
	 * @param key
	 *            the key of the resource required
	 * @return its value
	 */
	public Object getEntry(String key) {
		Object o = localRegistry.get(key);
		if (o != null && o instanceof Entry) {
			Entry entry = (Entry) o;
			if (entry.isDynamic()) {
                if (entry.isCached() && !entry.isExpired()) {
                    return entry.getValue();
                } else if (registry != null) {
                    o = registry.getResource(entry);
                } else {
                    if (log.isDebugEnabled()) {
                        log.debug(""Will not  evaluate the value of the remote entry with a key ""
                            + key + "",  because the registry is not available"");
                    }
                    return null; // otherwise will return an entry with a value null
                    // (method expects return  a value not an entry )
                }
			} else {
				return entry.getValue();
			}
		}
		return o;
	}

	/**
	 * Get the Entry object mapped to the given key
	 *
	 * @param key
	 *            the key for which the Entry is required
	 * @return its value
	 */
	public Entry getEntryDefinition(String key) {
		Object o = localRegistry.get(key);
		if (o == null || o instanceof Entry) {
			if (o == null) {
				// this is not a local definition
				Entry entry = new Entry(key);
				entry.setType(Entry.REMOTE_ENTRY);
				addEntry(key, entry);
				return entry;
			}
			return (Entry) o;
		} else {
			handleException(""Invalid local registry entry : "" + key);
			return null;
		}
	}

	/**
	 * Deletes any reference mapped to the given key from the local registry
	 *
	 * @param key
	 *            the key of the reference to be removed
	 */
	public void removeEntry(String key) {
		localRegistry.remove(key);
	}

    /**
     * Clears the cache of the remote entry with the key specified
     * 
     * @param key - String key of the entry
     */
    public void clearCachedEntry(String key) {
        Entry entry = getEntryDefinition(key);
        if (entry.isDynamic() && entry.isCached()) {
            entry.clearCache();
        }
    }

    /**
     * Clears the cache of all the remote entries which has been
     * cached in the configuration
     */
    public void clearCache() {
        for (Iterator itr = localRegistry.values().iterator(); itr.hasNext();) {
            Object o = itr.next();
            if (o != null && o instanceof Entry) {
                Entry entry = (Entry) o;
                if (entry.isDynamic() && entry.isCached()) {
                    entry.clearCache();
                }
            }
        }
    }

    /**
	 * Define a named endpoint with the given key
	 *
	 * @param key
	 *            the key for the endpoint
	 * @param endpoint
	 *            the endpoint definition
	 */
	public void addEndpoint(String key, Endpoint endpoint) {
		localRegistry.put(key, endpoint);
	}

	/**
	 * Add a dynamic endpoint definition to the local registry
	 *
	 * @param key
	 *            the key for the endpoint definition
	 * @param entry
	 *            the actual endpoint definition to be added
	 */
	public void addEndpoint(String key, Entry entry) {
		localRegistry.put(key, entry);
	}

	/**
	 * Returns the map of defined endpoints in the configuraiton excluding the
	 * fetched endpoints from remote registry
	 *
	 * @return Map of Endpoints defined in the local configuraion
	 */
	public Map getDefinedEndpoints() {
		Map definedEndpoints = new HashMap();
		Iterator itr = localRegistry.values().iterator();
		while (itr.hasNext()) {
			Object o = itr.next();
			if (o instanceof Endpoint) {
				definedEndpoints.put(((Endpoint) o).getName(), o);
			}
		}
		return definedEndpoints;
	}

	/**
	 * Get the definition of the endpoint with the given key
	 *
	 * @param key
	 *            the key of the endpoint
	 * @return the endpoint definition
	 */
	public Endpoint getEndpoint(String key) {
		Object o = localRegistry.get(key);
		if (o != null && o instanceof Endpoint) {
			return (Endpoint) o;
		}

		Entry entry = null;
		if (o != null && o instanceof Entry) {
			entry = (Entry) o;
		} else {
			entry = new Entry(key);
			entry.setType(Entry.REMOTE_ENTRY);
			entry.setMapper(XMLToEndpointMapper.getInstance());
		}

		if (registry != null) {
			o = registry.getResource(entry);
			if (o != null && o instanceof Endpoint) {
				localRegistry.put(key, entry);
				return (Endpoint) o;
			}
		}

		return null;
	}

	/**
	 * Deletes the endpoint with the given key
	 *
	 * @param key
	 *            of the endpoint to be deleted
	 */
	public void removeEndpoint(String key) {
		localRegistry.remove(key);
	}

	/**
	 * Add a Proxy service to the configuration
	 *
	 * @param name
	 *            the name of the Proxy service
	 * @param proxy
	 *            the Proxy service instance
	 */
	public void addProxyService(String name, ProxyService proxy) {
		proxyServices.put(name, proxy);
	}

	/**
	 * Get the Proxy service with the given name
	 *
	 * @param name
	 *            the name being looked up
	 * @return the Proxy service
	 */
	public ProxyService getProxyService(String name) {
		return (ProxyService) proxyServices.get(name);
	}

	/**
	 * Deletes the Proxy Service named with the given name
	 *
	 * @param name
	 *            of the Proxy Service to be deleted
	 */
	public void removeProxyService(String name) {
		Object o = proxyServices.get(name);
		if (o == null) {
			handleException(""Unknown proxy service for name : "" + name);
		} else {
			try {
				if (getAxisConfiguration().getServiceForActivation(name) != null) {
					if (getAxisConfiguration().getServiceForActivation(name)
							.isActive()) {
						getAxisConfiguration().getService(name)
								.setActive(false);
					}
					getAxisConfiguration().removeService(name);
				}
				proxyServices.remove(name);
			} catch (AxisFault axisFault) {
				handleException(axisFault.getMessage());
			}
		}
	}

	/**
	 * Return the list of defined proxy services
	 *
	 * @return the proxy services defined
	 */
	public Collection getProxyServices() {
		return proxyServices.values();
	}

	/**
	 * Return an unmodifiable copy of the local registry
	 *
	 * @return an unmodifiable copy of the local registry
	 */
	public Map getLocalRegistry() {
		return Collections.unmodifiableMap(localRegistry);
	}

	/**
	 * Get the remote registry defined (if any)
	 *
	 * @return the currently defined remote registry
	 */
	public Registry getRegistry() {
		return registry;
	}

	/**
	 * Set the remote registry for the configuration
	 *
	 * @param registry
	 *            the remote registry for the configuration
	 */
	public void setRegistry(Registry registry) {
		this.registry = registry;
	}

	/**
	 * Set the Axis2 AxisConfiguration to the SynapseConfiguration
	 *
	 * @param axisConfig
	 */
	public void setAxisConfiguration(AxisConfiguration axisConfig) {
		this.axisConfiguration = axisConfig;
	}

	/**
	 * Get the Axis2 AxisConfiguration for the SynapseConfiguration
	 *
	 * @return AxisConfiguration of the Axis2
	 */
	public AxisConfiguration getAxisConfiguration() {
		return axisConfiguration;
	}

	/**
	 * The path to the currently loaded configuration file
	 *
	 * @return file path to synapse.xml
	 */
	public String getPathToConfigFile() {
		return pathToConfigFile;
	}

	/**
	 * Set the path to the loaded synapse.xml
	 *
	 * @param pathToConfigFile
	 *            path to the synapse.xml loaded
	 */
	public void setPathToConfigFile(String pathToConfigFile) {
		this.pathToConfigFile = pathToConfigFile;
	}

    /**
     * Set the default QName of the Synapse Configuration
     * 
     * @param defaultQName
     *          QName specifying the default QName of the configuration
     */
    public void setDefaultQName(QName defaultQName) {
		this.defaultQName = defaultQName;
	}

    /**
     * Get the default QName of the configuraiton
     * 
     * @return default QName of the configuration
     */
    public QName getDefaultQName() {
		return defaultQName;
	}

    /**
     * Get the timer object for the Synapse Configuration
     *
     * @return synapseTimer timer object of the configuration
     */
    public Timer getSynapseTimer() {
        return synapseTimer;
    }

    /**
     * Get the startup collection in the configuration
     *
     * @return collection of startup objects registered
     */
    public Collection getStartups() {
        return startups.values();
    }

    /**
     * Get the Startup with the specified name
     * 
     * @param id - String name of the startup to be retrieved
     * @return Startup object with the specified name or null
     */
    public Startup getStartup(String id) {
        return (Startup) startups.get(id);
    }

    /**
     * Add a startup to the startups map in the configuration
     *
     * @param startup - Startup object to be added 
     */
    public void addStartup(Startup startup) {
        startups.put(startup.getName(), startup);
    }

    /**
     * Removes the startup specified by the name
     * 
     * @param name - name of the startup that needs to be removed
     */
    public void removeStartup(String name) {
        startups.remove(name);
    }

    /**
     * Gets the properties to configure the synapse enviorenment
     * 
     * @return set of properties as Properties
     */
    public Properties getProperties() {
        return properties;
    }

    /**
     * Sets the properties to configure the synapse enviorenment
     *
     * @param properties - Properties which needs to be set
     */
    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    /**
     * Gets the String representation of the property value if there is a property for the
     * given propKey or returns the default value passed
     * 
     * @param propKey - key for the property lookup
     * @param def     - default value
     * @return String representation of the property value with the given key or the def value
     */
    public String getProperty(String propKey, String def) {
        String val = System.getProperty(propKey);
        if (val == null) {
            val = properties.getProperty(propKey);
        }

        if (val != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Using synapse tuning parameter : "" + propKey + "" = "" + val);
            }
            return val;
        }
        return def;
    }

    /**
     * Gets the propety value if the property specified by the propKey is there or null else
     *
     * @param propKey - key for the property lookup
     * @return String representation of the property value if found or null else
     */
    public String getProperty(String propKey) {
        String val = System.getProperty(propKey);
        if (val == null) {
            val = properties.getProperty(propKey);
        }

        if (val != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Using synapse tuning parameter : "" + propKey + "" = "" + val);
            }
            return val;
        }
        return null;
    }

    /**
     * This method will be called on the soft shutdown or destroying the configuration
     * and will destroy all the statefull managed parts of the configuration
     */
    public void destroy() {
        
        if (log.isDebugEnabled()) {
            log.debug(""Destroying the Synapse Configuration"");
        }

        // clear the timer tasks of Synapse
        synapseTimer.cancel();
        synapseTimer = null;

        // stop and shutdown all the proxy services
        for (Iterator it = getProxyServices().iterator(); it.hasNext();) {
            Object o = it.next();
            if (o instanceof ProxyService) {
                ProxyService p = (ProxyService) o;
                if (p.getTargetInLineInSequence() != null) {
                    p.getTargetInLineInSequence().destroy();
                }
                if (p.getTargetInLineOutSequence() != null) {
                    p.getTargetInLineOutSequence().destroy();
                }
            }
        }

        // destroy the managed mediators
        Map sequences = getDefinedSequences();
        for (Iterator it = sequences.entrySet().iterator(); it.hasNext();) {
            Object o = it.next();
            if (o instanceof ManagedLifecycle) {
                ManagedLifecycle m = (ManagedLifecycle) o;
                m.destroy();
            }
        }

        // destroy the startups
        if (startups != null) {
            for (Iterator it = startups.values().iterator(); it.hasNext();) {
                Object o = it.next();
                if (o instanceof ManagedLifecycle) {
                    ManagedLifecycle m = (ManagedLifecycle) o;
                    m.destroy();
                }
            }
        }
    }

    /**
     * This method will be called in the startup of Synapse or in an initiation
     * and will initialize all the managed parts of the Synapse Configuration
     *
     * @param se
     *          SynapseEnvironment specifying the env to be initialized
     */
    public void init(SynapseEnvironment se) {
        
        if (log.isDebugEnabled()) {
            log.debug(""Initializing the Synapse Configuration"");
        }

        // initialize all the proxy services
        for (Iterator it = getProxyServices().iterator(); it.hasNext();) {
            Object o = it.next();
            if (o instanceof ProxyService) {
                ProxyService p = (ProxyService) o;
                if (p.getTargetInLineInSequence() != null) {
                    p.getTargetInLineInSequence().init(se);
                }
                if (p.getTargetInLineOutSequence() != null) {
                    p.getTargetInLineOutSequence().init(se);
                }
            }
        }

        // initialize managed mediators
        Map sequences = getDefinedSequences();
        for (Iterator it = sequences.values().iterator(); it.hasNext();) {
            Object o = it.next();
            if (o instanceof ManagedLifecycle) {
                ManagedLifecycle m = (ManagedLifecycle) o;
                m.init(se);
            }
        }
    }

    private void handleException(String msg) {
		log.error(msg);
		throw new SynapseException(msg);
	}
}
"
org/apache/synapse/config/xml/InMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

import javax.xml.namespace.QName;

/**
 * Creates an In mediator instance
 *
 * <pre>
 * &lt;in&gt;
 *    mediator+
 * &lt;/in&gt;
 * </pre>
 */
public class InMediatorFactory extends AbstractListMediatorFactory {

    private static final QName IN_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""in"");

    public Mediator createMediator(OMElement elem) {
        InMediator filter = new InMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);
        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return IN_Q;
    }
}
"
org/apache/synapse/config/xml/AbstractListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ListMediator;
import org.apache.synapse.Mediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * This implements the basic logic to build a list mediator from a given XML
 * configuration. It recursively builds the child mediators of the list.
 */
public abstract class AbstractListMediatorFactory extends AbstractMediatorFactory {

    protected static void addChildren(OMElement el, ListMediator m) {
        Iterator it = el.getChildElements();
        while (it.hasNext()) {
            OMElement child = (OMElement) it.next();
            Mediator med = MediatorFactoryFinder.getInstance().getMediator(child);
            if (med != null) {
                m.addChild(med);
            } else {
                String msg = ""Unknown mediator : "" + child.getLocalName();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }
}
"
org/apache/synapse/mediators/db/DBReportMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.synapse.MessageContext;

import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * A mediator that writes (i.e. inserts one row) to a table using message information
 */
public class DBReportMediator extends AbstractDBMediator {

    protected void processStatement(Statement stmnt, MessageContext msgCtx) {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        try {
            PreparedStatement ps = getPreparedStatement(stmnt, msgCtx);
            int count = ps.executeUpdate();

            if (count > 0) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Inserted "" + count + "" row/s using statement : "" + stmnt.getRawStatement());
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""No rows were inserted for statement : "" + stmnt.getRawStatement());
                }
            }
        } catch (SQLException e) {
            handleException(""Error execuring insert statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName(), e, msgCtx);
        }
    }
}
"
org/apache/synapse/config/xml/XSLTMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.config.xml.OMElementUtils;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.config.xml.AbstractMediatorFactory;
import org.apache.synapse.config.xml.MediatorPropertyFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates a XSLT mediator from the given XML
 *
 * <pre>
 * &lt;xslt key=""property-key"" [source=""xpath""]&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/transform&gt;
 * </pre>
 */
public class XSLTMediatorFactory extends AbstractMediatorFactory {

    private static final QName TAG_NAME    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""xslt"");

    public QName getTagQName() {
        return TAG_NAME;
    }

    public Mediator createMediator(OMElement elem) {

        XSLTMediator transformMediator = new XSLTMediator();

        OMAttribute attXslt   = elem.getAttribute(ATT_KEY);
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);

        if (attXslt != null) {
            transformMediator.setXsltKey(attXslt.getAttributeValue());
        } else {
            handleException(""The 'key' attribute is required for the XSLT mediator"");
        }

        if (attSource != null) {
            try {
                transformMediator.setSourceXPathString(attSource.getAttributeValue());
                AXIOMXPath xp = new AXIOMXPath(attSource.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                transformMediator.setSource(xp);

            } catch (JaxenException e) {
                handleException(""Invalid XPath specified for the source attribute : "" +
                    attSource.getAttributeValue());
            }
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(transformMediator, elem);
        // set the features 
        Iterator iter = elem.getChildrenWithName(FEATURE_Q);
        while (iter.hasNext()) {
            OMElement featureElem = (OMElement) iter.next();
            OMAttribute attName = featureElem.getAttribute(ATT_NAME);
            OMAttribute attValue = featureElem.getAttribute(ATT_VALUE);
            if (attName != null && attValue != null) {
                String name = attName.getAttributeValue();
                String value = attValue.getAttributeValue();
                if (name != null && value != null) {
                    if (""true"".equals(value.trim())) {
                        transformMediator.addFeature(name.trim(),
                                true);
                    } else if (""false"".equals(value.trim())) {
                        transformMediator.addFeature(name.trim(),
                                false);
                    } else {
                        handleException(""The feature must have value true or false"");
                    }
                } else {
                    handleException(""The valid values for both of the name and value are need"");
                }
            } else {
                handleException(""Both of the name and value attribute are required for a feature"");
            }
        }
        transformMediator.addAllProperties(
            MediatorPropertyFactory.getMediatorProperties(elem));

        return transformMediator;
    }
}
"
org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;

import java.util.HashMap;
import java.util.Map;
import java.util.Collections;

/**
 * Dispatches sessions based on HTTP cookies. Session is initiated by the server in the first response
 * when it sends ""Set-Cookie"" HTTP header with the session ID. For all successive messages client
 * should send ""Cookie"" HTTP header with session ID send by the server.
 */
public class HttpSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    Map sessionMap = Collections.synchronizedMap(new HashMap());

    /**
     * Check if ""Cookie"" HTTP header is available. If so, check if that cookie is in the session map.
     * If cookie is available, there is a session for this cookie. return the (server) endpoint for
     * that session.
     *
     * @param synCtx MessageContext possibly containing a ""Cookie"" HTTP header.
     *
     * @return Endpoint Server endpoint for the given HTTP session.
     */
    public Endpoint getEndpoint(MessageContext synCtx) {

        Endpoint endpoint = null;

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Cookie"");

            if (cookie != null) {
                Object e = sessionMap.get(cookie);
                if (e != null) {
                    endpoint = (Endpoint) e;
                }
            }
        }

        return endpoint;
    }

    /**
     * Searches for ""Set-Cookie"" HTTP header in the message context. If found and that given
     * session ID is not already in the session map update the session map by mapping the cookie
     * to the endpoint.
     *
     * @param synCtx MessageContext possibly containing the ""Set-Cookie"" HTTP header.
     * @param endpoint Endpoint to be mapped to the session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint) {

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Set-Cookie"");

            if (cookie != null) {
                // synchronized to avoid possible replacement of sessions
                synchronized(sessionMap) {
                    if (!sessionMap.containsKey(cookie)) {
                        sessionMap.put(cookie, endpoint);
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(""TRANSPORT_HEADERS"");
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(""Cookie"");

            if (cookie != null) {
                sessionMap.remove(cookie);
            }
        }
    }

    /**
     * HTTP sessions are initiated by the server.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/config/xml/RegistrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import java.util.Iterator;

/**
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistrySerializer {

    private static final Log log = LogFactory.getLog(RegistrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    public static OMElement serializeRegistry(OMElement parent, Registry registry) {

        OMElement reg = fac.createOMElement(""registry"", synNS);

        if (registry.getProviderClass() != null) {
            reg.addAttribute(fac.createOMAttribute(
                ""provider"", nullNS, registry.getProviderClass()));
        } else {
            handleException(""Invalid registry. Provider is required"");
        }

        Iterator iter = registry.getConfigProperties().keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            String value = (String) registry.getConfigProperties().get(name);
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, name));
            property.setText(value.trim());
            reg.addChild(property);
        }

        if (parent != null) {
            parent.addChild(reg);
        }
        return reg;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.List;

public class SALoadbalanceEndpointSerializer implements EndpointSerializer {

    private static final Log log = LogFactory.getLog(SALoadbalanceEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof SALoadbalanceEndpoint)) {
            handleException(""Invalid endpoint type for serializing. "" +
                    ""Expected: SALoadbalanceEndpoint Found: "" + endpoint.getClass().getName());
        }

        SALoadbalanceEndpoint loadbalanceEndpoint = (SALoadbalanceEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        Dispatcher dispatcher = loadbalanceEndpoint.getDispatcher();

        if (dispatcher instanceof SoapSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""soap"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof HttpSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""http"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof SimpleClientSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""simpleClientSession"", null);
            endpointElement.addChild(sessionElement);
        }

        OMElement loadbalanceElement = fac.createOMElement(""loadbalance"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute(""algorithm"", algorithmName, null);

        List endpoints = loadbalanceEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            loadbalanceElement.addChild(aeElement);
        }

        return endpointElement;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.endpoints.Endpoint;

/**
 * All endpoint serializers should implement this interface. Use EndpointAbstractSerializer to obtain
 * the correct EndpointSerializer implementation for a particular endpoint. EndpointSerializer implementation
 * may call other EndpointSerializer implementations to serialize nested endpoints.
 */
public interface EndpointSerializer {

    /**
     * Serializes the given endpoint implementation to an XML object.
     *
     * @param endpoint Endpoint implementation to be serialized.
     * @return OMElement containing XML configuration.
     */
    public OMElement serializeEndpoint(Endpoint endpoint);
}
"
org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.util.Iterator;

public class SynapseXMLConfigurationFactory implements ConfigurationFactory {
    
    private static Log log = LogFactory.getLog(SynapseXMLConfigurationFactory.class);

    public SynapseConfiguration getConfiguration(OMElement definitions) {
        
        if (!definitions.getQName().equals(XMLConfigConstants.DEFINITIONS_ELT)) {
            throw new SynapseException(
                    ""Wrong QName for this config factory "" + definitions.getQName());
        }

        SynapseConfiguration config = new SynapseConfiguration();
        config.setDefaultQName(definitions.getQName());

        SequenceMediator rootSequence = new SequenceMediator();
        rootSequence.setName(org.apache.synapse.SynapseConstants.MAIN_SEQUENCE_KEY);

        Iterator iter = definitions.getChildren();
        
        while (iter.hasNext()) {
            Object o = iter.next();
            if (o instanceof OMElement) {
                OMElement elt = (OMElement) o;
                if (XMLConfigConstants.SEQUENCE_ELT.equals(elt.getQName())) {
                    String key = elt.getAttributeValue(
                            new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
                    // this could be a sequence def or a mediator of the main sequence
                    if (key != null) {
                        Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                        rootSequence.addChild(m);
                    } else {
                        defineSequence(config, elt);
                    }
                } else if (XMLConfigConstants.ENDPOINT_ELT.equals(elt.getQName())) {
                    defineEndpoint(config, elt);
                } else if (XMLConfigConstants.ENTRY_ELT.equals(elt.getQName())) {
                    defineEntry(config, elt);
                } else if (XMLConfigConstants.PROXY_ELT.equals(elt.getQName())) {
                    defineProxy(config, elt);
                } else if (XMLConfigConstants.REGISTRY_ELT.equals(elt.getQName())) {
                    defineRegistry(config, elt);
                } else if (XMLConfigConstants.TASK_ELT.equals(elt.getQName())) {
                    defineStartup(config, elt);
                } else {
                    Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                    rootSequence.addChild(m);
                }
            }
        }

        if (config.getLocalRegistry().isEmpty() && config.getProxyServices().isEmpty() &&
                rootSequence.getList().isEmpty() && config.getRegistry() != null) {
            OMNode remoteConfigNode = config.getRegistry().lookup(""synapse.xml"");
            try {
                config = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils
                    .getStreamSource(remoteConfigNode).getInputStream());
            } catch (XMLStreamException xse) {
                throw new SynapseException(""Problem loading remote synapse.xml "", xse);
            }

        }

        // if there is no sequence named main defined locally look for the set of mediators in
        // the root level before trying to look in the registry (hence config.getMainSequence
        // can not be used here)
        if (!config.getLocalRegistry().containsKey(SynapseConstants.MAIN_SEQUENCE_KEY)) {
            // if the root tag does not contain any mediators & registry does not have a
            // entry with key main then use the defualt main sequence
            if (rootSequence.getList().isEmpty() && config.getMainSequence() == null) {
                setDefaultMainSequence(config);
            } else {
                config.addSequence(rootSequence.getName(), rootSequence);
            }
        } else if (!rootSequence.getList().isEmpty()) {
            handleException(""Invalid Synapse Configuration : Conflict in resolving the \""main\"" "" +
                    ""mediator\n\tSynapse Configuration cannot have sequence named \""main\"" and "" +
                    ""toplevel mediators simultaniously"");
        }

        if (config.getFaultSequence() == null) {
            setDefaultFaultSequence(config);
        }

        return config;
    }

    private static void defineRegistry(SynapseConfiguration config, OMElement elem) {
        if (config.getRegistry() != null) {
            handleException(""Only one remote registry can be defined within a configuration"");
        }
        config.setRegistry(RegistryFactory.createRegistry(elem));
    }

    private static void defineStartup(SynapseConfiguration config, OMElement elem) {
        Startup startup = StartupFinder.getInstance().getStartup(elem);
        if (config.getStartup(startup.getName()) != null) {
            handleException(""Duplicate startup with name : "" + startup.getName());
        }
        config.addStartup(startup);
    }

    private static void defineProxy(SynapseConfiguration config, OMElement elem) {
        ProxyService proxy = ProxyServiceFactory.createProxy(elem);
        if (config.getProxyService(proxy.getName()) != null) {
            handleException(""Duplicate proxy service with name : "" + proxy.getName());
        }
        config.addProxyService(proxy.getName(), proxy);
    }

    private static void defineEntry(SynapseConfiguration config, OMElement elem) {
        Entry entry = EntryFactory.createEntry(elem);
        if (config.getLocalRegistry().get(entry.getKey()) != null) {
            handleException(""Duplicate registry entry definition for key : "" + entry.getKey());
        }
        config.addEntry(entry.getKey(), entry);
    }

    public static void defineSequence(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name) != null) {
                handleException(""Duplicate sequence definition : "" + name);
            }
            config.addSequence(name, MediatorFactoryFinder.getInstance().getMediator(ele));
        } else {
            handleException(""Invalid sequence definition without a name"");
        }
    }

    public static void defineEndpoint(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name.trim()) != null) {
                handleException(""Duplicate endpoint definition : "" + name);
            }
            Endpoint endpoint =
                    EndpointAbstractFactory.getEndpointFactroy(ele).createEndpoint(ele, false);
            config.addEndpoint(name.trim(), endpoint);
        } else {
            handleException(""Invalid endpoint definition without a name"");
        }
    }

    /**
     * Return the main sequence if one is not defined. This implementation defaults to
     * a simple sequence with a <send/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultMainSequence(SynapseConfiguration config) {
        SequenceMediator main = new SequenceMediator();
        main.setName(SynapseConstants.MAIN_SEQUENCE_KEY);
        main.addChild(new LogMediator());
        main.addChild(new DropMediator());
        config.addSequence(SynapseConstants.MAIN_SEQUENCE_KEY, main);
    }

    /**
     * Return the fault sequence if one is not defined. This implementation defaults to
     * a simple sequence with a <log level=""full""/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultFaultSequence(SynapseConfiguration config) {
        SequenceMediator fault = new SequenceMediator();
        fault.setName(org.apache.synapse.SynapseConstants.FAULT_SEQUENCE_KEY);
        LogMediator log = new LogMediator();
        log.setLogLevel(LogMediator.FULL);
        fault.addChild(log);
        config.addSequence(org.apache.synapse.SynapseConstants.FAULT_SEQUENCE_KEY, fault);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }


    public QName getTagQName() {

        return XMLConfigConstants.DEFINITIONS_ELT;
    }

    public Class getSerializerClass() {
        return SynapseXMLConfigurationSerializer.class;
    }

}
"
org/apache/synapse/config/xml/endpoints/EndpointAbstractSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.*;
import org.apache.synapse.SynapseException;

/**
 * Abstract serialier for endpoint serializers. Use this class to obtain the EndpointSerializer
 * implementation for particular endpoint type.
 */
public class EndpointAbstractSerializer {

    /**
     * Returns the EndpointSerializer implementation for the given endpoint. Throws a SynapseException,
     * if there is no serializer for the given endpoint type.
     *
     * @param endpoint Endpoint implementaion.
     * @return EndpointSerializer implementation.
     */
    public static EndpointSerializer getEndpointSerializer(Endpoint endpoint) {

        if (endpoint instanceof AddressEndpoint) {
            return new AddressEndpointSerializer();
        } else if (endpoint instanceof WSDLEndpoint) {
            return new WSDLEndpointSerializer();
        } else if (endpoint instanceof IndirectEndpoint) {
            return new IndirectEndpointSerializer();
        } else if (endpoint instanceof LoadbalanceEndpoint) {
            return new LoadbalanceEndpointSerializer();
        } else if (endpoint instanceof SALoadbalanceEndpoint) {
            return new SALoadbalanceEndpointSerializer();
        } else if (endpoint instanceof FailoverEndpoint) {
            return new FailoverEndpointSerializer();
        }

        throw new SynapseException(""Serializer for endpoint "" +
                endpoint.getClass().toString() + "" is not defined."");
    }
}
"
org/apache/synapse/config/xml/SynapseMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SynapseMediator;

/**
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SynapseMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SynapseMediator mediator = (SynapseMediator) m;
        OMElement rules = fac.createOMElement(""rules"", synNS);
        saveTracingState(rules,mediator);

        serializeChildren(rules, mediator.getList());

        if (parent != null) {
            parent.addChild(rules);
        }
        return rules;
    }

    public String getMediatorClassName() {
        return SynapseMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/endpoints/XMLToEndpointMapper.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;

/**
 * This is a generic XMLToObjectMapper implementation for all endpoint types. Use this if the endpoint
 * type is not known at the time mapper is created. If the endpoint type is known use the EndpointFactory
 * implementation for that specific endpoint.
 */
public class XMLToEndpointMapper implements XMLToObjectMapper {

    private static XMLToEndpointMapper instance = new XMLToEndpointMapper();

    private XMLToEndpointMapper() {}

    public static XMLToEndpointMapper getInstance() {
        return instance;
    }

    /**
     * Constructs the Endpoint implementation for the given OMNode.
     *
     * @param om OMNode containig endpoint configuration. This should be an OMElement.
     * @return Endpoint implementaiotn for the given OMNode.
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            OMElement epElement = (OMElement) om;
            return EndpointAbstractFactory.
                    getEndpointFactroy(epElement).createEndpoint(epElement, false);
        } else {
            throw new SynapseException(""Configuration is not in proper format."");
        }
    }
}
"
org/apache/synapse/mediators/base/SequenceMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;

import java.util.Stack;

/**
 * The Sequence mediator either refers to a named Sequence mediator instance
 * or is a *Named* list/sequence of other (child) Mediators
 * <p/>
 * If this instance defines a sequence mediator, then the name is required, and
 * an errorHandler sequence name optional. If this instance refers to another (defined)
 * sequence mediator, the errorHandler will not have a meaning, and if an error in
 * encountered in the reffered sequence, its errorHandler would execute.
 */
public class SequenceMediator extends AbstractListMediator {

    /** The name of the this sequence */
    private String name = null;
    /** The local registry key which is used to pick a sequence definition*/
    private String key = null;
    /** The name of the error handler which is used to handle error during the mediation */
    private String errorHandler = null;
    /** is this definition dynamic */
    private boolean dynamic = false;
    /** the registry key to load this definition if dynamic */
    private String registryKey = null;

    /** To decide to whether statistics should have collected or not  */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;

    /**
     * If this mediator refers to another named Sequence, execute that. Else
     * execute the list of mediators (children) contained within this. If a referenced
     * named sequence mediator instance cannot be found at runtime, an exception is
     * thrown. This may occur due to invalid configuration of an erroneous runtime
     * change of the synapse configuration. It is the responsibility of the
     * SynapseConfiguration builder to ensure that dead references are not present.
     *
     * @param synCtx the synapse message
     * @return as per standard mediator result
     */
    public boolean mediate(MessageContext synCtx) {

        boolean statsOn = SynapseConstants.STATISTICS_ON == statisticsState;
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Sequence <""
                + (name == null ? (key == null ? ""anonymous"" : key) : name) + "">"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (key == null) {

            // The onError sequence for handling errors which may occur during the
            // mediation through this sequence
            Mediator errorHandlerMediator = null;

            // Setting Required property to collect the sequence statistics
            if (statsOn) {
                StatisticsStack sequenceStack = (StatisticsStack)
                    synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
                if (sequenceStack == null) {
                    sequenceStack = new SequenceStatisticsStack();
                    synCtx.setProperty(SynapseConstants.SEQUENCE_STATS, sequenceStack);
                }
                String seqName = (name == null ? SynapseConstants.ANONYMOUS_SEQUENCE : name);
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                sequenceStack.put(seqName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statsOn, isFault);
            }
            try {

                // push the errorHandler sequence into the current message as the fault handler
                if (errorHandler != null) {
                    errorHandlerMediator = synCtx.getSequence(errorHandler);

                    if (errorHandlerMediator != null) {
                        if (traceOrDebugOn) {
                            traceOrDebug(traceOn, ""Setting the onError handler : "" +
                                errorHandler + "" for the sequence : "" + name);
                        }
                        synCtx.pushFaultHandler(
                                new MediatorFaultHandler(errorHandlerMediator));
                    } else {
                        auditWarn(""onError handler : "" + errorHandler + "" for sequence : "" +
                            name + "" cannot be found"", synCtx);
                    }
                }

                boolean result = super.mediate(synCtx);

                // if we pushed an error handler, pop it from the fault stack
                // before we exit normally without an exception
                if (errorHandlerMediator != null) {
                    Stack faultStack = synCtx.getFaultStack();
                    if (faultStack != null && !faultStack.isEmpty()) {
                        Object o = faultStack.peek();

                        if (o instanceof MediatorFaultHandler &&
                            errorHandlerMediator.equals(
                                ((MediatorFaultHandler) o).getFaultMediator())) {
                            faultStack.pop();
                        }
                    }
                }

                if (traceOrDebugOn) {
                    if (traceOn && trace.isTraceEnabled()) {
                        trace.trace(""Message : "" + synCtx.getEnvelope());
                    }

                    traceOrDebug(traceOn,
                        ""End : Sequence <"" + (name == null ? ""anonymous"" : name) + "">"");
                }

                return result;

            } finally {

                //If this sequence is finished it's task normally
                if (statsOn) {
                    StatisticsUtils.processSequenceStatistics(synCtx);
                }
                //If this sequence is a IN or OUT sequence of a proxy service
                StatisticsUtils.processProxyServiceStatistics(synCtx);
            }

        } else {

            Mediator m = synCtx.getSequence(key);
            if (m == null) {
                handleException(""Sequence named "" + key + "" cannot be found"", synCtx);

            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Executing sequence named "" + key);
                }

                boolean result = m.mediate(synCtx);

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""End : Sequence <"" + key + "">"");
                }
                return result;
            }
        }

        return false;
    }

    /**
     * To get the name of the sequence
     * @return the name of the sequence
     */
    public String getName() {
        return name;
    }

    /**
     * setting the name of the sequence
     * @param name the name of the this sequence
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * To get the key which which is used to fick the sequence definition from the local registry
     * @return  return the key which is used to fick the sequence definition from the local registry
     */
    public String getKey() {
        return key;
    }

    /**
     * To set the local registry key in order to pick the sequence definition
     * @param key the local registry key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     *
     * @return  Returns the errorhandler sequence name
     */
    public String getErrorHandler() {
        return errorHandler;
    }

    /**
     *
     * @param errorHandler to used handle error will appear during the
     *        mediation through this sequence
     */
    public void setErrorHandler(String errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState  To indicate statistics collecting state
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    /**
     * Is this a dynamic sequence?
     * @return true if dynamic
     */
    public boolean isDynamic() {
        return dynamic;
    }

    /**
     * Mark this as a dynamic sequence
     * @param dynamic true if this is a dynamic sequence
     */
    public void setDynamic(boolean dynamic) {
        this.dynamic = dynamic;
    }

    /**
     * Return the registry key used to load this sequence dynamically
     * @return  registry key
     */
    public String getRegistryKey() {
        return registryKey;
    }

    /**
     * To get the registry key used to load this sequence dynamically
     * @param registryKey  returns the registry key which point to this sequence
     */
    public void setRegistryKey(String registryKey) {
        this.registryKey = registryKey;
    }
}
"
org/apache/synapse/config/xml/SwitchMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.filters.SwitchMediator;

import java.util.Iterator;

/**
 * <pre>
 * &lt;switch source=""xpath""&gt;
 *   &lt;case regex=""string""&gt;
 *     mediator+
 *   &lt;/case&gt;+
 *   &lt;default&gt;
 *     mediator+
 *   &lt;/default&gt;?
 * &lt;/switch&gt;
 * </pre>
 */
public class SwitchMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SwitchMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SwitchMediator mediator = (SwitchMediator) m;
        OMElement switchMed = fac.createOMElement(""switch"", synNS);
        saveTracingState(switchMed, mediator);

        if (mediator.getSource() != null) {
            switchMed.addAttribute(fac.createOMAttribute(
                    ""source"", nullNS, mediator.getSource().toString()));
            super.serializeNamespaces(switchMed, mediator.getSource());

        } else {
            handleException(""Invalid switch mediator. Source required"");
        }

        Iterator iter = mediator.getCases().iterator();
        while (iter.hasNext()) {
            OMElement caseElem = fac.createOMElement(""case"", synNS);
            SwitchCase aCase = ((SwitchCase) iter.next());
            if (aCase.getRegex() != null) {
                caseElem.addAttribute(fac.createOMAttribute(
                        ""regex"", nullNS, aCase.getRegex().pattern()));
            } else {
                handleException(""Invalid switch case. Regex required"");
            }
            AnonymousListMediator caseMediator = aCase.getCaseMediator();
            if (caseMediator != null) {
                new AnonymousListMediatorSerializer().serializeMediator(
                        caseElem, caseMediator);
                switchMed.addChild(caseElem);
            }
        }
        SwitchCase defaultCase = mediator.getDefaultCase();
        if (defaultCase != null) {
            OMElement caseDefaultElem = fac.createOMElement(""default"", synNS);
            AnonymousListMediator caseDefaultMediator = defaultCase.getCaseMediator();
            if (caseDefaultMediator != null) {
                new AnonymousListMediatorSerializer().serializeMediator(
                        caseDefaultElem, caseDefaultMediator);
                switchMed.addChild(caseDefaultElem);
            }
        }
        if (parent != null) {
            parent.addChild(switchMed);
        }
        return switchMed;
    }

    public String getMediatorClassName() {
        return SwitchMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/LogMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import javax.xml.namespace.QName;

/**
 * Created a Log mediator that logs messages using commons-logging.
 *
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorFactory extends AbstractMediatorFactory  {

    private static final QName LOG_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""log"");
    private static final String SIMPLE  = ""simple"";
    private static final String HEADERS = ""headers"";
    private static final String FULL    = ""full"";
    private static final String CUSTOM  = ""custom"";
    private static final QName ATT_LEVEL = new QName(""level"");
    private static final QName ATT_SEPERATOR = new QName(""separator"");

    public QName getTagQName() {
        return LOG_Q;
    }

    public Mediator createMediator(OMElement elem) {

        LogMediator logMediator = new LogMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(logMediator,elem);
        
        // Set the high level set of properties to be logged (i.e. log level)
        OMAttribute level = elem.getAttribute(ATT_LEVEL);
        if (level != null) {
            String levelstr = level.getAttributeValue();
            if (SIMPLE.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.SIMPLE);
            } else if (HEADERS.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.HEADERS);
            } else if (FULL.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.FULL);
            } else if (CUSTOM.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.CUSTOM);
            }
        }

        // check if a custom separator has been supplied, if so use it
        OMAttribute separator = elem.getAttribute(ATT_SEPERATOR);
        if (separator != null) {
            logMediator.setSeparator(separator.getAttributeValue());
        }

        logMediator.addAllProperties(MediatorPropertyFactory.getMediatorProperties(elem));

        return logMediator;
    }
}
"
org/apache/synapse/mediators/transform/FaultMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMDocument;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.*;
import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import javax.xml.namespace.QName;
import java.net.URI;
import java.util.Iterator;

/**
 * This transforms the current message instance into a SOAP Fault message. The
 * SOAP version for the fault message could be explicitly specified. Else if the
 * original message was SOAP 1.1 the fault will also be SOAP 1.1 else, SOAP 1.2
 *
 * This class exposes methods to set SOAP 1.1 and 1.2 fault elements and uses
 * these as required.
 *
 * Directs the fault messages' ""To"" EPR to the ""FaultTo"" or the ""ReplyTo"" or to
 * null of the original SOAP message
 */
public class FaultMediator extends AbstractMediator {

    public static final String WSA_ACTION = ""Action"";
    /** Make a SOAP 1.1 fault */
    public static final int SOAP11 = 1;
    /** Make a SOAP 1.2 fault */
    public static final int SOAP12 = 2;
    /** Holds the SOAP version to be used to make the fault, if specified */
    private int soapVersion;

    // -- fault elements --
    /** The fault code QName to be used */
    private QName faultCodeValue = null;
    /** An XPath expression that will give the fault code QName at runtime */
    private AXIOMXPath faultCodeExpr = null;
    /** The fault reason to be used */
    private String faultReasonValue = null;
    /** An XPath expression that will give the fault reason string at runtime */
    private AXIOMXPath faultReasonExpr = null;
    /** The fault node URI to be used */
    private URI faultNode = null;
    /** The fault role URI to be used - if applicable */
    private URI faultRole = null;
    /** The fault detail to be used */
    private String faultDetail = null;

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Fault mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        switch (soapVersion) {
            case SOAP11:
                return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
            case SOAP12:
                return makeSOAPFault(synCtx, SOAP12, traceOrDebugOn, traceOn);

            default : {
                // determine from current message's SOAP envelope namespace
                SOAPEnvelope envelop = synCtx.getEnvelope();
                if (envelop != null) {
                    if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                        envelop.getNamespace().getNamespaceURI())) {
                        soapVersion = SOAP12;
                        return makeSOAPFault(synCtx, SOAP12, traceOrDebugOn, traceOn);
                    } else {
                        soapVersion = SOAP11;
                        return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
                    }
                } else {
                    // default to SOAP 11
                    return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
                }
            }
        }
    }

    /**
     * Actual transformation of the current message into a fault message
     * @param synCtx the current message context
     * @param soapVersion SOAP version of the resulting fault desired
     * @param traceOrDebugOn is trace or debug logging on?
     * @param traceOn is tracing on?
     * @return true, always
     */
    private boolean makeSOAPFault(MessageContext synCtx, int soapVersion,
        boolean traceOrDebugOn, boolean traceOn) {

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Creating a SOAP "" + (soapVersion == SOAP11 ? ""1.1"" : ""1.2"") + "" fault"");
        }

        // get the correct SOAP factory to be used
        SOAPFactory factory = (
            soapVersion == SOAP11 ? OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory());

        // create the SOAP fault document and envelope
        OMDocument soapFaultDocument = factory.createOMDocument();
        SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();
        soapFaultDocument.addChild(faultEnvelope);

        // create the fault element  if it is need
        SOAPFault fault = faultEnvelope.getBody().getFault();
        if(fault == null){
            fault = factory.createSOAPFault();
        }

        // populate it
        setFaultCode(synCtx, factory, fault);
        setFaultResaon(synCtx, factory, fault);
        setFaultNode(factory, fault);
        setFaultRole(factory, fault);
        setFaultDetail(factory, fault);

        // set the all headers of original SOAP Envelope to the Fault Envelope
        if (synCtx.getEnvelope() != null) {
            SOAPHeader soapHeader = synCtx.getEnvelope().getHeader();
            if (soapHeader != null) {
                for (Iterator iter = soapHeader.examineAllHeaderBlocks(); iter.hasNext();) {
                    Object o = iter.next();
                    if (o instanceof SOAPHeaderBlock) {
                        SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                        faultEnvelope.getHeader().addChild(header);
                    } else if (o instanceof OMElement) {
                        faultEnvelope.getHeader().addChild((OMElement) o);
                    }
                }
            }
        }

        if (traceOrDebugOn) {
            String msg =
                ""Original SOAP Message : "" + synCtx.getEnvelope().toString() +
                ""Fault Message created : "" + faultEnvelope.toString();
            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(msg);
            }
            if (log.isTraceEnabled()) {
                log.trace(msg);
            }
        }

        // overwrite current message envelope with new fault envelope
        try {
            synCtx.setEnvelope(faultEnvelope);
        } catch (AxisFault af) {
            handleException(""Error replacing current SOAP envelope with the fault envelope"", af, synCtx);
        }

        if (synCtx.getFaultTo() != null) {
            synCtx.setTo(synCtx.getFaultTo());
        } else if (synCtx.getReplyTo() != null) {
            synCtx.setTo(synCtx.getReplyTo());
        } else {
            synCtx.setTo(null);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Fault mediator"");
        }
        
        return true;
    }

    private void setFaultCode(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {

        QName fault_code = null;

        if (faultCodeValue == null && faultCodeExpr == null) {
            handleException(""A valid fault code QName value or expression is required"", synCtx);
        } else if (faultCodeValue != null) {
            fault_code = faultCodeValue;
        } else {
            fault_code = QName.valueOf(Axis2MessageContext.getStringValue(faultCodeExpr, synCtx));
        }

        SOAPFaultCode code = factory.createSOAPFaultCode();
        switch(soapVersion){
            case SOAP11:
                code.setText(fault_code);
                break;
            case SOAP12:
                SOAPFaultValue value = factory.createSOAPFaultValue(code);
                value.setText(fault_code);
                break;
        }
        fault.setCode(code);
    }

    private void setFaultResaon(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {
        String reasonString = null;

        if (faultReasonValue == null && faultReasonExpr == null) {
            handleException(""A valid fault reason value or expression is required"", synCtx);
        } else if (faultReasonValue != null) {
            reasonString = faultReasonValue;
        } else {
            reasonString = Axis2MessageContext.getStringValue(faultReasonExpr, synCtx);
        }

        SOAPFaultReason reason = factory.createSOAPFaultReason();
        switch(soapVersion){
            case SOAP11:
                reason.setText(reasonString);
                break;
            case SOAP12:
                SOAPFaultText text = factory.createSOAPFaultText();
                text.setText(reasonString);
                reason.addSOAPText(text);
                break;
        }
        fault.setReason(reason);
    }

    private void setFaultNode(SOAPFactory factory, SOAPFault fault) {
        if (faultNode != null) {
            SOAPFaultNode soapfaultNode = factory.createSOAPFaultNode();
            soapfaultNode.setNodeValue(faultNode.toString());
            fault.setNode(soapfaultNode);
        }
    }

    private void setFaultRole(SOAPFactory factory, SOAPFault fault) {
        if (faultRole != null) {
            SOAPFaultRole soapFaultRole = factory.createSOAPFaultRole();
            soapFaultRole.setRoleValue(faultRole.toString());
            fault.setRole(soapFaultRole);
        }
    }

    private void setFaultDetail(SOAPFactory factory, SOAPFault fault) {
        if (faultDetail != null) {
            SOAPFaultDetail soapFaultDetail = factory.createSOAPFaultDetail();
            soapFaultDetail.setText(faultDetail);
            fault.setDetail(soapFaultDetail);
        } else if (fault.getDetail() != null) {
            // work around for a rampart issue in the following thread
            // http://www.nabble.com/Access-to-validation-error-message-tf4498668.html#a13284520
            fault.getDetail().detach();
        }
    }

    public int getSoapVersion() {
        return soapVersion;
    }

    public void setSoapVersion(int soapVersion) {
        this.soapVersion = soapVersion;
    }

    public QName getFaultCodeValue() {
        return faultCodeValue;
    }

    public void setFaultCodeValue(QName faultCodeValue) {

        if (soapVersion == SOAP11) {
            this.faultCodeValue = faultCodeValue;

        } else {
            if (
                SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(faultCodeValue.getNamespaceURI()) &&

                (SOAP12Constants.FAULT_CODE_DATA_ENCODING_UNKNOWN.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_MUST_UNDERSTAND.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_RECEIVER.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_SENDER.equals(faultCodeValue.getLocalPart()) ||
                SOAP12Constants.FAULT_CODE_VERSION_MISMATCH.equals(faultCodeValue.getLocalPart())) ){

                this.faultCodeValue = faultCodeValue;

            } else {
                String msg = ""Invalid Fault code value for a SOAP 1.2 fault : "" + faultCodeValue;
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }

    public AXIOMXPath getFaultCodeExpr() {
        return faultCodeExpr;
    }

    public void setFaultCodeExpr(AXIOMXPath faultCodeExpr) {
        this.faultCodeExpr = faultCodeExpr;
    }

    public String getFaultReasonValue() {
        return faultReasonValue;
    }

    public void setFaultReasonValue(String faultReasonValue) {
        this.faultReasonValue = faultReasonValue;
    }

    public AXIOMXPath getFaultReasonExpr() {
        return faultReasonExpr;
    }

    public void setFaultReasonExpr(AXIOMXPath faultReasonExpr) {
        this.faultReasonExpr = faultReasonExpr;
    }

    public URI getFaultNode() {
        return faultNode;
    }

    public void setFaultNode(URI faultNode) {
        if (soapVersion == SOAP11) {
            String msg = ""A fault node does not apply to a SOAP 1.1 fault"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        this.faultNode = faultNode;
    }

    public URI getFaultRole() {
        return faultRole;
    }

    public void setFaultRole(URI faultRole) {
        this.faultRole = faultRole;
    }

    public String getFaultDetail() {
        return faultDetail;
    }

    public void setFaultDetail(String faultDetail) {
        this.faultDetail = faultDetail;
    }
}
"
org/apache/synapse/core/axis2/DynamicAxisOperation.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.transport.TransportUtils;
import org.apache.axis2.i18n.Messages;
import org.apache.axis2.util.TargetResolver;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.async.Callback;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisEngine;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.synapse.SynapseConstants;

import javax.xml.namespace.QName;

/**
 * DynamicAxisOperation which switch dynamically between MEPs
 */
public class DynamicAxisOperation extends OutInAxisOperation {

	public DynamicAxisOperation() {
		super();
	}

	public DynamicAxisOperation(QName name) {
		super(name);
	}

	public OperationClient createClient(ServiceContext sc, Options options) {
		return new DynamicOperationClient(this, sc, options);
	}

	class DynamicOperationClient extends OperationClient {

		DynamicOperationClient(OutInAxisOperation axisOp, ServiceContext sc, Options options) {
            super(axisOp, sc, options);
		}

		/**
         * same as OutInAxisOperationClient
		 */
		public void addMessageContext(MessageContext mc) throws AxisFault {
			mc.setServiceContext(sc);
			if (mc.getMessageID() == null) {
				setMessageID(mc);
			}
			axisOp.registerOperationContext(mc, oc);
		}

		/**
		 * same as OutInAxisOperationClient
		 */
		public MessageContext getMessageContext(String messageLabel) throws AxisFault {
			return oc.getMessageContext(messageLabel);
		}

        /**
         * same as OutInAxisOperationClient
         */
        public void setCallback(Callback callback) {
			this.callback = callback;
		}

		public void executeImpl(boolean block) throws AxisFault {

            // if the MEP is completed, throw a fault
            if (completed) {
				throw new AxisFault(Messages.getMessage(""mepiscomplted""));
			}

            // if the OUT message is not set on the operation context, throw a fault
            MessageContext outMsgCtx = oc.getMessageContext(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
			if (outMsgCtx == null) {
				throw new AxisFault(Messages.getMessage(""outmsgctxnull""));
			}

            ConfigurationContext cfgCtx = sc.getConfigurationContext();

            // set ClientOptions to the current outgoing message
            outMsgCtx.setOptions(options);

			// do Target Resolution
			TargetResolver tr = cfgCtx.getAxisConfiguration().getTargetResolverChain();
            if (tr != null) {
                tr.resolveTarget(outMsgCtx);
            }

            // if the transport to use for sending is not specified, try to find it from the URL
			TransportOutDescription transportOut = options.getTransportOut();
			if (transportOut == null) {
				EndpointReference toEPR =
                    (options.getTo() != null) ? options.getTo() : outMsgCtx.getTo();
				transportOut =
                    ClientUtils.inferOutTransport(cfgCtx.getAxisConfiguration(), toEPR, outMsgCtx);
			}
			outMsgCtx.setTransportOut(transportOut);

			if (options.getTransportIn() == null && outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(
                    ClientUtils.inferInTransport(cfgCtx.getAxisConfiguration(), options, outMsgCtx));
			} else if (outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(options.getTransportIn());
			}

            // add reference parameters to To EPR
            addReferenceParameters(outMsgCtx);

            if (options.isUseSeparateListener()) {

                /* TODO - review and finalise this - asankha 22 feb 2007
				// options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
				options.setTransportIn(outMsgCtx.getConfigurationContext()
						.getAxisConfiguration().getTransportIn(
								new QName(Constants.TRANSPORT_HTTP)));

				SynapseCallbackReceiver callbackReceiver = (SynapseCallbackReceiver) axisOp
						.getMessageReceiver();
				callbackReceiver.addCallback(outMsgCtx.getMessageID(), callback);
				EndpointReference replyToFromTransport = outMsgCtx
						.getConfigurationContext().getListenerManager()
						.getEPRforService(sc.getAxisService().getKey(),
								axisOp.getKey().getLocalPart(),
								outMsgCtx.getTransportOut().getKey().getLocalPart());

				if (outMsgCtx.getReplyTo() == null) {
					outMsgCtx.setReplyTo(replyToFromTransport);
				} else {
					outMsgCtx.getReplyTo().setAddress(
							replyToFromTransport.getAddress());
				}
				// if dont do this , this guy will wait till its gets HTTP 202
				// in the case
				// HTTP
				outMsgCtx.addFeature(MessageContext.TRANSPORT_NON_BLOCKING,
						Boolean.TRUE);
				AxisEngine engine = new AxisEngine(cfgCtx);
				outMsgCtx.getConfigurationContext().registerOperationContext(
						outMsgCtx.getMessageID(), oc);
				engine.send(outMsgCtx);

				// Options object reused so soapAction needs to be removed so
				// that soapAction+wsa:Action on response don't conflict
				options.setAction("""");
                */

			} else {

                SynapseCallbackReceiver callbackReceiver =
                    (SynapseCallbackReceiver) axisOp.getMessageReceiver();
                callbackReceiver.addCallback(outMsgCtx.getMessageID(), axisCallback);
                send(outMsgCtx);
			}
		}

		private void send(MessageContext msgctx) throws AxisFault {

			// create the responseMessageContext and set that its related to the current outgoing
            // message, so that it could be tied back to the original request even if the response
            // envelope does not contain addressing headers
            MessageContext responseMessageContext = new MessageContext();
            responseMessageContext.setMessageID(msgctx.getMessageID());
            responseMessageContext.setProperty(SynapseConstants.RELATES_TO_FOR_POX, msgctx.getMessageID());
            responseMessageContext.setOptions(options);
			addMessageContext(responseMessageContext);

            AxisEngine engine = new AxisEngine(msgctx.getConfigurationContext());
			engine.send(msgctx);

            // did the engine receive a immediate synchronous response?
            // e.g. sometimes the transport sender may listen for a syncronous reply
			if (msgctx.getProperty(MessageContext.TRANSPORT_IN) != null) {

                responseMessageContext.setOperationContext(msgctx.getOperationContext());                
                responseMessageContext.setAxisMessage(
                    msgctx.getOperationContext().getAxisOperation().
                    getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));
                responseMessageContext.setAxisService(msgctx.getAxisService());

                // set properties on responseMessageContext
                responseMessageContext.setServerSide(true);
                responseMessageContext.setProperty(MessageContext.TRANSPORT_OUT,
                    msgctx.getProperty(MessageContext.TRANSPORT_OUT));
                responseMessageContext.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    msgctx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));

                responseMessageContext.setProperty(
                    org.apache.synapse.SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // If request is REST assume that the responseMessageContext is REST too
                responseMessageContext.setDoingREST(msgctx.isDoingREST());

                responseMessageContext.setProperty(MessageContext.TRANSPORT_IN,
                    msgctx.getProperty(MessageContext.TRANSPORT_IN));
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // Options object reused above so soapAction needs to be removed so
                // that soapAction+wsa:Action on response don't conflict
                responseMessageContext.setSoapAction("""");

                if (responseMessageContext.getEnvelope() == null) {
                    // If request is REST we assume the responseMessageContext is
                    // REST, so set the variable

                    SOAPEnvelope resenvelope =
                        TransportUtils.createSOAPMessage(responseMessageContext);

                    if (resenvelope != null) {
                        responseMessageContext.setEnvelope(resenvelope);
                        engine = new AxisEngine(msgctx.getConfigurationContext());
                        engine.receive(responseMessageContext);
                        if (responseMessageContext.getReplyTo() != null) {
                            sc.setTargetEPR(responseMessageContext.getReplyTo());
                        }
                    } else {
                        throw new AxisFault(Messages.getMessage(""blockingInvocationExpectsResponse""));
                    }
                }
            }
        }
	}
}
"
org/apache/synapse/config/xml/TargetSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.mediators.eip.Target;

/**
 * This will serialize the Target util object for EIP mediators in to the
 * &lt;target&gt; element as specified below
 *
 * &lt;target (sequence=""string reference"")? (endpoint=""string reference"")?&gt;
 *  (&lt;sequence&gt; | &lt;endpoinit&gt;)?
 * &lt;/target&gt;
 */
public class TargetSerializer {

    /**
     * This holds the OMFactory to be used for the OMElement creations
     */
    private static final OMFactory fac = OMAbstractFactory.getOMFactory();

    /**
     * This holds the Synapse namesapce for all the elements (qualified from default)
     */
    private static final OMNamespace synNS
            = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");

    /**
     * This holds the null namespace for all the attributes (unqualified from default)
     */
    private static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * This static method will serialize the Target object to the target elements
     *
     * @param target - Target which is subjected to the serialization
     * @return OMElement representing the serialized Target
     */
    public static OMElement serializeTarget(Target target) {

        OMElement targetElem = fac.createOMElement(""target"", synNS);
        if (target.getTo() != null) {
            targetElem.addAttribute(""to"", target.getTo(), nullNS);
        }

        if (target.getSoapAction() != null) {
            targetElem.addAttribute(""soapAction"", target.getSoapAction(), nullNS);
        }

        if (target.getSequenceRef() != null) {
            targetElem.addAttribute(""sequence"", target.getSequenceRef(), nullNS);
        }

        if (target.getEndpointRef() != null) {
            targetElem.addAttribute(""endpoint"", target.getEndpointRef(), nullNS);
        }

        if (target.getSequence() != null) {
            SequenceMediatorSerializer serializer = new SequenceMediatorSerializer();
            serializer.serializeAnonymousSequence(targetElem, target.getSequence());
        }

        if (target.getEndpoint() != null) {
            targetElem.addChild(EndpointAbstractSerializer.getEndpointSerializer(
                    target.getEndpoint()).serializeEndpoint(target.getEndpoint()));
        }

        return targetElem;
    }
}
"
org/apache/synapse/config/xml/TargetFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * This will build the Target util object for EIP mediators using
 * &lt;target&gt; element specified as follows
 *
 * &lt;target (sequence=""string reference"")? (endpoint=""string reference"")?&gt;
 *  (&lt;sequence&gt; | &lt;endpoinit&gt;)?
 * &lt;/target&gt;
 */
public class TargetFactory {

    /**
     * This will hold the logger for the logging purposes
     */
    private static final Log log = LogFactory.getLog(TargetFactory.class);

    /**
     * Holds the QName of the target element in the xml configuration
     */
    private static final QName TARGET_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * This static method will be used to build the Target from the specified element
     * 
     * @param elem - OMElement describing the xml configuration of the target
     * @return Target built by parsing the given element
     */
    public static Target createTarget(OMElement elem) {

        if (!TARGET_Q.equals(elem.getQName())) {
            handleException(""Element does not match with the target QName"");
        }

        Target target = new Target();
        OMAttribute toAttr = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""to""));
        if (toAttr != null && toAttr.getAttributeValue() != null) {
            target.setTo(toAttr.getAttributeValue());
        }

        OMAttribute soapAction = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""soapAction""));
        if (soapAction != null && soapAction.getAttributeValue() != null) {
            target.setSoapAction(soapAction.getAttributeValue());
        }

        OMAttribute sequenceAttr = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""sequence""));
        if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {
            target.setSequenceRef(sequenceAttr.getAttributeValue());
        }

        OMAttribute endpointAttr = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""endpoint""));
        if (endpointAttr != null && endpointAttr.getAttributeValue() != null) {
            target.setEndpointRef(endpointAttr.getAttributeValue());
        }

        OMElement sequence = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sequence""));
        if (sequence != null) {
            SequenceMediatorFactory fac = new SequenceMediatorFactory();
            target.setSequence(fac.createAnonymousSequence(sequence));
        }

        OMElement endpoint = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint""));
        if (endpoint != null) {
            target.setEndpoint(EndpointAbstractFactory.
                    getEndpointFactroy(endpoint).createEndpoint(endpoint, true));
        }

        return target;
    }

    /**
     * This privaet method is used for the exception handling and logging purposes
     *
     * @param message - String message to be logged and the message of the exception
     */
    private static void handleException (String message) {
        if (log.isDebugEnabled()) {
            log.debug(message);
        }
        throw new SynapseException(message);
    }
}
"
org/apache/synapse/SynapseException.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

/**
 * <p>Runtime exception for Synapse code to throw
 */
public class SynapseException extends RuntimeException {

    private static final long serialVersionUID = -7244032125641596311L;

    public SynapseException(String string) {
        super(string);
    }

    public SynapseException(String msg, Throwable e) {
        super(msg, e);
    }

    public SynapseException(Throwable t) {
        super(t);
    }

}
"
org/apache/synapse/metrics/MetricsAggregatorModule.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.AxisDescription;
import org.apache.axis2.description.AxisModule;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
/*
 * 
 */

public class MetricsAggregatorModule implements Module {
    // initialize the module
    public void init(ConfigurationContext configContext, AxisModule module) throws AxisFault {
        AxisConfiguration axiConfiguration = configContext.getAxisConfiguration();

        Counter globalRequestCounter = new Counter();
        Parameter globalRequestCounterParameter = new Parameter();
        globalRequestCounterParameter.setName(MetricsConstants.GLOBAL_REQUEST_COUNTER);
        globalRequestCounterParameter.setValue(globalRequestCounter);
        axiConfiguration.addParameter(globalRequestCounterParameter);

    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {}

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation 
    }

    // shutdown the module
    public void shutdown(ConfigurationContext configurationContext) throws AxisFault {}
}
"
org/apache/synapse/startup/quartz/SimpleQuartzSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.StartupSerializer;
import org.apache.synapse.config.xml.XMLConfigConstants;

import javax.xml.namespace.QName;

public class SimpleQuartzSerializer implements StartupSerializer {

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS
        = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS
        = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"", ""syn"");

    public OMElement serializeStartup(OMElement parent, Startup s) {

        if (!(s instanceof SimpleQuartz)) {
            throw new SynapseException(""called TaskSerializer on some other "" +
                    ""kind of startup"" + s.getClass().getName());
        }

        SimpleQuartz sq = (SimpleQuartz) s;

        OMElement task = fac.createOMElement(""task"", synNS, parent);
        task.addAttribute(""name"", sq.getName(), nullNS);
        task.addAttribute(""class"", sq.getJobClass(), nullNS);

        OMElement el = fac.createOMElement(""trigger"", synNS, task);
        if (sq.getInterval() == 1 && sq.getCount() == 1) {
            el.addAttribute(""once"", ""true"", nullNS);
        } else if (sq.getCron() != null) {
            el.addAttribute(""cron"", sq.getCron(), nullNS);
        } else {
            if (sq.getCount() != -1) {
                el.addAttribute(""count"", Integer.toString(sq.getCount()), nullNS);
            }

            if (sq.getInterval() != 0) {
                el.addAttribute(""interval"", Long.toString(sq.getInterval()), nullNS);
            }
        }
        
        for (Object o : sq.getProperties()) {
            OMElement prop = (OMElement) o;
            task.addChild(prop.cloneOMElement());
        }

        return task;
    }

}
"
org/apache/synapse/core/axis2/SynapseMustUnderstandHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.handlers.AbstractHandler;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * This is a handler for axis2 which will clear the mustUnderstand ness of the headers
 * if there are any after the Dispatch, which will allow Synapse to get the message
 * even with unprocessed mustUnderstand headers
 */
public class SynapseMustUnderstandHandler extends AbstractHandler {
    
    public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {

        SOAPEnvelope envelope = messageContext.getEnvelope();

        if (envelope.getHeader() != null) {
            Iterator headerBlocks = envelope.getHeader().getHeadersToProcess(null);
            ArrayList markedHeaderBlocks = new ArrayList();

            while (headerBlocks.hasNext()) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) headerBlocks.next();

                // if this header block mustUnderstand but has not been processed
                // then mark it as processed to get the message in to Synapse
                if (!headerBlock.isProcessed() && headerBlock.getMustUnderstand()) {
                    markedHeaderBlocks.add(headerBlock);
                    headerBlock.setProcessed();
                }
            }

            // incase we need to get them inside synapse
            messageContext.setProperty(""headersMarkedAsProcessedBySynapse"", markedHeaderBlocks);
        }

        return InvocationResponse.CONTINUE;
    }
}
"
org/apache/synapse/config/xml/MediatorSerializerFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import sun.misc.Service;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class MediatorSerializerFinder {

    private static final Log log = LogFactory.getLog(MediatorSerializerFinder.class);

    private static final Class[] mediatorSerializers = {
        SequenceMediatorSerializer.class,
        LogMediatorSerializer.class,
        SendMediatorSerializer.class,
        FilterMediatorSerializer.class,
        SynapseMediatorSerializer.class,
        DropMediatorSerializer.class,
        HeaderMediatorSerializer.class,
        FaultMediatorSerializer.class,
        PropertyMediatorSerializer.class,
        SwitchMediatorSerializer.class,
        InMediatorSerializer.class,
        OutMediatorSerializer.class,
        RMSequenceMediatorSerializer.class,     
        ClassMediatorSerializer.class,
        ValidateMediatorSerializer.class,
        XSLTMediatorSerializer.class,
        POJOCommandMediatorSerializer.class,
        CloneMediatorSerializer.class,
        IterateMediatorSerializer.class,
        AggregateMediatorSerializer.class,
        DBLookupMediatorSerializer.class,
        DBReportMediatorSerializer.class,
        CacheMediatorSerializer.class
    };

    private static MediatorSerializerFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map serializerMap = new HashMap();

    public static synchronized MediatorSerializerFinder getInstance() {
        if (instance == null) {
            instance = new MediatorSerializerFinder();
        }
        return instance;
    }

    public MediatorSerializer getSerializer(Mediator mediator) {
        return (MediatorSerializer) serializerMap.get(mediator.getClass().getName());
    }

    private MediatorSerializerFinder() {

        serializerMap = new HashMap();

        for (int i = 0; i < mediatorSerializers.length; i++) {
            Class c = mediatorSerializers[i];
            try {
                MediatorSerializer ser = (MediatorSerializer) c.newInstance();
                serializerMap.put(ser.getMediatorClassName(), ser);
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    /**
     * Register pluggable mediator serializers from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {
        if (log.isDebugEnabled()) {
            log.debug(""Registering mediator extensions found in the classpath : "" + System.getProperty(""java.class.path""));
        }
        // register MediatorSerializer extensions
        Iterator it = Service.providers(MediatorSerializer.class);
        while (it.hasNext()) {
            MediatorSerializer ms = (MediatorSerializer) it.next();
            String name = ms.getMediatorClassName();
            try {
                serializerMap.put(name, ms.getClass().newInstance());
            } catch (InstantiationException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            }
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorSerializer "" + ms.getClass().getName() + "" to handle "" + name);
            }
        }
    }

    /**
     * This method will return the serializer Map registered with the Finder
     * 
     * @return Map of serilaizers already registered with the Finder
     */
    public Map getSerializerMap() {
        return serializerMap;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/builtin/DropMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.mediators.AbstractMediator;

/**
 * Halts further processing/mediation of the current message. i.e. returns false
 */
public class DropMediator extends AbstractMediator {

    /**
     * Halts further mediation of the current message by returning false.
     *
     * @param synCtx the current message
     * @return false always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Drop mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        //If drop mediator is a child of a sequence
        // and if this sequence is a IN or OUT sequence of a proxy service
        StatisticsUtils.processProxyServiceStatistics(synCtx);
        //If this a sequence is not  a IN or OUT sequence of a proxy service
        StatisticsUtils.processAllSequenceStatistics(synCtx);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Drop mediator"");
        }
        synCtx.setTo(null);
        return false;
    }
}
"
org/apache/synapse/config/xml/SendMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

/**
 *
 * //TODO document endpoints, failover and loadbalacing
 *
 * The &lt;send&gt; element is used to send messages out of Synapse to some endpoint. In the simplest case,
 * the place to send the message to is implicit in the message (via a property of the message itself)-
 * that is indicated by the following
 * <pre>
 *  &lt;send/&gt;
 * </pre>
 *
 * If the message is to be sent to one or more endpoints, then the following is used:
 * <pre>
 *  &lt;send&gt;
 *   (endpointref | endpoint)+
 *  &lt;/send&gt;
 * </pre>
 * where the endpointref token refers to the following:
 * <pre>
 * &lt;endpoint ref=""name""/&gt;
 * </pre>
 * and the endpoint token refers to an anonymous endpoint defined inline:
 * <pre>
 *  &lt;endpoint address=""url""/&gt;
 * </pre>
 * If the message is to be sent to an endpoint selected by load balancing across a set of endpoints,
 * then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;load-balance algorithm=""uri""&gt;
 *     (endpointref | endpoint)+
 *   &lt;/load-balance&gt;
 * &lt;/send&gt;
 * </pre>
 * Similarly, if the message is to be sent to an endpoint with failover semantics, then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;failover&gt;
 *     (endpointref | endpoint)+
 *   &lt;/failover&gt;
 * &lt;/send&gt;
 * </pre>
 */
public class SendMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SendMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SendMediator mediator = (SendMediator) m;
        OMElement send = fac.createOMElement(""send"", synNS);
        saveTracingState(send, mediator);

        Endpoint activeEndpoint = mediator.getEndpoint();
        if (activeEndpoint != null) {
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(activeEndpoint);

            OMElement endpointElement = serializer.serializeEndpoint(activeEndpoint);
            send.addChild(endpointElement);
        }

        if (parent != null) {
            parent.addChild(send);
        }
        return send;
    }

    public String getMediatorClassName() {
        return SendMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/base/SynapseMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The SynapseMediator is the ""mainmediator"" of the synapse engine. It is
 * given each message on arrival at the synapse engine. The synapse configuration
 * holds a reference to this special mediator instance. The SynapseMediator
 * holds the list of mediators supplied within the <rules> element of an XML
 * based Synapse configuration
 *
 * @see org.apache.synapse.config.SynapseConfiguration#getMainSequence()
 */
public class SynapseMediator extends AbstractListMediator {

    /**
     * Perform the mediation specified by the rule set
     *
     * @param synCtx the message context
     * @return as per standard mediate() semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Mediation using '"" + SynapseConstants.MAIN_SEQUENCE_KEY +
                ""' sequence Message is a : "" + (synCtx.isResponse() ? ""response"" : ""request""));

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // If the message flow path is OUT, then process the satatistics
        if (synCtx.isResponse()) {
            StatisticsUtils.processAllSequenceStatistics(synCtx);
        }

        //put the required property for the collecttng statistics for the message mediation
        StatisticsStack sequenceStack = (StatisticsStack) synCtx.getProperty(
                SynapseConstants.SEQUENCE_STATS);
        if (sequenceStack == null) {
            sequenceStack = new SequenceStatisticsStack();
            synCtx.setProperty(SynapseConstants.SEQUENCE_STATS,sequenceStack);
        }
        String seqName = ""MainSequence"";
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        sequenceStack.put(seqName,System.currentTimeMillis(),!synCtx.isResponse(),true,isFault);

        boolean result = super.mediate(synCtx);

        if (traceOrDebugOn) {
            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
            traceOrDebug(traceOn, ""End : Mediation using '"" +
                SynapseConstants.MAIN_SEQUENCE_KEY + ""' sequence"");
        }
        return result;        
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.MessageContext;

/**
 * This mediator represents an unnamed list mediator
 */

public class AnonymousListMediator extends AbstractListMediator {

     public boolean mediate(MessageContext synCtx) {
         return super.mediate(synCtx);
     }
}
"
org/apache/synapse/config/xml/POJOCommandMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.POJOCommandMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Class mediator using XML configuration specified
 * <p/>
 * <pre>
 * &lt;pojoCommand name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot;&gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 *   &lt;property name=&quot;string&quot; expression=&quot;XPATH expression&quot;/&gt;
 * &lt;/pojoCommand&gt;
 * </pre>
 */
public class POJOCommandMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {
        
        if (!(m instanceof POJOCommandMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        
        POJOCommandMediator mediator = (POJOCommandMediator) m;
        
        OMElement pojoCommand = fac.createOMElement(""pojoCommand"", synNS);
        saveTracingState(pojoCommand, mediator);

        if (mediator.getCommand() != null && mediator.getCommand().getClass().getName() != null) {
            pojoCommand.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, mediator.getCommand().getName()));
        } else {
            handleException(""Invalid POJO Command mediator. The command class name is required"");
        }

        for (Iterator itr = mediator.getStaticProps().keySet().iterator(); itr.hasNext(); ) {
            String propName = (String) itr.next();
            String value = (String) mediator.getStaticProps().get(propName);
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
            prop.addAttribute(fac.createOMAttribute(""value"", nullNS, value));
            pojoCommand.addChild(prop);
        }

        for (Iterator itr = mediator.getDynamicProps().keySet().iterator(); itr.hasNext(); ) {
            String propName = (String) itr.next();
            AXIOMXPath exprn = (AXIOMXPath) mediator.getDynamicProps().get(propName);
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
            prop.addAttribute(fac.createOMAttribute(""expression"", nullNS,
                exprn.toString()));
            serializeNamespaces(prop, exprn);
            pojoCommand.addChild(prop);
        }

        if (parent != null) {
            parent.addChild(pojoCommand);
        }
        return pojoCommand;
    }

    public String getMediatorClassName() {
        return POJOCommandMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/HeaderMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.HeaderMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * This builds a Header Mediator parsing the XML configuration supplied
 *
 * Set header
 *   <pre>
 *      &lt;header name=""qname"" (value=""literal"" | expression=""xpath"")/&gt;
 *   </pre>
 *
 * Remove header
 *   <pre>
 *      &lt;header name=""qname"" action=""remove""/&gt;
 *   </pre>
 */
public class HeaderMediatorFactory extends AbstractMediatorFactory  {

    private static final QName HEADER_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""header"");
    private static final QName ATT_ACTION = new QName(""action"");

    public Mediator createMediator(OMElement elem) {

        HeaderMediator headerMediator = new HeaderMediator();
        OMAttribute name   = elem.getAttribute(ATT_NAME);
        OMAttribute value  = elem.getAttribute(ATT_VALUE);
        OMAttribute exprn  = elem.getAttribute(ATT_EXPRN);
        OMAttribute action = elem.getAttribute(ATT_ACTION);

        if (name == null || name.getAttributeValue() == null) {
            String msg = ""A valid name attribute is required for the header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            String nameAtt = name.getAttributeValue();
            int colonPos = nameAtt.indexOf("":"");
            if (colonPos != -1) {
                // has a NS prefix.. find it and the NS it maps into
                String prefix = nameAtt.substring(0, colonPos);
                Iterator it = elem.getAllDeclaredNamespaces();
                while (it.hasNext()) {
                    OMNamespace n = (OMNamespace) it.next();
                    if (prefix.equals(n.getPrefix())) {
                        headerMediator.setQName(
                            new QName(n.getNamespaceURI(), nameAtt.substring(colonPos+1), prefix));
                    }
                }
            } else {
                // no prefix
                headerMediator.setQName(new QName(nameAtt));
            }
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(headerMediator,elem);

        // The action attribute is optional, if provided and equals to 'remove' the
        // header mediator will act as a header remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            headerMediator.setAction(HeaderMediator.ACTION_REMOVE);
        }

        if (headerMediator.getAction() == HeaderMediator.ACTION_SET &&
            value == null && exprn == null) {
            String msg = ""A 'value' or 'expression' attribute is required for a [set] header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (value != null && value.getAttributeValue() != null) {
            headerMediator.setValue(value.getAttributeValue());

        } else if (exprn != null && exprn.getAttributeValue() != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(exprn.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                headerMediator.setExpression(xp);
            } catch (JaxenException je) {
                String msg = ""Invalid XPath expression : "" + exprn.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg, je);
            }
        }

        return headerMediator;
    }

    public QName getTagQName() {
        return HEADER_Q;
    }
}
"
org/apache/synapse/config/xml/CacheMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CacheMediator;

/**
 * Serializes the Cache mediator to the XML configuration specified
 *
 * &lt;cache (id=""string"")? hashGenerator=""class"" scope=""string"" timeout=""mili-seconds""&gt;
 *  &lt;onCacheHit (sequence=""key"")?&gt;
 *   (mediator)+
 *  &lt;/onCacheHit&gt;
 *  &lt;implementation type=(memory | disk) maxSize=""int""/&gt;
 * &lt;/cache&gt;
 */
public class CacheMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof CacheMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        CacheMediator mediator = (CacheMediator) m;
        OMElement cache = fac.createOMElement(""cache"", synNS);
        saveTracingState(cache, mediator);

        if (mediator.getId() != null) {
            cache.addAttribute(fac.createOMAttribute(""id"", nullNS, mediator.getId()));
        }

        if (mediator.getDigestGenerator() != null) {
            cache.addAttribute(fac.createOMAttribute(""hashGenerator"", nullNS,
                mediator.getDigestGenerator().getClass().getName()));
        }

        if (mediator.getScope() != null) {
            cache.addAttribute(fac.createOMAttribute(""scope"", nullNS, mediator.getScope()));
        }

        if (mediator.getTimeout() != 0) {
            cache.addAttribute(
                fac.createOMAttribute(""timeout"", nullNS, Long.toString(mediator.getTimeout())));
        }

        if (mediator.getOnCacheHitRef() != null) {
            OMElement onCacheHit = fac.createOMElement(""onCacheHit"", synNS);
            onCacheHit.addAttribute(
                fac.createOMAttribute(""sequence"", nullNS, mediator.getOnCacheHitRef()));
            cache.addChild(onCacheHit);
        } else if (mediator.getOnCacheHitSequence() != null) {
            OMElement onCacheHit = fac.createOMElement(""onCacheHit"", synNS);
            new SequenceMediatorSerializer().serializeChildren(
                onCacheHit, mediator.getOnCacheHitSequence().getList());
            cache.addChild(onCacheHit);
        }

        if (mediator.getInMemoryCacheSize() != 0) {
            OMElement implElem = fac.createOMElement(""implementation"", synNS);
            implElem.addAttribute(fac.createOMAttribute(""type"", nullNS, ""memory""));
            implElem.addAttribute(fac.createOMAttribute(
                ""maxSize"", nullNS, Integer.toString(mediator.getInMemoryCacheSize())));
            cache.addChild(implElem);
        }
        
        if (mediator.getDiskCacheSize() != 0) {
            OMElement implElem = fac.createOMElement(""implementation"", synNS);
            implElem.addAttribute(fac.createOMAttribute(""type"", nullNS, ""disk""));
            implElem.addAttribute(fac.createOMAttribute(
                ""maxSize"", nullNS, Integer.toString(mediator.getDiskCacheSize())));
            cache.addChild(implElem);
        }

        if (parent != null) {
            parent.addChild(cache);
        }

        return cache;
    }

    public String getMediatorClassName() {
        return CacheMediator.class.getName();
    }
}
"
org/apache/synapse/core/axis2/SynapseInitializationModule.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.MDC;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.SynapseConfigurationBuilder;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.Date;

/**
 * This is the Synapse Module implementation class, which would initialize Synapse when it is
 * deployed onto an Axis2 configuration.
 */
public class SynapseInitializationModule implements Module {

    private static final Log log = LogFactory.getLog(SynapseInitializationModule.class);
    private SynapseConfiguration synCfg;

    public void init(ConfigurationContext configurationContext,
        AxisModule axisModule) throws AxisFault {

        log.info(""Initializing Synapse at : "" + new Date());
        try {
            InetAddress addr = InetAddress.getLocalHost();
            if (addr != null) {
                // Get IP Address
                String ipAddr = addr.getHostAddress();
                if (ipAddr != null) {
                    MDC.put(""ip"", ipAddr);
                }

                // Get hostname
                String hostname = addr.getHostName();
                if (hostname == null) {
                    hostname = ipAddr;
                }
                MDC.put(""host"", hostname);
            }
        } catch (UnknownHostException e) {
            log.warn(""Unable to determine hostname or IP address of the server for logging"", e);
        }

        // this will deploy the mediators in the mediator extensions folder
        log.info(""Loading mediator extensions..."");
        configurationContext.getAxisConfiguration().getConfigurator().loadServices();

        // Initializing the SynapseEnvironment and SynapseConfiguration
        log.info(""Initializing the Synapse configuration ..."");
        synCfg = getConfiguration(configurationContext);

        log.info(""Deploying the Synapse service.."");
        // Dynamically initialize the Synapse Service and deploy it into Axis2
        AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();
        AxisService synapseService = new AxisService(SynapseConstants.SYNAPSE_SERVICE_NAME);
        AxisOperation mediateOperation = new InOutAxisOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);
        mediateOperation.setMessageReceiver(new SynapseMessageReceiver());
        synapseService.addOperation(mediateOperation);
        List transports = new ArrayList();
        transports.add(Constants.TRANSPORT_HTTP);
        transports.add(Constants.TRANSPORT_HTTPS);
        synapseService.setExposedTransports(transports);
        axisCfg.addService(synapseService);

        log.info(""Initializing Sandesha 2..."");
        AxisModule sandeshaAxisModule = configurationContext.getAxisConfiguration().
            getModule(SynapseConstants.SANDESHA2_MODULE_NAME);
        if (sandeshaAxisModule != null) {
            Module sandesha2 = sandeshaAxisModule.getModule();
            sandesha2.init(configurationContext, sandeshaAxisModule);
        }

        log.info(""Deploying Proxy services..."");
        Iterator iter = synCfg.getProxyServices().iterator();
        while (iter.hasNext()) {
            ProxyService proxy = (ProxyService) iter.next();
            proxy.buildAxisService(synCfg, axisCfg);
            log.info(""Deployed Proxy service : "" + proxy.getName());
            if (!proxy.isStartOnLoad()) {
                proxy.stop(synCfg);
            }
        }
        
        log.info(""Synapse initialized successfully...!"");
    }

    private static SynapseConfiguration getConfiguration(ConfigurationContext cfgCtx) {

        cfgCtx.setProperty(""addressing.validateAction"", Boolean.FALSE);
        AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();
        SynapseConfiguration synapseConfiguration;

        String config = System.getProperty(SynapseConstants.SYNAPSE_XML);

        if (config != null) {
            if (log.isDebugEnabled()) {
                log.debug(""System property '"" + SynapseConstants.SYNAPSE_XML +
                        ""' specifies Synapse configuration as "" + config);
            }
            synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);
        } else {
            log.warn(""System property '"" + SynapseConstants.SYNAPSE_XML +
                ""' is not specified. Using default configuration.."");
            synapseConfiguration = SynapseConfigurationBuilder.getDefaultConfiguration();
        }

        // Set the Axis2 ConfigurationContext to the SynapseConfiguration
        synapseConfiguration.setAxisConfiguration(cfgCtx.getAxisConfiguration());

        // set the Synapse configuration and environment into the Axis2 configuration
        Parameter synapseCtxParam = new Parameter(SynapseConstants.SYNAPSE_CONFIG, null);
        synapseCtxParam.setValue(synapseConfiguration);
        MessageContextCreatorForAxis2.setSynConfig(synapseConfiguration);

        Parameter synapseEnvParam = new Parameter(SynapseConstants.SYNAPSE_ENV, null);
        Axis2SynapseEnvironment synEnv = new Axis2SynapseEnvironment(cfgCtx, synapseConfiguration);
        synapseEnvParam.setValue(synEnv);
        MessageContextCreatorForAxis2.setSynEnv(synEnv);

        try {
            axisConfiguration.addParameter(synapseCtxParam);
            axisConfiguration.addParameter(synapseEnvParam);

        } catch (AxisFault e) {
            String msg =
                ""Could not set parameters '"" + SynapseConstants.SYNAPSE_CONFIG +
                    ""' and/or '"" + SynapseConstants.SYNAPSE_ENV +
                    ""'to the Axis2 configuration : "" + e.getMessage();
            log.fatal(msg, e);
            throw new SynapseException(msg, e);
        }
        synapseConfiguration.init(synEnv);
        
        return synapseConfiguration;
    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {
        // ignore
    }

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation
    }

    public void shutdown(ConfigurationContext configurationContext)
        throws AxisFault {
        // ignore
    	synCfg.destroy();
    }
}
"
org/apache/synapse/config/xml/MediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

import javax.xml.namespace.QName;

/**
 * A mediator factory capable of creating an instance of a mediator through a given
 * XML should implement this interface
 */
public interface MediatorFactory {
    /**
     * Creates an instance of the mediator using the OMElement
     * @param elem
     * @return the created mediator
     */
    public Mediator createMediator(OMElement elem);

    /**
     * The QName of this mediator element in the XML config
     * @return QName of the mediator element
     */
    public QName getTagQName();
}
"
org/apache/synapse/mediators/GetPropertyFunction.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.jaxen.Context;
import org.jaxen.Function;
import org.jaxen.FunctionCallException;
import org.jaxen.Navigator;
import org.jaxen.function.StringFunction;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Implements the XPath extension function synapse:get-property(scope,prop-name)
 */
public class GetPropertyFunction implements Function {

    private static final Log log = LogFactory.getLog(GetPropertyFunction.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public static final String NULL_STRING = """";

    /** Synapse Message context*/
    private MessageContext synCtx = null;

    public MessageContext getSynCtx() {
        return synCtx;
    }

    public void setSynCtx(MessageContext synCtx) {
        this.synCtx = synCtx;
    }

    /**
     * Returns the string value of the property which is get from the corresponding context to the provided scope .
     * The default scope is used to get property from the synapse message context
     *
     * @param context the context at the point in the expression when the function is called
     * @param args  arguments of the functions 
     * @return The string value of a property
     * @throws FunctionCallException
     */
    public Object call(Context context, List args) throws FunctionCallException {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (args == null || args.size() == 0) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Property key value for lookup is not specified"");
            }
            return null;

        } else {
            int size = args.size();
            if (size == 1) {
                return evaluate(
                    XMLConfigConstants.SCOPE_DEFAULT, args.get(0), context.getNavigator());

            } else if (size == 2) {
                return evaluate(args.get(0), args.get(1), context.getNavigator());

            } else {

                String msg = ""Invalid arguments for synapse:get-property(prop-name) 0r  "" +
                    ""synapse:get-property(scope, prop-name) XPath function "";
                if (traceOn) {
                    trace.error(msg);
                }
                log.error(msg);
                throw new FunctionCallException(msg);
            }
        }
    }

    /**
     * Returns the string value of the property using arg one as key and arg two as scope
     *
     * @param scopeObject scope will decide from where property will be picked up from
     *        i.e. axis2, transport, default/synapse
     * @param keyObject the key of the property
     * @param navigator object model which can be used for navigation around
     * @return The String value of property using arg one as key and arg two as scope
     */
    public Object evaluate(Object scopeObject, Object keyObject, Navigator navigator) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (synCtx == null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Synapse message context has not been set for the "" +
                    ""XPath extension function 'synapse:get-property(prop-name)'"");
            }
            return null;
        }

        String scope = StringFunction.evaluate(scopeObject, navigator);
        String key = StringFunction.evaluate(keyObject, navigator);

        if (key == null || """".equals(key)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn,
                    ""property-name should be provided when executing synapse:get-property"" +
                    ""(scope,prop-name) or synapse:get-property(prop-name) Xpath function"");
            }
            return null;
        }
        
        if (XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {

            if (SynapseConstants.HEADER_TO.equals(key)) {
                EndpointReference toEPR = synCtx.getTo();
                if (toEPR != null) {
                    return toEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_FROM.equals(key)) {
                EndpointReference fromEPR = synCtx.getFrom();
                if (fromEPR != null) {
                    return fromEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_ACTION.equals(key)) {
                String wsaAction = synCtx.getWSAAction();
                if (wsaAction != null) {
                    return wsaAction;
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_FAULT.equals(key)) {
                EndpointReference faultEPR = synCtx.getFaultTo();
                if (faultEPR != null) {
                    return faultEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_REPLY_TO.equals(key)) {
                EndpointReference replyToEPR = synCtx.getReplyTo();
                if (replyToEPR != null) {
                    return replyToEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_MESSAGE_ID.equals(key)) {
                String messageID = synCtx.getMessageID();
                if (messageID != null) {
                    return messageID;
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.PROPERTY_MESSAGE_FORMAT.equals(key)) {
                if(synCtx.isDoingPOX())
                    return SynapseConstants.FORMAT_POX;
                else  if (synCtx.isSOAP11())
                    return SynapseConstants.FORMAT_SOAP11;
                else
                    return SynapseConstants.FORMAT_SOAP12;
            } else {
                Object result = synCtx.getProperty(key);
                if (result != null) {
                    return result;
                } else {
                    return synCtx.getEntry(key);
                }
            }

        } else if (XMLConfigConstants.SCOPE_AXIS2.equals(scope)
            && synCtx instanceof Axis2MessageContext) {

            org.apache.axis2.context.MessageContext axis2MessageContext
                = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            return axis2MessageContext.getProperty(key);

        } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
            && synCtx instanceof Axis2MessageContext) {

            org.apache.axis2.context.MessageContext axis2MessageContext
                = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            Object headers = axis2MessageContext.getProperty(
                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

            if (headers != null && headers instanceof Map) {
                Map headersMap = (HashMap) headers;
                return headersMap.get(key);
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Invalid scope : '"" + scope + ""' has been set for the "" +
                    ""synapse:get-property(scope,prop-name) XPath function"");
            }
        }
        return NULL_STRING;
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

}

"
org/apache/synapse/util/TextFileDataSource.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.axiom.om.OMDataSource;
import org.apache.axiom.om.OMOutputFormat;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
import org.apache.axiom.om.impl.serialize.StreamingOMSerializer;
import org.apache.axiom.om.util.StAXUtils;
import org.apache.synapse.SynapseException;
import org.apache.synapse.transport.base.BaseConstants;

import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import java.io.*;

public class TextFileDataSource implements OMDataSource {

    private static final byte[] prefix =
        ""<text xmlns=\""http://ws.apache.org/commons/ns/payload\"">"".getBytes();
    private static final byte[] suffix = ""</text>"".getBytes();
    private static final byte[] empty =
        ""<text xmlns=\""http://ws.apache.org/commons/ns/payload\""/>"".getBytes();
    private InputStream is = null;
    private int i = 0, j = 0;

    public TextFileDataSource(DataSource ds) {
        try {
            this.is = ds.getInputStream();
        } catch (IOException e) {
            throw new SynapseException(
                ""Unable to get an InputStream for DataSource : "" + ds.getName(), e);
        }
    }

    public void serialize(OutputStream out, OMOutputFormat format) throws XMLStreamException {
        try {
            //out.write(prefix);
            // Transfer bytes from is to out
            byte[] buf = new byte[4096];
            int len;
            while ((len = is.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            //out.write(suffix);
        } catch (IOException e) {
            throw new SynapseException(""Error serializing TextFileDataSource to an OutputStream"", e);
        }
    }

    public void serialize(Writer writer, OMOutputFormat format) throws XMLStreamException {
        try {
            writer.write(new String(empty));
        } catch (IOException e) {
            throw new XMLStreamException(e);
        }
    }

    public void serialize(XMLStreamWriter xmlWriter) throws XMLStreamException {
        StreamingOMSerializer serializer = new StreamingOMSerializer();
        serializer.serialize(getReader(), xmlWriter);
    }

    public XMLStreamReader getReader() throws XMLStreamException {
        return StAXUtils.createXMLStreamReader(getInputStream());
    }

    private InputStream getInputStream() {

        return new InputStream() {

            public int read(byte b[]) throws IOException {
                return read(b, 0, b.length);
            }

            public int read(byte b[], int off, int len) throws IOException {
                int pos = off;
                if (i < prefix.length) {
                    while (i < prefix.length && pos-off < len) {
                        b[pos++] = prefix[i++];
                    }
                    return pos - off;
                }

                int ret = is.read(b, pos, len-pos);

                if (ret == -1 && j < suffix.length) {
                    while (j < suffix.length && pos-off < len) {
                        b[pos++] = suffix[j++];
                    }
                    return pos - off;
                }

                return ret;
            }

            public int read() throws IOException {
                if (i < prefix.length) {
                    while (i < prefix.length) {
                        return prefix[i++];
                    }
                }
                int ret = is.read();

                if (ret == -1 && j < suffix.length) {
                    while (j < suffix.length) {
                        return suffix[j++];
                    }
                }
                return ret;
            }
        };
    }

    public static void main(String[] args) throws Exception {
        TextFileDataSource textFileDataSource = new TextFileDataSource(
            //    new File(""/tmp/test.txt""));
            new FileDataSource(""/home/asankha/code/synapse/repository/conf/sample/resources/transform/message.xml""));

        OMFactory fac = OMAbstractFactory.getOMFactory();
        OMSourcedElementImpl element =
            new OMSourcedElementImpl(
                BaseConstants.DEFAULT_TEXT_WRAPPER, fac, textFileDataSource);
        element.serializeAndConsume(new FileOutputStream(""/tmp/out.txt""));
        element.serialize(System.out);
        //element.serializeAndConsume(System.out);
    }
}
"
org/apache/synapse/mediators/db/Statement.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.SynapseException;

import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Encapsulates an SQL statement, one or more parameters for it and optionally some information
 * about results that one would like to read.
 */
public class Statement {

    String rawStatement = null;
    List parameters = new ArrayList();
    Map resultsMap = new HashMap();

    public Statement(String rawStatement) {
        this.rawStatement = rawStatement;
    }

    public String getRawStatement() {
        return rawStatement;
    }

    public void addParameter(String propertyName, AXIOMXPath xpath, String type){
        parameters.add(new Parameter(propertyName, xpath, type));
    }

    public void addResult(String propertyName, String column) {
        resultsMap.put(propertyName, column);
    }

    public List getParameters() {
        return parameters;
    }

    public Map getResultsMap() {
        return resultsMap;
    }

    public class Parameter {
        String propertyName = null;
        AXIOMXPath xpath = null;
        int type = 0;

        Parameter(String value, AXIOMXPath xpath, String type) {

            this.propertyName = value;
            this.xpath = xpath; 
            if (""CHAR"".equals(type)) {
                this.type = Types.CHAR;
            } else if (""VARCHAR"".equals(type)) {
                this.type = Types.VARCHAR;
            } else if (""LONGVARCHAR"".equals(type)) {
                this.type = Types.LONGVARCHAR;
            } else if (""NUMERIC"".equals(type)) {
                this.type = Types.NUMERIC;
            } else if (""DECIMAL"".equals(type)) {
                this.type = Types.DECIMAL;
            } else if (""BIT"".equals(type)) {
                this.type = Types.BIT;
            } else if (""TINYINT"".equals(type)) {
                this.type = Types.TINYINT;
            } else if (""SMALLINT"".equals(type)) {
                this.type = Types.SMALLINT;
            } else if (""INTEGER"".equals(type)) {
                this.type = Types.INTEGER;
            } else if (""BIGINT"".equals(type)) {
                this.type = Types.BIGINT;
            } else if (""REAL"".equals(type)) {
                this.type = Types.REAL;
            } else if (""FLOAT"".equals(type)) {
                this.type = Types.FLOAT;
            } else if (""DOUBLE"".equals(type)) {
                this.type = Types.DOUBLE;
            } else if (""DATE"".equals(type)) {
                this.type = Types.DATE;
            } else if (""TIME"".equals(type)) {
                this.type = Types.TIME;
             } else if (""TIMESTAMP"".equals(type)) {
                this.type = Types.TIMESTAMP;
            } else {
                throw new SynapseException(""Unknown or unsupported JDBC type : "" + type);
            }
        }

        public String getPropertyName() {
            return propertyName;
        }

        public AXIOMXPath getXpath() {
            return xpath;
        }

        public int getType() {
            return type;
        }
    }
}

"
org/apache/synapse/util/concurrent/SynapseThreadFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.concurrent;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.ThreadFactory;

/**
 * This is the thread factory for Synapse threads which are accessibal through the
 * SynapseEnvironment as pooled threads
 */
public class SynapseThreadFactory implements ThreadFactory {

    /** Holds the ThreadGroup under which this factory creates threads */
    final ThreadGroup group;

    /** Holds the AtomicInteger class instance for the factory */
    final AtomicInteger count;

    /** prefix for the thread id, thread number will be followed to construct the id */
    final String namePrefix;

    /**
     * Constructor for the ThreadFactory to create new threads
     *
     * @param group      - all the threads are created under this group by this factory
     * @param namePrefix - name prefix of the threads created by this factory
     */
    public SynapseThreadFactory(final ThreadGroup group, final String namePrefix) {
        super();
        this.count = new AtomicInteger(1);
        this.group = group;
        this.namePrefix = namePrefix;
    }

    /**
     * This method is the implementation of the the newThread method and will
     * create new threads under the group and with the nameprefix followed by the
     * thread number as the id
     * 
     * @param runnable - Runnable class to run by the created thread
     * @return a Thread executing the given runnable
     */
    public Thread newThread(final Runnable runnable) {
        StringBuffer buffer = new StringBuffer();
        buffer.append(this.namePrefix);
        buffer.append('-');
        buffer.append(this.count.getAndIncrement());
        Thread t = new Thread(group, runnable, buffer.toString(), 0);
        t.setDaemon(false);
        t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }

}
"
org/apache/synapse/config/xml/AggregateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.eip.aggregator.AggregateMediator;
import org.apache.synapse.mediators.ext.ClassMediator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;aggregate&gt;
 *  &lt;corelateOn expression=""XPATH-expression""/&gt;
 *  &lt;completeCondition timeout=""time-in-seconds""&gt;
 *   &lt;messageCount min=""int-min"" max=""int-max""/&gt;
 *  &lt;/completeCondition&gt;
 *  &lt;onComplete expression=""XPATH-expression"" sequence=""sequence-ref""&gt;
 *   (mediator +)?
 *  &lt;/onComplete&gt;
 *  &lt;invalidate sequence=""sequence-ref"" timeout=""time-in-seconds""&gt;
 *   (mediator +)?
 *  &lt;/invalidate&gt;
 * &lt;/aggregate&gt;
 */
public class AggregateMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(AggregateMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof AggregateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        AggregateMediator mediator = (AggregateMediator) m;
        OMElement aggregator = fac.createOMElement(""aggregate"", synNS);
        saveTracingState(aggregator, mediator);

        if (mediator.getCorelateExpression() != null) {
            OMElement corelateOn = fac.createOMElement(""corelateOn"", synNS);
            corelateOn.addAttribute(""expression"", mediator.getCorelateExpression().toString(), nullNS);
            super.serializeNamespaces(corelateOn, mediator.getCorelateExpression());
            aggregator.addChild(corelateOn);
        }

        OMElement completeCond = fac.createOMElement(""completeCondition"", synNS);
        if (mediator.getCompleteTimeout() != 0) {
            completeCond.addAttribute(""timeout"", """" + mediator.getCompleteTimeout(), nullNS);
        }
        OMElement messageCount = fac.createOMElement(""messageCount"", synNS);
        if (mediator.getMinMessagesToComplete() != 0) {
            messageCount.addAttribute(""min"", """" + mediator.getMinMessagesToComplete(), nullNS);
        }
        if (mediator.getMaxMessagesToComplete() != 0) {
            messageCount.addAttribute(""max"", """" + mediator.getMaxMessagesToComplete(), nullNS);
        }
        completeCond.addChild(messageCount);
        aggregator.addChild(completeCond);

        OMElement aggregatorElem = fac.createOMElement(""aggregator"", synNS);
//        aggregatorElem.addAttribute(""type"", mediator.getAggregator().getClass().getName(), nullNS);
//        aggregatorElem.addAttribute(""expression"", mediator.get)

        return aggregator;
    }

    public String getMediatorClassName() {
        return AggregateMediator.class.getName();
    }
}
"
org/apache/synapse/registry/RegistryEntry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import java.net.URI;

/**
 * This interface defines the core information to be returned by a Registry implementation
 * about a resource being managed by it. Every Registry implementation *must* provide valid
 * information for the methods marked below as 'required'
 */
public interface RegistryEntry {

    /** The key for the resource - required */
    public String getKey();

    /** A name for the resource - optional */
    public String getName();

    /** The version of the resource - required */
    public long getVersion();

    /** The type of the resource - optional */
    public URI getType();

    /** A description for the resource - optional */
    public String getDescription();

    /** The created time for the resource - optional */
    public long getCreated();

    /** The last updated time for the resource - optional */
    public long getLastModified();

    /** The number of milliseconds this resource could be cached */
    public long getCachableDuration();
}
"
org/apache/synapse/config/xml/HeaderMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.HeaderMediator;

import javax.xml.namespace.QName;

/**
 * Set header
 *   <pre>
 *      &lt;header name=""qname"" (value=""literal"" | expression=""xpath"")/&gt;
 *   </pre>
 *
 * Remove header
 *   <pre>
 *      &lt;header name=""qname"" action=""remove""/&gt;
 *   </pre>
 */
public class HeaderMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof HeaderMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        HeaderMediator mediator = (HeaderMediator) m;
        OMElement header = fac.createOMElement(""header"", synNS);
        saveTracingState(header,mediator);

        QName qName = mediator.getQName();
        if (qName != null) {
            if (qName.getNamespaceURI() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS,
                    (qName.getPrefix() != null && !"""".equals(qName.getPrefix())
                        ? qName.getPrefix() + "":"" : """") + 
                    qName.getLocalPart()));
                header.declareNamespace(qName.getNamespaceURI(), qName.getPrefix());
            } else {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, qName.getLocalPart()));
            }
        }

        if (mediator.getAction() == HeaderMediator.ACTION_REMOVE) {
            header.addAttribute(fac.createOMAttribute(
                ""action"", nullNS, ""remove""));
        } else {
            if (mediator.getValue() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

            } else if (mediator.getExpression() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""expression"", nullNS, mediator.getExpression().toString()));
                super.serializeNamespaces(header, mediator.getExpression());

            } else {
                handleException(""Value or expression required for a set header mediator"");
            }
        }

        if (parent != null) {
            parent.addChild(header);
        }
        return header;
    }

    public String getMediatorClassName() {
        return HeaderMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.PropertyMediator;

/**
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"")/&gt;
 * </pre>
 */
public class PropertyMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof PropertyMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        PropertyMediator mediator = (PropertyMediator) m;
        OMElement property = fac.createOMElement(""property"", synNS);
        saveTracingState(property, mediator);

        if (mediator.getName() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
        } else {
            handleException(""Invalid property mediator. Name is required"");
        }

        if (mediator.getValue() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

        } else if (mediator.getExpression() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""expression"", nullNS, mediator.getExpression().toString()));
            super.serializeNamespaces(property, mediator.getExpression());

        } else if (mediator.getAction() == PropertyMediator.ACTION_SET) {
            handleException(""Invalid property mediator. Value or expression is required if action is SET"");
        }
        if (mediator.getScope() != null) {
            // if we have already built a mediator with scope, scope should be valid, now save it
            property.addAttribute(fac.createOMAttribute(""scope"", nullNS, mediator.getScope()));
        }
        if (mediator.getAction() == PropertyMediator.ACTION_REMOVE) {
            property.addAttribute(fac.createOMAttribute(
                    ""action"", nullNS, ""remove""));
        }
        if (parent != null) {
            parent.addChild(property);
        }
        return property;
    }

    public String getMediatorClassName() {
        return PropertyMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/transform/XSLTMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axiom.om.impl.dom.DOOMAbstractFactory;
import org.apache.axiom.om.impl.dom.jaxp.DocumentBuilderFactoryImpl;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
import org.apache.axiom.om.util.ElementHelper;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.FixedByteArrayOutputStream;
import org.apache.synapse.util.TextFileDataSource;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.transport.base.BaseConstants;
import org.jaxen.JaxenException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.namespace.QName;
import javax.activation.FileDataSource;
import javax.activation.DataHandler;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * The XSLT mediator performs an XSLT transformation requested, using
 * the current message. The source attribute (if available) spcifies the source element
 * on which the transformation would be applied. It will default to the first child of
 * the messages' SOAP body, if it is omitted.
 *
 * Additional properties passed into this mediator would become parameters for XSLT.
 * Additional features passed into this mediator would become features except for
 * ""http://ws.apache.org/ns/synapse/transform/feature/dom"" for the Transformer Factory, which
 * is used to decide between using DOM and Streams during the transformation process. By default
 * this is turned on as an optimization, but should be set to false if issues are detected
 *
 *  Note: Set the TransformerFactory system property to generate and use translets
 *  -Djavax.xml.transform.TransformerFactory=org.apache.xalan.xsltc.trax.TransformerFactoryImpl
 * 
 */
public class XSLTMediator extends AbstractMediator {

    /** Maximum size of a byte array stream attempted in-memory before file serialization is used */
    private static final int BYTE_ARRAY_SIZE = 8192;
    /**
     * The feature for which deciding swiching between DOM and Stream during the
     * transformation process
     */
    public static final String USE_DOM_SOURCE_AND_RESULTS =
        ""http://ws.apache.org/ns/synapse/transform/feature/dom"";
    /**
     * The resource key/name which refers to the XSLT to be used for the transformation
     */
    private String xsltKey = null;

    /** Variable to hold source XPath string to use for debugging */
    private String sourceXPathString = null;

    /**
     * The (optional) XPath expression which yeilds the source element for a transformation
     */
    private AXIOMXPath source = null;

    /**
     * Any parameters which should be passed into the XSLT transformation
     */
    private List properties = new ArrayList();

    /**
     * Any features which should be set to the TransformerFactory by explicitly
     */
    private List explicitFeatures = new ArrayList();

    /**
     * The Template instance used to create a Transformer object. This is  thread-safe
     *
     * @see javax.xml.transform.Templates
     */
    private Templates cachedTemplates = null;

    /**
     * The TransformerFactory instance which use to create Templates...This is not thread-safe.
     * @see javax.xml.transform.TransformerFactory
     */
    private final TransformerFactory transFact = TransformerFactory.newInstance();

    /**
     * Lock used to ensure thread-safe creation and use of the above Transformer
     */
    private final Object transformerLock = new Object();

    /**
     *  Is it need to use DOMSource and DOMResult?
     */
    private boolean useDOMSourceAndResults = false;

    // todo - this is a hack to get the handler module case working - ruwan
    //    public static final String DEFAULT_XPATH = ""//s11:Envelope/s11:Body/child::*[position()=1] | "" +
    //            ""//s12:Envelope/s12:Body/child::*[position()=1]"";
    public static final String DEFAULT_XPATH = ""s11:Body/child::*[position()=1] | "" +
            ""s12:Body/child::*[position()=1]"";

    public XSLTMediator() {
        // create the default XPath
        try {
            this.source = new AXIOMXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            String msg = ""Error creating default source XPath expression : "" + DEFAULT_XPATH;
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * Transforms this message (or its element specified as the source) using the
     * given XSLT transformation
     *
     * @param synCtx the current message where the transformation will apply
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : XSLT mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            performXLST(synCtx, traceOrDebugOn, traceOn);

        } catch (Exception e) {
            handleException(""Unable to perform XSLT transformation using : "" + xsltKey +
                "" against source XPath : "" +
                (sourceXPathString == null ? DEFAULT_XPATH : "" source XPath : "" +
                 sourceXPathString), e, synCtx);

        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : XSLT mediator"");
        }

        return true;
    }

    /**
     * Perform actual XSLT transformation
     * @param synCtx current message
     * @param traceOrDebugOn is trace or debug on?
     * @param traceOn is trace on?
     */
    private void performXLST(MessageContext synCtx, boolean traceOrDebugOn, boolean traceOn) {

        boolean reCreate = false;
        OMNode sourceNode = getTransformSource(synCtx);
        OutputStream osForTarget = null;
        InputStream  isForSource = null;
        ByteArrayOutputStream baosForTarget = new FixedByteArrayOutputStream(BYTE_ARRAY_SIZE);
        File tempTargetFile = null;
        File tempSourceFile = null;

        if (traceOrDebugOn) {
            trace.trace(""Transformation source : "" + sourceNode.toString());
        }

        Source transformSrc = null;
        Result transformTgt = null;

        if (useDOMSourceAndResults) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Using a DOMSource for transformation"");
            }

            // for fast transformations create a DOMSource - ** may not work always though **
            transformSrc = new DOMSource(
                ((Element) ElementHelper.importOMElement((OMElement) sourceNode,
                DOOMAbstractFactory.getOMFactory())).getOwnerDocument());
            DocumentBuilderFactoryImpl.setDOOMRequired(true);

            try {
                transformTgt = new DOMResult(
                    DocumentBuilderFactoryImpl.newInstance().newDocumentBuilder().newDocument());
            } catch (ParserConfigurationException e) {
                handleException(""Error creating a DOMResult for the transformation,"" +
                    "" Consider setting optimization feature : "" + USE_DOM_SOURCE_AND_RESULTS +
                    "" off"", e, synCtx);
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Using byte array serialization for transformation"");
            }

            try {
                // create a byte array output stream and serialize the source node into it
                ByteArrayOutputStream baosForSource = new FixedByteArrayOutputStream(BYTE_ARRAY_SIZE);
                XMLStreamWriter xsWriterForSource = XMLOutputFactory.newInstance().
                    createXMLStreamWriter(baosForSource);

                sourceNode.serialize(xsWriterForSource);
                isForSource = new ByteArrayInputStream(baosForSource.toByteArray());
                transformSrc = new StreamSource(isForSource);
                transformTgt = new StreamResult(baosForTarget);

            } catch (XMLStreamException e) {
                handleException(""Error creating a StreamResult for the transformation"", e, synCtx);

            } catch (SynapseException x) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Error creating a StreamResult using a byte array"" +
                        "" - attempting using temporary files for serialization"");
                }

                OutputStream osForSource = null;

                try {
                    // create a output stream and serialize the source node into it
                    tempSourceFile = File.createTempFile(""xs_"", "".xml"");
                    tempTargetFile = File.createTempFile(""xt_"", "".xml"");

                    osForSource = new FileOutputStream(tempSourceFile);
                    osForTarget = new FileOutputStream(tempTargetFile);

                    XMLStreamWriter xsWriterForSource =
                        XMLOutputFactory.newInstance().createXMLStreamWriter(osForSource);

                    sourceNode.serialize(xsWriterForSource);
                    transformSrc = new StreamSource(tempSourceFile);
                    transformTgt = new StreamResult(osForTarget);

                } catch (XMLStreamException e) {
                    handleException(""Error creating a StreamResult for the transformation"", e, synCtx);
                } catch (IOException e) {
                    handleException(""Error using a temporary file/s for the transformation"", e, synCtx);
                } finally {
                    try {
                        osForSource.close();
                    } catch (IOException ignore) {}
                }
            }
        }

        if (transformTgt == null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Was unable to get a javax.xml.transform.Result created"");
            }
            return;
        }

        // build transformer - if necessary
        Entry dp = synCtx.getConfiguration().getEntryDefinition(xsltKey);

        // if the xsltKey refers to a dynamic resource
        if (dp != null && dp.isDynamic()) {
            if (!dp.isCached() || dp.isExpired()) {
                reCreate = true;
            }
        }

        synchronized (transformerLock) {
            if (reCreate || cachedTemplates == null) {
                try {
                    cachedTemplates = transFact.newTemplates(
                        SynapseConfigUtils.getStreamSource(synCtx.getEntry(xsltKey)));

                } catch (TransformerConfigurationException e) {
                    handleException(""Error creating XSLT transformer using : "" + xsltKey, e, synCtx);
                }
            }
        }

        try {
            // perform transformation
            Transformer transformer = cachedTemplates.newTransformer();
            if (!properties.isEmpty()) {
                // set the parameters which will pass to the Transformation
                for (int i = 0; i < properties.size(); i++) {
                    MediatorProperty prop = (MediatorProperty) properties.get(i);
                    if (prop != null) {
                        if (prop.getValue() != null) {
                            transformer.setParameter(prop.getName(), prop.getValue());
                        } else {
                            transformer.setParameter(prop.getName(),
                                Axis2MessageContext.getStringValue(prop.getExpression(), synCtx));
                        }
                    }
                }
            }

            try {
                transformer.transform(transformSrc, transformTgt);

            } catch (TransformerException x) {
                // did we exceed the in-memory BYTE_ARRAY_SIZE? if so, use a file for output
                try {
                    tempTargetFile = File.createTempFile(""xt_"", "".xml"");
                    osForTarget  = new FileOutputStream(tempTargetFile);
                    transformTgt = new StreamResult(osForTarget);

                    // retry transformation again
                    isForSource.reset();
                    transformer.reset();
                    transformer.transform(transformSrc, transformTgt);

                } catch (IOException e) {
                    handleException(""Error using a temporary file/s for the transformation"", e, synCtx);
                }
            }

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Transformation completed - processing result"");
            }

            if (tempSourceFile != null) {
                boolean deleted = tempSourceFile.delete();
                if (!deleted) {
                    tempSourceFile.deleteOnExit();
                }
            }

            // get the result OMElement
            OMElement result = null;
            if (transformTgt instanceof DOMResult) {
                Node node = ((DOMResult) transformTgt).getNode();
                if (node == null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, (""Transformation result (DOMResult) was null""));
                    }
                    return;
                }
                Node resultNode = node.getFirstChild();
                if (resultNode == null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, (""Transformation result (DOMResult) was empty""));
                    }
                    return;
                }

                result = ElementHelper.importOMElement(
                    (OMElement) resultNode, OMAbstractFactory.getOMFactory());

            } else {

                // if we used a temporary file for the output of the transformation, read from it
                if (tempTargetFile != null) {
                    try {
                        StAXOMBuilder builder = new StAXOMBuilder(new FileInputStream(tempTargetFile));
                        result = builder.getDocumentElement();

                    } catch (XMLStreamException e) {
                        handleException(
                            ""Error building result element from XSLT transformation"", e, synCtx);

                    } catch (Exception e) {
                        result = handleNonXMLResult(tempTargetFile, traceOrDebugOn, traceOn);

                    } finally {
                        boolean deleted = tempTargetFile.delete();
                        if (!deleted) {
                            tempTargetFile.deleteOnExit();
                        }
                    }

                } else {
                    // read the Fixed byte array stream
                    try {
                        StAXOMBuilder builder = new StAXOMBuilder(
                            new ByteArrayInputStream(baosForTarget.toByteArray()));
                        result = builder.getDocumentElement();

                    } catch (XMLStreamException e) {
                        handleException(
                            ""Error building result element from XSLT transformation"", e, synCtx);

                    } catch (Exception e) {
                        result = handleNonXMLResult(baosForTarget.toString(), traceOrDebugOn, traceOn);
                    }
                }
            }

            if (result == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Transformation result was null"");
                }
                return;
            } else {
                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Transformation result : "" + result.toString());
                }
            }

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Replace source node with result"");
            }

            // replace the sourceNode with the result.
            sourceNode.insertSiblingAfter(result);
            sourceNode.detach();

        } catch (TransformerException e) {
            handleException(""Error performing XSLT transformation using : "" + xsltKey, e, synCtx);
        }
    }

    /**
     * Return the OMNode to be used for the transformation. If a source XPath is not specified,
     * this will default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which the transformation should be performed
     */
    private OMNode getTransformSource(MessageContext synCtx) {

        try {
            Object o = source.evaluate(synCtx.getEnvelope());
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                        + source + "" did not result in an OMNode"", synCtx);
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression : "" + source, e, synCtx);
        }
        return null;
    }

    public AXIOMXPath getSource() {
        return source;
    }

    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    public String getXsltKey() {
        return xsltKey;
    }

    public void setXsltKey(String xsltKey) {
        this.xsltKey = xsltKey;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }
    
    /**
     * to add a feature which need to set to the TransformerFactory
     * @param  featureName The name of the feature
     * @param isFeatureEnable should this feature enable?
     */
    
    public void addFeature(String featureName, boolean isFeatureEnable) {
        try {
            MediatorProperty mp = new MediatorProperty();
            mp.setName(featureName);
            if (isFeatureEnable) {
                mp.setValue(""true"");
            } else {
                mp.setValue(""false"");
            }
            explicitFeatures.add(mp);
            if (USE_DOM_SOURCE_AND_RESULTS.equals(featureName)) {
                useDOMSourceAndResults = isFeatureEnable;
            } else {
                transFact.setFeature(featureName, isFeatureEnable);
            }
        } catch (TransformerConfigurationException e) {
            String msg = ""Error occured when setting features to the TransformerFactory"";
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * If the transformation results in a non-XML payload, use standard wrapper elements
     * to wrap the text payload so that other mediators could still process the result
     * @param file the text payload file
     * @param traceOrDebugOn is tracing on debug logging on?
     * @param traceOn is tracing on?
     * @return an OMElement wrapping the text payload
     */
    private OMElement handleNonXMLResult(File file, boolean traceOrDebugOn, boolean traceOn) {

        OMFactory fac = OMAbstractFactory.getOMFactory();
        OMElement wrapper = null;

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Processing non SOAP/XML (text) transformation result"");
        }
        if (traceOn && trace.isTraceEnabled()) {
            trace.trace(""Wrapping text transformation result from : "" + file);
        }

        if (file != null) {
            TextFileDataSource txtFileDS = new TextFileDataSource(new FileDataSource(file));
            wrapper = new OMSourcedElementImpl(BaseConstants.DEFAULT_TEXT_WRAPPER, fac, txtFileDS);
        }

        return wrapper;
    }

    /**
     * If the transformation results in a non-XML payload, use standard wrapper elements
     * to wrap the text payload so that other mediators could still process the result
     * @param textPayload the text payload to wrap
     * @param traceOrDebugOn is tracing on debug logging on?
     * @param traceOn is tracing on?
     * @return an OMElement wrapping the text payload
     */
    private OMElement handleNonXMLResult(String textPayload, boolean traceOrDebugOn, boolean traceOn) {

        OMFactory fac = OMAbstractFactory.getOMFactory();
        OMElement wrapper = null;

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Processing non SOAP/XML (text) transformation result"");
        }
        if (traceOn && trace.isTraceEnabled()) {
            trace.trace(""Wrapping text transformation result : "" + textPayload);
        }

        if (textPayload != null) {
            OMTextImpl textData = (OMTextImpl) fac.createOMText(textPayload);
            wrapper = fac.createOMElement(BaseConstants.DEFAULT_TEXT_WRAPPER, null);
            wrapper.addChild(textData);
        }

        return wrapper;
    }

    /**
     *
     * @return Returns the features explicitly  set to the TransformerFactory through this mediator
     */
    public List getFeatures(){
        return explicitFeatures;
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }

    public void setSourceXPathString(String sourceXPathString) {
        this.sourceXPathString = sourceXPathString;
    }
}

	
"
org/apache/synapse/registry/url/SimpleURLRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry.url;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.registry.AbstractRegistry;
import org.apache.synapse.registry.Registry;
import org.apache.synapse.registry.RegistryEntry;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.*;
import java.net.*;
import java.util.ArrayList;

/**
 * A Simple HTTP GET based registry which will work with a Web Server / WebDAV
 * <p/>
 * This saves the root server URL, and appends the a given key to construct the
 * full URL to locate resources
 */
public class SimpleURLRegistry extends AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(SimpleURLRegistry.class);

    private static final int MAX_KEYS = 200;

    public OMNode lookup(String key) {

        log.info(""==> Repository fetch of resource with key : "" + key);
        URLConnection urlc = null;
        try {
            URL url = SynapseConfigUtils.getURLFromPath(getRoot() + key);
            if (url == null) {
                return null;
            }
            urlc = url.openConnection();
            urlc.connect();
        } catch (IOException e) {
            return null;
        }

        try {
            XMLStreamReader parser = XMLInputFactory.newInstance().
                    createXMLStreamReader(urlc.getInputStream());
            StAXOMBuilder builder = new StAXOMBuilder(parser);
            return builder.getDocumentElement();

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + getRoot() + key, e);
        } catch (FileNotFoundException fnf) {
            return null;
        } catch (IOException e) {
            handleException(""IO Error reading from URL "" + getRoot() + key, e);
        } catch (XMLStreamException e) {
            handleException(""XML Error reading from URL "" + getRoot() + key, e);
        }
        return null;
    }

    public RegistryEntry getRegistryEntry(String key) {
        if (log.isDebugEnabled()) {
            log.debug(""Perform RegistryEntry lookup for key : "" + key);
        }
        try {
            URL url = SynapseConfigUtils.getURLFromPath(getRoot() + key);
            if (url == null) {
                return null;
            }
            URLConnection urlc = url.openConnection();
            urlc.setReadTimeout(30000);
            urlc.setRequestProperty(""Connection"", ""Close"");

            URLRegistryEntry wre = new URLRegistryEntry();
            wre.setKey(key);
            wre.setName(url.getFile());
            wre.setType(new URI(urlc.getContentType()));
            wre.setDescription(""Resource at : "" + url.toString());
            wre.setLastModified(urlc.getLastModified());
            wre.setVersion(urlc.getLastModified());
            if (urlc.getExpiration() > 0) {
                wre.setCachableDuration(
                        urlc.getExpiration() - System.currentTimeMillis());
            } else {
                wre.setCachableDuration(getCachableDuration());
            }
            return wre;

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + getRoot() + key, e);
        } catch (IOException e) {
            handleException(""IO Error reading from URL "" + getRoot() + key, e);
        } catch (URISyntaxException e) {
            handleException(""URI Syntax error reading from URL "" + getRoot() + key, e);
        }
        return null;
    }

    public void addConfigProperty(String name, String value) {

        if (name.equals(""root"")) {

            // if the root is folder, it should always end with '/'
            // therefore, property keys do not have to begin with '/', which could be misleading
            try {
                URL url = new URL(value);
                if (url.getProtocol().equals(""file"")) {
                    if (!value.endsWith(""/"")) {
                        value = value + ""/"";
                    }
                }
            } catch (MalformedURLException e) {
                // don't do any thing if this is not a valid URL
            }
        }

        super.addConfigProperty(name, value);
    }

    public String getRoot() {
        String root = (String) properties.get(""root"");
        if (root == null) {
            return """";
        } else {
            return root;
        }
    }

    public long getCachableDuration() {
        String cachableDuration = (String) properties.get(""cachableDuration"");
        return cachableDuration == null ? 1500 : Long.parseLong(cachableDuration);
    }

    public RegistryEntry[] getChildren(RegistryEntry entry) {
        URL url;
        if (entry == null) {
            URLRegistryEntry urlEntry = new URLRegistryEntry();
            urlEntry.setKey("""");
            entry = urlEntry;
        }
        url = SynapseConfigUtils.getURLFromPath(getRoot() + entry.getKey());
        if (url == null) {
            return null;
        }
        if (url.getProtocol().equals(""file"")) {

            File file = new File(url.getFile());
            if (!file.isDirectory()) {
                return null;
            }
            InputStream inStream = null;
            try {
                inStream = (InputStream) url.getContent();

                BufferedReader reader = new BufferedReader(new InputStreamReader(inStream));
                ArrayList entryList = new ArrayList();
                String key = """";
                while ((key = reader.readLine()) != null) {
                    URLRegistryEntry registryEntry = new URLRegistryEntry();
                    if (entry.getKey().equals("""")) {
                        registryEntry.setKey(key);
                    } else {
                        if (entry.getKey().endsWith(""/"")) {
                            registryEntry.setKey(entry.getKey() + key);
                        } else {
                            registryEntry.setKey(entry.getKey() + ""/"" + key);
                        }
                    }

                    entryList.add(registryEntry);
                }

                RegistryEntry[] entries = new RegistryEntry[entryList.size()];
                for (int i = 0; i < entryList.size(); i++) {
                    entries[i] = (RegistryEntry) entryList.get(i);
                }
                return entries;

            } catch (Exception e) {
                throw new SynapseException(""Error in reading the URL."");
            }

        } else {
            throw new SynapseException(""Invalid protocol."");
        }
    }

    public RegistryEntry[] getDescendants(RegistryEntry entry) {

        ArrayList list = new ArrayList();
        RegistryEntry[] entries = getChildren(entry);
        if (entries != null) {
            for (int i = 0; i < entries.length; i++) {

                if (list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        }

        RegistryEntry[] descendants = new RegistryEntry[list.size()];
        for (int i = 0; i < list.size(); i++) {
            descendants[i] = (RegistryEntry) list.get(i);
        }

        return descendants;
    }

    private void fillDescendants(RegistryEntry parent, ArrayList list) {

        RegistryEntry[] entries = getChildren(parent);
        if (entries != null) {
            for (int i = 0; i < entries.length; i++) {

                if (list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        } else {
            list.add(parent);
        }
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/ClassMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.ClassMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * <pre>
 * &lt;class name=""class-name""&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorSerializer extends AbstractMediatorSerializer  {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ClassMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        ClassMediator mediator = (ClassMediator) m;
        OMElement clazz = fac.createOMElement(""class"", synNS);
        saveTracingState(clazz, mediator);

        if (mediator.getMediator() != null && mediator.getMediator().getClass().getName() != null) {
            clazz.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, mediator.getMediator().getClass().getName()));
        } else {
            handleException(""Invalid class mediator. The class name is required"");
        }

        Iterator itr = mediator.getProperties().keySet().iterator();
        while(itr.hasNext()) {
            String propName = (String) itr.next();
            Object o = mediator.getProperties().get(propName);
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));

            if (o instanceof String) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, (String) o));
            } else {
                prop.addChild((OMNode) o);
            }
            clazz.addChild(prop);
        }

        if (parent != null) {
            parent.addChild(clazz);
        }
        return clazz;
    }

    public String getMediatorClassName() {
        return ClassMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/builtin/RMSequenceMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Collections;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.sandesha2.client.SandeshaClientConstants;
import org.jaxen.JaxenException;

public class RMSequenceMediator extends AbstractMediator {

    private AXIOMXPath correlation = null;
    private AXIOMXPath lastMessage = null;
    private Boolean single = null;
    private String version = null;

    private static final String WSRM_SpecVersion_1_0 = ""Spec_2005_02"";
    private static final String WSRM_SpecVersion_1_1 = ""Spec_2007_02"";
    // set sequence expiry time to 5 minutes
    private static final long SEQUENCE_EXPIRY_TIME = 300000;
    private static Map sequenceMap = Collections.synchronizedMap(new HashMap());

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : RMSequence mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (!(synCtx instanceof Axis2MessageContext)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Only axis2 message contexts are supported"");
            }

        } else {
            Axis2MessageContext axis2MessageCtx = (Axis2MessageContext) synCtx;
            org.apache.axis2.context.MessageContext orgMessageCtx =
                axis2MessageCtx.getAxis2MessageContext();

            cleanupSequenceMap();

            String version = getVersionValue();
            orgMessageCtx.getOptions().setProperty(
                SynapseConstants.SANDESHA_SPEC_VERSION, version);

            if (isSingle()) {
                String sequenceID = UUIDGenerator.getUUID();
                String offeredSeqID = UUIDGenerator.getUUID();

                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.SANDESHA_SEQUENCE_KEY, sequenceID);
                orgMessageCtx.getOptions().setProperty(
                    SandeshaClientConstants.OFFERED_SEQUENCE_ID, offeredSeqID);
                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.SANDESHA_LAST_MESSAGE, ""true"");

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Using WS-RM version "" + version +
                        "" and a single message sequence : "" + sequenceID +
                        "" and offering sequence : "" + offeredSeqID);
                }

            } else {

                String correlationValue = getCorrelationValue(synCtx);
                boolean lastMessage = isLastMessage(synCtx);
                String offeredSeqID = null;

                if (!sequenceMap.containsKey(correlationValue)) {
                    offeredSeqID = UUIDGenerator.getUUID();
                    orgMessageCtx.getOptions().setProperty(
                        SandeshaClientConstants.OFFERED_SEQUENCE_ID, offeredSeqID);
                }

                String sequenceID = retrieveSequenceID(correlationValue);
                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.SANDESHA_SEQUENCE_KEY, sequenceID);

                if (lastMessage) {
                    orgMessageCtx.getOptions().setProperty(
                        SynapseConstants.SANDESHA_LAST_MESSAGE, ""true"");
                    sequenceMap.remove(correlationValue);
                }

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Correlation value : "" + correlationValue +
                        "" last message = "" + lastMessage + "" using sequence : "" + sequenceID +
                        (offeredSeqID != null ? "" offering sequence : "" + offeredSeqID : """"));
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : RMSequence mediator"");
        }
        return true;
    }

    private String retrieveSequenceID(String correlationValue) {
        String sequenceID = null;
        if (!sequenceMap.containsKey(correlationValue)) {
            sequenceID = UUIDGenerator.getUUID();
            if (log.isDebugEnabled()) {
                log.debug(""setting sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
            Entry sequenceEntry = new Entry();
            sequenceEntry.setValue(sequenceID);
            sequenceEntry.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);
            sequenceMap.put(correlationValue, sequenceEntry);
        } else {
            sequenceID = (String) ((Entry) sequenceMap.get(correlationValue)).getValue();
            if (log.isDebugEnabled()) {
                log.debug(""got sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
        }
        return sequenceID;
    }

    private String getCorrelationValue(MessageContext smc) {
        OMElement node = null;
        try {
            node = (OMElement) getCorrelation().selectSingleNode(smc.getEnvelope());

            if (node != null) {
                return node.getText();
            } else {
                handleException(""XPath expression : "" + getCorrelation() +
                    "" did not return any node"", smc);
            }

        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression to determine correlation : "" +
                getCorrelation(), e, smc);
        }
        return null; // never called
    }

    private String getVersionValue() {
        if (XMLConfigConstants.SEQUENCE_VERSION_1_1.equals(getVersion())) {
            return WSRM_SpecVersion_1_1;
        } else {
            return WSRM_SpecVersion_1_0;
        }
    }

    private boolean isLastMessage(MessageContext smc) {
        if (getLastMessage() == null) {
            return false;
        } else {
            try {
                return getLastMessage().booleanValueOf(smc.getEnvelope());
            } catch (JaxenException e) {
                handleException(""Error evaluating XPath expression to determine if last message : "" +
                    getLastMessage(), e, smc);
            }
            return false;
        }
    }

    private synchronized void cleanupSequenceMap() {
        Iterator itKey = sequenceMap.keySet().iterator();
        while (itKey.hasNext()) {
            Object key = itKey.next();
            Entry sequenceEntry = (Entry) sequenceMap.get(key);
            if (sequenceEntry.isExpired()) {
                sequenceMap.remove(key);
            }
        }
    }

    public boolean isSingle() {
        if (getSingle() != null && getSingle().booleanValue()) {
            return true;

        } else {
            return false;
        }
    }

    public AXIOMXPath getCorrelation() {
        return correlation;
    }

    public void setCorrelation(AXIOMXPath correlation) {
        this.correlation = correlation;
    }

    public AXIOMXPath getLastMessage() {
        return lastMessage;
    }

    public void setLastMessage(AXIOMXPath lastMessage) {
        this.lastMessage = lastMessage;
    }

    public Boolean getSingle() {
        return single;
    }

    public void setSingle(Boolean single) {
        this.single = single;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
}
"
org/apache/synapse/config/xml/PropertyHelper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.SynapseException;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * This class will be used as a Helper class to get the properties loaded while building the
 * Synapse Configuration from the XML
 */
public class PropertyHelper {

    /**
     * Log variable for the logging purposes
     */
    private static final Log log = LogFactory.getLog(PropertyHelper.class);

    /**
     * Find and invoke the setter method with the name of form setXXX passing in the value given
     * on the POJO object
     * @param name name of the setter field
     * @param val value to be set
     * @param obj POJO instance
     */
    public static void setInstanceProperty(String name, Object val, Object obj) {

        String mName = ""set"" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
        Method method = null;

        try {
            Method[] methods = obj.getClass().getMethods();
            boolean invoked = false;

            for (int i=0; i<methods.length; i++) {
                if (mName.equals(methods[i].getName())) {
                    Class[] params = methods[i].getParameterTypes();
                    if (params.length != 1) {
                        handleException(""Did not find a setter method named : "" + mName +
                            ""() that takes a single String, int, long, float, double "" +
                            ""or boolean parameter"");
                    } else if (val instanceof String) {
                        String value = (String) val;
                        if (params[0].equals(String.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{String.class});
                            method.invoke(obj, new String[]{value});
                        } else if (params[0].equals(int.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{int.class});
                            method.invoke(obj, new Integer[]{new Integer(value)});
                        } else if (params[0].equals(long.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{long.class});
                            method.invoke(obj, new Long[]{new Long(value)});
                        } else if (params[0].equals(float.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{float.class});
                            method.invoke(obj, new Float[]{new Float(value)});
                        } else if (params[0].equals(double.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{double.class});
                            method.invoke(obj, new Double[]{new Double(value)});
                        } else if (params[0].equals(boolean.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{boolean.class});
                            method.invoke(obj, new Boolean[]{new Boolean(value)});
                        } else {
                            handleException(""Did not find a setter method named : "" + mName +
                                ""() that takes a single String, int, long, float, double "" +
                                ""or boolean parameter"");
                        }
                    } else {
                        if (params[0].equals(OMElement.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{OMElement.class});
                            method.invoke(obj, new OMElement[]{(OMElement) val});
                        }
                    }
                    invoked = true;
                }
            }

            if (!invoked) {
                handleException(""Did not find a setter method named : "" + mName +
                    ""() that takes a single String, int, long, float, double "" +
                    ""or boolean parameter"");
            }

        } catch (Exception e) {
            handleException(""Error invoking setter method named : "" + mName +
                ""() that takes a single String, int, long, float, double "" +
                ""or boolean parameter"", e);
        }
    }

    /**
     * This method will set the static property discribed in the OMElement to the specified object.
     * This Object should have the setter method for the specified property name
     * 
     * @param property - OMElement specifying the property to be built in to the object
     * @param o - Object to which the specified property will be set.
     */
    public static void setStaticProperty(OMElement property, Object o) {

        if (property.getLocalName().toLowerCase().equals(""property"")) {

            String propertyName = property.getAttributeValue(new QName(""name""));
            String mName = ""set""
                    + Character.toUpperCase(propertyName.charAt(0))
                    + propertyName.substring(1);

            // try to set String value first
            if (property.getAttributeValue(new QName(""value"")) != null) {
                String value = property.getAttributeValue(new QName(""value""));

                try {
                    Method method = o.getClass().getMethod(mName, new Class[]{String.class});
                    if (log.isDebugEnabled()) {
                        log.debug(""Setting property :: invoking method ""
                                + mName + ""("" + value + "")"");
                    }
                    method.invoke(o, new Object[]{value});

                } catch (Exception e) {
                    handleException(""Error setting property : "" + propertyName
                            + "" as a String property into class mediator : "" + o.getClass() + "" : ""
                            + e.getMessage(), e);
                }
                
            } else {
                // now try XML child
                OMElement value = property.getFirstElement();
                if (value != null) {

                    try {
                        Method method = o.getClass().getMethod(mName, new Class[]{OMElement.class});
                        if (log.isDebugEnabled()) {
                            log.debug(""Setting property :: invoking method ""
                                    + mName + ""("" + value + "")"");
                        }
                        method.invoke(o, new Object[]{value});

                    } catch (Exception e) {
                        handleException(""Error setting property : "" + propertyName
                                + "" as an OMElement property into class mediator : ""
                                + o.getClass() + "" : "" + e.getMessage(), e);
                    }

                }

            }
        }
    }

    /**
     * This method will check the given OMElement represent either a static property or not
     * 
     * @param property - OMElement to be checked for the static property
     * @return boolean true if the elemet represents a static property element false otherwise
     */
    public static boolean isStaticProperty(OMElement property) {
        return ""property"".equals(property.getLocalName().toLowerCase())
            && (property.getAttributeValue(new QName(""expression"")) == null);
    }

    private static void handleException(String message, Throwable e) {
        log.error(message + e.getMessage());
        throw new SynapseException(message, e);
    }

    private static void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }    
}
"
org/apache/synapse/mediators/ext/POJOCommandMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.*;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axiom.om.xpath.AXIOMXPath;

import java.util.*;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * This mediator will use the specified command object and execute the command after setting
 * the properties specified to it through the configuraiton. The specified command object may or
 * may not implement the Command interface. If the Command object has not implemented the Command
 * interface then this will use reflection to find a method called execute() and execute it.
 *
 * @see org.apache.synapse.Command interface
 */
public class POJOCommandMediator extends AbstractMediator {

    /**
     * This will hold the command object to be executed
     */
    private Class command = null;

    /**
     * 'static' properties whose values are constant and does not depend
     * on the current message (i.e. and XPath over it)
     */
    private Map staticProps = new HashMap();
    /**
     * 'dynamic' properties whose values are dynamically evaluated before each
     * invocation of the command, by evaluating an XPath against the current message
     */
    private Map dynamicProps = new HashMap();

    /**
     * Implements the mediate method of the Mediator interface. This method will instantiate
     * a new instance of the POJO class, set all specified properties from the current runtime
     * state (and message context) and call the execute method of the Command object.
     *
     * @param synCtx - Synapse MessageContext to be mediated
     * @return boolean true since this will not stop exection chain
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : POJOCommand mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Creating a new instance of POJO class : "" + command.getClass());
        }

        Object commandObject = null;
        try {
            // instantiate a new command object each time
            commandObject = command.newInstance();
        } catch (Exception e) {
            handleException(""Error creating an instance of the POJO command class : "" +
                command.getClass(), e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Instance created, setting static and dynamic properties"");
        }

        // then set the static/constant properties first
        for (Iterator iter = staticProps.keySet().iterator(); iter.hasNext(); ) {
            String name = (String) iter.next();
            setInstanceProperty(name, (String) staticProps.get(name), commandObject, synCtx);
        }

        // now set the any dynamic properties evaluating XPath's on the current message
        for (Iterator iter = dynamicProps.keySet().iterator(); iter.hasNext(); ) {

            String name = (String) iter.next();
            AXIOMXPath xpath = (AXIOMXPath) dynamicProps.get(name);
            String value = Axis2MessageContext.getStringValue(xpath, synCtx);

            setInstanceProperty(name, value, commandObject, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""POJO initialized successfully, invoking the execute() method"");
        }

        // then call the execute method if the Command interface is implemented
        if (commandObject instanceof Command) {
            try {
                ((Command) commandObject).execute();
            } catch (Exception e) {
                handleException(""Error invoking POJO command class : ""
                    + command.getClass(), e, synCtx);
            }

        } else {

            Method exeMethod = null;
            try {
                exeMethod = command.getMethod(""execute"", new Class[]{});
                exeMethod.invoke(commandObject, new Object[]{});
            } catch (NoSuchMethodException e) {
                handleException(""Cannot locate an execute() method on POJO class : "" +
                    command.getClass(), e, synCtx);
            } catch (Exception e) {
                handleException(""Error invoking the execute() method on POJO class : "" +
                    command.getClass(), e, synCtx);
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : POJOCommand mediator"");
        }
        return true;
    }

    /**
     * Find and invoke the setter method with the name of form setXXX passing in the value given
     * on the POJO object
     * @param name name of the setter field
     * @param value value to be set
     * @param obj POJO instance
     * @param synCtx current message
     */
    private void setInstanceProperty(String name, String value, Object obj, MessageContext synCtx) {

        String mName = ""set"" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
        Method method = null;

        try {
            Method[] methods = obj.getClass().getMethods();
            boolean invoked = false;

            for (int i=0; i<methods.length; i++) {
                if (mName.equals(methods[i].getName())) {
                    Class[] params = methods[i].getParameterTypes();
                    if (params.length != 1) {
                        handleException(""Did not find a setter method named : "" + mName +
                            ""() that takes a single String, int, long, float, double "" +
                            ""or boolean parameter"", synCtx);
                    } else {
                        if (params[0].equals(String.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{String.class});
                            method.invoke(obj, new String[]{value});
                        } else if (params[0].equals(int.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{int.class});
                            method.invoke(obj, new Integer[]{new Integer(value)});
                        } else if (params[0].equals(long.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{long.class});
                            method.invoke(obj, new Long[]{new Long(value)});
                        } else if (params[0].equals(float.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{float.class});
                            method.invoke(obj, new Float[]{new Float(value)});
                        } else if (params[0].equals(double.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{double.class});
                            method.invoke(obj, new Double[]{new Double(value)});
                        } else if (params[0].equals(boolean.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{boolean.class});
                            method.invoke(obj, new Boolean[]{new Boolean(value)});
                        } else {
                            handleException(""Did not find a setter method named : "" + mName +
                                ""() that takes a single String, int, long, float, double "" +
                                ""or boolean parameter"", synCtx);
                        }
                    }
                    invoked = true;
                }
            }

            if (!invoked) {
                handleException(""Did not find a setter method named : "" + mName +
                    ""() that takes a single String, int, long, float, double "" +
                    ""or boolean parameter"", synCtx);
            }

        } catch (Exception e) {
            handleException(""Error invoking setter method named : "" + mName +
                ""() that takes a single String, int, long, float, double "" +
                ""or boolean parameter"", e, synCtx);
        }
    }

    public Class getCommand() {
        return command;
    }

    public void setCommand(Class command) {
        this.command = command;
    }

    public void addStaticProperty(String name, String value) {
        this.staticProps.put(name, value);
    }

    public void addDynamicProperty(String name, Object value) {
        this.dynamicProps.put(name, value);
    }

    public Map getStaticProps() {
        return this.staticProps;
    }

    public Map getDynamicProps() {
        return this.dynamicProps;
    }
}
"
org/apache/synapse/endpoints/AddressEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Stack;

/**
 * This class represents an actual endpoint to send the message. It is resposible for sending the
 * message, performing reries if a failure occured and informing the parent endpoint if a failure
 * couldn't be recovered.
 */
public class AddressEndpoint extends FaultHandler implements Endpoint {

    private static final Log log = LogFactory.getLog(AddressEndpoint.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * Determines if this endpoint is active or not. This variable have to be loaded always from the
     * memory as multiple threads could access it.
     */
    private volatile boolean active = true;

    /**
     * Stores the endpoint details for this endpoint. Details include EPR, WS-Addressing information,
     * WS-Security information, etc.
     */
    private EndpointDefinition endpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    /**
     * Leaf level endpoints will be suspended for the specified time by this variable, after a
     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to suspended forever.
     */
    private long suspendOnFailDuration = -1;

    /**
     * Time to recover a failed endpoint. Value of this is calculated when endpoint is set as
     * failed by adding suspendOnFailDuration to current time.
     */
    private long recoverOn = Long.MAX_VALUE;

    public EndpointDefinition getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(EndpointDefinition endpoint) {
        this.endpoint = endpoint;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
                recoverOn = 0;
            }
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public synchronized void setActive(boolean active, MessageContext synMessageContext) {

        // this is synchronized as recoverOn can be set to unpredictable values if two threads call
        // this method simultaneously.

        if (!active) {
            if (suspendOnFailDuration != -1) {
                recoverOn = System.currentTimeMillis() + suspendOnFailDuration;
            } else {
                recoverOn = Long.MAX_VALUE;
            }
        }

        this.active = active;
    }

    /**
     * Sends the message through this endpoint. This method just handles statistics related functions
     * and gives the message to the Synapse environment to send. It does not add any endpoint
     * specific details to the message context. These details are added only to the cloned message
     * context by the Axis2FlexibleMepClient. So that we can reuse the original message context for
     * resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Address Endpoint"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        String endPointName = this.getName();
        if (endPointName == null) {
            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        // Setting Required property to collect the End Point statistics
        boolean statisticsEnable = (SynapseConstants.STATISTICS_ON == endpoint.getStatisticsState());
        if (statisticsEnable) {
            EndPointStatisticsStack endPointStatisticsStack = null;
            Object statisticsStackObj =
                synCtx.getProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS);
            if (statisticsStackObj == null) {
                endPointStatisticsStack = new EndPointStatisticsStack();
                synCtx.setProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS,
                    endPointStatisticsStack);
            } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
            }
            if (endPointStatisticsStack != null) {
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                    !synCtx.isResponse(), statisticsEnable, isFault);
            }
        }

        if (endpoint.getAddress() != null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Sending message to endpoint : "" +
                    endPointName + "" resolves to address = "" + endpoint.getAddress());
                traceOrDebug(traceOn, ""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                    synCtx.getSoapAction() : ""null""));
                traceOrDebug(traceOn, ""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                    synCtx.getWSAAction() : ""null""));

                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Envelope : \n"" + synCtx.getEnvelope());
                }
            }
        }

        // register this as the immediate fault handler for this message.
        synCtx.pushFaultHandler(this);

        // add this as the last endpoint to process this message. it is used by statistics code.
        synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);

        synCtx.getEnvironment().send(endpoint, synCtx);
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // nothing to do as this is a leaf level endpoint
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public long getSuspendOnFailDuration() {
        return suspendOnFailDuration;
    }

    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
        this.suspendOnFailDuration = suspendOnFailDuration;
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        setActive(false, synCtx);

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return
            (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
            (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }
}
"
org/apache/synapse/registry/Registry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.synapse.config.Entry;

import java.util.Map;

/**
 * This is the interface to a Registry from Synapse.
 */
public interface Registry {

    /**
     * Perform an actual lookup for for an XML resource as an OMNode for the given key
     * @param key the key for the registry lookup
     * @return the XML content from the registry as an OMNode
     */
    public OMNode lookup(String key);

    /**
     * This is the publicly used interface to the registry. It will fetch
     * the content from the registry and cache if required.
     * @see AbstractRegistry
     *
     * @param entry the registry Entry
     * @return the value from the registry or local cache
     */
    public Object getResource(Entry entry);

    /**
     * Get the registry entry for the given key
     * @param key the registry key
     * @return The registry entry for the given key
     */
    public RegistryEntry getRegistryEntry(String key);

    /**
     * Set a configuration property on the registry. Could be used to initialize a registry
     * @param name property name
     * @param value simple String value
     */
    public void addConfigProperty(String name, String value);

    /**
     * Returns the child elements of a given registry entry
     * @param entry - parent registry entry
     * @return Array of child registry entries of the given parent registry entry
     */
    public RegistryEntry[] getChildren(RegistryEntry entry);

    /**
     * Returns all decendant entries of the given registry entry
     * @param entry - parent registry entry
     * @return Array of decendant registry entries of the given registry entry
     */
    public RegistryEntry[] getDescendants(RegistryEntry entry);

    /**
     * Return the name of the implementation class
     * @return name of the registry provider implementation class name
     */
    public String getProviderClass();

    /**
     * Return the list of configuration properties set on this instance
     * @return a Map of configuration properties
     */
    public Map getConfigProperties();
}
"
org/apache/synapse/core/axis2/ProxyServiceMessageReceiver.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This is the MessageReceiver set to act on behalf of Proxy services.
 */
public class ProxyServiceMessageReceiver extends SynapseMessageReceiver {

    private static final Log log = LogFactory.getLog(ProxyServiceMessageReceiver.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** The name of the Proxy Service */
    private String name = null;
    /** The proxy service */
    private ProxyService proxy = null;

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        boolean traceOn = proxy.getTraceState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        String remoteAddr = (String) mc.getProperty(
            org.apache.axis2.context.MessageContext.REMOTE_ADDR);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Proxy Service "" + name + "" received a new message"" +
                (remoteAddr != null ? "" from : "" + remoteAddr : ""...""));
            traceOrDebug(traceOn, (""Message To: "" +
                (mc.getTo() != null ? mc.getTo().getAddress() : ""null"")));
            traceOrDebug(traceOn, (""SOAPAction: "" +
                (mc.getSoapAction() != null ? mc.getSoapAction() : ""null"")));
            traceOrDebug(traceOn, (""WSA-Action: "" +
                (mc.getWSAAction() != null ? mc.getWSAAction() : ""null"")));

            if (traceOn && trace.isTraceEnabled()) {
                String[] cids = mc.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (int i = 0; i < cids.length; i++) {
                        trace.trace(""With attachment content ID : "" + cids[i]);
                    }
                }
                trace.trace(""Envelope : "" + mc.getEnvelope());
            }
        }

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);

        // get service log for this message and attach to the message context also set proxy name
        Log serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX + name);
        ((Axis2MessageContext) synCtx).setServiceLog(serviceLog);

        synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);
        synCtx.setTracingState(proxy.getTraceState());

        try {
            // Setting property to collect the proxy service statistics
            boolean statsOn = (SynapseConstants.STATISTICS_ON == proxy.getStatisticsState());
            if (statsOn) {
                ProxyServiceStatisticsStack proxyServiceStatisticsStack
                        = new ProxyServiceStatisticsStack();
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                proxyServiceStatisticsStack.put(name, System.currentTimeMillis(),
                        !synCtx.isResponse(), statsOn, isFault);
                synCtx.setProperty(SynapseConstants.PROXY_STATS,
                        proxyServiceStatisticsStack);
            }

            // setup fault sequence - i.e. what happens when something goes wrong with this message
            if (proxy.getTargetFaultSequence() != null) {

                Mediator faultSequence = synCtx.getSequence(proxy.getTargetFaultSequence());
                if (faultSequence != null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn,
                            ""Setting the fault-sequence to : "" + faultSequence);
                    }
                    synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(proxy.getTargetFaultSequence())));

                } else {
                    // when we can not find the reference to the fault sequence of the proxy
                    // service we should not throw an exception because still we have the global
                    // fault sequence and the message mediation can still continue
                    traceOrDebug(traceOn, ""Unable to find fault-sequence : "" +
                        proxy.getTargetFaultSequence() + ""; using default fault sequence"");
                    synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(SynapseConstants.FAULT_SEQUENCE_KEY)));
                }

            } else if (proxy.getTargetInLineFaultSequence() != null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Setting specified anonymous fault-sequence for proxy"");
                }
                synCtx.pushFaultHandler(
                    new MediatorFaultHandler(proxy.getTargetInLineFaultSequence()));
            }

            // Using inSequence for the incoming message mediation
            if (proxy.getTargetInSequence() != null) {

                Mediator inSequence = synCtx.getSequence(proxy.getTargetInSequence());
                if (inSequence != null) {
                    traceOrDebug(traceOn, ""Using sequence named : ""
                        + proxy.getTargetInSequence() + "" for incoming message mediation"");
                    inSequence.mediate(synCtx);

                } else {
                    handleException(""Unable to find in-sequence : "" + proxy.getTargetInSequence(), synCtx);
                }

            } else if (proxy.getTargetInLineInSequence() != null) {
                traceOrDebug(traceOn, ""Using the anonymous "" +
                    ""in-sequence of the proxy service for mediation"");
                proxy.getTargetInLineInSequence().mediate(synCtx);
            }

            if (proxy.getTargetEndpoint() != null) {
                Endpoint endpoint = synCtx.getEndpoint(proxy.getTargetEndpoint());

                if (endpoint != null) {
                    traceOrDebug(traceOn, ""Forwarding message to the endpoint : ""
                        + proxy.getTargetEndpoint());
                    endpoint.send(synCtx);

                } else {
                    handleException(""Unable to find the endpoint specified : "" +
                        proxy.getTargetEndpoint(), synCtx);
                }

            } else if (proxy.getTargetInLineEndpoint() != null) {
                traceOrDebug(traceOn, ""Forwarding the message to the anonymous "" +
                    ""endpoint of the proxy service"");
                proxy.getTargetInLineEndpoint().send(synCtx);
            }

        } catch (SynapseException syne) {

            if (!synCtx.getFaultStack().isEmpty()) {
                warn(traceOn, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(traceOn, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
    }

    /**
     * Set the name of the corresponding proxy service
     *
     * @param name the proxy service name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Set reference to actual proxy service
     * @param proxy
     */
    public void setProxy(ProxyService proxy) {
        this.proxy = proxy;
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }

    private void handleException(String msg, MessageContext msgContext) {
        log.error(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg);
        }
        if (proxy.getTraceState() == SynapseConstants.TRACING_ON) {
            trace.error(msg);
        }
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/ConfigurationFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.config.SynapseConfiguration;

/**
 * This interface defines the configuration factories of Synapse
 */
public interface ConfigurationFactory {

    /**
     * Get the tag QName of the element piece that will be
     * build using the factory
     *
     * @return QName describing the element
     */
    QName getTagQName();

    /**
     * Get (basically builds) the configuration of Synapse built up from
     * an OMElement using the defined factory
     *
     * @param element OMElement describing the configuration to be build
     * @return SynapseConfiguration build using the relevant factory
     */
    SynapseConfiguration getConfiguration(OMElement element);

    /**
     * Get the class which serializes the specified element
     *
     * @return Class defining the Serializer
     */
    Class getSerializerClass();
}
"
org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.context.ServiceGroupContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisServiceGroup;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.sandesha2.client.SandeshaClientConstants;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.util.MessageHelper;

import javax.xml.namespace.QName;
import java.util.ArrayList;

/**
 * This is a simple client that handles both in only and in out
 */
public class Axis2FlexibleMEPClient {

    private static final Log log = LogFactory.getLog(Axis2FlexibleMEPClient.class);

    /**
     * Based on the Axis2 client code. Sends the Axis2 Message context out and returns
     * the Axis2 message context for the response.
     *
     * Here Synapse works as a Client to the service. It would expect 200 ok, 202 ok and
     * 500 internal server error as possible responses.
     *
     * @param endpoint the endpoint being sent to, maybe null
     * @param synapseOutMessageContext the outgoing synapse message
     * @throws AxisFault on errors
     */
    public static void send(

        EndpointDefinition endpoint,
        org.apache.synapse.MessageContext synapseOutMessageContext) throws AxisFault {

        boolean separateListener    = false;
        boolean wsSecurityEnabled   = false;
        String wsSecPolicyKey       = null;
        boolean wsRMEnabled         = false;
        String wsRMPolicyKey        = null;
        boolean wsAddressingEnabled = false;

        if (endpoint != null) {
            separateListener    = endpoint.isUseSeparateListener();
            wsSecurityEnabled   = endpoint.isSecurityOn();
            wsSecPolicyKey      = endpoint.getWsSecPolicyKey();
            wsRMEnabled         = endpoint.isReliableMessagingOn();
            wsRMPolicyKey       = endpoint.getWsRMPolicyKey();
            wsAddressingEnabled = endpoint.isAddressingOn() || wsSecurityEnabled || wsRMEnabled;
        }

        if (log.isDebugEnabled()) {
            log.debug(
                ""Sending [add = "" + wsAddressingEnabled +
                ""] [sec = "" + wsSecurityEnabled +
                ""] [rm = "" + wsRMEnabled +
                (endpoint != null ?
                    ""] [ mtom = "" + endpoint.isUseMTOM() +
                    ""] [ swa = "" + endpoint.isUseSwa() +
                    ""] [ format = "" + endpoint.getFormat() +                    
                    ""] [ force soap11="" + endpoint.isForceSOAP11() +
                    ""] [ force soap12="" + endpoint.isForceSOAP12() +
                    ""; pox="" + endpoint.isForcePOX() : """") +
                ""] [ to "" + synapseOutMessageContext.getTo() + ""]"");
        }

        // save the original message context wihout altering it, so we can tie the response
        MessageContext originalInMsgCtx
            = ((Axis2MessageContext) synapseOutMessageContext).getAxis2MessageContext();

        // create a new MessageContext to be sent out as this should not corrupt the original
        // we need to create the response to the original message later on
        MessageContext axisOutMsgCtx = cloneForSend(originalInMsgCtx);

        // set all the details of the endpoint only to the cloned message context
        // so that we can use the original message context for resending through different endpoints
        if (endpoint != null) {

            if (SynapseConstants.FORMAT_POX.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(true);
                
            } else if (SynapseConstants.FORMAT_SOAP11.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(false);
                if (axisOutMsgCtx.getSoapAction() == null && axisOutMsgCtx.getWSAAction() != null) {
                    axisOutMsgCtx.setSoapAction(axisOutMsgCtx.getWSAAction());
                }
                if(!axisOutMsgCtx.isSOAP11()) {
                    SOAPUtils.convertSOAP12toSOAP11(axisOutMsgCtx);
                }
                
            } else if (SynapseConstants.FORMAT_SOAP12.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(false);
                if (axisOutMsgCtx.getSoapAction() == null && axisOutMsgCtx.getWSAAction() != null) {
                    axisOutMsgCtx.setSoapAction(axisOutMsgCtx.getWSAAction());
                }
                if(axisOutMsgCtx.isSOAP11()) {
                    SOAPUtils.convertSOAP11toSOAP12(axisOutMsgCtx);
                }                
                
            }

            if (endpoint.isUseMTOM()) {
                axisOutMsgCtx.setDoingMTOM(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingMTOM(true);

            } else if (endpoint.isUseSwa()) {
                axisOutMsgCtx.setDoingSwA(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingSwA(true);
            }

            if (endpoint.getAddress() != null) {
                axisOutMsgCtx.setTo(new EndpointReference(endpoint.getAddress()));
            }

            if (endpoint.isUseSeparateListener()) {
                axisOutMsgCtx.getOptions().setUseSeparateListener(true);
            }
        }

        if (wsAddressingEnabled) {
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.FALSE);

        } else {
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);
        }

        ConfigurationContext axisCfgCtx = axisOutMsgCtx.getConfigurationContext();
        AxisConfiguration axisCfg       = axisCfgCtx.getAxisConfiguration();

        AxisService anoymousService =
            AnonymousServiceFactory.getAnonymousService(synapseOutMessageContext.getConfiguration(),
            axisCfg, wsAddressingEnabled, wsRMEnabled, wsSecurityEnabled);
        ServiceGroupContext sgc = new ServiceGroupContext(
            axisCfgCtx, (AxisServiceGroup) anoymousService.getParent());
        ServiceContext serviceCtx = sgc.getServiceContext(anoymousService);

        boolean outOnlyMessage = ""true"".equals(
            synapseOutMessageContext.getProperty(SynapseConstants.OUT_ONLY));

        // get a reference to the DYNAMIC operation of the Anonymous Axis2 service
        AxisOperation axisAnonymousOperation = anoymousService.getOperation(
            outOnlyMessage ?
                new QName(AnonymousServiceFactory.OUT_ONLY_OPERATION) :
                new QName(AnonymousServiceFactory.OUT_IN_OPERATION));

        Options clientOptions = new Options();
        clientOptions.setUseSeparateListener(separateListener);
        // if RM is requested,
        if (wsRMEnabled) {
            // if a WS-RM policy is specified, use it
            if (wsRMPolicyKey != null) {
                clientOptions.setProperty(
                    SynapseConstants.SANDESHA_POLICY,
                    getPolicy(synapseOutMessageContext, wsRMPolicyKey));
            }
            copyRMOptions(originalInMsgCtx, clientOptions);
        }

        // if security is enabled,
        if (wsSecurityEnabled) {
            // if a WS-Sec policy is specified, use it
            if (wsSecPolicyKey != null) {
                clientOptions.setProperty(
                    SynapseConstants.RAMPART_POLICY,
                    getPolicy(synapseOutMessageContext, wsSecPolicyKey));
            }
            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (axisOutMsgCtx.getEnvelope().getHeader() == null) {
                SOAPFactory fac = axisOutMsgCtx.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(axisOutMsgCtx.getEnvelope());
            }
        }

        OperationClient mepClient = axisAnonymousOperation.createClient(serviceCtx, clientOptions);
        mepClient.addMessageContext(axisOutMsgCtx);
        axisOutMsgCtx.setAxisMessage(
            axisAnonymousOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));

        if (!outOnlyMessage) {
            // always set a callback as we decide if the send it blocking or non blocking within
            // the MEP client. This does not cause an overhead, as we simply create a 'holder'
            // object with a reference to the outgoing synapse message context
            // synapseOutMessageContext
            AsyncCallback callback = new AsyncCallback(synapseOutMessageContext);
            if (endpoint != null) {
                // set the timeout time and the timeout action to the callback, so that the
                // TimeoutHandler can detect timed out callbacks and take approprite action.
                callback.setTimeOutOn(System.currentTimeMillis() + endpoint.getTimeoutDuration());
                callback.setTimeOutAction(endpoint.getTimeoutAction());
            } else {
                callback.setTimeOutOn(System.currentTimeMillis());
            }
            mepClient.setCallback(callback);
        }

        mepClient.execute(true);

        // with the nio transport, this causes the listener not to write a 202
        // Accepted response, as this implies that Synapse does not yet know if
        // a 202 or 200 response would be written back.
        originalInMsgCtx.getOperationContext().setProperty(
            org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");
   }

    private static MessageContext cloneForSend(MessageContext ori) throws AxisFault {

        MessageContext newMC = MessageHelper.clonePartially(ori);

        newMC.setEnvelope(ori.getEnvelope());        
        removeAddressingHeaders(newMC);

        newMC.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
            ori.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS));

        return newMC;
    }

    private static void copyRMOptions(MessageContext oriContext, Options targetOptions) {
        Options oriOptions = oriContext.getOptions();
        if (oriOptions.getProperty(SynapseConstants.SANDESHA_LAST_MESSAGE) != null) {
            targetOptions.setProperty(SynapseConstants.SANDESHA_LAST_MESSAGE,
                    oriOptions.getProperty(SynapseConstants.SANDESHA_LAST_MESSAGE));
        }
        if (oriOptions.getProperty(SynapseConstants.SANDESHA_SPEC_VERSION) != null) {
            targetOptions.setProperty(SynapseConstants.SANDESHA_SPEC_VERSION,
                    oriOptions.getProperty(SynapseConstants.SANDESHA_SPEC_VERSION));
        }
        if (oriOptions.getProperty(SynapseConstants.SANDESHA_SEQUENCE_KEY) != null) {
            targetOptions.setProperty(SynapseConstants.SANDESHA_SEQUENCE_KEY,
                    oriOptions.getProperty(SynapseConstants.SANDESHA_SEQUENCE_KEY));
        }
        if (oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID) != null) {
            targetOptions.setProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID,
                    oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID));
        }
    }

    /**
     * Get the Policy object for the given name from the Synapse configuration at runtime
     * @param synCtx the current synapse configuration to get to the synapse configuration
     * @param propertyKey the name of the property which holds the Policy required
     * @return the Policy object with the given name, from the configuration
     */
    private static Policy getPolicy(org.apache.synapse.MessageContext synCtx, String propertyKey) {
        Object property = synCtx.getEntry(propertyKey);
        if (property != null && property instanceof OMElement) {
            return PolicyEngine.getPolicy((OMElement) property);
        } else {
            handleException(""Cannot locate policy from the property : "" + propertyKey);
        }
        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Removes Submission and Final WS-Addressing headers and return the SOAPEnvelope
     * from the given message context
     * @param axisMsgCtx the Axis2 Message context
     * @return the resulting SOAPEnvelope
     */
    public static SOAPEnvelope removeAddressingHeaders(MessageContext axisMsgCtx) {

        SOAPEnvelope env = axisMsgCtx.getEnvelope();
        SOAPHeader soapHeader = env.getHeader();
        ArrayList addressingHeaders;

        if (soapHeader != null) {
            addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                AddressingConstants.Submission.WSA_NAMESPACE);

            if (addressingHeaders != null && addressingHeaders.size() != 0) {
                detachAddressingInformation(addressingHeaders);

            } else {
                addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                    AddressingConstants.Final.WSA_NAMESPACE);
                if (addressingHeaders != null && addressingHeaders.size() != 0) {
                    detachAddressingInformation(addressingHeaders);
                }
            }
        }
        return env;
    }

    /**
     * Remove WS-A headers
     * @param headerInformation headers to be removed
     */
    private static void detachAddressingInformation(ArrayList headerInformation) {
        for (Object o : headerInformation) {
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                headerBlock.detach();
            } else if (o instanceof OMElement) {
                // work around for a known addressing bug which sends non SOAPHeaderBlock objects
                OMElement om = (OMElement) o;
                OMNamespace ns = om.getNamespace();
                if (ns != null && (
                    AddressingConstants.Submission.WSA_NAMESPACE.equals(ns.getNamespaceURI()) ||
                        AddressingConstants.Final.WSA_NAMESPACE.equals(ns.getNamespaceURI()))) {
                    om.detach();
                }
            }
        }
    }
}
"
org/apache/synapse/mediators/builtin/ValidateMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.Entry;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;
import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.Source;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.XMLConstants;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Validate a message or an element against a schema
 * <p/>
 * This internally uses the Xerces2-j parser, which cautions a lot about thread-safety and
 * memory leaks. Hence this initial implementation will create a single parser instance
 * for each unique mediator instance, and re-use it to validate multiple messages - even
 * concurrently - by synchronizing access
 */
public class ValidateMediator extends AbstractListMediator {

    /**
     * A list of property keys, referring to the schemas to be used for the validation
     */
    private List schemaKeys = new ArrayList();

    /**
     * An XPath expression to be evaluated against the message to find the element to be validated.
     * If this is not specified, the validation will occur against the first child element of the
     * SOAP body
     */
    private AXIOMXPath source = null;

    /**
     * A Map containing features to be passed to the actual validator (Xerces)
     */
    private List explicityFeatures = new ArrayList();

    /**
     * This is the actual schema instance used to create a new schema
     * This is a thred-safe instance.
     */
    private Schema cachedSchema;

    /**
     * Lock used to ensure thread-safe creation and use of the above Validator
     */
    private final Object validatorLock = new Object();

    /**
     * The SchemaFactory for whcih used to create new schema instance
     */
    private  SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

//    private static final String DEFAULT_XPATH = ""//s11:Envelope/s11:Body/child::*[position()=1] | "" +
//        ""//s12:Envelope/s12:Body/child::*[position()=1]"";

    public static final String DEFAULT_XPATH = ""s11:Body/child::*[position()=1] | "" +
        ""s12:Body/child::*[position()=1]"";
    
    public ValidateMediator() {
        // create the default XPath
        try {
            this.source = new AXIOMXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            String msg = ""Error creating default source XPath expression : "" + DEFAULT_XPATH;
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Validate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // Input source for the validation
        Source validateSrc = getValidationSource(synCtx, traceOrDebugOn, traceOn);

        // flag to check if we need to initialize/re-initialize the schema
        boolean reCreate = false;
        // if any of the schemas are not loaded, or have expired, load or re-load them
        for (Iterator iter = schemaKeys.iterator(); iter.hasNext();) {
            String propKey = (String) iter.next();
            Entry dp = synCtx.getConfiguration().getEntryDefinition(propKey);
            if (dp != null && dp.isDynamic()) {
                if (!dp.isCached() || dp.isExpired()) {
                    reCreate = true;       // request re-initialization of Validator
                }
            }
        }

        // This is the reference to the DefaultHandler instance
        MyErrorHandler errorHandler = new MyErrorHandler();

        // do not re-initialize schema unless required
        synchronized (validatorLock) {
            if (reCreate || cachedSchema == null) {

                factory.setErrorHandler(errorHandler);
                StreamSource[] sources = new StreamSource[schemaKeys.size()];
                int i = 0;
                for (Iterator iterator = schemaKeys.iterator(); iterator.hasNext();) {
                    String propName = (String) iterator.next();
                    sources[i++] = SynapseConfigUtils.getStreamSource(synCtx.getEntry(propName));
                }

                try {
                    cachedSchema = factory.newSchema(sources);
                } catch (SAXException e) {
                    handleException(""Error creating a new schema objects for "" +
                        ""schemas : "" + schemaKeys.toString(), e, synCtx);
                }

                if (errorHandler.isValidationError()) {
                    //reset the errorhandler state
                    errorHandler.setValidationError(false);

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Error creating a new schema objects for "" +
                            ""schemas : "" + schemaKeys.toString());
                    }
                }
            }
        }

        // no need to synchronize, schema instances are thread-safe
        try {
            Validator validator = cachedSchema.newValidator();
            validator.setErrorHandler(errorHandler);

            // perform actual validation
            validator.validate(validateSrc);

            if (errorHandler.isValidationError()) {

                if (traceOrDebugOn) {
                    String msg = ""Validation of element returned by XPath : "" + source +
                        "" failed against the given schema(s) "" + schemaKeys +
                        ""with error : "" + errorHandler.getSaxParseException().getMessage() +
                        "" Executing 'on-fail' sequence"";
                    traceOrDebug(traceOn, msg);

                    // write a warning to the service log
                    synCtx.getServiceLog().warn(msg);

                    if (traceOn && trace.isTraceEnabled()) {
                        log.debug(""Failed message envelope : "" + synCtx.getEnvelope());
                    }
                }

                // set error message and detail (stack trace) into the message context
                synCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
                    errorHandler.getSaxParseException().getMessage());
                synCtx.setProperty(SynapseConstants.ERROR_DETAIL,
                    FaultHandler.getStackTrace(errorHandler.getSaxParseException()));

                // super.mediate() invokes the ""on-fail"" sequence of mediators
                return super.mediate(synCtx);
            }
        } catch (SAXException e) {
            handleException(""Error validating "" + source + "" element"", e, synCtx);
        } catch (IOException e) {
            handleException(""Error validating "" + source + "" element"", e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Validation of element returned by the XPath expression : ""
                + source + "" succeeded against the given schemas and the current message"");
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Validate mediator"");
        }

        return true;
    }

    /**
     * Get the validation Source for the message context
     *
     * @param synCtx the current message to validate
     * @param traceOrDebugOn is tracing or debugging on?
     * @param traceOn is tracing on?
     * @return the validation Source for the current message
     */
    private Source getValidationSource(MessageContext synCtx,
        boolean traceOrDebugOn, boolean traceOn) {

        try {
            // create a byte array output stream and serialize the source node into it
            ByteArrayOutputStream baosForSource = new ByteArrayOutputStream();
            XMLStreamWriter xsWriterForSource =
                    XMLOutputFactory.newInstance().createXMLStreamWriter(baosForSource);

            // serialize the validation target and get an input stream into it
            OMNode validateSource = getValidateSource(synCtx);
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Validation source : "" + validateSource.toString());
            }
            validateSource.serialize(xsWriterForSource);

            ByteArrayInputStream baisFromSource = new ByteArrayInputStream(
                baosForSource.toByteArray());
            XMLReader reader = XMLReaderFactory.createXMLReader();
            return new SAXSource(reader, new InputSource(baisFromSource));

        } catch (Exception e) {
            handleException(""Error accessing source element : "" + source, e, synCtx);
        }
        return null; // never reaches here
    }

    /**
     * This class handles validation errors to be used for the error reporting
     */
    private class MyErrorHandler extends DefaultHandler {

        private boolean validationError = false;
        private SAXParseException saxParseException = null;

        public void error(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void fatalError(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void warning(SAXParseException exception) throws SAXException {
        }

        public boolean isValidationError() {
            return validationError;
        }

        public SAXParseException getSaxParseException() {
            return saxParseException;
        }
        
        /**
         * To set explicitly validation error condition
         * @param validationError  is occur validation error?
         */
        public void setValidationError(boolean validationError) {
            this.validationError = validationError;
        }
    }

    /**
     * Return the OMNode to be validated. If a source XPath is not specified, this will
     * default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which validation should be performed
     */
    private OMNode getValidateSource(MessageContext synCtx) {

        try {
            Object o = source.evaluate(synCtx.getEnvelope());
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                    + source + "" did not result in an OMNode : "" + o, synCtx);
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression : "" + source, e, synCtx);
        }
        return null;
    }

    // setters and getters

    /**
     * Get a mediator feature. The common use case is a feature for the
     * underlying Xerces validator
     *
     * @param key property key / feature name
     * @return property string value (usually true|false)
     */
    public Object getFeature(String key) {
        for (Iterator iter = explicityFeatures.iterator(); iter.hasNext();) {
            MediatorProperty prop = (MediatorProperty) iter.next();
            if (key.equals(prop.getName())) {
                return prop.getValue();
            }
        }
        return null;
    }

    /**
     * add a feature which need to set for the Schema Factory
     *
     * @param  featureName The name of the feature
     * @param isFeatureEnable should this feature enable?(true|false)
     * @see #getFeature(String)
     * @throws SAXException on an unknown feature
     */
   public void addFeature(String featureName, boolean isFeatureEnable) throws SAXException {
        MediatorProperty mp = new MediatorProperty();
        mp.setName(featureName);
        if (isFeatureEnable) {
            mp.setValue(""true"");
        } else {
            mp.setValue(""false"");
        }
        explicityFeatures.add(mp);
        factory.setFeature(featureName, isFeatureEnable);
    }

    /**
     * Set a list of local property names which refer to a list of schemas to be
     * used for validation
     *
     * @param schemaKeys list of local property names
     */
    public void setSchemaKeys(List schemaKeys) {
        this.schemaKeys = schemaKeys;
    }

    /**
     * Set the given XPath as the source XPath
     * @param source an XPath to be set as the source
     */
    public void setSource(AXIOMXPath source) {
       this.source = source;
    }

    /**
     * Get the source XPath which yeilds the source element for validation
     * @return the XPath which yeilds the source element for validation
     */
    public AXIOMXPath getSource() {
        return source;
    }

    /**
     * The keys for the schema resources used for validation
     * @return schema registry keys
     */
    public List getSchemaKeys() {
        return schemaKeys;
    }

    /**
     * Features for the actual Xerces validator
     * @return explicityFeatures to be passed to the Xerces validator
     */
    public List getFeatures() {
        return explicityFeatures;
    }
}
"
org/apache/synapse/config/xml/XMLConfigurationSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.core.axis2.ProxyService;

import javax.xml.stream.XMLStreamException;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

/**
 * Serialize a SynapseConfiguration into an OutputStream
 */
public class XMLConfigurationSerializer {

    private static final Log log = LogFactory.getLog(XMLConfigurationSerializer.class);

    /**
     * order of entries is irrelavant, however its nice to have some order
     * @param synCfg
     * @param outputStream
     * @throws XMLStreamException
     */
    public static void serializeConfiguration(SynapseConfiguration synCfg,
        OutputStream outputStream) throws XMLStreamException {

        log.info(""Serializing the XML Configuration to the output stream"");
        
        OMElement definitions
                = ConfigurationFactoryAndSerializerFinder.serializeConfiguration(synCfg);
        definitions.serialize(outputStream);
    }
    
}
"
org/apache/synapse/mediators/filters/FilterMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;
import org.jaxen.JaxenException;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * The filter mediator combines the regex and xpath filtering functionality. If an xpath
 * is set, it is evaluated; else the given regex is evaluated against the source xpath.
 */
public class FilterMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    private AXIOMXPath source = null;
    private Pattern regex = null;
    private AXIOMXPath xpath = null;

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Filter mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = false;
        if (test(synCtx)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, (xpath == null ?
                    ""Source : "" + source + "" against : "" + regex.pattern() + "" matches"" :
                    ""XPath expression : ""  + xpath + "" evaluates to true"") +
                    "" - executing child mediators"");
            }
            result = super.mediate(synCtx);

        } else {

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, (xpath == null ?
                    ""Source : "" + source + "" against : "" + regex.pattern() + "" does not match"" :
                    ""XPath expression : ""  + xpath + "" evaluates to false"") +
                    "" - skipping child mediators"");
            }
            result = true;
        }

        if (traceOrDebugOn) {
            trace.trace(""End : Filter mediator "");
        }
        return result;
    }

    /**
     * Tests the supplied condition after evaluation against the given XPath
     * or Regex (against a source XPath). When a regular expression is supplied
     * the source XPath is evaluated into a String value, and matched against
     * the given regex
     *
     * @param synCtx the current message for evaluation of the test condition
     * @return true if evaluation of the XPath/Regex results in true
     */
    public boolean test(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (xpath != null) {
            try {
                return xpath.booleanValueOf(synCtx.getEnvelope());
            } catch (JaxenException e) {
                handleException(""Error evaluating XPath expression : "" + xpath, e, synCtx);
            }

        } else if (source != null && regex != null) {
            String sourceString = Axis2MessageContext.getStringValue(source, synCtx);
            if (sourceString == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Source String : "" + source + "" evaluates to null"");
                }
                return false;
            }
            Matcher matcher = regex.matcher(sourceString);
            if (matcher == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Regex pattren matcher for : "" + regex.pattern() +
                        ""against source : "" + sourceString + "" is null"");
                }
                return false;
            }
            return matcher.matches();
        }

        return false; // never executes
    }


    public AXIOMXPath getSource() {
        return source;
    }

    public void setSource(AXIOMXPath source) {
        this.source = source;
    }

    public Pattern getRegex() {
        return regex;
    }

    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    public AXIOMXPath getXpath() {
        return xpath;
    }

    public void setXpath(AXIOMXPath xpath) {
        this.xpath = xpath;
    }

}
"
org/apache/synapse/startup/AbstractStartup.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup;

import org.apache.synapse.Startup;

/**
 * 
 */
public abstract class AbstractStartup implements Startup {

    /**
     * Holds the name of a Startup
     */
    protected String name = null;

    /**
     * This will return the name of the startup
     *
     * @return String representing the name
     */
    public String getName() {
        return this.name;
    }

    /**
     * This will set the name of a Startup
     *
     * @param name
     *          String name to be set to the startup
     */
    public void setName(String name) {
        this.name = name;
    }
}
"
org/apache/synapse/endpoints/FailoverEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;

import java.util.List;

/**
 * FailoverEndpoint can have multiple child endpoints. It will always try to send messages to current
 * endpoint. If the current endpoint is failing, it gets another active endpoint from the list and
 * make it the current endpoint. Then the message is sent to the current endpoint and if it fails, above
 * procedure repeats until there are no active endpoints. If all endpoints are failing and parent
 * endpoint is available, this will delegate the problem to the parent endpoint. If parent endpoint
 * is not available it will pop the next FaultHandler and delegate the problem to that.
 */
public class FailoverEndpoint implements Endpoint {

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * Determine whether this endpoint is active or not. This is active iff all child endpoints of
     * this endpoint is active. This is always loaded from the memory as it could be accessed from
     * multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * List of child endpoints. Failover sending is done among these. Any object implementing the
     * Endpoint interface can be a child.
     */
    private List endpoints = null;

    /**
     * Endpoint for which currently sending the SOAP traffic.
     */
    private Endpoint currentEndpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects. But use of
     * SALoadbalanceEndpoint as the parent is the logical scenario.
     */
    private Endpoint parentEndpoint = null;

    public void send(MessageContext synMessageContext) {

        // We have to build the envelop if we are supporting failover.
        // Failover should sent the original message multiple times if failures occur. So we have to
        // access the envelop multiple times.        
        synMessageContext.getEnvelope().build();

        if (currentEndpoint.isActive(synMessageContext)) {
            currentEndpoint.send(synMessageContext);
        } else {

            Endpoint liveEndpoint = null;
            boolean foundEndpoint = false;
            for (int i = 0; i < endpoints.size(); i++) {
                liveEndpoint = (Endpoint) endpoints.get(i);
                if (liveEndpoint.isActive(synMessageContext)) {
                    foundEndpoint = true;
                    currentEndpoint = liveEndpoint;
                    currentEndpoint.send(synMessageContext);
                    break;
                }
            }

            if (!foundEndpoint) {
                // there are no active child endpoints. so mark this endpoint as failed.
                setActive(false, synMessageContext);

                if (parentEndpoint != null) {
                    parentEndpoint.onChildEndpointFail(this, synMessageContext);
                } else {
                    Object o = synMessageContext.getFaultStack().pop();
                    if (o != null) {
                        ((FaultHandler) o).handleFault(synMessageContext);
                    }
                }
            }
        }
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            for (int i = 0; i < endpoints.size(); i++) {
                Endpoint endpoint = (Endpoint) endpoints.get(i);
                if (endpoint.isActive(synMessageContext)) {
                    active = true;

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean value is thread safe.
        this.active = active;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
        if (endpoints.size() > 0) {
            currentEndpoint = (Endpoint) endpoints.get(0);
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        send(synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }
}
"
org/apache/synapse/config/xml/StartupFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Startup;

/**
 * Defines the factories which builds startups
 */
public interface StartupFactory {

    /**
     * Create (build from OM) from the specified OMElement
     *
     * @param elem
     *          OMELement describing the Startup
     * @return Startup build from the given element
     */
    public Startup createStartup(OMElement elem);

    /**
     * Get the tag QName of the element
     *
     * @return QName of the element
     */
    public QName getTagQName();

    /**
     * Get the Serializer class for this factory
     *
     * @return Class defining the serialization of the startup
     */
    public Class getSerializerClass();
}
"
org/apache/synapse/config/xml/CloneMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.CloneMediator;
import org.apache.synapse.mediators.eip.Target;

import java.util.Iterator;

/**
 * This will serialize the CloneMediator to the xml configuration as specified bellow
 *
 * <pre>
 *  &lt;clone continueParent=(true | false)&gt;
 *   &lt;target to=""TO address"" [soapAction=""urn:Action""] sequence=""sequence ref""
 *                                                         endpoint=""endpoint ref""&gt;
 *    &lt;sequence&gt; (mediator +) &lt;/sequence&gt;
 *    &lt;endpoint&gt; endpoint &lt;/endpoint&gt;
 *   &lt;/target&gt;
 *  &lt;/iterate&gt;
 * </pre>
 */
public class CloneMediatorSerializer extends AbstractMediatorSerializer {

    /**
     * This method will implement the serializeMediator method of the MediatorSerializer interface
     * and implements the serialization of CloneMediator to its configuration
     *
     * @param parent OMElement describing the parent element to which the newlly generated
     *          clone element should be attached as a child, if provided
     * @param m Mediator of the type CloneMediator which is subjected to the serialization
     * @return OMElement serialized in to xml from the given parameters
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {

        OMElement cloneElem = fac.createOMElement(""clone"", synNS);
        saveTracingState(cloneElem, m);

        CloneMediator clone = (CloneMediator) m;
        if (clone.isContinueParent()) {
            cloneElem.addAttribute(""continueParent"", Boolean.toString(true), nullNS);
        }

        for (Iterator itr = clone.getTargets().iterator(); itr.hasNext();) {
            Object o = itr.next();
            if (o instanceof Target) {
                cloneElem.addChild(TargetSerializer.serializeTarget((Target) o));
            }
        }

        // attach the serialized element to the parent if specified
        if (parent != null) {
            parent.addChild(cloneElem);
        }

        return cloneElem;
    }

    /**
     * This method will implement the getMediatorClassName method of the
     * MediatorSerializer interface
     * 
     * @return full class name of the Mediator which is serialized by this Serializer
     */
    public String getMediatorClassName() {
        return CloneMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/FilterMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.FilterMediator;

/**
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FilterMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FilterMediator mediator = (FilterMediator) m;
        OMElement filter = fac.createOMElement(""filter"", synNS);

        if (mediator.getSource() != null && mediator.getRegex() != null) {
            filter.addAttribute(fac.createOMAttribute(
                ""source"", nullNS, mediator.getSource().toString()));
            super.serializeNamespaces(filter, mediator.getSource());

            filter.addAttribute(fac.createOMAttribute(
                ""regex"", nullNS, mediator.getRegex().pattern()));

        } else if (mediator.getXpath() != null) {
            filter.addAttribute(fac.createOMAttribute(
                ""xpath"", nullNS, mediator.getXpath().toString()));
            super.serializeNamespaces(filter, mediator.getXpath());

        } else {
            handleException(""Invalid filter mediator. "" +
                ""Should have either a 'source' and a 'regex' OR an 'xpath' "");
        }

        saveTracingState(filter, mediator);
        serializeChildren(filter, mediator.getList());

        if (parent != null) {
            parent.addChild(filter);
        }
        return filter;
    }

    public String getMediatorClassName() {
        return FilterMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/RegistryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Create an instance of the given registry, and sets properties on it.
 *
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistryFactory {

    private static final Log log = LogFactory.getLog(RegistryFactory.class);

    public static final QName PROVIDER_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""provider"");
    public static final QName PARAMETER_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter"");
    public static final QName NAME_Q     = new QName(XMLConfigConstants.NULL_NAMESPACE, ""name"");

    public static Registry createRegistry(OMElement elem) {

        OMAttribute prov = elem.getAttribute(PROVIDER_Q);
        if (prov != null) {
            try {
                Class provider = Class.forName(prov.getAttributeValue());
                Registry registry = (Registry) provider.newInstance();
                setProperties(registry, elem);
                return registry;

            } catch (ClassNotFoundException e) {
                handleException(""Cannot locate registry provider class : "" +
                    prov.getAttributeValue(), e);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            } catch (InstantiationException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            }
        } else {
            handleException(""The registry 'provider' attribute is required for a registry definition"");
        }

        return null;
    }

    private static void setProperties(Registry reg, OMElement elem) {
        Iterator params = elem.getChildrenWithName(PARAMETER_Q);
        while (params.hasNext()) {
            Object o = params.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(NAME_Q);
                String propertyValue = prop.getText();
                if (pname != null) {
                    if (propertyValue != null) {
                        reg.addConfigProperty(pname.getAttributeValue(), propertyValue.trim());
                    }
                } else {
                    handleException(""Invalid registry property - property should have a name "");
                }
            } else {
                handleException(""Invalid registry property"");
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/DBLookupMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.db.DBLookupMediator;

import javax.xml.namespace.QName;

/**
 * <dblookup>
 *   <connection>
 *     <pool>
 *      (
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     |
 *       <dsName/>
 *       <icClass/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     )
 *       <property name=""name"" value=""value""/>*
 *     </pool>
 *   </connection>
 *   <statement>
 *     <sql>select something from table where something_else = ?</sql>
 *     <parameter [value="""" | expression=""""] type=""int|string""/>*
 *     <result name=""string"" column=""int|string""/>*
 *   </statement>+
 * </dblookup>
 */
public class DBLookupMediatorFactory extends AbstractDBMediatorFactory {

    private static final QName DBLOOKUP_Q =
        new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""dblookup"");

    public Mediator createMediator(OMElement elem) {

        DBLookupMediator mediator = new DBLookupMediator();
        buildDataSource(elem, mediator);
        processStatements(elem, mediator);
        return mediator;
    }

    public QName getTagQName() {
        return DBLOOKUP_Q;
    }
}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates SALoadbalanceEndpoint from a XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <session type=""soap | ..other session types.."" />
 *    <loadbalance policy=""policy"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class SALoadbalanceEndpointFactory implements EndpointFactory {

    private static Log log = LogFactory.getLog(LoadbalanceEndpointFactory.class);

    private static SALoadbalanceEndpointFactory instance = new SALoadbalanceEndpointFactory();

    private SALoadbalanceEndpointFactory() {}

    public static SALoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    public Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms
        SALoadbalanceEndpoint loadbalanceEndpoint = new SALoadbalanceEndpoint();

        // get the session for this endpoint
        OMElement sessionElement = epConfig.
                getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""session""));
        if (sessionElement != null) {

            String type = sessionElement.getAttributeValue(new QName(""type""));

            if (type.equalsIgnoreCase(""soap"")) {
                Dispatcher soapDispatcher = new SoapSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(soapDispatcher);

            } else if (type.equalsIgnoreCase(""http"")) {
                Dispatcher httpDispatcher = new HttpSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(httpDispatcher);

            } else if (type.equalsIgnoreCase(""simpleClientSession"")) {
                Dispatcher csDispatcher = new SimpleClientSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(csDispatcher);
            }
        } else {
            handleException(""Session affinity endpoints should have a session element in the configuration."");
        }

        // set endpoint name
        OMAttribute name = epConfig.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            loadbalanceEndpoint.setName(name.getAttributeValue());
        }

        OMElement loadbalanceElement =  null;
        loadbalanceElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            // set endpoints
            ArrayList endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set abandon time
            //long abandonTime = 0;
            //OMAttribute atAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, org.apache.synapse.config.xml.Constants.RETRY_AFTER_FAILURE_TIME));
            //if(atAttribute != null) {
            //    String at = atAttribute.getAttributeValue();
            //    abandonTime = Long.parseLong(at);
            //    loadbalanceEndpoint.setAbandonTime(abandonTime);
            //}

            //long retryInterval = 30000;
            //OMAttribute riAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.RETRY_INTERVAL));
            //
            //if(riAttribute != null) {
            //    String ri = riAttribute.getAttributeValue();
            //    retryInterval = Long.parseLong(ri);
            //}

            //int maximumRetries = 0;
            //OMAttribute mrAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.MAXIMUM_RETRIES));
            //
            //if(mrAttribute != null) {
            //    String mr = mrAttribute.getAttributeValue();
            //    maximumRetries = Integer.parseInt(mr);
            //}

            return loadbalanceEndpoint;
        }

        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    private ArrayList getEndpoints(OMElement loadbalanceElement, Endpoint parent) {

        ArrayList endpoints = new ArrayList();
        Iterator iter = loadbalanceElement.getChildrenWithName
                (org.apache.synapse.config.xml.XMLConfigConstants.ENDPOINT_ELT);
        while (iter.hasNext()) {

            OMElement endptElem = (OMElement) iter.next();

            EndpointFactory epFac = EndpointAbstractFactory.getEndpointFactroy(endptElem);
            Endpoint endpoint = epFac.createEndpoint(endptElem, true);
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/POJOCommandMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ext.POJOCommandMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Class mediator using XML configuration specified
 * <p/>
 * <pre>
 * &lt;pojoCommand name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot;&gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 *   &lt;property name=&quot;string&quot; expression=&quot;XPATH expression&quot;/&gt;
 * &lt;/pojoCommand&gt;
 * </pre>
 */
public class POJOCommandMediatorFactory extends AbstractMediatorFactory {

    private static final QName POJO_COMMAND_Q =
        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""pojoCommand"");

    public Mediator createMediator(OMElement elem) {

        POJOCommandMediator pojoMediator = new POJOCommandMediator();

        // Class name of the Command object should be present
        OMAttribute name = elem.getAttribute(ATT_NAME);
        if (name == null) {
            String msg = ""The name of the actual POJO command implementation class"" +
                    "" is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        // load the class for the command object
        try {
            pojoMediator.setCommand(
                    getClass().getClassLoader().loadClass(name.getAttributeValue()));
        } catch (ClassNotFoundException e) {
            handleException(""Unable to load the class specified as the command ""
                    + name.getAttributeValue(), e);
        }

        // setting the properties to the command. these properties will be instantiated
        // at the mediation time
        for (Iterator it = elem.getChildElements(); it.hasNext();) {
            OMElement child = (OMElement) it.next();
            if(""property"".equals(child.getLocalName())) {

                String propName = child.getAttribute(ATT_NAME).getAttributeValue();
                if (propName == null) {
                    handleException(
                        ""A POJO command mediator property must specify the name attribute"");
                } else {
                    if (child.getAttribute(ATT_EXPRN) != null) {
                        AXIOMXPath xpath = null;
                        try {
                            xpath = new AXIOMXPath(
                                child.getAttribute(ATT_EXPRN).getAttributeValue());
                            OMElementUtils.addNameSpaces(xpath, child, log);
                            pojoMediator.addDynamicProperty(propName, xpath);
                        } catch (JaxenException e) {
                            handleException(""Error instantiating XPath expression : "" +
                                child.getAttribute(ATT_EXPRN), e);
                        }
                    } else {
                        if (child.getAttribute(ATT_VALUE) != null) {
                            pojoMediator.addStaticProperty(propName,
                                child.getAttribute(ATT_VALUE).getAttributeValue());
                        } else {
                            handleException(""A POJO mediator property must specify either "" +
                                ""name and expression attributes, or name and value attributes"");
                        }
                    }
                }
            }
        }

        return pojoMediator;
    }

    public QName getTagQName() {
        return POJO_COMMAND_Q;
    }

}

"
org/apache/synapse/config/xml/RMSequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;
import org.jaxen.JaxenException;

/**
 * Creates a RMSequence mediator through the supplied XML configuration
 * <p/>
 * <pre>
 * &lt;RMSequence (correlation=""xpath"" [last-message=""xpath""]) | single=""true"" [version=""1.0|1.1""]/&gt;
 * </pre>
 */
public class RMSequenceMediatorFactory extends AbstractMediatorFactory {

    private static final QName SEQUENCE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""RMSequence"");
    private static final QName ATT_CORR = new QName(""correlation"");
    private static final QName ATT_LASTMSG = new QName(""last-message"");
    private static final QName ATT_VERSION = new QName(""version"");
    private static final QName ATT_SINGLE = new QName(""single"");

    public Mediator createMediator(OMElement elem) {

        RMSequenceMediator sequenceMediator = new RMSequenceMediator();
        OMAttribute correlation = elem.getAttribute(ATT_CORR);
        OMAttribute lastMessage = elem.getAttribute(ATT_LASTMSG);
        OMAttribute single = elem.getAttribute(ATT_SINGLE);
        OMAttribute version = elem.getAttribute(ATT_VERSION);

        if (single == null && correlation == null) {
            String msg = ""The 'single' attribute value of true or a 'correlation' attribute is "" +
                ""required for the configuration of a RMSequence mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (correlation != null) {
            if (correlation.getAttributeValue() != null &&
                correlation.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for correlation"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setCorrelation(new AXIOMXPath(correlation.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute correlation : ""
                        + correlation.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(sequenceMediator.getCorrelation(), elem, log);
        }

        if (single != null) {
            sequenceMediator.setSingle(Boolean.valueOf(single.getAttributeValue()));
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getCorrelation() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);

        } else if (!sequenceMediator.isSingle() && sequenceMediator.getCorrelation() == null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence must have a ""
                + ""single attribute value of true or a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (lastMessage != null) {
            if (lastMessage.getAttributeValue() != null &&
                lastMessage.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for last-message"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setLastMessage(new AXIOMXPath(lastMessage.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute last-message : ""
                        + lastMessage.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(sequenceMediator.getLastMessage(), elem, log);
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getLastMessage() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a last-message attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (version != null) {
            if (!XMLConfigConstants.SEQUENCE_VERSION_1_0.equals(version.getAttributeValue()) &&
                !XMLConfigConstants.SEQUENCE_VERSION_1_1.equals(version.getAttributeValue())) {
                String msg = ""Only '"" + XMLConfigConstants.SEQUENCE_VERSION_1_0 + ""' or '"" +
                    XMLConfigConstants.SEQUENCE_VERSION_1_1
                    + ""' values are allowed for attribute version for a RMSequence mediator""
                    + "", Unsupported version "" + version.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            sequenceMediator.setVersion(version.getAttributeValue());
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sequenceMediator, elem);

        return sequenceMediator;
    }

    public QName getTagQName() {
        return SEQUENCE_Q;
    }
}
"
org/apache/synapse/config/xml/CloneMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.CloneMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * The &lt;clone&gt; element is used to copy messages in Synapse to simillar messages but with
 * different message contexts and mediated using the specified targets
 *
 * <pre>
 *  &lt;clone continueParent=(true | false)&gt;
 *   &lt;target to=""TO address"" [soapAction=""urn:Action""] sequence=""sequence ref""
 *                                                         endpoint=""endpoint ref""&gt;
 *    &lt;sequence&gt; (mediator +) &lt;/sequence&gt;
 *    &lt;endpoint&gt; endpoint &lt;/endpoint&gt;
 *   &lt;/target&gt;
 *  &lt;/clone&gt;
 * </pre>
 */
public class CloneMediatorFactory extends AbstractMediatorFactory {

    /**
     * This will hold the QName of the clone mediator element in the xml configuration
     */
    private static final QName CLONE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""clone"");
    private static final QName ATT_CONTPAR = new QName(""continueParent"");
    private static final QName TARGET_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * This method implements the createMediator method of the MediatorFactory interface
     * 
     * @param elem - OMElement describing the element which will be parsed
     *  to build the CloneMediator
     * @return Mediator of the type CloneMediator built from the config element
     */
    public Mediator createMediator(OMElement elem) {

        CloneMediator mediator = new CloneMediator();
        processTraceState(mediator, elem);
        
        OMAttribute continueParent = elem.getAttribute(ATT_CONTPAR);
        if (continueParent != null) {
            mediator.setContinueParent(
                    Boolean.valueOf(continueParent.getAttributeValue()).booleanValue());
        }

        Iterator targetElements = elem.getChildrenWithName(TARGET_Q);
        while (targetElements.hasNext()) {
            mediator.addTarget(TargetFactory.createTarget((OMElement) targetElements.next()));
        }

        return mediator;
    }

    /**
     * This method will implement the getTagQName method of the MediatorFactory interface
     *
     * @return QName of the clone element in xml configuraiton
     */
    public QName getTagQName() {
        return CLONE_Q;
    }
}
"
org/apache/synapse/endpoints/algorithms/RoundRobin.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import java.util.ArrayList;

/**
 * This is the implementation of the round robin load balancing algorithm. It simply iterates through
 * the endpoint list one by one for until an active endpoint is found.
 */
public class RoundRobin implements LoadbalanceAlgorithm {

    private ArrayList endpoints = null;
    private int currentEPR = 0;

    public RoundRobin(ArrayList endpoints) {
        this.endpoints = endpoints;
    }

    /**
     * Choose an active endpoint using the round robin algorithm. If there are no active endpoints
     * available, returns null.
     *
     * @param synapseMessageContext
     * @return endpoint to send the next message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext) {

        Endpoint nextEndpoint = null;
        int attempts = 0;

        do {
            // two successive clients could get the same endpoint if not synchronized.
            synchronized(this) {
                nextEndpoint = (Endpoint) endpoints.get(currentEPR);

                if(currentEPR == endpoints.size() - 1) {
                    currentEPR = 0;
                } else {
                    currentEPR++;
                }
            }

            attempts++;
            if (attempts > endpoints.size()) {
                return null;
            }

        } while (!nextEndpoint.isActive(synapseMessageContext));

        return nextEndpoint;
    }

    public void reset() {
        currentEPR = 0;
    }
}
"
org/apache/synapse/core/axis2/SynapseDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.HandlerDescription;
import org.apache.axis2.engine.AbstractDispatcher;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.synapse.SynapseConstants;

import javax.xml.namespace.QName;

/**
 * This is the Axis2 Dispatcher which is registered with the Axis2 engine. It dispatches
 * each and every message received to the SynapseMessageReceiver for processing.
 */
public class SynapseDispatcher extends AbstractDispatcher {

    public void initDispatcher() {
        QName qn = new QName(""http://synapse.apache.org"", ""SynapseDispatcher"");
        HandlerDescription hd = new HandlerDescription(qn.getLocalPart());
        super.init(hd);
    }

    public AxisService findService(MessageContext mc) throws AxisFault {
        AxisConfiguration ac = mc.getConfigurationContext().getAxisConfiguration();
        AxisService as = ac.getService(SynapseConstants.SYNAPSE_SERVICE_NAME);
        return as;
    }

    public AxisOperation findOperation(AxisService svc, MessageContext mc) throws AxisFault {
        AxisOperation ao = svc.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);
        return ao;
    }
}
"
org/apache/synapse/endpoints/WSDLEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axiom.om.OMElement;

import java.util.Stack;

/**
 * WSDLEndpoint represents the endpoints built using a wsdl document. It stores the details about
 * the endpoint in a EndpointDefinition object. Once the WSDLEndpoint object is contructed, it should
 * not access the wsdl document at runtime to obtain endpoint information. If it is neccessary to
 * create an endpoint using a dynamic wsdl, store the endpoint configuration in the registry and
 * create a dynamic wsdl endpoint using that registry key.
 * <p/>
 * TODO: This should allow variuos policies to be applied on fine grained level (e.g. operations).
 */
public class WSDLEndpoint extends FaultHandler implements Endpoint {

    private static final Log log = LogFactory.getLog(AddressEndpoint.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    private String name = null;
    private String wsdlURI;
    private OMElement wsdlDoc;
    private String serviceName;
    private String portName;

    /**
     * Leaf level endpoints will be suspended for the specified time by this variable, after a
     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to suspended forever.
     */
    private long suspendOnFailDuration = -1;

    /**
     * Time to recover a failed endpoint. Value of this is calculated when endpoint is set as
     * failed by adding suspendOnFailDuration to current time.
     */
    private long recoverOn = Long.MAX_VALUE;

    private boolean active = true;
    private Endpoint parentEndpoint = null;
    private EndpointDefinition endpoint = null;

    /**
     * Sends the message through this endpoint. This method just handles statistics related functions
     * and gives the message to the Synapse environment to send. It does not add any endpoint
     * specific details to the message context. These details are added only to the cloned message
     * context by the Axis2FlexibleMepClient. So that we can reuse the original message context for
     * resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Address Endpoint"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        String eprAddress = null;
        if (endpoint.getAddress() != null) {

            eprAddress = endpoint.getAddress();
            String endPointName = this.getName();
            if (endPointName == null) {
                endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
            }

            // Setting Required property to collect the End Point statistics
            boolean statisticsEnable =
                (SynapseConstants.STATISTICS_ON == endpoint.getStatisticsState());
            
            if (statisticsEnable) {
                EndPointStatisticsStack endPointStatisticsStack = null;
                Object statisticsStackObj =
                    synCtx.getProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS);
                if (statisticsStackObj == null) {
                    endPointStatisticsStack = new EndPointStatisticsStack();
                    synCtx.setProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS,
                        endPointStatisticsStack);
                } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                    endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
                }
                if (endPointStatisticsStack != null) {
                    boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                    endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statisticsEnable, isFault);
                }
            }
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Sending message to WSDL endpoint : "" +
                    endPointName + "" resolves to address = "" + eprAddress);
                traceOrDebug(traceOn, ""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                    synCtx.getSoapAction() : ""null""));
                traceOrDebug(traceOn, ""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                    synCtx.getWSAAction() : ""null""));

                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Envelope : \n"" + synCtx.getEnvelope());
                }
            }

            // register this as the immediate fault handler for this message.
            synCtx.pushFaultHandler(this);

            // add this as the last endpoint to process this message. it is used by statistics code.
            synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);

            synCtx.getEnvironment().send(endpoint, synCtx);
        }
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // WSDLEndpoint does not contain any child endpoints. So this method will never be called.
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public long getSuspendOnFailDuration() {
        return suspendOnFailDuration;
    }

    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
        this.suspendOnFailDuration = suspendOnFailDuration;
    }

    public String getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(String wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public OMElement getWsdlDoc() {
        return wsdlDoc;
    }

    public void setWsdlDoc(OMElement wsdlDoc) {
        this.wsdlDoc = wsdlDoc;
    }

    public String getServiceName() {
        return serviceName;
    }

    public void setServiceName(String serviceName) {
        this.serviceName = serviceName;
    }

    public String getPortName() {
        return portName;
    }

    public void setPortName(String portName) {
        this.portName = portName;
    }

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
            }
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {

        if (!active) {
            if (suspendOnFailDuration != -1) {
                recoverOn = System.currentTimeMillis() + suspendOnFailDuration;
            } else {
                recoverOn = Long.MAX_VALUE;
            }
        }

        this.active = active;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public EndpointDefinition getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(EndpointDefinition endpoint) {
        this.endpoint = endpoint;
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return
            (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
            (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }
}
"
org/apache/synapse/config/xml/EntrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import javax.xml.stream.XMLStreamConstants;
import java.net.URL;

public class EntrySerializer {

    private static Log log = LogFactory.getLog(EntrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(
            XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * Serialize the Entry object to an OMElement representing the entry
     * @param entry
     * @param parent
     * @return OMElement representing the entry
     */
    public static OMElement serializeEntry(Entry entry, OMElement parent) {
        OMElement propertyElement = fac.createOMElement(""localEntry"", synNS);
        propertyElement.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, entry.getKey().trim()));
        int type = entry.getType();
        if (type == Entry.URL_SRC) {
            URL srcUrl = entry.getSrc();
            if (srcUrl != null) {
                propertyElement.addAttribute(fac.createOMAttribute(
                        ""src"", nullNS, srcUrl.toString().trim()));
            }
        } else if (type == Entry.INLINE_XML) {
            Object value = entry.getValue();
            if (value != null && value instanceof OMElement) {
                propertyElement.addChild((OMElement) value);
            }
        } else if (type == Entry.INLINE_TEXT) {
            Object value = entry.getValue();
            if (value != null && value instanceof String) {
                OMTextImpl textData = (OMTextImpl) fac.createOMText(((String) value).trim());
                textData.setType(XMLStreamConstants.CDATA);
                propertyElement.addChild(textData);
            }
        } else if (type == Entry.REMOTE_ENTRY) {
            // nothing to serialize
            return null;
        } else {
            handleException(""Entry type undefined"");
        }
        if (parent != null) {
            parent.addChild(propertyElement);
        }
        return propertyElement;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Serializes AddressEndpoint to XML.
 *
 * <endpoint [name=""name""]>
 *  <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *  <address uri=""url"">
 *
 *    .. extensibility ..
 *
 *    <!-- Axis2 Rampart configurations : may be obsolete soon -->
 *    <parameter name=""OutflowSecurity"">
 *      ...
 *    </parameter>+
 *
 *    <!-- Apache Sandesha configurations : may be obsolete soon -->
 *    <wsp:Policy xmlns:wsp=""http://schemas.xmlsoap.org/ws/2004/09/policy""..
 *      xmlns:wsrm=""http://ws.apache.org/sandesha2/policy"" wsu:Id=""RMPolicy"">
 *      ...
 *    </Policy>+
 *
 *    <enableRM/>+
 *    <enableSec/>+
 *    <enableAddressing/>+
 *
 *    <timeout>
 *      <duration>duration in milliseconds</duration>
 *      <action>discard | fault</action>
 *    </timeout>
 *
 *  </address>
 * </endpoint>
 */
public class AddressEndpointSerializer implements EndpointSerializer {

    private static Log log = LogFactory.getLog(AddressEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof AddressEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        AddressEndpoint addressEndpoint = (AddressEndpoint) endpoint;
        String name = addressEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        EndpointDefinition epAddress = addressEndpoint.getEndpoint();
        OMElement addressElement = serializeEndpointDefinition(epAddress);
        endpointElement.addChild(addressElement);

        long suspendDuration = addressEndpoint.getSuspendOnFailDuration();
        if (suspendDuration != -1) {
            // user has set some value for this. let's serialize it.

            OMElement suspendElement = fac.createOMElement(
                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE,
                    SynapseConstants.SYNAPSE_OMNAMESPACE);

            suspendElement.setText(Long.toString(suspendDuration / 1000));
            addressElement.addChild(suspendElement);
        }

        return endpointElement;
    }

    public OMElement serializeEndpointDefinition(EndpointDefinition endpt) {

        OMElement address = fac.createOMElement(""address"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        if (SynapseConstants.FORMAT_POX.equals(endpt.getFormat())) {
        	address.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
        	
        } else if (SynapseConstants.FORMAT_SOAP11.equals(endpt.getFormat())) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
        	
        } else if (SynapseConstants.FORMAT_SOAP12.equals(endpt.getFormat())) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));
        
        	// following two kept for backward compatibility
        } else if (endpt.isForcePOX()) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
            
        } else if (endpt.isForceSOAP11()) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
        } else if (endpt.isForceSOAP12()) {
            address.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));
        }
        
        if (endpt.isUseSwa()) {
            address.addAttribute(fac.createOMAttribute(""optimize"", null, ""swa""));
        } else if (endpt.isUseMTOM()) {
            address.addAttribute(fac.createOMAttribute(""optimize"", null, ""mtom""));
        }
        if (endpt.getAddress() != null) {
            address.addAttribute(fac.createOMAttribute(
                    ""uri"", null, endpt.getAddress()));
//        } else {
//            handleException(""Invalid Endpoint. Address is required"");
        }

        int isEnableStatistics = endpt.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            address.addAttribute(fac.createOMAttribute(
                    org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ATTRIB_NAME, null, statisticsValue));
        }
        if (endpt.isAddressingOn()) {
            OMElement addressing = fac.createOMElement(""enableAddressing"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpt.isUseSeparateListener()) {
                addressing.addAttribute(fac.createOMAttribute(
                        ""separateListener"", null, ""true""));
            }
            address.addChild(addressing);
        }

        if (endpt.isReliableMessagingOn()) {
            OMElement rm = fac.createOMElement(""enableRM"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpt.getWsRMPolicyKey() != null) {
                rm.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpt.getWsRMPolicyKey()));
            }
            address.addChild(rm);
        }

        if (endpt.isSecurityOn()) {
            OMElement sec = fac.createOMElement(""enableSec"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpt.getWsSecPolicyKey() != null) {
                sec.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpt.getWsSecPolicyKey()));
            }
            address.addChild(sec);
        }

        if (endpt.getTimeoutAction() != SynapseConstants.NONE) {
            OMElement timeout = fac.createOMElement(""timeout"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            address.addChild(timeout);

            OMElement duration = fac.createOMElement(""duration"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            duration.setText(Long.toString(endpt.getTimeoutDuration() / 1000));
            timeout.addChild(duration);

            OMElement action = fac.createOMElement(""action"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpt.getTimeoutAction() == SynapseConstants.DISCARD) {
                action.setText(""discard"");
            } else if (endpt.getTimeoutAction() == SynapseConstants.DISCARD_AND_FAULT) {
                action.setText(""fault"");
            }
            timeout.addChild(action);
        }

        return address;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Serializes an WSDL based endpoint to an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <suspendDurationOnFailue>suspend-duration</suspendDurationOnFailue>
 *    <wsdl uri=""wsdl uri"" service=""service name"" port=""port name"">
 *       .. extensibility ..
 *    </wsdl>
 * </endpoint>
 */
public class WSDLEndpointSerializer implements EndpointSerializer {

    private static Log log = LogFactory.getLog(WSDLEndpointSerializer.class);

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof WSDLEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        WSDLEndpoint wsdlEndpoint = (WSDLEndpoint) endpoint;
        String name = wsdlEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement wsdlElement = fac.createOMElement(""wsdl"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        String serviceName = wsdlEndpoint.getServiceName();
        if (serviceName != null) {
            wsdlElement.addAttribute(""service"", serviceName, null);
        }

        String portName = wsdlEndpoint.getPortName();
        if (portName != null) {
            wsdlElement.addAttribute(""port"", portName, null);
        }

        String uri = wsdlEndpoint.getWsdlURI();
        if (uri != null) {
            wsdlElement.addAttribute(""uri"", uri, null);
        }

        OMElement wsdlDoc = wsdlEndpoint.getWsdlDoc();
        if (wsdlDoc != null) {
            wsdlElement.addChild(wsdlDoc);
        }

        long suspendDuration = wsdlEndpoint.getSuspendOnFailDuration();
        if (suspendDuration != -1) {
            // user has set some value for this. let's serialize it.

            OMElement suspendElement = fac.createOMElement(
                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE,
                    SynapseConstants.SYNAPSE_OMNAMESPACE);

            suspendElement.setText(Long.toString(suspendDuration / 1000));
            wsdlElement.addChild(suspendElement);
        }

        // currently, we have to get QOS information from the endpoint definition and set them as
        // special elements under the wsdl element. in future, these information should be
        // extracted from the wsdl.
        EndpointDefinition epAddress = wsdlEndpoint.getEndpoint();
        serializeQOSInformation(epAddress, wsdlElement);

        endpointElement.addChild(wsdlElement);

        return endpointElement;
    }

    public void serializeQOSInformation
            (EndpointDefinition endpointDefinition, OMElement wsdlElement) {

        if (SynapseConstants.FORMAT_POX.equals(endpointDefinition.getFormat())) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
            
        } else if (SynapseConstants.FORMAT_SOAP11.equals(endpointDefinition.getFormat())) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
            
        } else if (SynapseConstants.FORMAT_SOAP12.equals(endpointDefinition.getFormat())) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));
        
            // following two kept for backward compatibility
        } else if (endpointDefinition.isForcePOX()) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
            
        } else if (endpointDefinition.isForceSOAP11()) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
        } else if (endpointDefinition.isForceSOAP12()) {
            wsdlElement.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));
        }
        
        int isEnableStatistics = endpointDefinition.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            wsdlElement.addAttribute(fac.createOMAttribute(
                    org.apache.synapse.config.xml.XMLConfigConstants.STATISTICS_ATTRIB_NAME, null, statisticsValue));
        }
        if (endpointDefinition.isAddressingOn()) {
            OMElement addressing = fac.createOMElement(""enableAddressing"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.isUseSeparateListener()) {
                addressing.addAttribute(fac.createOMAttribute(
                        ""separateListener"", null, ""true""));
            }
            wsdlElement.addChild(addressing);
        }

        if (endpointDefinition.isReliableMessagingOn()) {
            OMElement rm = fac.createOMElement(""enableRM"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getWsRMPolicyKey() != null) {
                rm.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsRMPolicyKey()));
            }
            wsdlElement.addChild(rm);
        }

        if (endpointDefinition.isSecurityOn()) {
            OMElement sec = fac.createOMElement(""enableSec"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getWsSecPolicyKey() != null) {
                sec.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsSecPolicyKey()));
            }
            wsdlElement.addChild(sec);
        }

        if (endpointDefinition.getTimeoutAction() != SynapseConstants.NONE) {
            OMElement timeout = fac.createOMElement(""timeout"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            wsdlElement.addChild(timeout);

            OMElement duration = fac.createOMElement(""duration"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            duration.setText(Long.toString(endpointDefinition.getTimeoutDuration() / 1000));
            timeout.addChild(duration);

            OMElement action = fac.createOMElement(""action"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getTimeoutAction() == SynapseConstants.DISCARD) {
                action.setText(""discard"");
            } else if (endpointDefinition.getTimeoutAction() == SynapseConstants.DISCARD_AND_FAULT) {
                action.setText(""fault"");
            }
            timeout.addChild(action);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/endpoints/LoadbalanceEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;

import java.util.ArrayList;
import java.util.List;

/**
 * Load balance endpoint can have multiple endpoints. It will route messages according to the
 * specified loadbalance algorithm. This will assume that all immediate child endpoints are identical
 * in state (state is replicated) or state is not maintained at those endpoints. If an endpoint is
 * failing, the failed endpoint is marked as inactive and the message to the next endpoint obtained
 * using the loadbalance algorithm. If all the endpoints have failed and the parent endpoint is
 * available, onChildEndpointFail(...) methos of parent endpoint is called. If parent is not
 * avialable, this will call next FaultHandler for the message context.
 */
public class LoadbalanceEndpoint implements Endpoint {

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the load. Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

    /**
     * Determine whether this endpoint is active or not. This is active iff all child endpoints of
     * this endpoint is active. This is always loaded from the memory as it could be accessed from
     * multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * If this supports load balancing with failover. If true, request will be directed to the next
     * endpoint if the current one is failing.
     */
    private boolean failover = true;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    public void send(MessageContext synMessageContext) {

        Endpoint endpoint = algorithm.getNextEndpoint(synMessageContext);
        if (endpoint != null) {

            // We have to build the envelop if we are supporting failover.
            // Failover should sent the original message multiple times if failures occur. So we have to
            // access the envelop multiple times.
            if (failover) {
                synMessageContext.getEnvelope().build();
            }

            endpoint.send(synMessageContext);

        } else {
            // there are no active child endpoints. so mark this endpoint as failed.
            setActive(false, synMessageContext);

            if (parentEndpoint != null) {
                parentEndpoint.onChildEndpointFail(this, synMessageContext);
            } else {
                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true. As this a sessionless load balancing endpoint
     * having one active child endpoint is enough to consider this as active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     *
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        if (!active) {
            for (int i = 0; i < endpoints.size(); i++) {
                Endpoint endpoint = (Endpoint) endpoints.get(i);
                if (endpoint.isActive(synMessageContext)) {
                    active = true;

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean variable is thread safe.
        this.active = active;
    }

    public boolean isFailover() {
        return failover;
    }

    public void setFailover(boolean failover) {
        this.failover = failover;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        // resend (to a different endpoint) only if we support failover
        if (failover) {
            send(synMessageContext);
        } else {
            // we are not informing this to the parent endpoint as the failure of this loadbalance
            // endpoint. there can be more active endpoints under this, and current request has
            // failed only because the currently selected child endpoint has failed AND failover is
            // turned off in this load balance endpoint. so just call the next fault handler.
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }
}
"
org/apache/synapse/config/xml/endpoints/IndirectEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;

/**
 * Serializes an IndirectEndpoint to an XML configuration.
 *
 * <endpoint key=""key"" />
 */
public class IndirectEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof IndirectEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        IndirectEndpoint indirectEndpoint = (IndirectEndpoint) endpoint;
        String ref = indirectEndpoint.getKey();
        if (ref != null) {
            endpointElement.addAttribute(""key"", ref, null);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/mediators/AbstractMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This is the superclass of all mediators, and defines common logging, tracing other aspects
 * for all mediators who extend from this.
 * elements of a mediator class.
 */
public abstract class AbstractMediator implements Mediator {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected Log log;
    /** The runtime trace log for mediators */
    protected static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** State of tracing for this mediator */
     protected int traceState = SynapseConstants.TRACING_UNSET;

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediator() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * Returns the class name of the mediator
     * @return the class name of the mediator
     */
    public String getType() {
        String cls = getClass().getName();
        int p = cls.lastIndexOf(""."");
        if (p == -1)
            return cls;
        else
            return cls.substring(p + 1);
    }

    /**
     * Returns the tracing state
     * @return the tracing state for this mediator (see SynapseConstants)
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing state variable
     * @param traceState the new tracing state for this mediator (see SynapseConstants)
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    /**
     * This method is used to save previous tracing state and set next the tracing
     * state for a child mediator
     *
     * @param synCtx current message
     */
    public void setEffectiveTraceState(MessageContext synCtx) {
        // if I have been explicitly asked to enable or disable tracing, use it and pass it on
        // else, do nothing -> i.e. let the parents state flow
        if (traceState != SynapseConstants.TRACING_UNSET) {
            synCtx.setTracingState(traceState);
        }
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param parentTraceState parents trace state
     * @return true if tracing should be performed
     */
    public boolean shouldTrace(int parentTraceState){
        return
            (traceState == SynapseConstants.TRACING_ON) ||
            (traceState == SynapseConstants.TRACING_UNSET &&
                parentTraceState == SynapseConstants.TRACING_ON);
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return
            (traceState == SynapseConstants.TRACING_ON) ||
            (traceState == SynapseConstants.TRACING_UNSET &&
                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    /**
     * Perform Trace and Debug logging of a message @WARN
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
    }

    /**
     * Perform an audit log message to all logs @ INFO. Writes to the general log, the service log
     * and the trace log (of trace is on)
     * @param msg the log message
     * @param msgContext the message context
     */
    protected void auditLog(String msg, MessageContext msgContext) {
        log.info(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().info(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.info(msg);
        }
    }

    /**
     * Perform an error log message to all logs @ ERROR. Writes to the general log, the service log
     * and the trace log (of trace is on) and throws a SynapseException
     * @param msg the log message
     * @param msgContext the message context
     */
    protected void handleException(String msg, MessageContext msgContext) {
        log.error(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.error(msg);
        }
        throw new SynapseException(msg);
    }

    /**
     * Write an audit entry at WARN and trace and standard logs @WARN
     * @param msg the message to log
     * @param msgContext message context
     */
    protected void auditWarn(String msg, MessageContext msgContext) {
        log.warn(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.warn(msg);
        }
    }

    /**
     * Perform an error log message to all logs @ ERROR. Writes to the general log, the service log
     * and the trace log (of trace is on) and throws a SynapseException
     * @param msg the log message
     * @param e an Exception encountered
     * @param msgContext the message context
     */
    protected void handleException(String msg, Exception e, MessageContext msgContext) {
        log.error(msg, e);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg, e);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.error(msg, e);
        }
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


import java.util.Iterator;

/**
 * This is factory for creating an anonymous list mediator(an unnamed list of mediators )
 *
 */

public abstract class AnonymousListMediatorFactory extends AbstractListMediatorFactory {

    /**
     * To create an anonymous list mediator form OMElement
     * @param el
     * @return List mediator
     */
    public static AnonymousListMediator createAnonymousListMediator(OMElement el) {
        AnonymousListMediator mediator = new AnonymousListMediator();
        {
            addChildren(el, mediator);
        }
        return mediator;
    }

}
"
org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

/**
 * All load balance algorithms must implement this interface. Implementations of this interface can
 * be registered in LoadbalanceManagers.
 */
public interface LoadbalanceAlgorithm {

    /**
     * This method returns the next node according to the algorithm implementation.
     *
     * @param synapseMessageContext SynapseMessageContext of the current message
     * @return Next node for directing the message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext);

    /**
     * Resets the algorithm to its initial position. Initial position depends on the implementation.
     */
    public void reset();
}
"
org/apache/synapse/config/xml/ClassMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ext.ClassMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Class mediator using XML configuration specified
 * <p/>
 * <pre>
 * &lt;class name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot;&gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorFactory extends AbstractMediatorFactory {

    private static final QName CLASS_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""class"");

    public Mediator createMediator(OMElement elem) {

        ClassMediator classMediator = new ClassMediator();

        OMAttribute name = elem.getAttribute(ATT_NAME);
        if (name == null) {
            String msg = ""The name of the actual mediator class is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        Class clazz = null;
        Mediator m = null;
        try {
            clazz = getClass().getClassLoader().loadClass(
                    name.getAttributeValue());
            m = (Mediator) clazz.newInstance();
        } catch (Exception e) {
            String msg = ""Error : "" + name.getAttributeValue();
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }

        for (Iterator it = elem.getChildrenWithName(PROP_Q); it.hasNext();) {
            OMElement child = (OMElement) it.next();

            String propName = child.getAttribute(ATT_NAME).getAttributeValue();
            if (propName == null) {
                handleException(
                    ""A Class mediator property must specify the name attribute"");
            } else {
                if (child.getAttribute(ATT_VALUE) != null) {
                    String value = child.getAttribute(ATT_VALUE).getAttributeValue();
                    classMediator.addProperty(propName, value);
                    PropertyHelper.setInstanceProperty(propName, value, m);
                } else {
                    OMNode omNode = child.getFirstOMChild();
                    if (omNode != null) {
                        classMediator.addProperty(propName, omNode);
                        PropertyHelper.setInstanceProperty(propName, omNode, m);
                    } else {
                        handleException(""A Class mediator property must specify "" +
                            ""name and value attributes, or a name and a child XML fragment"");
                    }
                }
            }
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        classMediator.setMediator(m);
        processTraceState(classMediator, elem);

        return classMediator;
    }

    public QName getTagQName() {
        return CLASS_Q;
    }
}
"
org/apache/synapse/config/xml/DBReportMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.db.DBReportMediator;

import javax.xml.namespace.QName;

/**
 * <dbreport>
 *   <connection>
 *     <pool>
 *       (
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     |
 *       <dsName/>
 *       <icClass/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     )
 *       <property name=""name"" value=""value""/>*
 *     </pool>
 *   </connection>
 *   <statement>
 *     <sql>insert into table values (?, ?, ..)</sql>
 *     <parameter [value="""" | expression=""""] type=""int|string""/>*
 *   </statement>+
 * </dbreport>
 */
public class DBReportMediatorFactory extends AbstractDBMediatorFactory {

    private static final QName DBREPORT_Q =
        new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""dbreport"");

    public Mediator createMediator(OMElement elem) {
        DBReportMediator mediator = new DBReportMediator();
        buildDataSource(elem, mediator);
        processStatements(elem, mediator);
        return mediator;
    }

    public QName getTagQName() {
        return DBREPORT_Q;
    }
}
"
org/apache/synapse/config/xml/InMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

public class InMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof InMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        InMediator mediator = (InMediator) m;
        OMElement in = fac.createOMElement(""in"", synNS);
        saveTracingState(in,mediator);

        serializeChildren(in, mediator.getList());

        if (parent != null) {
            parent.addChild(in);
        }
        return in;
    }

    public String getMediatorClassName() {
        return InMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/IterateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.IterateMediator;

/**
 * This class will be acting as the serializer for the IterateMediator which will convert the
 * IterateMediator instance to the following xml configuration
 *
 * <pre>
 *  &lt;iterate continueParent=(true | false) expression=""XPATH expression""&gt;
 *   &lt;target to=""TO address"" [soapAction=""urn:Action""] sequence=""sequence ref""
 *                                                         endpoint=""endpoint ref""&gt;
 *    &lt;sequence&gt; (mediator +) &lt;/sequence&gt;
 *    &lt;endpoint&gt; endpoint &lt;/endpoint&gt;
 *   &lt;/target&gt;
 *  &lt;/iterate&gt;
 * </pre>
 */
public class IterateMediatorSerializer extends AbstractMediatorSerializer {

    /**
     * This method will implement the serialization logic of the IterateMediator class to the
     * relevant xml configuration
     *
     * @param parent
     *              OMElement specifying the parent element to which the created configurtaion
     *              element will be attached
     *
     * @param m
     *          IterateMediator to be serialized
     *
     * @return OMElement describing the serialized configuration of the IterateMediator
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof IterateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        
        OMElement itrElem = fac.createOMElement(""iterate"", synNS);
        saveTracingState(itrElem, m);

        IterateMediator itrMed = (IterateMediator) m;
        if (itrMed.isContinueParent()) {
            itrElem.addAttribute(""continueParent"", Boolean.toString(true), nullNS);
        }

        if (itrMed.isPreservePayload()) {
            itrElem.addAttribute(""preservePayload"", Boolean.toString(true), nullNS);
        }

        if (itrMed.getAttachPath() != null && !""."".equals(itrMed.getAttachPath().toString())) {
            itrElem.addAttribute(""attachPath"", itrMed.getAttachPath().toString(), nullNS);
            serializeNamespaces(itrElem, itrMed.getAttachPath());
        }
        
        if (itrMed.getExpression() != null) {
            itrElem.addAttribute(""expression"", itrMed.getExpression().toString(), nullNS);
            serializeNamespaces(itrElem, itrMed.getExpression());
        } else {
            handleException(""Missing expression of the IterateMediator which is required."");
        }

        itrElem.addChild(TargetSerializer.serializeTarget(itrMed.getTarget()));

        // attach the serialized element to the parent if specified
        if (parent != null) {
            parent.addChild(itrElem);
        }

        return itrElem;
    }

    /**
     * This method implements the getMediatorClassName of the interface MediatorSerializer and
     * will be used in getting the mediator class name which will be serialized by this serializer
     *
     * @return String representing the full class name of the mediator
     */
    public String getMediatorClassName() {
        return IterateMediator.class.getName();
    }
}
"
org/apache/synapse/endpoints/SALoadbalanceEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.MessageContext;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axis2.context.OperationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * SALoadbalanceEndpoint supports session affinity based load balancing. Each of this endpoint
 * maintains a list of dispatchers. These dispatchers will be updated for both request (for client
 * initiated sessions) and response (for server initiated sessions). Once updated, each dispatcher
 * will check if has already encountered that session. If not, it will update the
 * session -> endpoint map. To update sessions for response messages, all SALoadbalanceEndpoint
 * objects are kept in a global property. When a message passes through SALoadbalanceEndpoints, each
 * endpoint appends its ""Synapse unique ID"" to the operation context. Once the response for that
 * message arrives, response sender checks first endpoint of the endpoint sequence from the operation
 * context and get that endpoint from the above mentioned global property. Then it will invoke
 * updateSession(...) method of that endpoint. After that, each endpoint will call updateSession(...)
 * method of their appropriate child endpoint, so that all the sending endpoints for the session will
 * be updated.
 *
 * This endpoint gets the target endpoint first from the dispatch manager, which will ask all listed
 * dispatchers for a matching session. If a matching session is found it will just invoke the send(...)
 * method of that endpoint. If not it will find an endpoint using the loadbalance policy and send to
 * that endpoint.
 */
public class SALoadbalanceEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(SALoadbalanceEndpoint.class);

    private static final String FIRST_MESSAGE_IN_SESSION = ""first_message_in_session"";

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the first request of sessions.
     * Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

     /**
     * Determine whether this endpoint is active or not. This is always loaded from the memory as it
     * could be accessed from multiple threads simultaneously.
     */
    private volatile boolean active = true;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Although any endpoint
     * can be the parent, only SALoadbalanceEndpoint should be used here. Use of any other endpoint
     * would invalidate the session.
     */
    private Endpoint parentEndpoint = null;

    /**
     * Dispatcher used for session affinity.
     */
    private Dispatcher dispatcher = null;

    public void send(MessageContext synMessageContext) {

        Endpoint endpoint = null;

        // first check if this session is associated with a session. if so, get the endpoint
        // associated for that session.
        endpoint = dispatcher.getEndpoint(synMessageContext);
        if (endpoint == null) {

            // there is no endpoint associated with this session. get a new endpoint using the
            // load balance policy.
            endpoint = algorithm.getNextEndpoint(synMessageContext);

            // this is a start of a new session. so update session map.
            if (dispatcher.isServerInitiatedSession()) {

                // add this endpoint to the endpoint sequence of operation context.
                Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synMessageContext;
                OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
                Object o = opCtx.getProperty(""endpointList"");

                if (o != null) {
                    List endpointList = (List) o;
                    endpointList.add(this);

                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
                        endpointList.add(endpoint);
                    }

                } else {

                    // this is the first endpoint in the heirachy. so create the queue and insert
                    // this as the first element.
                    List endpointList = new ArrayList();
                    endpointList.add(this);

                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
                        endpointList.add(endpoint);
                    }

                    opCtx.setProperty(""endpointList"", endpointList);
                }

            } else {
                dispatcher.updateSession(synMessageContext, endpoint);
            }

            // this is the first request. so an endpoint has not been bound to this session and we
            // are free to failover if the currently selected endpoint is not working. but for
            // failover to work, we have to build the soap envelope.
            synMessageContext.getEnvelope().build();

            // we should also indicate that this is the first message in the session. so that
            // onFault(...) method can resend only the failed attempts for the first message.
            synMessageContext.setProperty(FIRST_MESSAGE_IN_SESSION, Boolean.TRUE);
        }

        if (endpoint != null) {

            // endpoints given by session dispatchers may not be active. therefore, we have check
            // it here.
            if (endpoint.isActive(synMessageContext)) {                
                endpoint.send(synMessageContext);
            } else {
                informFailure(synMessageContext);
            }

        } else {

            // all child endpoints have failed. so mark this also as failed.
            setActive(false, synMessageContext);
            informFailure(synMessageContext);
        }
    }

    /**
     * This will be called for the response of the first message of each server initiated session.
     *
     * @param responseMsgCtx
     * @param endpointList
     */
    public void updateSession(MessageContext responseMsgCtx, List endpointList) {

        Endpoint endpoint = (Endpoint) endpointList.remove(0);
        dispatcher.updateSession(responseMsgCtx, endpoint);
        if (endpoint instanceof SALoadbalanceEndpoint) {
            ((SALoadbalanceEndpoint) endpoint).updateSession(responseMsgCtx, endpointList);
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * This is active in below conditions:
     * If a session is not started AND at least one child endpoint is active.
     * If a session is started AND the binding endpoint is active.
     *
     * This is not active for all other conditions.
     *
     * @param synMessageContext MessageContext of the current message. This is used to determine the
     * session.
     *
     * @return true is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        // todo: implement above

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        this.active = active;
    }

    public List getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public Dispatcher getDispatcher() {
        return dispatcher;
    }

    public void setDispatcher(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    /**
     * It is logically incorrect to failover a session affinity endpoint after the session has started.
     * If we redirect a message belonging to a particular session, new endpoint is not aware of the
     * session. So we can't handle anything more at the endpoint level. Therefore, this method just
     * deactivate the failed endpoint and give the fault to the next fault handler.
     *
     * But if the session has not started (i.e. first message), the message will be resend by binding
     * it to a different endpoint.
     *
     * @param endpoint Failed endpoint.
     * @param synMessageContext MessageContext of the failed message.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        Object o = synMessageContext.getProperty(FIRST_MESSAGE_IN_SESSION);

        if (o != null && Boolean.TRUE.equals(o)) {

            // this is the first message. so unbind the sesion with failed endpoint and start
            // new one by resending.
            dispatcher.unbind(synMessageContext);
            send(synMessageContext);

        } else {

            // session has already started. we can't failover.
            informFailure(synMessageContext);
        }
    }

    private void informFailure(MessageContext synMessageContext) {

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);

        } else {

            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.PropertyMediator;
import org.jaxen.JaxenException;

/**
 * Creates a property mediator through the supplied XML configuration
 * <p/>
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"") [scope=(axis2 | axis2-client | transport)]/&gt;
 * </pre>
 */
public class PropertyMediatorFactory extends AbstractMediatorFactory {
    private static final QName ATT_SCOPE = new QName(""scope"");
    private static final QName ATT_ACTION = new QName(""action"");

    public Mediator createMediator(OMElement elem) {

        PropertyMediator propMediator = new PropertyMediator();
        OMAttribute name = elem.getAttribute(ATT_NAME);
        OMAttribute value = elem.getAttribute(ATT_VALUE);
        OMAttribute expression = elem.getAttribute(ATT_EXPRN);
        OMAttribute scope = elem.getAttribute(ATT_SCOPE);
        OMAttribute action = elem.getAttribute(ATT_ACTION);

        if (name == null) {
            String msg = ""The 'name' attribute is required for the configuration of a property mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else if ((value == null && expression == null) && !(action != null && ""remove"".equals(action.getAttributeValue()))) {
            String msg = ""Either an 'value' or 'expression' attribute is required for a property mediator when action is SET"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        propMediator.setName(name.getAttributeValue());
        if (value != null) {
            propMediator.setValue(value.getAttributeValue());
        } else if (expression != null) {
            try {
                AXIOMXPath xp = new AXIOMXPath(expression.getAttributeValue());
                OMElementUtils.addNameSpaces(xp, elem, log);
                propMediator.setExpression(xp);

            } catch (JaxenException e) {
                String msg = ""Invalid XPath expression for attribute 'expression' : "" + expression.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        if (scope != null) {
            String valueStr = scope.getAttributeValue();
            if (!XMLConfigConstants.SCOPE_AXIS2.equals(valueStr) && !XMLConfigConstants.SCOPE_TRANSPORT.equals(valueStr)
                    && !XMLConfigConstants.SCOPE_DEFAULT.equals(valueStr) && !XMLConfigConstants.SCOPE_CLIENT.equals(valueStr)) {
                String msg = ""Only '"" + XMLConfigConstants.SCOPE_AXIS2 + ""' or '"" + XMLConfigConstants.SCOPE_TRANSPORT + ""' or '"" + XMLConfigConstants.SCOPE_CLIENT
                        + ""' values are allowed for attribute scope for a property mediator""
                        + "", Unsupported scope "" + valueStr;
                log.error(msg);
                throw new SynapseException(msg);
            }
            propMediator.setScope(valueStr);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(propMediator, elem);
        // The action attribute is optional, if provided and equals to 'remove' the
        // property mediator will act as a property remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            propMediator.setAction(PropertyMediator.ACTION_REMOVE);
        }
        return propMediator;
    }

    public QName getTagQName() {
        return PROP_Q;
    }
}
"
org/apache/synapse/config/xml/StartupSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Startup;

/**
 * Defines the serialization of Startups
 */
public interface StartupSerializer {

    /**
     * Serializes the Startup to an OMElement and
     * attaches as a child to the provided parent OMElement
     *
     * @param parent  - OMElement to which, serialized startup will be attached
     * @param startup - Startup to be serialized
     * @return Serialized OMElement
     */
    public OMElement serializeStartup(OMElement parent, Startup startup);
}"
org/apache/synapse/config/xml/FilterMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.filters.FilterMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Creates a filter mediator instance
 *
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorFactory extends AbstractListMediatorFactory {

    private static final QName FILTER_Q    = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""filter"");

    public Mediator createMediator(OMElement elem) {
        FilterMediator filter = new FilterMediator();

        OMAttribute attXpath  = elem.getAttribute(ATT_XPATH);
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);
        OMAttribute attRegex  = elem.getAttribute(ATT_REGEX);

        if (attXpath != null) {
            if (attXpath.getAttributeValue() != null && attXpath.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for xpath"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    filter.setXpath(new AXIOMXPath(attXpath.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute xpath : "" + attXpath.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(filter.getXpath(), elem, log);

        } else if (attSource != null && attRegex != null) {

            if (
                (attSource.getAttributeValue() != null && attSource.getAttributeValue().trim().length() == 0) ||
                (attRegex.getAttributeValue()  != null && attRegex.getAttributeValue().trim().length() == 0) ){
                String msg = ""Invalid attribute values for source and/or regex specified"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    filter.setSource(new AXIOMXPath(attSource.getAttributeValue()));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute source : "" + attSource.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
                try {
                    filter.setRegex(Pattern.compile(attRegex.getAttributeValue()));
                } catch (PatternSyntaxException pse) {
                    String msg = ""Invalid Regular Expression for attribute regex : "" + attRegex.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
            OMElementUtils.addNameSpaces(filter.getSource(), elem, log);

        } else {
            String msg = ""An xpath or (source, regex) attributes are required for a filter"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);
        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return FILTER_Q;
    }
}
"
org/apache/synapse/mediators/filters/InMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The In Mediator acts only on ""incoming"" messages into synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class InMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : In mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = true;
        if (test(synCtx)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is incoming - executing child mediators"");
            }
            result = super.mediate(synCtx);

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is a response - skipping child mediators"");
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : In mediator"");
        }

        return result;
    }

    /**
     * Apply mediation only on request messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return !synCtx.isResponse();
    }
}
"
org/apache/synapse/mediators/MediatorWorker.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.*;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class will be used as the executer for the injectAsync method for the
 * sequence mediation
 */
public class MediatorWorker implements Runnable {

    private static final Log log = LogFactory.getLog(MediatorWorker.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** Mediator to be executed */
    private Mediator seq = null;

    /** MessageContext to be mediated using the mediator */
    private MessageContext synCtx = null;

    /**
     * Constructor of the MediatorWorker which sets the sequence and the message context
     *
     * @param seq    - Sequence Mediator to be set
     * @param synCtx - Synapse MessageContext to be set
     */
    public MediatorWorker(Mediator seq, MessageContext synCtx) {
        this.seq = seq;
        this.synCtx = synCtx;
    }

    /**
     * Constructor od the MediatorWorker which sets the provided message context and the
     * main sequence as the sequence for mediation
     *
     * @param synCtx - Synapse MessageContext to be set
     */
    public MediatorWorker(MessageContext synCtx) {
        this.synCtx = synCtx;
        seq = synCtx.getMainSequence();
    }

    /**
     * Execution method of the thread. This will just call the mediation of the specified
     * Synapse MessageContext using the specified Sequence Mediator
     */
    public void run() {
        try {
            seq.mediate(synCtx);
            ((Axis2MessageContext)synCtx).getAxis2MessageContext().getEnvelope().discard();

        } catch (SynapseException syne) {
            if (!synCtx.getFaultStack().isEmpty()) {
                warn(false, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(false, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }

        } catch (Exception e) {
            String msg = ""Unexpected error executing task"";
            log.error(msg, e);
            if (synCtx.getServiceLog() != null) {
                synCtx.getServiceLog().error(msg, e);
            }
            if (!synCtx.getFaultStack().isEmpty()) {
                warn(false, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, e);

            } else {
                warn(false, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
        synCtx = null;
        seq = null;
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }

}
"
org/apache/synapse/core/axis2/SOAPUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.soap.*;
import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import java.util.Iterator;
import java.util.List;

public class SOAPUtils {

    private static final Log log = LogFactory.getLog(SOAPUtils.class);

    /**
     * Converts the SOAP version of the message context.  Creates a new envelope of the given SOAP
     * version, copy headers and bodies from the old envelope and sets the new envelope to the same
     * message context.
     *
     * @param axisOutMsgCtx  messageContext where version conversion is done
     * @param soapVersionURI either org.apache.axis2.namespace.Constants.URI_SOAP12_ENV or
     *                       org.apache.axis2.namespace.Constants.URI_SOAP11_ENV
     * @throws AxisFault
     */
    public static void convertSoapVersion(org.apache.axis2.context.MessageContext axisOutMsgCtx,
        String soapVersionURI) throws AxisFault {

        if (org.apache.axis2.namespace.Constants.URI_SOAP12_ENV.equals(soapVersionURI)) {
            convertSOAP11toSOAP12(axisOutMsgCtx);
        } else if (org.apache.axis2.namespace.Constants.URI_SOAP11_ENV.equals(soapVersionURI)) {
            convertSOAP12toSOAP11(axisOutMsgCtx);
        } else {
            throw new SynapseException(""Invalid soapVersionURI:"" + soapVersionURI);
        }
    }

    private static String SOAP_ATR_ACTOR = ""actor"";
    private static String SOAP_ATR_ROLE = ""role"";
    private static String SOAP_ATR_MUST_UNDERSTAND = ""mustUnderstand"";

    /**
     * Converts the version of the the message context to 1.2.
     * <br />
     * <b>Message Changes:</b>
     * <ol>
     *     <li>Convert envelope, header elements</li>
     *     <li>For each header block convert attribute actor to role</li>
     *     <li>For each header block convert mustUnderstand value type</li>
     *     <li>For each header block remove 1.1 namespaced other attributes</li>
     * </ol>
     *
     * <b>Fault Changes:</b>
     * <ol>
     *     <li>Convert fault element</li>
     *     <li>faultcode to Fault/Code</li>
     *     <li>faultstring to First Fault/Reason/Text with lang=en</li>
     * </ol>
     *
     * @param axisOutMsgCtx
     * @throws AxisFault
     */
    public static void convertSOAP11toSOAP12(
        org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {

        if(log.isDebugEnabled()) {
            log.debug(""convert SOAP11 to SOAP12"");
        }
        SOAPEnvelope oldEnvelope = axisOutMsgCtx.getEnvelope();

        SOAPFactory soap12Factory = OMAbstractFactory.getSOAP12Factory();
        SOAPEnvelope newEnvelope  = soap12Factory.getDefaultEnvelope();

        if (oldEnvelope.getHeader() != null) {
            Iterator itr = oldEnvelope.getHeader().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock soapHeader = (SOAPHeaderBlock) omNode;
                    SOAPHeaderBlock newSOAPHeader = soap12Factory.createSOAPHeaderBlock(
                        soapHeader.getLocalName(), soapHeader.getNamespace());
                    Iterator allAttributes = soapHeader.getAllAttributes();

                    while(allAttributes.hasNext()) {
                        OMAttribute attr = (OMAttribute) allAttributes.next();
                        if(attr.getNamespace() != null
                            && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                            attr.getNamespace().getNamespaceURI())) {
                            String attrName = attr.getLocalName();

                            if(SOAP_ATR_ACTOR.equals(attrName)) {
                                OMAttribute newAtr = omNode.getOMFactory().createOMAttribute(
                                    SOAP_ATR_ROLE, newEnvelope.getNamespace(),
                                    attr.getAttributeValue());
                                newSOAPHeader.addAttribute(newAtr);

                            } else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {
                                boolean isMustUnderstand = soapHeader.getMustUnderstand();
                                newSOAPHeader.setMustUnderstand(isMustUnderstand);

                            } else {
                                log.warn(""removed unsupported attribute from SOAP 1.1 "" +
                                    ""namespace when converting to SOAP 1.2:"" + attrName);
                            }

                        } else {
                            newSOAPHeader.addAttribute(attr);
                        }

                        Iterator itrChildren = soapHeader.getChildren();
                        while (itrChildren.hasNext()) {
                            newSOAPHeader.addChild(((OMNode) itrChildren.next()));
                        }

                        newEnvelope.getHeader().addChild(newSOAPHeader);
                    } // while(allAttributes.hasNext())

                } else {
                    newEnvelope.getHeader().addChild(omNode);
                }

            } // while (itr.hasNext())

        } // if (oldEnvelope.getHeader() != null)

        if (oldEnvelope.getBody() != null) {

            Iterator itrBodyChildren = oldEnvelope.getBody().getChildren();
            while (itrBodyChildren.hasNext()) {
                OMNode omNode = (OMNode) itrBodyChildren.next();

                if (omNode instanceof SOAPFault) {
                    SOAPFault soapFault = (SOAPFault) omNode;
                    if(soapFault != null) {
                        SOAPFault newSOAPFault = soap12Factory.createSOAPFault();
                        newEnvelope.getBody().addChild(newSOAPFault);
                        // get the existing envelope
                        SOAPFaultCode code = soapFault.getCode();
                        if(code != null) {
                            SOAPFaultCode newSOAPFaultCode = soap12Factory.createSOAPFaultCode();
                            newSOAPFault.setCode(newSOAPFaultCode);

                            String value = code.getText();
                            if(value != null) {
                                SOAPFaultValue newSOAPFaultValue
                                    = soap12Factory.createSOAPFaultValue(newSOAPFaultCode);
                                newSOAPFaultValue.setText(value);
                            }

                        }

                        SOAPFaultReason reason = soapFault.getReason();
                        if(reason != null) {
                            SOAPFaultReason newSOAPFaultReason
                                = soap12Factory.createSOAPFaultReason(newSOAPFault);
                            String reasonText = reason.getText();
                            if(reasonText != null) {
                                SOAPFaultText newSOAPFaultText
                                    = soap12Factory.createSOAPFaultText(newSOAPFaultReason);
                                newSOAPFaultText.setLang(""en""); // hard coded
                                newSOAPFaultText.setText(reasonText);
                            }
                            newSOAPFault.setReason(newSOAPFaultReason);
                        }

                    } // if(soapFault != null)

                } else {
                    newEnvelope.getBody().addChild(omNode);

                } // if (omNode instanceof SOAPFault)

            } // while (itrBodyChildren.hasNext())

        } //if (oldEnvelope.getBody() != null)

        axisOutMsgCtx.setEnvelope(newEnvelope);
    }

    /**
     * Converts the version of the the message context to 1.1.
     * <br />
     * <b>Message Changes:</b>
     * <ol>
     *     <li>Convert envelope, header elements</li>
     *     <li>For each header block convert attribute role to actor</li>
     *     <li>For each header block convert mustUnderstand value type</li>
     *     <li>For each header block remove 1.2 namespaced other attributes</li>
     * </ol>
     *
     * <b>Fault Changes:</b>
     * <ol>
     *     <li>Convert fault element</li>
     *     <li>Fault/Code to faultcode</li>
     *     <li>First Fault/Reason/Text to faultstring</li>
     * </ol>
     * @param axisOutMsgCtx
     * @throws AxisFault
     */
    public static void convertSOAP12toSOAP11(
        org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {
        if (log.isDebugEnabled()) {
            log.debug(""convert SOAP12 to SOAP11"");
        }
        SOAPEnvelope oldEnvelope = axisOutMsgCtx.getEnvelope();

        SOAPFactory soap11Factory = OMAbstractFactory.getSOAP11Factory();
        SOAPEnvelope newEnvelope  = soap11Factory.getDefaultEnvelope();
        if (oldEnvelope.getHeader() != null) {
            Iterator itr = oldEnvelope.getHeader().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock soapHeaderBlock = (SOAPHeaderBlock) omNode;
                    SOAPHeaderBlock newSOAPHeader = soap11Factory.createSOAPHeaderBlock(
                        soapHeaderBlock.getLocalName(), soapHeaderBlock.getNamespace());

                    Iterator allAttributes = soapHeaderBlock.getAllAttributes();

                    while(allAttributes.hasNext()) {
                        OMAttribute attr = (OMAttribute) allAttributes.next();
                        if(attr.getNamespace() != null
                            && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                            attr.getNamespace().getNamespaceURI())) {
                            String attrName = attr.getLocalName();

                            if(SOAP_ATR_ROLE.equals(attrName)) {
                                OMAttribute newAtr = omNode.getOMFactory().createOMAttribute(
                                    SOAP_ATR_ACTOR, newEnvelope.getNamespace(),
                                    attr.getAttributeValue());
                                newSOAPHeader.addAttribute(newAtr);

                            } else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {
                                boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();
                                newSOAPHeader.setMustUnderstand(isMustUnderstand);

                            } else {
                                log.warn(""removed unsupported attribute from SOAP 1.2 "" +
                                    ""namespace when converting to SOAP 1.1:"" + attrName);
                            }

                        } else {
                            newSOAPHeader.addAttribute(attr);
                        }

                        Iterator itrChildren = soapHeaderBlock.getChildren();
                        while (itrChildren.hasNext()) {
                            newSOAPHeader.addChild(((OMNode) itrChildren.next()));
                        }

                        newEnvelope.getHeader().addChild(newSOAPHeader);
                    } // while(allAttributes.hasNext())

                } else {
                    newEnvelope.getHeader().addChild(omNode);
                } // if (omNode instanceof SOAPHeaderBlock)

            } // while (itr.hasNext())

        } // if (oldEnvelope.getHeader() != null)

        if (oldEnvelope.getBody() != null) {
            Iterator itr = oldEnvelope.getBody().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPFault) {

                    SOAPFault soapFault = (SOAPFault) omNode;
                    if(soapFault != null) {
                        SOAPFault newSOAPFault = soap11Factory.createSOAPFault();
                        newEnvelope.getBody().addChild(newSOAPFault);

                        SOAPFaultCode code = soapFault.getCode();
                        if(code != null) {
                            SOAPFaultCode newSOAPFaultCode
                                = soap11Factory.createSOAPFaultCode(newSOAPFault);

                            SOAPFaultValue value = code.getValue();
                            if(value != null) {
                                soap11Factory.createSOAPFaultValue(newSOAPFaultCode);
                                if(value.getText() != null) {
                                    newSOAPFaultCode.setText(value.getText());
                                }
                            }
                        }

                        SOAPFaultReason reason = soapFault.getReason();
                        if(reason != null) {
                            SOAPFaultReason newSOAPFaultReason
                                = soap11Factory.createSOAPFaultReason(newSOAPFault);

                            List allSoapTexts = reason.getAllSoapTexts();
                            Iterator iterAllSoapTexts = allSoapTexts.iterator();
                            while(iterAllSoapTexts.hasNext()) {
                                SOAPFaultText soapFaultText
                                    = (SOAPFaultText) iterAllSoapTexts.next();
                                SOAPFaultText newSOAPFaultText
                                    = soap11Factory.createSOAPFaultText(newSOAPFaultReason);
                                newSOAPFaultReason.setText(soapFaultText.getText());
                                break;
                            }
                        }

                    } // if(soapFault != null)

                } else {
                    newEnvelope.getBody().addChild(omNode);
                } // if (omNode instanceof SOAPFault)

            } // while (itr.hasNext())

        } // if (oldEnvelope.getBody() != null)
        axisOutMsgCtx.setEnvelope(newEnvelope);
    }

}"
org/apache/synapse/config/xml/AnonymousListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This is Serializer  for serialization of an anonymous list mediator(an unnamed list of mediators )
 */

public class AnonymousListMediatorSerializer extends AbstractListMediatorSerializer {

    /**
     * To serialize an  anonymous list mediator
     *
     * @param parent
     * @param m
     * @return OMElement
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {
        if (!(m instanceof AnonymousListMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        AnonymousListMediator mediator = (AnonymousListMediator) m;
        serializeChildren(parent, mediator.getList());
        return parent;
    }

    public String getMediatorClassName() {
        return AnonymousListMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.InputSource;

import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.WSDLException;
import javax.wsdl.Definition;
import javax.wsdl.Service;
import javax.wsdl.Port;
import javax.wsdl.extensions.soap.SOAPAddress;
import javax.wsdl.extensions.soap12.SOAP12Address;
import javax.wsdl.xml.WSDLReader;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.util.List;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStream;

/**
 * Builds the EndpointDefinition containing the details for an epr using a WSDL 1.1 document.
 */
public class WSDL11EndpointBuilder {

    private static Log log = LogFactory.getLog(WSDL11EndpointBuilder.class);

    /**
     * Creates an EndpointDefinition for WSDL endpoint from an inline WSDL supplied in the WSDL
     * endpoint configuration.
     *
     * @param wsdl OMElement representing the inline WSDL
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    public EndpointDefinition createEndpointDefinitionFromWSDL
            (OMElement wsdl, String service, String port) {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            wsdl.serialize(baos);
            InputStream in = new ByteArrayInputStream(baos.toByteArray());
            InputSource inputSource = new InputSource(in);
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            Definition definition = reader.readWSDL(null, inputSource);

            return createEndpointDefinitionFromWSDL(definition, service, port);

        } catch (XMLStreamException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        }

        return null;
    }

    /**
     * Creates an EndpointDefinition for WSDL endpoint from a WSDL document residing in the given URI.
     *
     * @param wsdlURI URI of the WSDL document
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String service, String port) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            Definition definition = reader.readWSDL(wsdlURI);

            return createEndpointDefinitionFromWSDL(definition, service, port);

        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the WSDL URI."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (Definition definition, String serviceName, String portName) {

        if (definition == null) {
            handleException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            handleException(""Service of the WSDL document is not specified."");
        }

        if (portName == null) {
            handleException(""Port of the WSDL document is not specified."");
        }


        String serviceURL = null;
        // get soap version from wsdl port and update endpoint definition below
        // so that correct soap version is used when endpoint is called
        String format = null; 
        String tns = definition.getTargetNamespace();
        Service service = definition.getService(new QName(tns, serviceName));
        if (service != null) {
            Port port = service.getPort(portName);
            if (port != null) {
                List ext = port.getExtensibilityElements();
                for (int i = 0; i < ext.size(); i++) {
                    Object o = ext.get(i);
                    if (o instanceof SOAPAddress) {
                        SOAPAddress address = (SOAPAddress) o;
                        serviceURL = address.getLocationURI();
                        format = SynapseConstants.FORMAT_SOAP11;
                        break;
                    } else if (o instanceof SOAP12Address) {
                        SOAP12Address address = (SOAP12Address) o;
                        serviceURL = address.getLocationURI();
                        format = SynapseConstants.FORMAT_SOAP12;
                        break;
                    }
                }
            }
        }

        if (serviceURL != null) {
            EndpointDefinition endpointDefinition = new EndpointDefinition();
            endpointDefinition.setAddress(serviceURL);
            endpointDefinition.setFormat(format);
            
            // todo: determine this using wsdl and policy                                    

            return endpointDefinition;

        } else {
            handleException(""Couldn't retrieve endpoint information from the WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/core/axis2/MessageContextCreatorForAxis2.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;

/**
 * The MessageContext needs to be set up and then is used by the SynapseMessageReceiver to inject messages.
 * This class is used by the SynapseMessageReceiver to find the environment. The env is stored in a Parameter to the Axis2 config
 */
public class MessageContextCreatorForAxis2 {

    private static final Log log = LogFactory.getLog(MessageContextCreatorForAxis2.class);

    private static SynapseConfiguration synCfg = null;
    private static SynapseEnvironment   synEnv = null;

    public static MessageContext getSynapseMessageContext(
            org.apache.axis2.context.MessageContext axisMsgCtx) throws AxisFault {

        if (synCfg == null || synEnv == null) {
            String msg = ""Synapse environment has not initialized properly.."";
            log.fatal(msg);
            throw new SynapseException(msg);
        }

        return new Axis2MessageContext(axisMsgCtx, synCfg, synEnv);
    }

    public static void setSynConfig(SynapseConfiguration synCfg) {
        MessageContextCreatorForAxis2.synCfg = synCfg;
    }

    public static void setSynEnv(SynapseEnvironment synEnv) {
        MessageContextCreatorForAxis2.synEnv = synEnv;
    }
}
"
org/apache/synapse/config/xml/DropMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

import javax.xml.namespace.QName;

/**
 * This creates a drop mediator instance
 *
 * <pre>
 * &lt;drop/&gt;
 * </pre>
 */
public class DropMediatorFactory extends AbstractMediatorFactory  {

    private static final QName DROP_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""drop"");

    public Mediator createMediator(OMElement el) {

        Mediator dropMediator = new DropMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(dropMediator,el);

        return dropMediator;
    }

    public QName getTagQName() {
        return DROP_Q;
    }
}
"
org/apache/synapse/Command.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

/**
 * This is the Command interface that will be implemented to write command objects, but it is not
 * required to implement this interface Synapse will use reflection to find an execute method as
 * a convention in the command pattern and will start the execution from the execute method
 */
public interface Command {

    /**
     * Thsi method will be implemented with a set of getters and setters for the command properties
     * in an implementation of a Command
     */
    public void execute();
}
"
org/apache/synapse/config/xml/SendMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

import javax.xml.namespace.QName;

/**
 * The Send mediator factory parses a Send element and creates an instance of the mediator
 *
 * //TODO document endpoints, failover and loadbalacing
 *
 * The &lt;send&gt; element is used to send messages out of Synapse to some endpoint. In the simplest case,
 * the place to send the message to is implicit in the message (via a property of the message itself)-
 * that is indicated by the following
 * <pre>
 *  &lt;send/&gt;
 * </pre>
 *
 * If the message is to be sent to one or more endpoints, then the following is used:
 * <pre>
 *  &lt;send&gt;
 *   (endpointref | endpoint)+
 *  &lt;/send&gt;
 * </pre>
 * where the endpointref token refers to the following:
 * <pre>
 * &lt;endpoint ref=""name""/&gt;
 * </pre>
 * and the endpoint token refers to an anonymous endpoint defined inline:
 * <pre>
 *  &lt;endpoint address=""url""/&gt;
 * </pre>
 * If the message is to be sent to an endpoint selected by load balancing across a set of endpoints,
 * then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;load-balance algorithm=""uri""&gt;
 *     (endpointref | endpoint)+
 *   &lt;/load-balance&gt;
 * &lt;/send&gt;
 * </pre>
 * Similarly, if the message is to be sent to an endpoint with failover semantics, then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;failover&gt;
 *     (endpointref | endpoint)+
 *   &lt;/failover&gt;
 * &lt;/send&gt;
 * </pre>
 */
public class SendMediatorFactory extends AbstractMediatorFactory  {

    private static final QName SEND_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""send"");
    private static final QName ENDPOINT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint"");

    public Mediator createMediator(OMElement elem) {

        SendMediator sm =  new SendMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sm,elem);

        OMElement epElement = elem.getFirstChildWithName(ENDPOINT_Q);
        if (epElement != null) {
            // get the factory for the element
            // create the endpoint and set it in the send medaitor

            EndpointFactory fac = EndpointAbstractFactory.getEndpointFactroy(epElement);
            if (fac != null) {
                Endpoint endpoint = fac.createEndpoint(epElement, true);
                if (endpoint != null) {
                    sm.setEndpoint(endpoint);
                }
            } else {
                throw new SynapseException(""Invalid endpoint fromat."");
            }
        }

        return sm;
    }

    public QName getTagQName() {
        return SEND_Q;
    }
}
"
org/apache/synapse/endpoints/dispatch/Dispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;

/**
 * Defines the behavior of session dispatchers. There can be two dispatcher types. Server intiated
 * session dispatchers and client initialted session dispatchers. In the former one, server generates
 * the session ID and sends it to the client in the first RESPONSE. In the later case, client should
 * generate the session ID and send it to the server in the first REQUEST. A dispatcher object will
 * be created for each session affinity load balance endpoint.
 */
public interface Dispatcher {

    /**
     * Dispatcher should check the session id pattern in the synapseMessageContext and return the
     * matching endpoint for that session id, if availabale. If the session id in the given
     * synapseMessageContext is not found it should return null.
     *
     * @param synCtx client -> esb message context.
     * @return Endpoint Endpoint associated with this session.
     */
    public Endpoint getEndpoint(MessageContext synCtx);
    
    /**
     * Updates the session maps. This will be called in the first client -> synapse -> server flow
     * for client initiated sessions. For server initiated sessions, this will be called in the first
     * server -> synapse -> client flow.
     *
     * @param synCtx SynapseMessageContext
     * @param endpoint Selected endpoint for this session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint);

    /**
     * Removes the session belonging to the given message context.
     *
     * @param synCtx MessageContext containing an session ID.         
     */
    public void unbind(MessageContext synCtx);

    /**
     * Determine whether the session supported by the implementing dispatcher is intiated by the
     * server (e.g. soap session) or by the client. This can be used for optimizing session updates.
     *
     * @return true, if the session is initiated by the server. false, otherwise.
     */
    public boolean isServerInitiatedSession();
}
"
org/apache/synapse/endpoints/IndirectEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class represents the endpoints referred by keys. It does not store the actual referred
 * endpoint as a private variable as it could expire. Therefore, it only stores the key and gets the
 * actual endpoint from the synapse configuration.
 *
 * As this is also an instance of endpoint, this can be used any place, where a normal endpoint is used.
 */
public class IndirectEndpoint implements Endpoint {

    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
    private static final Log log = LogFactory.getLog(IndirectEndpoint.class);

    private String name = null;
    private String key = null;
    private boolean active = true;
    private Endpoint parentEndpoint = null;

    /**
     * This should have a reference to the current message context as it gets the referred endpoint
     * from it.
     */
    private MessageContext currentMsgCtx = null;

    public void send(MessageContext synMessageContext) {
        // get the actual endpoint and send
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        if (endpoint.isActive(synMessageContext)) {
            endpoint.send(synMessageContext);

        } else {
            // if this is a child of some other endpoint, inform parent about the failure.
            // if not, inform to the next fault handler.
            if (parentEndpoint != null) {
                auditWarn(""Endpoint : "" + endpoint.getName() + "" is currently inactive"" +
                    "" - invoking parent endpoint"", synMessageContext);
                parentEndpoint.onChildEndpointFail(this, synMessageContext);

            } else {
                auditWarn(""Endpoint : "" + endpoint.getName() + "" is currently inactive"" +
                    "" - invoking fault handler / assuming failure"", synMessageContext);

                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * IndirectEndpoints are active if its referref endpoint is active and vise versa. Therefore,
     * this returns if its referred endpoint is active or not.
     *
     * @param synMessageContext MessageContext of the current message.
     *
     * @return true if the referred endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        return endpoint.isActive(synMessageContext);
    }

    /**
     * Activating or deactivating an IndirectEndpoint is the activating or deactivating its
     * referref endpoint. Therefore, this sets the active state of its referred endpoint.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext of the current message.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        endpoint.setActive(active, synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {        

        // if this is a child of some other endpoint, inform parent about the failure.
        // if not, inform to the next fault handler.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);
        } else {
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    protected void auditWarn(String msg, MessageContext msgContext) {
        log.warn(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
        if (shouldTrace(msgContext)) {
            trace.warn(msg);
        }
    }

    public boolean shouldTrace(MessageContext synCtx){
        Endpoint endpoint = synCtx.getEndpoint(key);
        EndpointDefinition endptDefn = null;
        if (endpoint instanceof AddressEndpoint) {
            AddressEndpoint addEndpt = (AddressEndpoint) endpoint;
            endptDefn = addEndpt.getEndpoint();
        } else if (endpoint instanceof WSDLEndpoint) {
            WSDLEndpoint wsdlEndpt = (WSDLEndpoint) endpoint;
            endptDefn = wsdlEndpt.getEndpoint();
        }

        if (endptDefn != null) {
            return (endptDefn.getTraceState() == SynapseConstants.TRACING_ON) ||
                   (endptDefn.getTraceState() == SynapseConstants.TRACING_UNSET &&
                        synCtx.getTracingState() == SynapseConstants.TRACING_ON);
        }
        return false;
    }

}
"
org/apache/synapse/mediators/builtin/LogMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * Logs the specified message into the configured logger. The log levels specify
 * which attributes would be logged, and is configurable. Additionally custom
 * properties may be defined to the logger, where literal values or expressions
 * could be specified for logging. The custom properties are printed into the log
 * using the defined separator (\n, "","" etc)
 */
public class LogMediator extends AbstractMediator {

    /** Only properties specified to the Log mediator */
    public static final int CUSTOM  = 0;
    /** To, From, WSAction, SOAPAction, ReplyTo, MessageID and any properties */
    public static final int SIMPLE  = 1;
    /** All SOAP header blocks and any properties */
    public static final int HEADERS = 2;
    /** all attributes of level 'simple' and the SOAP envelope and any properties */
    public static final int FULL    = 3;

    public static final String DEFAULT_SEP = "", "";

    /** The default log level is set to SIMPLE */
    private int logLevel = SIMPLE;
    /** The separator for which used to separate logging information */
    private String separator = DEFAULT_SEP;
    /** The holder for the custom properties */
    private List properties = new ArrayList();

    /**
     * Logs the current message according to the supplied semantics
     *
     * @param synCtx (current) message to be logged
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Log mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        String logMessage = getLogMessage(synCtx);
        synCtx.getServiceLog().info(logMessage);

        if (log.isInfoEnabled()) {
            log.info(logMessage);
        }
        if (traceOn) {
            trace.info(""Log message : "" + logMessage);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Log mediator"");
        }
        return true;
    }

    private String getLogMessage(MessageContext synCtx) {
        switch (logLevel) {
            case CUSTOM:
                return getCustomLogMessage(synCtx);
            case SIMPLE:
                return getSimpleLogMessage(synCtx);
            case HEADERS:
                return getHeadersLogMessage(synCtx);
            case FULL:
                return getFullLogMessage(synCtx);
            default:
                return ""Invalid log level specified"";
        }
    }

    private String getCustomLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getSimpleLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        if (synCtx.getTo() != null)
            sb.append(""To: "" + synCtx.getTo().getAddress());
        else
            sb.append(""To: "");
        if (synCtx.getFrom() != null)
            sb.append(separator + ""From: "" + synCtx.getFrom().getAddress());
        if (synCtx.getWSAAction() != null)
            sb.append(separator + ""WSAction: "" + synCtx.getWSAAction());
        if (synCtx.getSoapAction() != null)
            sb.append(separator + ""SOAPAction: "" + synCtx.getSoapAction());
        if (synCtx.getReplyTo() != null)
            sb.append(separator + ""ReplyTo: "" + synCtx.getReplyTo().getAddress());
        if (synCtx.getMessageID() != null)
            sb.append(separator + ""MessageID: "" + synCtx.getMessageID());
        sb.append(separator + ""Direction: "" + (synCtx.isResponse() ? ""response"" : ""request""));
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getHeadersLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        if (synCtx.getEnvelope() != null) {
            SOAPHeader header = synCtx.getEnvelope().getHeader();
            if (header != null) {
                for (Iterator iter = header.examineAllHeaderBlocks(); iter.hasNext();) {
                    Object o = iter.next();
                    if (o instanceof SOAPHeaderBlock) {
                        SOAPHeaderBlock headerBlk = (SOAPHeaderBlock) o;
                        sb.append(separator + headerBlk.getLocalName() + "" : "" +
                                headerBlk.getText());
                    } else if (o instanceof OMElement) {
                        OMElement headerElem = (OMElement) o;
                        sb.append(separator + headerElem.getLocalName() + "" : "" +
                                headerElem.getText());
                    }
                }
            }
        }
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getFullLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        sb.append(getSimpleLogMessage(synCtx));
        if (synCtx.getEnvelope() != null)
            sb.append(separator + ""Envelope: "" + synCtx.getEnvelope());        
        return trimLeadingSeparator(sb);
    }

    private void setCustomProperties(StringBuffer sb, MessageContext synCtx) {
        if (properties != null && !properties.isEmpty()) {
            for (Iterator iter = properties.iterator(); iter.hasNext();) {
                MediatorProperty prop = (MediatorProperty) iter.next();
                sb.append(separator + prop.getName() + "" = "" +
                        (prop.getValue() != null ? prop.getValue() :
                                prop.getEvaluatedExpression(synCtx)));
            }
        }
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getSeparator() {
        return separator;
    }

    public void setSeparator(String separator) {
        this.separator = separator;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }

    private String trimLeadingSeparator(StringBuffer sb) {
        String retStr = sb.toString();
        if (retStr.startsWith(separator)) {
            return retStr.substring(separator.length());
        } else {
            return retStr;
        }
    }
}
"
org/apache/synapse/config/xml/DBReportMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.db.DBReportMediator;

/**
 * <dbreport>
 *   <connection>
 *     <jdbc>
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     </jdbc>
 *   </connection>
 *   <insert>
 *     <sql>insert into table values (?, ?, ..)</sql>
 *     <parameter [property="""" | xpath=""""] type=""int|string""/>*
 *   </insert>+
 * </dbreport>
 */
public class DBReportMediatorSerializer extends AbstractDBMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DBReportMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DBReportMediator mediator = (DBReportMediator) m;
        OMElement dbReport = fac.createOMElement(""dbreport"", synNS);
        saveTracingState(dbReport,mediator);
        serializeDBInformation(mediator, dbReport);

        if (parent != null) {
            parent.addChild(dbReport);
        }
        return dbReport;
    }

    public String getMediatorClassName() {
        return DBReportMediator.class.getName();
    }
}
"
org/apache/synapse/SynapseConstants.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNamespace;

import javax.xml.namespace.QName;

/**
 * Global constants for the Apache Synapse project
 */
public final class SynapseConstants {

    /** The Synapse namespace */
    public static final String SYNAPSE_NAMESPACE = ""http://ws.apache.org/ns/synapse"";
    /** An OMNamespace object for the Synapse NS */
    public static final OMNamespace SYNAPSE_OMNAMESPACE =
            OMAbstractFactory.getOMFactory().createOMNamespace(SYNAPSE_NAMESPACE, ""syn"");

    /** The name of the main sequence for message mediation */
    public static final String MAIN_SEQUENCE_KEY  = ""main"";
    /** The name of the fault sequence to execute on failures during mediation */
    public static final String FAULT_SEQUENCE_KEY = ""fault"";

    /** The name of the Synapse service (used for message mediation) */
    public static final String SYNAPSE_SERVICE_NAME =""__SynapseService"";
    /** The operation name used by the Synapse service (for message mediation) */
    public static final QName SYNAPSE_OPERATION_NAME = new QName(""mediate"");

    //- names of modules to be engaged at runtime -
    /** The Name of the WS-RM Sandesha module */
    public static final String SANDESHA2_MODULE_NAME = ""sandesha2"";
    /** The Name of the WS-A Addressing module */
    public static final String ADDRESSING_MODULE_NAME = ""addressing"";
    /** The Name of the WS-Security Rampart module */
    public static final String RAMPART_MODULE_NAME = ""rampart"";

    //- Standard headers that can be read as get-property('header')-
    /** Refers to the To header */
    public static final String HEADER_TO = ""To"";
    /** Refers to the From header */
    public static final String HEADER_FROM = ""From"";
    /** Refers to the FaultTo header */
    public static final String HEADER_FAULT = ""FaultTo"";
    /** Refers to the Action header */
    public static final String HEADER_ACTION = ""Action"";
    /** Refers to the ReplyTo header */
    public static final String HEADER_REPLY_TO = ""ReplyTo"";
    /** Refers to the MessageID header */
    public static final String HEADER_MESSAGE_ID = ""MessageID"";
    /** Message format: pox, soap11, soap12 */
    public static final String PROPERTY_MESSAGE_FORMAT = ""MESSAGE_FORMAT"";

    /** The Axis2 client options property name for the Rampart policy */
    public static final String RAMPART_POLICY = ""rampartPolicy"";
    /** The Axis2 client options property name for the Sandesha policy */
	public static final String SANDESHA_POLICY = ""sandeshaPolicy"";

    /** The name of the Parameter set on the Axis2Configuration to hold the Synapse Configuration */
    public static final String SYNAPSE_CONFIG = ""synapse.config"";
    /** The name of the Parameter set on the Axis2Configuration to hold the Synapse Environment */
    public static final String SYNAPSE_ENV = ""synapse.env"";

    /** The name of the system property that will hold the Synapse home directory */
    public static final String SYNAPSE_HOME = ""synapse.home"";
    /** The default synapse.properties file path */
    public static final String DEFAULT_PROP_PATH = ""synapse.properties"";
    /** The name of the system property used to specify/override the synapse config XML location */
    public static final String SYNAPSE_XML = ""synapse.xml"";
    /** The name of the system property used to specify/override the synapse properties location */
    public static final String SYNAPSE_PROPERTIES = ""synapse.properties"";

    //- Synapse Message Context Properties -
        /** The Synapse MC property name that holds the name of the Proxy service thats handling it */
        public static final String PROXY_SERVICE = ""proxy.name"";
        /** The Synapse MC property that marks it as a RESPONSE */
        public static final String RESPONSE = ""RESPONSE"";
        /** The Synapse MC property that marks the message as a OUT_ONLY message */
        public static final String OUT_ONLY = ""OUT_ONLY"";

        //-- error handling --
        /** The message context property name which holds the error code for the last encountered exception */
        public static final String ERROR_CODE = ""ERROR_CODE"";
        /** The MC property name which holds the error message for the last encountered exception */
        public static final String ERROR_MESSAGE = ""ERROR_MESSAGE"";
        /** The message context property name which holds the error detail (stack trace) for the last encountered exception */
        public static final String ERROR_DETAIL = ""ERROR_DETAIL"";

        /** Sandesha last message property name */
        public static final String SANDESHA_LAST_MESSAGE = ""Sandesha2LastMessage"";
        /** Sandesha last sequence key property name */
        public static final String SANDESHA_SEQUENCE_KEY = ""Sandesha2SequenceKey"";
        /** Sandesha WS-RM specification version property name */
        public static final String SANDESHA_SPEC_VERSION = ""Sandesha2RMSpecVersion"";

    //- Axis2 Message Context Properties used by Synapse -
    /** an axis2 message context property set to hold the relates to for POX responses */
    public static final String RELATES_TO_FOR_POX = ""synapse.RelatesToForPox"";

    /** an axis2 message context property set to indicate this is a response message for Synapse */
    public static final String ISRESPONSE_PROPERTY = ""synapse.isresponse"";


    //- tracing and statistics constants -
        /** Tracing logger name */
        public static final String TRACE_LOGGER =""TRACE_LOGGER"";
        public static final String SERVICE_LOGGER_PREFIX =""SERVICE_LOGGER."";

        /** The tracing state -off */
        public static final int TRACING_OFF =0;
        /** The tracing state-on */
        public static final int TRACING_ON =1;
        /** The tracing state-unset */
        public static final int TRACING_UNSET=2;

        /** The statistics state -off */
        public static final int STATISTICS_OFF =0;
        /** The statistics state-on */
        public static final int STATISTICS_ON =1;
        /** The statistics state-unset */
        public static final int STATISTICS_UNSET=2;

        /** key for lookup sequence statistics stack */
        public static final String SEQUENCE_STATS =""synapse.sequence.stats"";

        /** key for lookup Proxy Service statistics stack */
        public static final String PROXY_STATS =""synapse.proxy.stats"";

        /** key for lookup Proxy Service statistics stack */
        public static final String SERVICE_STATS =""synapse.service.stats"";

        /** key for lookup Endpoint statistics stack */
        public static final String ENDPOINT_STATS =""synapse.endpoint.stats"";

        /** Sequence statistics category*/
        public static final int  SEQUENCE_STATISTICS = 0;

        /** Proxy Service statistics category */
        public static final int  PROXYSERVICE_STATISTICS = 1;

        /** Endpoint statistics category*/
        public static final int ENDPOINT_STATISTICS = 2;

    //- handling of timed out events from the callbacks -
        /** The System property that states the duration at which the timeout handler runs */
        public static final String TIMEOUT_HANDLER_INTERVAL = ""synapse.timeout_handler_interval"";

        /**
         * Interval for activating the timeout handler for cleaning up expired requests. Note that
         * there can be an error as large as the value of the interval. But for smaller intervals
         * and larger timeouts this error is negligable.
         */
        public static final long DEFAULT_TIMEOUT_HANDLER_INTERVAL = 15000;

        /**
         * This is a system wide interval for handling otherwise non-expiring callbacks to
         * ensure system stability over a period of time 
         */
        public static final String GLOBAL_TIMEOUT_INTERVAL = ""synapse.global_timeout_interval"";

        /**
         * this is the timeout for otherwise non-expiring callbacks
         * to ensure system stability over time
         */
        public static final long DEFAULT_GLOBAL_TIMEOUT = 24 * 60 * 60 * 1000;

        /**
         * don't do anything for response timeouts. this means infinite timeout. this is the default
         * action, if the timeout configuration is not explicitly set.
         */
        public static final int NONE = 100;

        /** Discard the callback if the timeout for the response is expired */
        public static final int DISCARD = 101;

        /**
         * Discard the callback and activate specified fault sequence if the timeout for the response
         * is expired
         */
        public static final int DISCARD_AND_FAULT = 102;

        /**
         * Error codes for message sending. We go with closest HTTP fault codes.
         */
        public static final String TIME_OUT = ""504"";
        public static final String SENDING_FAULT = ""503"";

    //- Endpoints processing constants -
    /** Property name to store the last endpoint through which the message has flowed */
    public static final String PROCESSED_ENDPOINT = ""processed_endpoint"";
    
    /** A name to use for anonymous endpoints */
    public static final String ANONYMOUS_ENDPOINT = ""AnonymousEndpoint"";

    /** A name to use for anonymous sequences in the sequence stack */
    public static final String ANONYMOUS_SEQUENCE = ""AnonymousSequence"";
    
    /** Message format values in EndpointDefinition. Used by address, wsdl endpoints */
    public static final String FORMAT_POX = ""pox"";
    public static final String FORMAT_SOAP11 = ""soap11"";
    public static final String FORMAT_SOAP12 = ""soap12"";    
}
"
org/apache/synapse/Mediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.synapse.MessageContext;

/**
 * All Synapse mediators must implement this Mediator interface. As a message passes
 * through the synapse system, each mediator's mediate() method is invoked in the
 * sequence/order defined in the SynapseConfiguration.
 */
public interface Mediator {

    /**
     * Invokes the mediator passing the current message for mediation. Each
     * mediator performs its mediation action, and returns true if mediation
     * should continue, or false if further mediation should be aborted.
     *
     * @param synCtx the current message for mediation
     * @return true if further mediation should continue
     */
    public boolean mediate(MessageContext synCtx);

    /**
     * This is used for debugging purposes and exposes the type of the current
     * mediator for logging and debugging purposes
     * @return a String representation of the mediator type
     */
    public String getType();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return value that indicate whether tracing is on, off or unset
     */
    public int getTraceState();

    /**
     * This is used to set the value of tracing enable variable
     * @param traceState Set whether the tracing is enabled or not
     */
    public void setTraceState(int traceState);
}
"
org/apache/synapse/statistics/StatisticsUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * A utils to process statistics
 *
 */

public class StatisticsUtils {

    /**
     * To process statistics related to the proxy services
     *
     * @param synCtx
     */
    public static void processProxyServiceStatistics(MessageContext synCtx) {

        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        ProxyServiceStatisticsStack proxyServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(SynapseConstants.PROXY_STATS);
        if (proxyServiceStatisticsStack != null) {
            proxyServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
        ProxyServiceStatisticsStack synapseServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SERVICE_STATS);
        if (synapseServiceStatisticsStack != null) {
            synapseServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

    /**
     * To process statistics related to the End Points
     *
     * @param synCtx
     */
    public static void processEndPointStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        EndPointStatisticsStack endPointStatisticsStack = (EndPointStatisticsStack)
                synCtx.getProperty(SynapseConstants.ENDPOINT_STATS);
        if (endPointStatisticsStack != null) {
            Object endpointObj = synCtx.getProperty(SynapseConstants.PROCESSED_ENDPOINT);
            if (endpointObj instanceof Endpoint) {
                Endpoint endpoint = (Endpoint) endpointObj;
                String name = endpoint.getName();
                if (name == null) {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault);
                } else {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault, name);
                }
                endPointStatisticsStack.reportAllToStatisticsCollector(statisticsCollector, true);
            }
        }
    }

    /**
     * To process statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

     /**
     * To process all statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processAllSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportAllToStatisticsCollector(statisticsCollector,isFault);
        }
    }
    /**
     * A helper method to get StatisticsCollector from the Synapse Message Context
     *
     * @param synCtx
     * @return StatisticsCollector
     */
    private static StatisticsCollector getStatisticsCollector(MessageContext synCtx) {
        SynapseEnvironment synEnv = synCtx.getEnvironment();
        StatisticsCollector statisticsCollector = null;
        if (synEnv != null) {
            statisticsCollector = synEnv.getStatisticsCollector();
            if (statisticsCollector == null) {
                statisticsCollector = new StatisticsCollector();
                synEnv.setStatisticsCollector(statisticsCollector);
            }
        }
        return statisticsCollector;
    }
}
"
org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java,true,"package org.apache.synapse.config.xml;

import java.io.OutputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Collection;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractSerializer;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.Startup;

public class SynapseXMLConfigurationSerializer implements ConfigurationSerializer {

    private static final Log log = LogFactory
            .getLog(XMLConfigurationSerializer.class);

    private static final OMFactory fac = OMAbstractFactory.getOMFactory();

    private static final OMNamespace synNS = fac.createOMNamespace(
            XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");

    private static final OMNamespace nullNS = fac.createOMNamespace(
            XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * order of entries is irrelavant, however its nice to have some order
     *
     * @param synCfg
     * @throws XMLStreamException
     */

    public OMElement serializeConfiguration(SynapseConfiguration synCfg) {

        OMElement definitions = fac.createOMElement(""definitions"", synNS);

        // first process a remote registry if present
        if (synCfg.getRegistry() != null) {
            RegistrySerializer.serializeRegistry(definitions, synCfg
                    .getRegistry());
        }

        // add proxy services
        Iterator iter = synCfg.getProxyServices().iterator();
        while (iter.hasNext()) {
            ProxyService service = (ProxyService) iter.next();
            ProxyServiceSerializer.serializeProxy(definitions, service);
        }

        Map entries = new HashMap();
        Map endpoints = new HashMap();
        Map sequences = new HashMap();

        iter = synCfg.getLocalRegistry().keySet().iterator();
        while (iter.hasNext()) {
            Object key = iter.next();
            Object o = synCfg.getLocalRegistry().get(key);
            if (o instanceof Mediator) {
                sequences.put(key, o);
            } else if (o instanceof Endpoint) {
                endpoints.put(key, o);
            } else if (o instanceof Entry) {
                entries.put(key, o);
            } else {
                handleException(""Unknown object : "" + o.getClass()
                        + "" for serialization into Synapse configuration"");
            }
        }

        // process entries
        serializeEntries(definitions, entries);

        // process endpoints
        serializeEndpoints(definitions, endpoints);

        // process sequences
        serializeSequences(definitions, sequences);

        // handle startups
        serializeStartups(definitions, synCfg.getStartups());

        return definitions;
    }

    private static void serializeEntries(OMElement definitions, Map entries) {
        Iterator iter = entries.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            EntrySerializer.serializeEntry((Entry) entries.get(key),
                    definitions);
        }
    }

    private static void serializeStartups(OMElement definitions, Collection startups) {
        Iterator it = startups.iterator();
        while (it.hasNext()) {
            Startup s = (Startup) it.next();
            StartupFinder.getInstance().serializeStartup(definitions, s);
        }
    }

    private static void serializeEndpoints(OMElement definitions, Map endpoints) {
        Iterator iter = endpoints.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            Object o = endpoints.get(key);
            if (o instanceof Endpoint) {
                Endpoint endpoint = (Endpoint) o;
                OMElement epElement = EndpointAbstractSerializer
                        .getEndpointSerializer(endpoint).serializeEndpoint(
                        endpoint);
                definitions.addChild(epElement);
            }

        }
    }

    private static void serializeSequences(OMElement definitions, Map sequences) {
        Iterator iter = sequences.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            Mediator mediator = (Mediator) sequences.get(key);
            MediatorSerializerFinder.getInstance().getSerializer(mediator)
                    .serializeMediator(definitions, mediator);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public QName getTagQName() {
        return XMLConfigConstants.DEFINITIONS_ELT;
	}

}
"
org/apache/synapse/core/axis2/MediatorDeployer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.deployment.Deployer;
import org.apache.axis2.deployment.DeploymentClassLoader;
import org.apache.axis2.deployment.DeploymentException;
import org.apache.axis2.deployment.repository.util.DeploymentFileData;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.xml.MediatorFactory;
import org.apache.synapse.config.xml.MediatorFactoryFinder;
import org.apache.synapse.config.xml.MediatorSerializer;
import org.apache.synapse.config.xml.MediatorSerializerFinder;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;

/**
 * This will support the hot deployment and hot update of the mediators at runtime using the
 * Axis2 concepts of deployers
 */
public class MediatorDeployer implements Deployer {

    /**
     * Holds the log variable for logging purposes
     */
    private static final Log log = LogFactory.getLog(MediatorDeployer.class);

    /**
     * ConfigurationContext of Axis2
     */
    private ConfigurationContext cfgCtx = null;

    /**
     * Initializes the Deployer
     *
     * @param configurationContext - ConfigurationContext of Axis2 from which
     *  the deployer is initialized
     */
    public void init(ConfigurationContext configurationContext) {
        this.cfgCtx = configurationContext;
    }

    /**
     * This will be called when there is a change in the specified deployement
     * folder (in the axis2.xml) and this will load the relevant classe to the system and
     * registeres them with the MediatorFactoryFinder
     *
     * @param deploymentFileData - describes the updated file
     * @throws DeploymentException - in case an error on the deployment
     */
    public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {

        log.info(""Loading mediator from: "" + deploymentFileData.getAbsolutePath());

        // get the context class loader for the later restore of the context class loader
        ClassLoader prevCl = Thread.currentThread().getContextClassLoader();

        try {

            DeploymentClassLoader urlCl = new DeploymentClassLoader(
                    new URL[]{deploymentFileData.getFile().toURL()}, null, prevCl);
            Thread.currentThread().setContextClassLoader(urlCl);

            // MediatorFactory registration
            URL facURL = urlCl.findResource(
                    ""META-INF/services/org.apache.synapse.config.xml.MediatorFactory"");
            if (facURL != null) {
                InputStream facStream = facURL.openStream();
                InputStreamReader facreader = new InputStreamReader(facStream);

                StringBuffer facSB = new StringBuffer();
                int c;
                while ((c = facreader.read()) != -1) {
                    facSB.append((char) c);
                }

                String[] facClassName = facSB.toString().split(""\n"");
                for (int i=0; i<facClassName.length; i++) {
                    log.info(""Registering the Mediator factory: "" + facClassName[i]);
                    Class facClass = urlCl.loadClass(facClassName[i]);
                    MediatorFactory facInst = (MediatorFactory) facClass.newInstance();
                    MediatorFactoryFinder.getInstance()
                            .getFactoryMap().put(facInst.getTagQName(), facClass);
                    log.info(""Mediator loaded and registered for "" +
                            ""the tag name: "" + facInst.getTagQName());
                }
            } else {
                handleException(""Unable to find the MediatorFactory implementation. "" +
                        ""Unable to register the MediatorFactory with the FactoryFinder"");
            }

            // MediatorSerializer registration
            URL serURL = urlCl.findResource(
                    ""META-INF/services/org.apache.synapse.config.xml.MediatorSerializer"");
            if (serURL != null) {
                InputStream serStream = serURL.openStream();
                InputStreamReader serReader = new InputStreamReader(serStream);

                StringBuffer serSB = new StringBuffer();
                int c;
                while ((c = serReader.read()) != -1) {
                    serSB.append((char) c);
                }

                String[] serClassName = serSB.toString().split(""\n"");
                for (int i=0; i<serClassName.length; i++) {
                    log.info(""Registering the Mediator serializer: "" + serClassName[i]);
                    Class serClass = urlCl.loadClass(serClassName[i]);
                    MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();
                    MediatorSerializerFinder.getInstance()
                            .getSerializerMap().put(serInst.getMediatorClassName(), serInst);
                    log.info(""Mediator loaded and registered for "" +
                            ""the serialization as: "" + serInst.getMediatorClassName());
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Unable to find the MediatorSerializer implementation. "" +
                            ""Unable to register the MediatorSerializer with the SerializerFinder"");
                }
            }

        } catch (IOException e) {
            handleException(""I/O error in reading the mediator jar file"", e);
        } catch (ClassNotFoundException e) {
            handleException(""Unable to find the specified class on the path or in the jar file"", e);
        } catch (IllegalAccessException e) {
            handleException(""Unable to load the class from the jar"", e);
        } catch (InstantiationException e) {
            handleException(""Unable to instantiate the class specified"", e);
        } finally {
            // restore the class loader back
            if (log.isDebugEnabled()) {
                log.debug(""Restoring the context class loader to the original"");
            }
            Thread.currentThread().setContextClassLoader(prevCl);
        }
    }

    /**
     * This will not be implemented because we do not support changing the directory at runtime
     *
     * @param string -
     */
    public void setDirectory(String string) {
        // we do not support changing the directory
    }

    /**
     * This will not be implemented because we do not support changing the extension at runtime
     *
     * @param string -
     */
    public void setExtension(String string) {
        // we do not support changing the extension
    }

    /**
     * This will be called when a particulr jar file is deleted from the specified folder
     *
     * @param string - filename of the deleted file
     * @throws DeploymentException - incase of an error in undeployment
     */
    public void unDeploy(String string) throws DeploymentException {
        // todo: implement the undeployement
    }

    private void handleException(String message, Exception e) throws DeploymentException {
        if (log.isDebugEnabled()) {
            log.debug(message, e);
        }
        throw new DeploymentException(message, e);
    }

    private void handleException(String message) throws DeploymentException {
        if (log.isDebugEnabled()) {
            log.debug(message);
        }
        throw new DeploymentException(message);
    }
}
"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;

import java.util.List;

/**
 * Serializes LoadbalanceEndpoint to an XML configuration.
 *
 * <endpoint [name=""name""]>
 *    <loadbalance policy=""load balance algorithm"">
 *       <endpoint>+
 *    </loadbalance>
 * </endpoint>
 */
public class LoadbalanceEndpointSerializer implements EndpointSerializer {

    private OMFactory fac = null;

    public OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof LoadbalanceEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        LoadbalanceEndpoint loadbalanceEndpoint = (LoadbalanceEndpoint) endpoint;

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement loadbalanceElement = fac.createOMElement(""loadbalance"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute
                (org.apache.synapse.config.xml.XMLConfigConstants.ALGORITHM_NAME, algorithmName, null);

        // set if failover is turned off in the endpoint
        if (!loadbalanceEndpoint.isFailover()) {
            loadbalanceElement.addAttribute(""failover"", ""false"", null);
        }

        List endpoints = loadbalanceEndpoint.getEndpoints();
        for (int i = 0; i < endpoints.size(); i++) {
            Endpoint childEndpoint = (Endpoint) endpoints.get(i);
            EndpointSerializer serializer = EndpointAbstractSerializer.
                    getEndpointSerializer(childEndpoint);
            OMElement aeElement = serializer.serializeEndpoint(childEndpoint);
            loadbalanceElement.addChild(aeElement);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.aggregator;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.eip.EIPUtils;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.jaxen.JaxenException;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * This mediator will aggregate the messages flowing in to this with the specified message types
 * and build a one message
 */
public class AggregateMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(AggregateMediator.class);

    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     * This will hold the maximum lifetime of an aggregate and if a particular aggregate does not
     * completed before its life time it will be invalidated and taken off from the activeAggregates
     * map and put in to the expiredAggregates map and the invalidate sequence will be called to
     * mediate the messages in the expired aggregate if there are any
     */
    private long timeToInvalidate = 0;

    /**
     * Messages comming to the aggregator will be examined for the existance of a node described
     * in this XPATH and if it contains the XPATH pick that, if not try to find the messageSequence
     * property for the corelation and if not pass the message through
     */
    private AXIOMXPath corelateExpression = null;

    /**
     * This will be used in the complete condition to complete the aggregation after waiting a
     * specified timeout and send the messages gatherd in the aggregate after aggregation
     * if there are any messages
     */
    private long completeTimeout = 0;

    /**
     * Minimum number of messages required to evaluate the complete condition to true unless the
     * aggregate has timedout with the provided timeout if there is a one
     */
    private int minMessagesToComplete = -1;

    /**
     * Maximum number of messages that can be contained in a particular aggregation
     */
    private int maxMessagesToComplete = -1;

    /**
     * This will hold the implementation of the aggregation algorithm and upon validating the
     * complete condition getAggregatedMessage method of the aggregator will be called to get
     * the aggregated message
     */
    private AXIOMXPath aggregationExpression = null;

    /**
     * Holds a String reference to the Named Sequence which will be called to mediate the invalid
     * messages coming in to the aggregator
     */
    private String invalidMsgSequenceRef = null;

    /**
     * Sequece which will be called to mediate the invalid messages comming in to aggregator
     */
    private SequenceMediator invalidMsgSequence = null;

    /**
     * This will be used to destroy the aggreagtes which were kept in the expiredAggregates map
     */
    private long invlidateToDestroyTime = 0;

    /**
     * This holds the reference sequence name of the
     */
    private String onCompleteSequenceRef = null;

    /**
     *
     */
    private SequenceMediator onCompleteSequence = null;

    /**
     * This will hold the map of active aggragates at any given time
     */
    private Map activeAggregates = new HashMap();

    /**
     * This will hold the expired aggregates at any given time, these will be cleaned by a timer
     * task time to time in order to ensure uncontroled growth
     */
    private Map expiredAggregates = new HashMap();

    private boolean isTimerSet = false;

    public AggregateMediator() {
        try {
            aggregationExpression = new AXIOMXPath(""s11:Body/child::*[position()=1] | "" +
                ""s12:Body/child::*[position()=1]"");
            aggregationExpression.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            aggregationExpression.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            if (log.isDebugEnabled()) {
                handleException(""Unable to set the default "" +
                    ""aggregationExpression for the aggregation"", e, null);
            }
        }
    }

    /**
     * This is the mediate method implementation of the AggregateMediator. And this will aggregate
     * the messages going through this mediator according to the corelation criteria and the
     * aggregation algorith specified to it
     *
     * @param synCtx - MessageContext to be mediated and aggregated
     * @return boolean true if the complete condition for the particular aggregate is validated
     *         false if not
     */
    public boolean mediate(MessageContext synCtx) {
        // tracing and debuggin related mediation initiation
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Aggregate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

//        todo: revisit this         
//        if (!isTimerSet) {
//            synCtx.getConfiguration().getSynapseTimer()
//                    .schedule(new AggregateCollector(this), 5000);
//        }

        try {
            Aggregate aggregate = null;

            // if the corelate aggregationExpression is provided and there is a coresponding
            // element in the message corelate the messages on that
            if (this.corelateExpression != null
                    && this.corelateExpression.evaluate(synCtx.getEnvelope()) != null) {

                if (activeAggregates.containsKey(this.corelateExpression.toString())) {
                    Object o = activeAggregates.get(this.corelateExpression.toString());
                    if (o instanceof Aggregate) {
                        aggregate = (Aggregate) o;
                    } else {
                        handleException(""Undefined aggregate type."", synCtx);
                    }
                } else {
                    aggregate = new Aggregate(this.corelateExpression.toString(),
                            this.completeTimeout, this.minMessagesToComplete,
                            this.maxMessagesToComplete);
                    activeAggregates.put(this.corelateExpression.toString(), aggregate);
                }

            // if the corelattion can not be found using the aggregationExpression try to find the
            // corelation on the default criteria which is through the aggregate corelation
            // property of the message
            } else if (synCtx.getProperty(EIPConstants.AGGREGATE_CORELATION) != null) {

                String corelation = synCtx.getProperty(
                    EIPConstants.AGGREGATE_CORELATION) instanceof String ? synCtx.getProperty(
                    EIPConstants.AGGREGATE_CORELATION).toString() : null;

                // check whether the message corelation name is in the expired aggregates
                if (expiredAggregates.containsKey(corelation)) {

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Message with the corelation ""
                                + corelation + "" expired. Invalidating the message."");
                    }

                    invalidate(synCtx, traceOrDebugOn, traceOn);
                    return false;
                }

                if (corelation != null) {

                    if (activeAggregates.containsKey(corelation)) {

                        Object o = activeAggregates.get(corelation);
                        if (o instanceof Aggregate) {
                            aggregate = (Aggregate) o;
                        } else {
                            handleException(""Undefined aggregate type."", synCtx);
                        }

                    } else {
                        aggregate = new Aggregate(corelation, this.completeTimeout,
                                this.minMessagesToComplete, this.maxMessagesToComplete);
                        activeAggregates.put(corelation, aggregate);
                    }

                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn,
                            ""Error in getting corelation details. Skip the aggregator."");
                    }
                    return true;
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Unable to find the aggregation corelation. Skip the aggregation"");
                }
                return true;
            }

            // if there is an aggregate continue on aggregation
            if (aggregate != null) {

                // add the message to the aggregate and if the maximum count of the aggregate is
                // exceeded invalidate the message
                if (!aggregate.addMessage(synCtx)) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Can not exceed aggregate "" +
                                ""max message count. Invalidating message"");
                    }
                    invalidate(synCtx, traceOrDebugOn, traceOn);
                    return false;
                }

                // check the completeness of the aggregate and is completed aggregate the messages
                // if not completed return false and block the message sequence till it completes
                if (aggregate.isComplete()) {
                    return completeAggregate(aggregate);
                }

            // if the aggregation corelation can not be found then continue the message on the
            // normal path by returning true
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Unable to find the aggregate. Skip the aggregation"");
                }
                return true;
            }

        } catch (JaxenException e) {
            handleException(""Unable to execute the XPATH over the message"", e, synCtx);
        }

        // finalize tracing and debugging
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Aggregate mediator"");
        }

        return false;
    }

    private void invalidate(MessageContext synCtx, boolean traceOrDebugOn, boolean traceOn) {

        if (this.invalidMsgSequenceRef != null && synCtx.getConfiguration()
                .getSequence(invalidMsgSequenceRef) != null) {

            // use the sequence reference to get the sequence for mediation
            synCtx.getConfiguration().getSequence(invalidMsgSequenceRef).mediate(synCtx);

        } else if (this.invalidMsgSequence != null) {

            // use the sequence to mediate the invalidated messages
            invalidMsgSequence.mediate(synCtx);

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""No invalid message sequence defined. Dropping the message"");
            }
        }
    }

    public boolean completeAggregate(Aggregate aggregate) {

            MessageContext newSynCtx = getAggregatedMessage(aggregate);
            activeAggregates.remove(aggregate.getCorelation());

            if ((this.corelateExpression != null && !this.corelateExpression
                    .toString().equals(aggregate.getCorelation())) ||
                    this.corelateExpression == null) {

//                            aggregate.setExpireTime(
//                                    System.currentTimeMillis() + this.invlidateToDestroyTime);
                expiredAggregates.put(aggregate.getCorelation(),
                        new Long(System.currentTimeMillis() + this.invlidateToDestroyTime));

                if (this.onCompleteSequence != null) {
                    this.onCompleteSequence.mediate(newSynCtx);
                } else if (this.onCompleteSequenceRef != null
                        && newSynCtx.getSequence(this.onCompleteSequenceRef) != null) {
                    newSynCtx.getSequence(this.onCompleteSequenceRef).mediate(newSynCtx);
                } else {
                    handleException(""Unable to find the sequence for the mediation "" +
                            ""of the aggregated message"", newSynCtx);
                }
                return false;
            } else {
                return true;
            }
    }

    public MessageContext getAggregatedMessage(Aggregate aggregate) {
        MessageContext newCtx = null;
        Iterator itr = aggregate.getMessages().iterator();
        while (itr.hasNext()) {
            Object o = itr.next();
            if (o instanceof MessageContext) {
                MessageContext synCtx = (MessageContext) o;
                if (newCtx == null) {
                    newCtx = synCtx;
                } else {
                    try {
                        EIPUtils.enrichEnvelope(
                            newCtx.getEnvelope(), synCtx.getEnvelope(), this.aggregationExpression);
                    } catch (JaxenException e) {
                        handleException(""Unable to get the aggreagated message"", e, synCtx);
                    }
                }
            }
        }
        return newCtx;
    }

    public AXIOMXPath getCorelateExpression() {
        return corelateExpression;
    }

    public void setCorelateExpression(AXIOMXPath corelateExpression) {
        this.corelateExpression = corelateExpression;
    }

    public String getInvalidMsgSequenceRef() {
        return invalidMsgSequenceRef;
    }

    public void setInvalidMsgSequenceRef(String invalidMsgSequenceRef) {
        this.invalidMsgSequenceRef = invalidMsgSequenceRef;
    }

    public SequenceMediator getInvalidMsgSequence() {
        return invalidMsgSequence;
    }

    public void setInvalidMsgSequence(SequenceMediator invalidMsgSequence) {
        this.invalidMsgSequence = invalidMsgSequence;
    }

    public long getTimeToInvalidate() {
        return timeToInvalidate;
    }

    public void setTimeToInvalidate(long timeToInvalidate) {
        this.timeToInvalidate = timeToInvalidate;
    }

    public long getCompleteTimeout() {
        return completeTimeout;
    }

    public void setCompleteTimeout(long completeTimeout) {
        this.completeTimeout = completeTimeout;
    }

    public int getMinMessagesToComplete() {
        return minMessagesToComplete;
    }

    public void setMinMessagesToComplete(int minMessagesToComplete) {
        this.minMessagesToComplete = minMessagesToComplete;
    }

    public int getMaxMessagesToComplete() {
        return maxMessagesToComplete;
    }

    public void setMaxMessagesToComplete(int maxMessagesToComplete) {
        this.maxMessagesToComplete = maxMessagesToComplete;
    }

    public AXIOMXPath getAggregationExpression() {
        return aggregationExpression;
    }

    public void setAggregationExpression(AXIOMXPath aggregationExpression) {
        this.aggregationExpression = aggregationExpression;
    }

    public long getInvlidateToDestroyTime() {
        return invlidateToDestroyTime;
    }

    public void setInvlidateToDestroyTime(long invlidateToDestroyTime) {
        this.invlidateToDestroyTime = invlidateToDestroyTime;
    }

    public String getOnCompleteSequenceRef() {
        return onCompleteSequenceRef;
    }

    public void setOnCompleteSequenceRef(String onCompleteSequenceRef) {
        this.onCompleteSequenceRef = onCompleteSequenceRef;
    }

    public SequenceMediator getOnCompleteSequence() {
        return onCompleteSequence;
    }

    public void setOnCompleteSequence(SequenceMediator onCompleteSequence) {
        this.onCompleteSequence = onCompleteSequence;
    }

    public Map getExpiredAggregates() {
        return expiredAggregates;
    }

    public Map getActiveAggregates() {
        return activeAggregates;
    }
}
"
org/apache/synapse/core/axis2/TimeoutHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;

import java.util.Iterator;
import java.util.Map;
import java.util.Stack;
import java.util.TimerTask;

/**
 * An object of this class is registered to be invoked in some predefined time intervals. This
 * checks the timeouts of callbacks stored in the SynapseCallbackReceiver and removes all expired
 * callbacks. Timeouts of the callbacks are stored as the time, not the duration. So that the
 * time or the interval of invoking this class does not affect the correctness of the timeouts,
 * although longer intervals would introduce larger error between the actual timeout and the
 * specified timeout.
 *
 * For each invocation this gets a time value to be compared against the timeouts of the callback
 * objects. This time is the System.currentTimeMillis() for Java 1.4 and System.nanoTime() for
 * Java 1.5 and later.
 */
public class TimeoutHandler extends TimerTask {

    private static final Log log = LogFactory.getLog(TimeoutHandler.class);

    /** The callback map - already a Collections.synchronized() hash map */
    private Map callbackStore = null;
    /** a lock to prevent concurrent execution while ensuring least overhead */
    private Object lock = new Object();
    private boolean alreadyExecuting = false;
    /**
     * this is the timeout for otherwise non-expiring callbacks
     * to ensure system stability over time
     */
    private long globalTimeout = SynapseConstants.DEFAULT_GLOBAL_TIMEOUT;

    public TimeoutHandler(Map callbacks) {
        this.callbackStore = callbacks;
        try {
            globalTimeout = Long.parseLong(
                System.getProperty(SynapseConstants.GLOBAL_TIMEOUT_INTERVAL));
        } catch (Exception ignore) {}
        log.info(""This engine will expire all callbacks after : "" + (globalTimeout /1000) +
            "" seconds, irrespective of the timeout action, after the specified or optional timeout"");
    }

    /**
     * Checks if the timeout has expired for each callback in the callback store. If expired, removes
     * the callback. If specified sends a fault message to the client about the timeout.
     */
    public void run() {
        if (alreadyExecuting) return;

        synchronized(lock) {
            alreadyExecuting = true;
            try {
                processCallbacks();
            } catch (Exception ignore) {}
            alreadyExecuting = false;
        }
    }

    private void processCallbacks() {

        // checks if callback store contains at least one entry before proceeding. otherwise getting
        // the time for doing nothing would be a inefficient task.

        // we have to synchronize this on the callbackStore as iterators of thread safe collections
        // are not thread safe. callbackStore can be modified concurrently by the SynapseCallbackReceiver.
        synchronized(callbackStore) {

            if (callbackStore.size() > 0) {

                long currentTime = currentTime();
                Iterator i = callbackStore.keySet().iterator();

                while (i.hasNext()) {

                    Object key = i.next();
                    AsyncCallback callback = (AsyncCallback) callbackStore.get(key);

                    if (callback.getTimeOutAction() != SynapseConstants.NONE) {

                        if (callback.getTimeOutOn() <= currentTime) {
                            callbackStore.remove(key);

                            if (callback.getTimeOutAction() == SynapseConstants.DISCARD_AND_FAULT) {

                                // actiavte the fault sequence of the current sequence mediator
                                MessageContext msgContext = callback.getSynapseOutMsgCtx();

                                // add an error code to the message context, so that error sequences
                                // can identify the cause of error
                                msgContext.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.TIME_OUT);

                                Stack faultStack = msgContext.getFaultStack();

                                for (int j = 0; j < faultStack.size(); j++) {
                                    Object o = faultStack.pop();
                                    if (o instanceof FaultHandler) {
                                        ((FaultHandler) o).handleFault(msgContext);
                                    }
                                }

                            }
                        }

                    } else if (currentTime > globalTimeout + callback.getTimeOutOn()) {
                        log.warn(""Expiring message ID : "" + key + ""; dropping message after "" +
                            ""global timeout of : "" + (globalTimeout/1000) + "" seconds"");
                        callbackStore.remove(key);
                    }
                }
            }
        }
    }

    /**
     * Returns the current time.
     *
     * @return  System.currentTimeMillis() on Java 1.4
     *          System.nanoTime() on Java 1.5 (todo: implement)
     */
    private long currentTime() {
        return System.currentTimeMillis();
    }
}
"
org/apache/synapse/util/FixedByteArrayOutputStream.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.synapse.SynapseException;
import java.io.ByteArrayOutputStream;

public class FixedByteArrayOutputStream extends ByteArrayOutputStream {

    public FixedByteArrayOutputStream(int size) {
        super(size);
    }

    public synchronized void write(int b) {
        if (count+1 > buf.length) {
            throw new SynapseException(""Fixed size of internal byte array exceeded"");
        }
        super.write(b);
    }

    public synchronized void write(byte b[], int off, int len) {
        if (count+len > buf.length) {
            throw new SynapseException(""Fixed size of internal byte array exceeded"");
        }
        super.write(b, off, len);
    }
}
"
org/apache/synapse/endpoints/Endpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;

/**
 * Endpoint defines the bahavior common to all synapse endpoints. Synapse endpoints should be able
 * to send the given synapse message context, rather than just providing the information for sending
 * the message. The task a particuler endpoint does in its send(...) methis is specific to the endpoint.
 * For example a loadbalance endpoint may choose another endpoint using its loadbalance policy and
 * call its send(...) method while an address endpoint (leaf level) may send the message to a actual
 * endpoint url. Endpoints may contain zero or more endpoints in them and build up a heirachycal
 * structure of endpoints.
 */
public interface Endpoint {

    /**
     * Sends the message context according to an endpoint specific behavior.
     *
     * @param synMessageContext MessageContext to be sent.
     */
    public void send(MessageContext synMessageContext);

    /**
     * Endpoints that contain other endpoints should implement this method. It will be called if a
     * child endpoint causes an exception. Action to be taken on such failure is upto the implementation.
     * But it is good practice to first try addressing the issue. If it can't be addressed propagate the
     * exception to parent endpoint by calling parent endpoint's onChildEndpointFail(...) method.
     *
     * @param endpoint The child endpoint which caused the exception.
     * @param synMessageContext MessageContext that was used in the failed attempt.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext);

    /**
     * Sets the parent endpoint for the current endpoint.
     *
     * @param parentEndpoint parent endpoint containing this endpoint. It should handle the onChildEndpointFail(...)
     * callback.
     */
    public void setParentEndpoint(Endpoint parentEndpoint);

    /**
     * Returns the name of the endpoint.
     *
     * @return Endpoint name.
     */
    public String getName();

    /**
     * Sets the name of the endpoint. Local registry use this name as the key for storing the
     * endpoint.
     *
     * @param name Name for the endpoint.
     */
    public void setName(String name);

    /**
     * Returns if the endpoint is currently active or not. Messages should not be sent to inactive
     * endpoints.
     *
     * @param synMessageContext MessageContext for the current message. This is required for
     * IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     * Endpoint implementations may ignore this parameter.
     *
     * @return true if the endpoint is in active state. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext);

    /**
     * Sets the endpoint as active or inactive. If an endpoint is detected as failed, it should be
     * set as inactive. But endpoints may be eventually set as active by the endpoint refresher to
     * avoid ignoring endpoints forever.
     *
     * @param active true if active. false otherwise.
     *
     * @param synMessageContext MessageContext for the current message. This is required for
     * IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     * Endpoint implementations may ignore this parameter.
     */
    public void setActive(boolean active, MessageContext synMessageContext);
}
"
org/apache/synapse/config/xml/StartupFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.xml.namespace.QName;

import org.apache.axiom.om.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Startup;
import org.apache.synapse.startup.quartz.SimpleQuartzFactory;

import sun.misc.Service;

public class StartupFinder {

    private static final Log log = LogFactory
            .getLog(ConfigurationFactoryAndSerializerFinder.class);

    private static StartupFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap(),
            serializerMap = new HashMap();

    public static synchronized StartupFinder getInstance() {
        if (instance == null) {
            instance = new StartupFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private static final Class[] builtins = {SimpleQuartzFactory.class};

    private StartupFinder() {
        // preregister any built in
        for (int i = 0; i < builtins.length; i++) {
            Class b = builtins[i];
            StartupFactory sf;
            try {
                sf = (StartupFactory) b.newInstance();
            } catch (Exception e) {
                throw new SynapseException(""cannot instantiate "" + b.getName(), e);

            }
            factoryMap.put(sf.getTagQName(), b);
            serializerMap.put(sf.getTagQName(), sf.getSerializerClass());

        }

        registerExtensions();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     * <p/>
     * This looks for JAR files containing a META-INF/services that adheres to
     * the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        // log.debug(""Registering mediator extensions found in the classpath : ""
        // + System.getResource(""java.class.path""));

        // register MediatorFactory extensions
        Iterator it = Service.providers(StartupFactory.class);
        while (it.hasNext()) {
            StartupFactory sf = (StartupFactory) it.next();
            QName tag = sf.getTagQName();
            factoryMap.put(tag, sf.getClass());
            serializerMap.put(tag, sf.getSerializerClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added StartupFactory "" + sf.getClass()
                        + "" to handle "" + tag);
            }
        }
    }

    /**
     * This method returns a Processor given an OMElement. This will be used
     * recursively by the elements which contain processor elements themselves
     * (e.g. rules)
     *
     * @param element
     * @return Processor
     */
    public Startup getStartup(OMElement element) {

        QName qName = element.getQName();
        if (log.isDebugEnabled()) {
            log.debug(""Creating the Startup for : "" + qName);
        }

        Class cls = (Class) factoryMap.get(qName);
        if (cls == null) {
            String msg = ""Unknown Startup type referenced by startup element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            StartupFactory sf = (StartupFactory) cls.newInstance();
            return sf.createStartup(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * This method will serialize the config using the supplied QName (looking
     * up the right class to do it)
     *
     * @param parent  -
     *                Parent OMElement to which the created element will be added if
     *                not null
     * @param startup -
     *                Startup to be serialized
     * @return OMElement startup
     */
    public OMElement serializeStartup(OMElement parent, Startup startup) {

        Class cls = (Class) serializerMap.get(startup.getTagQName());
        if (cls == null) {
            String msg = ""Unknown startup type referenced by startup element : ""
                    + startup.getTagQName();
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            StartupSerializer ss = (StartupSerializer) cls.newInstance();
            return ss.serializeStartup(parent, startup);

        } catch (InstantiationException e) {
            String msg = ""Error initializing startup serializer: "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing startup ser: "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /*
      * This method exposes all the StartupFactories and its Extensions
      */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /*
	 * This method exposes all the StartupSerializers and its Extensions
	 */
    public Map getSerializerMap() {
        return serializerMap;
    }

    /**
     * Allow the startup finder to act as an XMLToObjectMapper for
     * Startup (i.e. Startup) loaded dynamically from a Registry
     *
     * @param om
     * @return
     */
    public Startup getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getStartup((OMElement) om);
        } else {
			handleException(""Invalid configuration XML : "" + om);
		}
		return null;
	}

}
"
org/apache/synapse/startup/quartz/SimpleQuartzFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import java.util.Iterator;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.config.xml.PropertyHelper;
import org.apache.synapse.config.xml.StartupFactory;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseException;

/**
 * &lt;task class=""org.my.synapse.Task"" name=""string""&gt;
 *  &lt;property name=""stringProp"" value=""String""/&gt;
 *  &lt;property name=""xmlProp""&gt;
 *   &lt;somexml&gt;config&lt;/somexml&gt;
 *  &lt;/property&gt;
 *  &lt;trigger ([[count=""10""]? interval=""1000""] | [cron=""0 * 1 * * ?""] | [once=(true | false)])/&gt;
 * &lt;/task&gt;
 */
public class SimpleQuartzFactory implements StartupFactory {

    public final static QName TASK
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""task"");

    private final static QName TRIGGER
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""trigger"");

    private final static QName PROPERTY
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");

    private final static Log log = LogFactory.getLog(SimpleQuartzFactory.class);

    public Startup createStartup(OMElement el) {
        
        if (log.isDebugEnabled()) {
            log.debug(""Creating SimpleQuartz Task"");
        }
        
        if (el.getQName().equals(TASK)) {
            
            SimpleQuartz q = new SimpleQuartz();

            String name = el.getAttributeValue(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
            if (name != null) {
                q.setName(name);
            } else {
                handleException(""Name for a task is required, missing name in the task"");
            }

            // set the task class
            OMAttribute classAttr = el.getAttribute(new QName(""class""));
            if (classAttr != null && classAttr.getAttributeValue() != null) {
                String classname = classAttr.getAttributeValue();
                try {
                    Class.forName(classname).newInstance();
                } catch (Exception e) {
                    handleException(""Failed to load task class "" + classname, e);
                }
                q.setJobClass(classname);
            } else {
                handleException(""Syntax error in the Task : no task class specified"");
            }

            // next sort out the property children
            Iterator it = el.getChildrenWithName(PROPERTY);
            while (it.hasNext()) {
                OMElement prop = (OMElement) it.next();
                if (PropertyHelper.isStaticProperty(prop)) {
                    q.addProperty(prop);
                } else {
                    handleException(""Tasks does not support dynamic properties"");
                }
            }

            // setting the trigger to the task
            OMElement trigger = el.getFirstChildWithName(TRIGGER);
            if (trigger != null) {

                OMAttribute count = trigger.getAttribute(new QName(""count""));
                if (count != null) {
                    try {
                        q.setCount(Integer.parseInt(count.getAttributeValue()));
                    } catch (Exception e) {
                        handleException(""Failed to parse trigger count as an integer"", e);
                    }
                }

                OMAttribute once = trigger.getAttribute(new QName(""once""));
                if (once != null && Boolean.TRUE.toString().equals(once.getAttributeValue())) {
                    q.setCount(1);
                    q.setInterval(1);
                }

                OMAttribute repeatInterval = trigger.getAttribute(new QName(""interval""));
                if (repeatInterval == null && q.getCount() > 1) {
                    handleException(""Trigger seems to be "" +
                        ""a simple trigger, but no interval specified"");
                } else if (repeatInterval != null && repeatInterval.getAttributeValue() != null) {
                    try {
                        q.setInterval(Long.parseLong(repeatInterval.getAttributeValue()));
                    } catch (Exception e) {
                        handleException(""Failed to parse trigger interval as a long value"", e);
                    }
                }

                OMAttribute expr = trigger.getAttribute(new QName(""cron""));
                if (expr == null && q.getInterval() == 0) {
                    q.setCount(1);
                    q.setInterval(1);
                } else if (expr != null && q.getInterval() > 0) {
                    handleException(""Trigger syntax error : "" +
                        ""both cron and simple trigger attributes are present"");
                } else if (expr != null && expr.getAttributeValue() != null) {
                    q.setCron(expr.getAttributeValue());
                }

            } else {
                q.setCount(1);
                q.setInterval(1);
            }

            return q;
        } else {
            handleException(""Syntax error in the task : wrong QName for the task"");
            return null;
        }
    }

    public Class getSerializerClass() {
        return SimpleQuartzSerializer.class;
    }

    public QName getTagQName() {
        return TASK;
    }

    private void handleException(String message, Exception e) {
        log.error(message);
        throw new SynapseException(message, e);
    }

    private void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }

}
"
org/apache/synapse/ServerManager.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.axis2.description.TransportInDescription;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.engine.ListenerManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.config.SynapseConfiguration;

import java.io.File;
import java.net.ServerSocket;
import java.util.Iterator;
import java.util.Collection;

/**
 * To manage the Synapse Server  instances. This class is responsible for
 * the staring and stopping listeners
 */

public class ServerManager {

    private static ServerManager instance;
    private static final Log log = LogFactory.getLog(ServerManager.class);
    private String axis2Repolocation;
    private ListenerManager listenerManager;
    private ConfigurationContext configctx;

    /**
     * To ensure that there is a only one Manager
     * @return  Server Manager Instance
     */
    public static ServerManager getInstance() {
        if (instance == null) {
            instance = new ServerManager();
        }
        return instance;
    }

    public void setAxis2Repolocation(String axis2Repolocation) {
        this.axis2Repolocation = axis2Repolocation;
    }

    /**
     * starting all the listeners
     */
    public void start() {

        if (axis2Repolocation == null) {
            log.fatal(""The Axis2 Repository must be provided"");
            return;
        }
        log.info(""Using the Axis2 Repository ""
                           + new File(axis2Repolocation).getAbsolutePath());
        try {
            configctx = ConfigurationContextFactory.
                    createConfigurationContextFromFileSystem(axis2Repolocation, null);
            
            listenerManager = configctx.getListenerManager();
            if (listenerManager == null) {
                listenerManager = new ListenerManager();
                listenerManager.init(configctx);
            }
            // decide on HTTP port to execute
            selectPort(configctx);

            Iterator iter = configctx.getAxisConfiguration().
                    getTransportsIn().keySet().iterator();
            while (iter.hasNext()) {
                String trp = (String) iter.next();
                TransportInDescription trsIn = (TransportInDescription)
                        configctx.getAxisConfiguration().getTransportsIn().get(trp);
                listenerManager.addListener(trsIn, false);
                String msg = ""Starting transport "" + trsIn.getName();
                if (trsIn.getParameter(""port"") != null) {
                    msg += "" on port "" + trsIn.getParameter(""port"").getValue();
                }
                log.info(msg);
            }

            // now initialize SynapseConfig
            Parameter synEnv
                = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);
            Parameter synCfg
                = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);
            String message = ""Unable to initialize the Synapse Configuration : Can not find the "";
            if (synCfg == null || synCfg.getValue() == null
                || !(synCfg.getValue() instanceof SynapseConfiguration)) {
                log.fatal(message + ""Synapse Configuration"");
                throw new SynapseException(message + ""Synapse Configuration"");
            }

            if (synEnv == null || synEnv.getValue() == null
                || !(synEnv.getValue() instanceof SynapseEnvironment)) {
                log.fatal(message + ""Synapse Environment"");
                throw new SynapseException(message + ""Synapse Environment"");
            } else {
                ((SynapseEnvironment) synEnv.getValue()).setInitialized(true);
                // initialize the startups
                Collection startups = ((SynapseConfiguration) synCfg.getValue()).getStartups();
                for (Iterator it = startups.iterator(); it.hasNext();) {
                    Object o = it.next();
                    if (o instanceof ManagedLifecycle) {
                        ManagedLifecycle m = (ManagedLifecycle) o;
                        m.init((SynapseEnvironment) synEnv.getValue());
                    }
                }
            }
            log.info(""Ready for processing"");

        } catch (Throwable t) {
            t.printStackTrace();
            log.fatal(""Startup failed..."");
        }
    }

    /**
     * stop all the listeners
     */
    public void stop() {
        try {
            if (listenerManager != null) {
                listenerManager.stop();
                listenerManager.destroy();
            }
            //we need to call this method to clean the team fils we created.
            if (configctx != null) {
                configctx.terminate();
            }
        } catch (Exception ignored) {
        }
    }

    /**
     * Helper method to select a alternate port if the currently selected port is in use
     * @param configCtx configuration context 
     */
    private static void selectPort(ConfigurationContext configCtx) {
        // check if configured port is available
        TransportInDescription trsIn = (TransportInDescription)
                configCtx.getAxisConfiguration().getTransportsIn().get(""http"");

        if (trsIn != null) {

            int port = 8080;

            String strPort = System.getProperty(""port"");
            if (strPort != null) {
                // port is specified as a VM parameter
                try {
                    port = new Integer(strPort).intValue();
                } catch (NumberFormatException e) {
                    // user supplied parameter is not a valid integer. so use the port in configuration.
                    log.error(""Given port is not a valid integer. Port specified in the configuration is used for the server."");
                    port = Integer.parseInt(trsIn.getParameter(""port"").getValue().toString());
                }

            } else {
                port = Integer.parseInt(trsIn.getParameter(""port"").getValue().toString());
            }

            while (true) {
                ServerSocket sock = null;
                try {
                    sock = new ServerSocket(port);
                    trsIn.getParameter(""port"").setValue(Integer.toString(port));
                    break;
                } catch (Exception e) {
                    log.warn(""Port "" + port + "" already in use. Trying alternate"");
                    if (port == 8080) {
                        port = 8008;
                    } else {
                        port++;
                    }
                } finally {
                    if (sock != null) {
                        try {
                            sock.close();
                        } catch (Exception e) {
                        }
                    }
                }
            }
        }
    }

    public ConfigurationContext getConfigurationContext() {
        return configctx;
    }
}"
org/apache/synapse/mediators/ext/ClassMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.mediators.AbstractMediator;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * The class mediator delegates the mediation to a single instance of a specified
 * class. The specified class must implement the Mediator interface and optionally
 * may implement the ManagedLifecycle interface. At initialization time, a single
 * instance of the class is instantiated using a public no argument constructor, and
 * any one-time properties (parameter constants specified through the Synapse config)
 * are set on the instance. If each request needs synchronization, the user must
 * implement it within the specified class.
 * 
 * @see Mediator
 */
public class ClassMediator extends AbstractMediator implements ManagedLifecycle {

    /** The reference to the actual class that implments the Mediator interface */
    private Mediator mediator = null;
    /** A list of simple properties that would be set on the class before being used */
    private Map properties = new HashMap();

    /**
	 * Don't use a new instance... do one instance of the object per instance of
	 * this mediator
	 * 
	 * @param synCtx
	 *            the message context
	 * @return as per standard semantics
	 */
	public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Class mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (traceOrDebugOn) {
			traceOrDebug(traceOn, ""invoking : "" + mediator.getClass() + "".mediate()"");
		}

        boolean result = true;
        try {
			result = mediator.mediate(synCtx);
        } catch (Exception e) {
            // throw Synapse Exception for any exception in class meditor
            // so that the fault handler will be invoked
            throw new SynapseException(""Error occured in the mediation of the class mediator"", e);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Class mediator"");
        }
        return result;
    }

	public void destroy() {
        if (log.isDebugEnabled()) {
            log.debug(""Destroying class mediator instance for : "" + mediator.getClass());
        }
        if (mediator instanceof ManagedLifecycle) {
			((ManagedLifecycle) mediator).destroy();
		}
	}

	public void init(SynapseEnvironment se) {
        if (log.isDebugEnabled()) {
            log.debug(""Initializing class mediator instance for : "" + mediator.getClass());
        }
        if (mediator == null) {
            log.warn(""init() called before mediator reference set"");
            return;
		}

		if (mediator instanceof ManagedLifecycle) {
			((ManagedLifecycle) mediator).init(se);
		}
	}

	public void setMediator(Mediator mediator) {
		this.mediator = mediator;
	}

	public Mediator getMediator() {
		return mediator;
	}

    public void addProperty(String name, Object value) {
        properties.put(name, value);
    }

    public Map getProperties() {
        return this.properties;
    }
}
"
org/apache/synapse/core/axis2/AsyncCallback.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.client.async.Callback;
import org.apache.axis2.client.async.AsyncResult;
import org.apache.axis2.client.async.AxisCallback;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;

/**
 * This class only ""holds"" the Synapse out message context for the Synapse callback message
 * receiver when a response is received or error is encountered
 */
public class AsyncCallback implements AxisCallback {

    /** The corresponding Synapse outgoing message context this instance is holding onto */
    MessageContext synapseOutMsgCtx = null;

    /** Time to timeout this callback */
    private long timeOutOn;

    /** Action to perform when timeout occurs */
    private int timeOutAction = SynapseConstants.NONE;

    public AsyncCallback(MessageContext synapseOutMsgCtx) {
        this.synapseOutMsgCtx = synapseOutMsgCtx;
    }

    public void onMessage(org.apache.axis2.context.MessageContext messageContext) {}

    public void onFault(org.apache.axis2.context.MessageContext messageContext) {}

    public void onError(Exception e) {}

    public void onComplete() {}

    public org.apache.synapse.MessageContext getSynapseOutMsgCtx() {
        return synapseOutMsgCtx;
    }

    public long getTimeOutOn() {
        return timeOutOn;
    }

    public void setTimeOutOn(long timeOutOn) {
        this.timeOutOn = timeOutOn;
    }

    public int getTimeOutAction() {
        return timeOutAction;
    }

    public void setTimeOutAction(int timeOutAction) {
        this.timeOutAction = timeOutAction;
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointAbstractFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;

import javax.xml.namespace.QName;

/**
 * Abstract factory for endpoint factories. Use this class to obtain the EndpointFactory implementation
 * for the required endpoint configuration.
 */
public class EndpointAbstractFactory {

    /**
     * Returns the EndpointFactory implementation for given endpoint configuration. Throws a SynapseException,
     * if there is no EndpointFactory for given configuration.
     *
     * @param configElement Endpoint configuration.
     * @return EndpointFactory implementation.
     */
    public static EndpointFactory getEndpointFactroy(OMElement configElement) {

        if (configElement.getAttribute(new QName(""key"")) != null) {
            IndirectEndpointFactory endpointFactory = IndirectEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement addressElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""address""));
        if (addressElement != null) {
            EndpointFactory endpointFactory = AddressEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement wsdlElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""wsdl""));
        if (wsdlElement != null) {
            EndpointFactory endpointFactory = WSDLEndpointFactory.getInstance();
            return endpointFactory;
        }

        OMElement lbElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));
        if (lbElement != null) {
            OMElement sessionElement = configElement.
                    getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""session""));
            if (sessionElement != null) {
                EndpointFactory endpointFactory = SALoadbalanceEndpointFactory.getInstance();
                return endpointFactory;
            } else {
                EndpointFactory endpointFactory = LoadbalanceEndpointFactory.getInstance();
                return endpointFactory;
            }            
        }

        OMElement foElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""failover""));
        if (foElement != null) {
            EndpointFactory endpointFactory = FailoverEndpointFactory.getInstance();
            return endpointFactory;
        }

        throw new SynapseException(""Invalid endpoint configuration."");
    }
}
"
org/apache/synapse/util/PayloadHelper.java,false,"package org.apache.synapse.util;

import java.util.Iterator;

import javax.activation.DataHandler;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamReader;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMText;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axiom.soap.SOAP11Version;
import org.apache.axiom.soap.SOAPBody;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPVersion;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.SimpleMap;

public class PayloadHelper {
	
	// this has to match org.apache.axis2.base.transport.BaseConstants 
	// at some future point we will merge this into Axiom as a common parent
	public final static String AXIOMPAYLOADNS = ""http://ws.apache.org/commons/ns/payload"";

	public final static QName BINARYELT = new QName(AXIOMPAYLOADNS, ""binary"",
			""ax"");

	public final static QName TEXTELT = new QName(AXIOMPAYLOADNS, ""text"", ""ax"");

	public final static QName MAPELT = new QName(AXIOMPAYLOADNS, ""map"", ""ax"");

	public final static int XMLPAYLOADTYPE = 0, BINARYPAYLOADTYPE = 1,
			TEXTPAYLOADTYPE = 2, MAPPAYLOADTYPE = 3;

	public static final Log log = LogFactory.getLog(PayloadHelper.class);

	// gets a indication of the payload type. Default is XML
	// You cannot set the payload type. Instead, it is set automatically when
	// the payload is set
	public static int getPayloadType(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el.getQName().equals(BINARYELT))
			return BINARYPAYLOADTYPE;
		else if (el.getQName().equals(TEXTELT))
			return TEXTPAYLOADTYPE;
		else if (el.getQName().equals(MAPELT))
			return MAPPAYLOADTYPE;
		else
			return XMLPAYLOADTYPE; // default XML
	}

	public static int getPayloadType(MessageContext mc) {
		if (mc.getEnvelope() == null)
			return 0;
		return getPayloadType(mc.getEnvelope());
	}

	// XML Payload is carried as the first (and only) child of the body
	public static OMElement getXMLPayload(SOAPEnvelope envelope) {
		SOAPBody body = envelope.getBody();
		if (body == null) {
			log.error(""No body found"");
			return null;
		}
		OMElement bodyEl = body.getFirstElement();
		if (bodyEl == null) {
			log.error(""No body child found"");
			return null;
		}
		return bodyEl;
	}

	public static void setXMLPayload(SOAPEnvelope envelope, OMElement element) {
		SOAPBody body = envelope.getBody();
		if (body == null) {

			SOAPVersion version = envelope.getVersion();
			if (version.getEnvelopeURI().equals(
					SOAP11Version.SOAP_ENVELOPE_NAMESPACE_URI)) {
				body = OMAbstractFactory.getSOAP11Factory().createSOAPBody();
			} else {
				body = OMAbstractFactory.getSOAP12Factory().createSOAPBody();
			}
			if (envelope.getHeader() != null) {
				envelope.getHeader().insertSiblingAfter(body);
			} else {
				envelope.addChild(body);
			}
		} else {
			for (Iterator it = body.getChildren(); it.hasNext();) {
				OMNode node = (OMNode) it.next();
				node.discard();
			}
		}
		body.addChild(element);
	}

	public static void setXMLPayload(MessageContext mc, OMElement element) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setXMLPayload(mc.getEnvelope(), element);
	}

	// Binary Payload is carried in a wrapper element with QName BINARYELT
	public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(BINARYELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		OMNode textNode = el.getFirstOMChild();
		if (textNode.getType() != OMNode.TEXT_NODE) {
			log.error(""Text Node not found"");
			return null;
		}
		OMText text = (OMText) textNode;
		DataHandler dh = null;
		try {
			dh = (DataHandler) text.getDataHandler();
		} catch (ClassCastException ce) {
			log.error(""cannot get DataHandler"" + ce.getMessage());
			return null;
		}
		return dh;

	}

	public static DataHandler getBinaryPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getBinaryPayload(mc.getEnvelope());
	}

	public static void setBinaryPayload(SOAPEnvelope envelope, DataHandler dh) {
		OMFactory fac = envelope.getOMFactory();
		OMElement binaryElt = envelope.getOMFactory()
				.createOMElement(BINARYELT);
		OMText text = fac.createOMText(dh, true);
		binaryElt.addChild(text);
		setXMLPayload(envelope, binaryElt);
	}

	public static void setBinaryPayload(MessageContext mc, DataHandler dh) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setBinaryPayload(mc.getEnvelope(), dh);

	}

	// Text payload is carried in a wrapper element with QName TEXTELT
	public static String getTextPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(TEXTELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		OMNode textNode = el.getFirstOMChild();
		if (textNode.getType() != OMNode.TEXT_NODE) {
			log.error(""Text Node not found"");
			return null;
		}
		OMText text = (OMText) textNode;
		return text.getText();
	}

	public static String getTextPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getTextPayload(mc.getEnvelope());
	}

	public static void setTextPayload(SOAPEnvelope envelope, String text) {
		OMFactory fac = envelope.getOMFactory();
		OMElement textElt = envelope.getOMFactory().createOMElement(TEXTELT);
		OMText textNode = fac.createOMText(text);
		textElt.addChild(textNode);
		setXMLPayload(envelope, textElt);
	}

	public static void setTextPayload(MessageContext mc, String text) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setTextPayload(mc.getEnvelope(), text);
	}

	// Map payload must be a Map of String->int, boolean, float, double, char,
	// short, byte, byte[], long, String
	public static SimpleMap getMapPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(MAPELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		SimpleMap map = new SimpleMapImpl(el);
		return map;
	}

	public static SimpleMap getMapPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getMapPayload(mc.getEnvelope());
	}

	public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {

		if (map instanceof SimpleMapImpl) {
			SimpleMapImpl impl = (SimpleMapImpl) map;
			OMElement mapElt = impl.getOMElement(envelope.getOMFactory());
			if (mapElt == null) {
				log.debug(""null map element returned"");
				return;
			}
			setXMLPayload(envelope, mapElt);
		} else {
			throw new SynapseException(""cannot handle any other instance of SimpleMap at this point TODO"");
		}
	}

	public static void setMapPayload(MessageContext mc, SimpleMap map) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setMapPayload(mc.getEnvelope(), map);
	}
	
	public static XMLStreamReader getStAXPayload(SOAPEnvelope envelope) {
		 
		OMElement el = getXMLPayload(envelope);
		if (el==null) {
			return null;
		}
		return el.getXMLStreamReader();
	}
	public static XMLStreamReader getStAXPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getStAXPayload(mc.getEnvelope());
	}
	public static void setStAXPayload(SOAPEnvelope envelope, XMLStreamReader streamReader) {
		StAXOMBuilder builder = new StAXOMBuilder(envelope.getOMFactory(), streamReader);
		OMElement el = builder.getDocumentElement();
		setXMLPayload(envelope, el);
	}
	public static void setStAXPayload(MessageContext mc, XMLStreamReader streamReader) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
			setStAXPayload(mc.getEnvelope(), streamReader);
		}
	
	}
	
	
}
"
org/apache/synapse/config/xml/ProxyServiceFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointAbstractFactory;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.axis2.wsdl.WSDLConstants;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Creates a ProxyService instance using the XML fragment specification
 * <p/>
 * <proxy-service name=""string"" [transports=""(http |https |jms )+|all""] [trace=""enable|disable""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *    </publishWSDL>?
 *    <enableSec/>?
 *    <enableRM/>?
 *    <policy key=""string"">?
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxy-service>
 */
public class ProxyServiceFactory {

    private static final Log log = LogFactory.getLog(ProxyServiceFactory.class);

    public static ProxyService createProxy(OMElement elem) {

        ProxyService proxy = null;

        OMAttribute name = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name == null) {
            handleException(""The 'name' attribute is required for a Proxy service definition"");
        } else {
            proxy = new ProxyService(name.getAttributeValue());
        }

        OMAttribute statistics = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    proxy.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    proxy.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }

        OMAttribute trans = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""transports""));
        if (trans != null) {
            String transports = trans.getAttributeValue();
            if (transports == null || ProxyService.ALL_TRANSPORTS.equals(transports)) {
                // default to all transports using service name as destination
            } else {
                StringTokenizer st = new StringTokenizer(transports, "" ,"");
                ArrayList transportList = new ArrayList();
                while (st.hasMoreTokens()) {
                    String token = st.nextToken();
                    if (token.length() != 0) {
                        transportList.add(token);
                    }
                }
                proxy.setTransports(transportList);
            }
        }
        OMAttribute trace = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.TRACE_ATTRIB_NAME));
        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(XMLConfigConstants.TRACE_ENABLE)) {
                    proxy.setTraceState(org.apache.synapse.SynapseConstants.TRACING_ON);
                } else if (traceValue.equals(XMLConfigConstants.TRACE_DISABLE)) {
                    proxy.setTraceState(org.apache.synapse.SynapseConstants.TRACING_OFF);
                }
            }
        }
        OMAttribute startOnLoad = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""startOnLoad""));
        if (startOnLoad != null) {
            proxy.setStartOnLoad(Boolean.valueOf(startOnLoad.getAttributeValue()).booleanValue());
        } else {
            proxy.setStartOnLoad(true);
        }

        // setting the description of the proxy service
        OMElement descriptionElement = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""description""));
        if (descriptionElement != null) {
            proxy.setDescription(descriptionElement.getText().trim());
        }

        // read definition of the target of this proxy service. The target could be an 'endpoint'
        // or a named sequence. If none of these are specified, the messages would be mediated
        // by the Synapse main mediator
        OMElement target = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target""));
        if (target != null) {
            boolean isTargetOk = false;
            SequenceMediatorFactory mediatorFactory = new SequenceMediatorFactory();
            OMAttribute inSequence = target.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""inSequence""));
            if (inSequence != null) {
                proxy.setTargetInSequence(inSequence.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement inSequenceElement = target.getFirstChildWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""inSequence""));
                if (inSequenceElement != null) {
                    proxy.setTargetInLineInSequence(mediatorFactory.createAnonymousSequence(inSequenceElement));
                    isTargetOk = true;
                }
            }
            OMAttribute outSequence = target.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""outSequence""));
            if (outSequence != null) {
                proxy.setTargetOutSequence(outSequence.getAttributeValue());
            } else {
                OMElement outSequenceElement = target.getFirstChildWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""outSequence""));
                if (outSequenceElement != null) {
                    proxy.setTargetInLineOutSequence(mediatorFactory.createAnonymousSequence(outSequenceElement));
                } else {
                    handleException(""Target for the proxy service must declare an out sequence"");
                }
            }
            OMAttribute faultSequence = target.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""faultSequence""));
            if (faultSequence != null) {
                proxy.setTargetFaultSequence(faultSequence.getAttributeValue());
            } else {
                OMElement faultSequenceElement = target.getFirstChildWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""faultSequence""));
                if (faultSequenceElement != null) {
                    proxy.setTargetInLineFaultSequence(mediatorFactory.createAnonymousSequence(faultSequenceElement));
                }
            }
            OMAttribute tgtEndpt = target.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""endpoint""));
            if (tgtEndpt != null) {
                proxy.setTargetEndpoint(tgtEndpt.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement endpointElement = target.getFirstChildWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint""));
                if (endpointElement != null) {
                    EndpointFactory fac = EndpointAbstractFactory.getEndpointFactroy(endpointElement);
                    proxy.setTargetInLineEndpoint(fac.createEndpoint(endpointElement, true));
                    isTargetOk = true;
                }
            }
            if(!isTargetOk) {
                handleException(""Target of the proxy service must declare either an inSequence or endpoint or both"");
            }
        } else {
            handleException(""Target is required for a Proxy service definition"");
        }

        // read the WSDL, Schemas and Policies and set to the proxy service
        OMElement wsdl = elem.getFirstChildWithName(new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""publishWSDL""));
        if (wsdl != null) {
            OMAttribute wsdlkey = wsdl.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
            if (wsdlkey != null) {
                proxy.setWSDLKey(wsdlkey.getAttributeValue());
            } else {
                OMAttribute wsdlURI = wsdl.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""uri""));
                if (wsdlURI != null) {
                    try {
                        proxy.setWsdlURI(new URI(wsdlURI.getAttributeValue()));
                    } catch (URISyntaxException e) {
                        String msg = ""Error creating uri for proxy service wsdl"";
                        log.error(msg);
                        handleException(msg, e);
                    }
                } else {
                    OMElement wsdl11 = wsdl.getFirstChildWithName(new QName(WSDLConstants.WSDL1_1_NAMESPACE, ""definitions""));
                    if (wsdl11 != null) {
                        proxy.setInLineWSDL(wsdl11);
                    } else {
                        OMElement wsdl20 = wsdl.getFirstChildWithName(new QName(WSDLConstants.WSDL2_0_NAMESPACE, ""descriptions""));
                        if (wsdl20 != null) {
                            proxy.setInLineWSDL(wsdl20);
                        }
                    }
                }
            }
        }

//        OMElement schema = elem.getFirstChildWithName(
//                new QName(Constants.SYNAPSE_NAMESPACE, ""schema""));
        Iterator policies = elem.getChildrenWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""policy""));
        while (policies.hasNext()) {
            Object o = policies.next();
            if (o instanceof OMElement) {
                OMElement policy = (OMElement) o;
                OMAttribute key = policy.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
                if (key != null) {
                    proxy.addServiceLevelPolicy(key.getAttributeValue());
                } else {
                    handleException(""Policy element does not specify the policy key"");
                }
            } else {
                handleException(""Invalid 'policy' element found under element 'policies'"");
            }
        }

        Iterator props = elem.getChildrenWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter""));
        while (props.hasNext()) {
            Object o = props.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
                OMElement propertyValue = prop.getFirstElement();
                if (pname != null) {
                    if (propertyValue != null) {
                        proxy.addParameter(pname.getAttributeValue(), propertyValue);
                    } else {
                        proxy.addParameter(pname.getAttributeValue(), prop.getText().trim());
                    }
                } else {
                    handleException(""Invalid property specified for proxy service : "" + name);
                }
            } else {
                handleException(""Invalid property specified for proxy service : "" + name);
            }
        }

        if (elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableRM"")) != null) {
            proxy.setWsRMEnabled(true);
        }

        if (elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableSec"")) != null) {
            proxy.setWsSecEnabled(true);
        }

        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

}
"
org/apache/synapse/endpoints/utils/EndpointDefinition.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.utils;

import org.apache.synapse.SynapseConstants;


/**
 * Endpoint definition contains the information about an web services endpoint. It is used by leaf
 * level endpoints to keep these information (e.g. AddressEndpoint and WSDLEndpoint). An EndpointDefinition
 * object is used by only one endpoint and they cannot be looked up in the registry.
 */
public class EndpointDefinition {

    /** The simple address this endpoint resolves to - if explicitly specified */
    private String address = null;
    /** Should messages be sent in an WS-RM Sequence ? */
    private boolean reliableMessagingOn = false;
    /** Should messages be sent using WS-A? */
    private boolean addressingOn = false;
    /** Should messages be sent using WS-Security? */
    private boolean securityOn = false;
    /** The ""key"" for any WS-RM Policy overrides to be used */
    private String wsRMPolicyKey = null;
    /** The ""key"" for any Rampart Security Policy to be used */
    private String wsSecPolicyKey = null;
    /** use a separate listener - implies addressing is on **/
	private boolean useSeparateListener = false;
	/** force REST on **/
	private boolean forcePOX = false;
	/** force SOAP11 on **/
	private boolean forceSOAP11 = false;
    /** force SOAP11 on **/
	private boolean forceSOAP12 = false;
    /** use MTOM **/
    private boolean useMTOM = false;
    /** use SWA **/
    private boolean useSwa = false;
    /** Endpoint message format. pox/soap11/soap12 */
    private String format = null;

    /**
     * timeout duration for waiting for a response. if the user has set some timeout action and
     * the timeout duration is not set, default is set to 0 seconds. note that if the user has
     * not set any timeout configuration, default timeout action is set to NONE, which won't do
     * anything for timeouts.
    */
    private long timeoutDuration = 0;

    /** action to perform when a timeout occurs (NONE | DISCARD | DISCARD_AND_FAULT) **/
    private int timeoutAction = SynapseConstants.NONE;

    /** To decide to whether statistics should have collected or not */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;

    /** The variable that indicate tracing on or off for the current mediator */
    private int traceState = SynapseConstants.TRACING_UNSET;

    /**
     * This should return the absolute EPR address referenced by the named endpoint. This may be possibly computed.
     * @return an absolute address to be used to reference the named endpoint
     */
    public String getAddress() {
        return address;
    }

    /**
     * Set an absolute URL as the address for this named endpoint
     * @param address the absolute address to be used
     */
    public void setAddress(String address) {
        this.address = address;
    }

    /**
     * Is RM turned on on this endpoint?
     * @return true if on
     */
    public boolean isReliableMessagingOn() {
        return reliableMessagingOn;
    }

    /**
     * Request that RM be turned on/off on this endpoint
     * @param reliableMessagingOn
     */
    public void setReliableMessagingOn(boolean reliableMessagingOn) {
        this.reliableMessagingOn = reliableMessagingOn;
    }

    /**
     * Is WS-A turned on on this endpoint?
     * @return true if on
     */
    public boolean isAddressingOn() {
        return addressingOn;
    }

    /**
     * Request that WS-A be turned on/off on this endpoint
     * @param addressingOn
     */
    public void setAddressingOn(boolean addressingOn) {
        this.addressingOn = addressingOn;
    }

    /**
     * Is WS-Security turned on on this endpoint?
     * @return true if on
     */
    public boolean isSecurityOn() {
        return securityOn;
    }

    /**
     * Request that WS-Sec be turned on/off on this endpoint
     * @param securityOn
     */
    public void setSecurityOn(boolean securityOn) {
        this.securityOn = securityOn;
    }

    /**
     * Return the Rampart Security configuration policys' 'key' to be used (See Rampart)
     * @return the ORampart Security configuration policys' 'key' to be used (See Rampart)
     */
    public String getWsSecPolicyKey() {
        return wsSecPolicyKey;
    }

    /**
     * Set the Rampart Security configuration policys' 'key' to be used (See Rampart)
     * @param wsSecPolicyKey the Rampart Security configuration policys' 'key' to be used (See Rampart)
     */
    public void setWsSecPolicyKey(String wsSecPolicyKey) {
        this.wsSecPolicyKey = wsSecPolicyKey;
    }

    /**
     * Get the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     * @return the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     */
    public String getWsRMPolicyKey() {
        return wsRMPolicyKey;
    }

    /**
     * Set the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     * @param wsRMPolicyKey the WS-RM configuration policys' 'key' to be used (See Sandesha2)
     */
    public void setWsRMPolicyKey(String wsRMPolicyKey) {
        this.wsRMPolicyKey = wsRMPolicyKey;
    }

	public void setUseSeparateListener(boolean b) {
		this.useSeparateListener = b;
	}
	public boolean isUseSeparateListener() {
		return useSeparateListener;
	}

	public void setForcePOX(boolean forcePOX) {
		this.forcePOX = forcePOX;
	}

	public boolean isForcePOX() {
		return forcePOX;
	}

	public void setForceSOAP11(boolean forceSOAP11) {
		this.forceSOAP11 = forceSOAP11;
	}

	public boolean isForceSOAP11() {
		return forceSOAP11;
	}

    public void setForceSOAP12(boolean forceSOAP12) {
		this.forceSOAP12 = forceSOAP12;
	}

	public boolean isForceSOAP12() {
		return forceSOAP12;
	}

    public boolean isUseMTOM() {
        return useMTOM;
    }

    public void setUseMTOM(boolean useMTOM) {
        this.useMTOM = useMTOM;
    }

    public boolean isUseSwa() {
        return useSwa;
    }

    public void setUseSwa(boolean useSwa) {
        this.useSwa = useSwa;
    }

    public long getTimeoutDuration() {
        return timeoutDuration;
    }

    public void setTimeoutDuration(long timeoutDuration) {
        this.timeoutDuration = timeoutDuration;
    }

    public int getTimeoutAction() {
        return timeoutAction;
    }

    public void setTimeoutAction(int timeoutAction) {
        this.timeoutAction = timeoutAction;
    }
    
    public String getFormat() {
        return format;
	}

	public void setFormat(String format) {
		this.format = format;
	}

	/**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    public int getTraceState() {
        return traceState;
    }

    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }
}
"
org/apache/synapse/core/axis2/Axis2Sender.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.util.Utils;
import org.apache.synapse.transport.nhttp.NhttpConstants;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.AxisEngine;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.rampart.handler.WSSHandlerConstants;

/**
 * This class helps the Axis2SynapseEnvironment implement the send method
 */
public class Axis2Sender {

    private static final Log log = LogFactory.getLog(Axis2Sender.class);

    /**
     * Send a message out from the Synapse engine to an external service
     * @param endpoint the endpoint definition where the message should be sent
     * @param synapseInMessageContext the Synapse message context
     */
    public static void sendOn(EndpointDefinition endpoint,
        org.apache.synapse.MessageContext synapseInMessageContext) {

        try {
            Axis2FlexibleMEPClient.send(
                // The endpoint where we are sending to
                endpoint,
                // The Axis2 Message context of the Synapse MC
                synapseInMessageContext);

        } catch (Exception e) {
            handleException(""Unexpected error during sending message out"", e);
        }
    }

    /**
     * Send a response back to a client of Synapse
     * @param smc the Synapse message context sent as the response
     */
    public static void sendBack(org.apache.synapse.MessageContext smc) {

        MessageContext messageContext = ((Axis2MessageContext) smc).getAxis2MessageContext();

        // if this is a dummy 202 Accepted message meant only for the http/s transports
        // prevent it from going into any other transport sender
        if (messageContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED) &&
            messageContext.getTransportOut() != null &&
            !messageContext.getTransportOut().getName().startsWith(Constants.TRANSPORT_HTTP)) {
                return;
        }

        AxisEngine ae = new AxisEngine(messageContext.getConfigurationContext());

        try {
            messageContext.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            // check if addressing is already engaged for this message.
            // if engaged we should use the addressing enabled Configuraion context.
            if (smc.isResponse()) {
                //Process statistics
                StatisticsUtils.processEndPointStatistics(smc);
                StatisticsUtils.processProxyServiceStatistics(smc);
                StatisticsUtils.processAllSequenceStatistics(smc);
            }
            Axis2FlexibleMEPClient.removeAddressingHeaders(messageContext);
            messageContext.setMessageID(UUIDGenerator.getUUID());

            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (messageContext.isEngaged(WSSHandlerConstants.SECURITY_MODULE_NAME) &&
                messageContext.getEnvelope().getHeader() == null) {
                SOAPFactory fac = messageContext.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(messageContext.getEnvelope());
            }
            ae.send(messageContext);

        } catch (AxisFault e) {
            handleException(""Unexpected error sending message back"", e);
        }
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/registry/url/URLRegistryEntry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry.url;

import org.apache.synapse.registry.RegistryEntry;

import java.net.URI;
import java.util.Date;

public class URLRegistryEntry implements RegistryEntry {

    private String key = null;
    private String name = null;
    private long version = Long.MIN_VALUE;
    private URI type = null;
    private String description;
    private long created;
    private long lastModified;
    private long cachableDuration;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public URI getType() {
        return type;
    }

    public void setType(URI type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getCreated() {
        return created;
    }

    public void setCreated(long created) {
        this.created = created;
    }

    public long getLastModified() {
        return lastModified;
    }

    public void setLastModified(long lastModified) {
        this.lastModified = lastModified;
    }

    public long getCachableDuration() {
        return cachableDuration;
    }

    public void setCachableDuration(long cachableDuration) {
        this.cachableDuration = cachableDuration;
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(""RegistryEntry {"")
            .append("" Key : "" + key)
            .append("" Name : "" + name)
            .append("" Ver : "" + version)
            .append("" Type : "" + type)
            .append("" Desc : "" + description)
            .append("" Created : "" + new Date(created))
            .append("" Modified : "" + new Date(lastModified))
            .append("" Cacheable for : "" + (cachableDuration / 1000) + ""sec"")
            .append(""}"");
        return sb.toString();
    }
}
"
org/apache/synapse/mediators/eip/splitter/IterateMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.splitter;

import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.eip.EIPUtils;
import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.util.MessageHelper;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.OperationContext;
import org.jaxen.JaxenException;

import java.util.List;
import java.util.Iterator;

/**
 * This mediator will split the message in the criterian specified to it and inject in to Synapse
 */
public class IterateMediator extends AbstractMediator {

    /**
     * This holds whether to continue mediation on the parent message or not
     */
    private boolean continueParent = false;

    /**
     * This holds whether to preserve the payload and attach the iteration child to specified node
     * or to attach the child to the body of the envelope
     */
    private boolean preservePayload = false;

    /**
     * This holds the expression which will be evaluated for the presence of elements in the
     * mediating message for iterations
     */
    private AXIOMXPath expression = null;

    /**
     * This holds the node to which the iteration childs will be attached. This does not have any
     * meaning when the preservePayload is set to false
     */
    private AXIOMXPath attachPath = null;

    /**
     * This holds the target object for the newly created messages by the iteration
     */
    private Target target = null;

    /**
     * This method implemenents the Mediator interface and this mediator implements the message
     * splitting logic
     *
     * @param synCtx - MessageContext to be mediated
     * @return boolean false if need to stop processing the parent message, boolean true if further
     *         processing of the parent message is required
     */
    public boolean mediate(MessageContext synCtx) {

        // initializes the logging and tracing for the mediator
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Iterate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            // get a copy of the message for the processing, if the continueParent is set to true
            // this original message can go in further mediations and hence we should not change
            // the original message context
            SOAPEnvelope envelope = MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope());

            // get the iteration elements and iterate through the list,
            // this call will also detach all the iteration elements 
            List splitElements = EIPUtils.getDetachedMatchingElements(envelope, expression);
            if (splitElements != null) {

                int msgCount = splitElements.size();
                int msgNumber = 0;

                // if not preservePayload remove all the child elements
                if (!preservePayload && envelope.getBody() != null) {
                    for (Iterator itr = envelope.getBody().getChildren(); itr.hasNext();) {
                        ((OMNode) itr.next()).detach();
                    }
                }

                // iterate through the list
                for (Object o : splitElements) {

                    // clone the message for the mediation in iteration
                    MessageContext newCtx = MessageHelper.cloneMessageContext(synCtx);
                    // set the messageSequence property for possibal aggreagtions
                    newCtx.setProperty(EIPConstants.MESSAGE_SEQUENCE,
                        msgNumber + EIPConstants.MESSAGE_SEQUENCE_DELEMITER + msgCount);
                    // get a clone of the envelope to be attached
                    SOAPEnvelope newEnvelope = MessageHelper.cloneSOAPEnvelope(envelope);

                    // for the moment iterator will look for an OMNode as the iteration element
                    if (!(o instanceof OMNode)) {
                        handleException(
                            ""Error in splitting the message with expression : "" + expression,
                            synCtx);
                    }

                    // if payload should be preserved then attach the iteration element to the
                    // node specified by the attachPath
                    if (preservePayload) {

                        Object attachElem = attachPath.evaluate(newEnvelope);
                        if (attachElem instanceof List) {
                            attachElem = ((List) attachElem).get(0);
                        }

                        // for the moment attaching element should be an OMElement
                        if (attachElem instanceof OMElement) {
                            ((OMElement) attachElem).addChild((OMNode) o);
                        } else {
                            handleException(""Error in attaching the splitted elements :: "" +
                                ""Unable to get the attach path specified by the expression "" +
                                attachPath, synCtx);
                        }
                        // if not preserve payload then attach the iteration element to the body
                    } else if (o instanceof OMNode && newEnvelope.getBody() != null) {
                        newEnvelope.getBody().addChild((OMNode) o);
                    }

                    // set the envelope ant mediate as specified in the target
                    newCtx.setEnvelope(newEnvelope);
                    target.mediate(newCtx);
                    msgNumber++;

                }

            } else {
                handleException(
                    ""Splitting by expression : "" + expression + "" did not yeild in an OMElement"",
                    synCtx);
            }

        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression : "" + expression, e, synCtx);
        } catch (AxisFault axisFault) {
            handleException(""Unable to split the message using the expression : "" + expression,
                axisFault, synCtx);
        }

        // finalizing the tracing and logging on the iterate mediator
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Iterate mediator"");
        }

        // if the continuation of the parent message is stopped from here set the RESPONSE_WRITTEN
        // property to SKIP to skip the blank http response 
        OperationContext opCtx
            = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();
        if (!continueParent && opCtx != null) {
            opCtx.setProperty(Constants.RESPONSE_WRITTEN,""SKIP"");
        }

        // whether to continue mediation on the original message
        return continueParent;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public boolean isContinueParent() {
        return continueParent;
    }

    public void setContinueParent(boolean continueParent) {
        this.continueParent = continueParent;
    }

    public boolean isPreservePayload() {
        return preservePayload;
    }

    public void setPreservePayload(boolean preservePayload) {
        this.preservePayload = preservePayload;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    public AXIOMXPath getAttachPath() {
        return attachPath;
    }

    public void setAttachPath(AXIOMXPath attachPath) {
        this.attachPath = attachPath;
    }

    public Target getTarget() {
        return target;
    }

    public void setTarget(Target target) {
        this.target = target;
    }

}
"
org/apache/synapse/config/xml/AbstractDBMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.dbcp.BasicDataSource;
import org.apache.synapse.mediators.db.AbstractDBMediator;
import org.apache.synapse.mediators.db.Statement;
import org.jaxen.JaxenException;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import javax.xml.namespace.QName;
import java.sql.Connection;
import java.util.Hashtable;
import java.util.Iterator;

/**
 * <dbreport | dblookup | .. etc>
 *   <connection>
 *     <pool>
 *     (
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     | 
 *       <dsName/>
 *       <icClass/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     )
 *       <property name=""name"" value=""value""/>*
 *     </pool>
 *   </connection>
 *   <statement>
 *     <sql>insert into table values (?, ?, ..) OR select target from destinations where src = ?</sql>
 *     <parameter (value=""const"" | expression=""xpath"") type=""INTEGER|VARCHAR|...""/>*
 *     <result name=""propName"" column=""target | number""/>*
 *   </statement>+
 * </dbreport | dblookup | .. etc>
 *
 * Supported properties for custom DataSources
 * autocommit = true | false
 * isolation = Connection.TRANSACTION_NONE
 *           | Connection.TRANSACTION_READ_COMMITTED
 *           | Connection.TRANSACTION_READ_UNCOMMITTED 
 *           | Connection.TRANSACTION_REPEATABLE_READ 
 *           | Connection.TRANSACTION_SERIALIZABLE
 * initialsize = int
 * maxactive = int
 * maxidle = int
 * maxopenstatements = int
 * maxwait = long
 * minidle = int
 * poolstatements = true | false
 * testonborrow = true | false
 * testonreturn = true | false
 * testwhileidle = true | false
 * validationquery = String
 */
public abstract class AbstractDBMediatorFactory extends AbstractMediatorFactory {

    public static final QName URL_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""url"");
    static final QName DRIVER_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""driver"");
    static final QName USER_Q     = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""user"");
    static final QName PASS_Q     = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""password"");

    static final QName DSNAME_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""dsName"");
    static final QName ICCLASS_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""icClass"");

    static final QName STMNT_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""statement"");
    static final QName SQL_Q      = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sql"");
    static final QName PARAM_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter"");
    static final QName RESULT_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""result"");

    static final QName ATT_COLUMN = new QName(""column"");
    static final QName ATT_TYPE   = new QName(""type"");

    protected void buildDataSource(OMElement elem, AbstractDBMediator mediator) {

        OMElement pool = null;
        // get the 'pool' element and determine if we need to create a DataSource or
        // look up using JNDI
        try {
            AXIOMXPath xpath = new AXIOMXPath(""//syn:connection/syn:pool"");
            xpath.addNamespace(""syn"", XMLConfigConstants.SYNAPSE_NAMESPACE);
            pool = (OMElement) xpath.selectSingleNode(elem);

            if (pool.getFirstChildWithName(DRIVER_Q) != null) {
                mediator.setDataSource(createCustomDataSource(pool, mediator));

            } else if (
                pool.getFirstChildWithName(ICCLASS_Q) != null &&
                pool.getFirstChildWithName(DSNAME_Q) != null) {
                mediator.setDataSource(lookupDataSource(pool, mediator));
            } else {
                handleException(""The DataSource connection information must be specified for "" +
                    ""using a custom DataSource connection pool or for a JNDI lookup"");
            }

        } catch (JaxenException e) {
            handleException(""Error looking up DataSource connection information"", e);
        }
    }

    /**
     * Lookup the DataSource on JNDI using the specified properties
     * @param pool the toplevel 'pool' element that holds DataSource information
     * @param mediator the mediator to store properties for serialization
     * @return a DataSource looked up using specified properties
     */
    private DataSource lookupDataSource(OMElement pool, AbstractDBMediator mediator) {

        Hashtable props = new Hashtable();
        // load the minimum required properties
        props.put(Context.INITIAL_CONTEXT_FACTORY, (getValue(pool, ICCLASS_Q)));
        props.put(Context.SECURITY_PRINCIPAL, getValue(pool, USER_Q));
        props.put(Context.SECURITY_CREDENTIALS, getValue(pool, PASS_Q));
        props.put(Context.PROVIDER_URL, getValue(pool, URL_Q));
        String dsName = getValue(pool, DSNAME_Q);

        //save loaded properties for later
        mediator.addDataSourceProperty(ICCLASS_Q, getValue(pool, ICCLASS_Q));
        mediator.addDataSourceProperty(DSNAME_Q,  getValue(pool, DSNAME_Q));
        mediator.addDataSourceProperty(URL_Q,  getValue(pool, URL_Q));
        mediator.addDataSourceProperty(USER_Q, getValue(pool, USER_Q));
        mediator.addDataSourceProperty(PASS_Q, getValue(pool, PASS_Q));

        try {
            Context ctx = new InitialContext(props);
            if (ctx != null) {
                Object ds = ctx.lookup(dsName);
                if (ds != null && ds instanceof DataSource) {
                    return (DataSource) ds;
                } else {
                    handleException(""DataSource : "" + dsName + "" not found when looking up"" +
                        "" using JNDI properties : "" + props);
                }
            } else {
                handleException(""Error getting InitialContext using JNDI properties : "" + props);
            }
        } catch (NamingException e) {
            handleException(""Error looking up DataSource : "" + dsName +
                "" using JNDI properties : "" + props, e);
        }
        return null;
    }

    /**
     * Create a custom DataSource using the specified properties and Apache DBCP
     * @param pool the toplevel 'pool' element that holds DataSource information
     * @param mediator the mediator to store properties for serialization
     * @return a DataSource created using specified properties
     */
    private DataSource createCustomDataSource(OMElement pool, AbstractDBMediator mediator) {

        BasicDataSource ds = new BasicDataSource();

        // load the minimum required properties
        ds.setDriverClassName(getValue(pool, DRIVER_Q));
        ds.setUsername(getValue(pool, USER_Q));
        ds.setPassword(getValue(pool, PASS_Q));
        ds.setUrl(getValue(pool, URL_Q));

        //save loaded properties for later
        mediator.addDataSourceProperty(DRIVER_Q, getValue(pool, DRIVER_Q));
        mediator.addDataSourceProperty(URL_Q,  getValue(pool, URL_Q));
        mediator.addDataSourceProperty(USER_Q, getValue(pool, USER_Q));
        mediator.addDataSourceProperty(PASS_Q, getValue(pool, PASS_Q));

        Iterator props = pool.getChildrenWithName(PROP_Q);
        while (props.hasNext()) {

            OMElement prop = (OMElement) props.next();
            String name  = prop.getAttribute(ATT_NAME).getAttributeValue();
            String value = prop.getAttribute(ATT_VALUE).getAttributeValue();
            // save property for later
            mediator.addDataSourceProperty(name, value);

            if (""autocommit"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setDefaultAutoCommit(true);
                } else if (""false"".equals(value)) {
                    ds.setDefaultAutoCommit(false);
                }
            } else if (""isolation"".equals(name)) {
                try {
                    if (""Connection.TRANSACTION_NONE"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_NONE);
                    } else if (""Connection.TRANSACTION_READ_COMMITTED"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
                    } else if (""Connection.TRANSACTION_READ_UNCOMMITTED"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
                    } else if (""Connection.TRANSACTION_REPEATABLE_READ"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
                    } else if (""Connection.TRANSACTION_SERIALIZABLE"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
                    }
                } catch (NumberFormatException ignore) {}
            } else if (""initialsize"".equals(name)) {
                try {
                    ds.setInitialSize(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxactive"".equals(name)) {
                try {
                    ds.setMaxActive(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxidle"".equals(name)) {
                try {
                    ds.setMaxIdle(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxopenstatements"".equals(name)) {
                try {
                    ds.setMaxOpenPreparedStatements(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxwait"".equals(name)) {
                try {
                    ds.setMaxWait(Long.parseLong(value));
                } catch (NumberFormatException ignore) {}
            } else if (""minidle"".equals(name)) {
                try {
                    ds.setMinIdle(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""poolstatements"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setPoolPreparedStatements(true);
                } else if (""false"".equals(value)) {
                    ds.setPoolPreparedStatements(false);
                }
            } else if (""testonborrow"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestOnBorrow(true);
                } else if (""false"".equals(value)) {
                    ds.setTestOnBorrow(false);
                }
            } else if (""testonreturn"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestOnReturn(true);
                } else if (""false"".equals(value)) {
                    ds.setTestOnReturn(false);
                }
            } else if (""testwhileidle"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestWhileIdle(true);
                } else if (""false"".equals(value)) {
                    ds.setTestWhileIdle(false);
                }
            } else if (""validationquery"".equals(name)) {
                ds.setValidationQuery(value);
            }
        }
        return ds;
    }

    protected void processStatements(OMElement elem, AbstractDBMediator mediator) {

        Iterator iter = elem.getChildrenWithName(STMNT_Q);
        while (iter.hasNext()) {

            OMElement stmntElt = (OMElement) iter.next();
            Statement statement = new Statement(getValue(stmntElt, SQL_Q));

            Iterator paramIter = stmntElt.getChildrenWithName(PARAM_Q);
            while (paramIter.hasNext()) {

                OMElement paramElt = (OMElement) paramIter.next();
                String xpath = getAttribute(paramElt, ATT_EXPRN);
                String value = getAttribute(paramElt, ATT_VALUE);

                if (xpath != null || value != null) {
                    
                    AXIOMXPath xp = null;
                    if (xpath != null) {
                        try {
                            xp = new AXIOMXPath(xpath);
                            OMElementUtils.addNameSpaces(xp, paramElt, log);

                        } catch (JaxenException e) {
                            handleException(""Invalid XPath specified for the source attribute : "" +
                                    xpath);
                        }
                    }
                    statement.addParameter(
                            value,
                            xp,
                            getAttribute(paramElt, ATT_TYPE));
                }
            }

            Iterator resultIter = stmntElt.getChildrenWithName(RESULT_Q);
            while (resultIter.hasNext()) {

                OMElement resultElt = (OMElement) resultIter.next();
                statement.addResult(
                    getAttribute(resultElt, ATT_NAME),
                    getAttribute(resultElt, ATT_COLUMN));
            }

            mediator.addStatement(statement);
        }
    }

    protected String getValue(OMElement elt, QName qName) {
        OMElement e = elt.getFirstChildWithName(qName);
        if (e != null) {
            return e.getText();
        } else {
            handleException(""Unable to read configuration value for : "" + qName);
        }
        return null;
    }

    protected String getAttribute(OMElement elt, QName qName) {
        OMAttribute a = elt.getAttribute(qName);
        if (a != null) {
            return a.getAttributeValue();
        }
        return null;
    }
}

"
org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.MessageContext;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;

import javax.xml.namespace.QName;
import java.util.HashMap;
import java.util.Map;
import java.util.Collections;

public class SoapSessionDispatcher implements Dispatcher {

    /**
     * Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threds (e.g. multiple clients different sessions).
     */
    private Map sessionMap = Collections.synchronizedMap(new HashMap());

    /**
     * Gives the endpoint based on the service group context ID of the request message.
     *
     * @param synCtx Request MessageContext, possibly containing a service group context ID.
     *
     * @return Endpoint associated with the soap session, if current message is a soap session
     * message and if current message is not the first message of the session. Returns null, if
     * an Endpoint could not be found for the session.
     */
    public Endpoint getEndpoint(MessageContext synCtx) {
        Endpoint endpoint = null;

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement sgcID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));

            if(sgcID != null && sgcID.getText() != null) {

                Object e = sessionMap.get(sgcID.getText());

                if (e != null) {
                    endpoint = (Endpoint) e;
                }
            }
        }

        return endpoint;
    }

    /**
     * As this is a server initiated session, this method will only be called for response messages.
     * It extracts the service group context ID (if available) from the message and updates the
     * session (service group context ID) -> endpoint map.
     *
     * @param synCtx MessageContext of the response message.
     * @param endpoint Endpoint to associate with the session.
     */
    public void updateSession(MessageContext synCtx, Endpoint endpoint) {
        // get the service group context id
        // check if service group context id is a key of any entry
        // if not, add an entry <service group context id, endpoint>


        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement replyTo = header.getFirstChildWithName
                    (new QName(""http://www.w3.org/2005/08/addressing"", ""ReplyTo"", ""wsa""));

            if(replyTo != null) {
                OMElement referenceParameters = replyTo.getFirstChildWithName(new QName(
                        ""http://www.w3.org/2005/08/addressing"", ""ReferenceParameters"", ""wsa""));

                if(referenceParameters != null) {
                    OMElement sgcID = referenceParameters.getFirstChildWithName(new QName(
                            ""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));

                    // synchronized to avoid possible replacement of sessions
                    synchronized(sessionMap) {
                        if(!sessionMap.containsKey(sgcID.getText())) {
                            sessionMap.put(sgcID.getText(), endpoint);
                        }
                    }
                }
            }
        }
    }

    public void unbind(MessageContext synCtx) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if(header != null) {
            OMElement sgcID = header.getFirstChildWithName(
                    new QName(""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2""));
            if(sgcID != null && sgcID.getText() != null) {
                sessionMap.remove(sgcID.getText());
            }
        }
    }

    /**
     * Soap session is initiated by the server. So this method always returns true.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;

import javax.xml.namespace.QName;
import java.util.Collection;
import java.util.Iterator;

public abstract class AbstractMediatorSerializer implements MediatorSerializer {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected static Log log;

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS
            = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS
            = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"", ""syn"");

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediatorSerializer() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * Perform common functions and finalize the mediator serialization.
     * i.e. process any common attributes
     *
     * @param mediatorOmElement the OMElement being created
     * @param mediator          the Mediator instance being serialized
     */
    protected static void saveTracingState(OMElement mediatorOmElement, Mediator mediator) {
        int traceState = mediator.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.SynapseConstants.TRACING_ON) {
            traceValue = XMLConfigConstants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.SynapseConstants.TRACING_OFF) {
            traceValue = XMLConfigConstants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            mediatorOmElement.addAttribute(fac.createOMAttribute(
                XMLConfigConstants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }

    }

    protected void serializeMediatorProperties(OMElement parent, Collection props) {

        Iterator iter = props.iterator();
        while (iter.hasNext()) {
            MediatorProperty mp = (MediatorProperty) iter.next();
            OMElement prop = fac.createOMElement(""property"", synNS, parent);
            if (mp.getName() != null) {
                prop.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
            } else {
                handleException(""Mediator property name missing"");
            }

            if (mp.getValue() != null) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));

            } else if (mp.getExpression() != null) {
                prop.addAttribute(fac.createOMAttribute(""expression"", nullNS,
                    mp.getExpression().toString()));
                serializeNamespaces(prop, mp.getExpression());

            } else {
                handleException(""Mediator property must have a literal value or be an expression"");
            }
        }
    }

    protected void serializeProperties(OMElement parent, Collection props) {
        serializeMediatorProperties(parent, props);
    }

    protected void serializeNamespaces(OMElement elem, AXIOMXPath xpath) {
        Iterator iter = xpath.getNamespaces().keySet().iterator();
        while (iter.hasNext()) {
            String prefix = (String) iter.next();
            String uri = xpath.getNamespaceContext().translateNamespacePrefixToUri(prefix);
            if (!XMLConfigConstants.SYNAPSE_NAMESPACE.equals(uri)) {
                elem.declareNamespace(uri, prefix);
            }
        }
    }

    protected void handleException(String msg) {
        LogFactory.getLog(this.getClass()).error(msg);
        throw new SynapseException(msg);
    }

    protected void handleException(String msg, Exception e) {
        LogFactory.getLog(this.getClass()).error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/startup/Task.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup;

/**
 * Defines the Task for a SimpleQuarts Startup
 */
public interface Task {

    /**
     * Esecute method will be invoked by the SimpleQuartzStartup
     */
    public void execute();
}
"
org/apache/synapse/Startup.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import javax.xml.namespace.QName;

/**
 * This startup interface will be instatiated to create startup tasks
 */
public interface Startup extends ManagedLifecycle {

    /**
     * This will return the configuration tag QName of the implemented startup
     *
     * @return QName representing the configuraiton element for the startup
     */
    public abstract QName getTagQName();

    /**
     * This will return the name of the startup
     *
     * @return String representing the name
     */
    public String getName();

    /**
     * This will set the name of a Startup
     *
     * @param id String name to be set to the startup
     */
    public void setName(String id);
}
"
org/apache/synapse/config/xml/MediatorFactoryFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.XMLToObjectMapper;
import sun.misc.Service;

import javax.xml.namespace.QName;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 *
 * 
 * This class is based on J2SE Service Provider model
 * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
 */

public  class MediatorFactoryFinder implements XMLToObjectMapper {

	private static final Log log = LogFactory.getLog(MediatorFactoryFinder.class);

	private static final Class[] mediatorFactories = {
        SequenceMediatorFactory.class,
        LogMediatorFactory.class,
        SendMediatorFactory.class,         
        FilterMediatorFactory.class,
        SynapseMediatorFactory.class,
        DropMediatorFactory.class,
        HeaderMediatorFactory.class,
        FaultMediatorFactory.class,
        PropertyMediatorFactory.class,
        SwitchMediatorFactory.class,
        InMediatorFactory.class,
        OutMediatorFactory.class,
        RMSequenceMediatorFactory.class,          
        ClassMediatorFactory.class,
        ValidateMediatorFactory.class,
        XSLTMediatorFactory.class,
        POJOCommandMediatorFactory.class,
        CloneMediatorFactory.class,
        IterateMediatorFactory.class,
        AggregateMediatorFactory.class,
        DBReportMediatorFactory.class,
        DBLookupMediatorFactory.class,
        CacheMediatorFactory.class
    };

    private static MediatorFactoryFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap();

    public static synchronized MediatorFactoryFinder getInstance() {
        if (instance == null) {
            instance = new MediatorFactoryFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private MediatorFactoryFinder() {

        factoryMap = new HashMap();

        for (int i = 0; i < mediatorFactories.length; i++) {
			Class c = mediatorFactories[i];
			try {
                MediatorFactory fac = (MediatorFactory) c.newInstance();
                factoryMap.put(fac.getTagQName(), c);
            } catch (Exception e) {
				throw new SynapseException(""Error instantiating "" + c.getName(), e);
			}
		}
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        //log.debug(""Registering mediator extensions found in the classpath : "" + System.getResource(""java.class.path""));

        // register MediatorFactory extensions
        Iterator it = Service.providers(MediatorFactory.class);
        while (it.hasNext()) {
            MediatorFactory mf = (MediatorFactory) it.next();
            QName tag = mf.getTagQName();
            factoryMap.put(tag, mf.getClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorFactory "" + mf.getClass() + "" to handle "" + tag);
            }
        }
    }

    /**
	 * This method returns a Processor given an OMElement. This will be used
	 * recursively by the elements which contain processor elements themselves
	 * (e.g. rules)
	 * 
	 * @param element
     * @return Processor
	 */
	public Mediator getMediator(OMElement element) {

        String localName = element.getLocalName();
        QName qName = null;
        if (element.getNamespace() != null) {
            qName = new QName(element.getNamespace().getNamespaceURI(), localName);
        } else {
            qName = new QName(localName);
        }
        if (log.isDebugEnabled()) {
            log.debug(""getMediator("" + qName + "")"");
        }
        Class cls = (Class) factoryMap.get(qName);

        if (cls == null && localName.indexOf('.') > -1) {
            String newLocalName = localName.substring(0, localName.indexOf('.'));
            qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);
            if (log.isDebugEnabled()) {
                log.debug(""getMediator.2("" + qName + "")"");
            }
            cls = (Class) factoryMap.get(qName);
        }

        if (cls == null) {
            String msg = ""Unknown mediator referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
			MediatorFactory mf = (MediatorFactory) cls.newInstance();
			return mf.createMediator(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
		}
	}
    /*
    This method exposes all the MediatorFactories and its Extensions 
    */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /**
     * Allow the mediator factory finder to act as an XMLToObjectMapper for Mediators
     * (i.e. Sequence Mediator) loaded dynamically from a Registry 
     * @param om
     * @return
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getMediator((OMElement) om);
        } else {
            handleException(""Invalid mediator configuration XML : "" + om);
        }
        return null;
    }
}
"
org/apache/synapse/config/xml/AbstractListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;

import java.util.Iterator;
import java.util.List;

public abstract class AbstractListMediatorSerializer extends AbstractMediatorSerializer {

    protected void serializeChildren(OMElement parent, List list) {
        Iterator iter = list.iterator();
        while (iter.hasNext()) {
            Mediator child = (Mediator) iter.next();
            MediatorSerializer medSer = MediatorSerializerFinder.getInstance().getSerializer(child);
            if (medSer != null) {
                medSer.serializeMediator(parent, child);
            } else {
                handleException(""Unable to find a serializer for mediator : "" + child.getType());
            }
        }
    }
}
"
org/apache/synapse/statistics/impl/ProxyServiceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * The data structure to hold statistics related to the Proxy Services
 *
 */

public class ProxyServiceStatisticsStack implements StatisticsStack {

    private static final Log log = LogFactory.getLog(ProxyServiceStatisticsStack.class);
    /** The name of the proxy service*/
    private String proxyServiceName;
    /** To check whether statistics is enabled or not */
    private boolean isStatisticsEnable = false;
    /** The time which starts to collect statistics for IN flow */
    private long inTimeForInFlow = -1;
    /** The time which starts to collect statistics for OUT flow */
    private long inTimeForOutFlow = -1;
    /** To indicate whether IN Flow is fault or not*/
    private boolean isINFault;
    /** To indicate whether OUT Flow is fault or not*/
    private boolean isOUTFault;

    /**
     * To put a statistics
     * @param key                   - The Name of the proxy service
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (isInFlow) {
            this.proxyServiceName = key;
            this.isStatisticsEnable = isStatisticsEnable;
            this.inTimeForInFlow = initTime;
            this.isINFault = isFault;
        }
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        if (proxyServiceName != null && isStatisticsEnable && inTimeForInFlow != -1) {
            inTimeForOutFlow = System.currentTimeMillis();
            isOUTFault = isFault;
            statisticsCollector.reportForProxyService(proxyServiceName, false,
                    inTimeForInFlow, inTimeForOutFlow, isINFault);
            inTimeForInFlow = -1;
        } else if (inTimeForOutFlow != -1) {
            statisticsCollector.reportForProxyService(proxyServiceName, true,
                    inTimeForOutFlow, System.currentTimeMillis(), isFault);
            inTimeForOutFlow = -1;
        }
    }

    /**
     * Report a particular statistics to the StatisticsReporter
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (name != null && proxyServiceName != null && proxyServiceName.equals(name)) {
            reportToStatisticsCollector(statisticsCollector, isFault);
        } else {
            handleException(""Invalid ProxyService Name "" + name + "" expected "" + proxyServiceName);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        reportToStatisticsCollector(statisticsCollector, isFault);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/XMLToObjectMapper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.OMNode;

/**
 * Defines the interface which should be implemented by a mapper that could
 * convert a XML resource into a known Object such as WSDL, XSD, etc..
 */
public interface XMLToObjectMapper {

    /**
     * Create an application object from the given OMNode
     * @param om the XML
     * @return a suitable application object
     */
    public Object getObjectFromOMNode(OMNode om);
}
"
org/apache/synapse/statistics/StatisticsHolder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 * To hold statistics that will collected during both of in and out message mediation
 */

public class StatisticsHolder {

    private int statisticsCategory ;

    private String key ;

    /**  The statistics that will collect during in coming message mediation  */
    private Statistics inFlowStatistics;

    /**  The statistics that will collect during out going message mediation  */
    private Statistics outFlowStatistics;

    /**
     * To update the statistics
     *
     * @param isResponse - A boolean value that indicate whether message flow is in or out
     * @param inTime     - The processing start time
     * @param outTime    - The processing end time
     * @param isFault    - A boolean value that indicate whether falut has occured or not
     */
    public synchronized void update(boolean isResponse, long inTime, long outTime,
                                    boolean isFault) {
        if (isResponse) {
            if (outFlowStatistics == null) {
                outFlowStatistics = new Statistics();
            }
            outFlowStatistics.update(inTime, outTime, isFault);
        } else {
            if (inFlowStatistics == null) {
                inFlowStatistics = new Statistics();
            }
            inFlowStatistics.update(inTime, outTime, isFault);
        }

    }

    /**
     * To get Statistics related to the In Flow
     * @return  Statistics related to the In Flow
     */
    public synchronized Statistics getInFlowStatistics() {
        return inFlowStatistics;
    }

    /**
     * To get Statistics related to the Out Flow
     * @return  Statistics related to the Out Flow
     */
    public synchronized Statistics getOutFlowStatistics() {
        return outFlowStatistics;
    }

    /**
     * To get statistics category
     * @return  Statistics Category
     */
    public int getStatisticsCategory() {
        return statisticsCategory;
    }

    /**
     * To set statistics category
     * @param statisticsCategory
     */
    public void setStatisticsCategory(int statisticsCategory) {
        this.statisticsCategory = statisticsCategory;
    }

    /**
     * To get key of statistics
     * @return   key of statistics
     */
    public String getKey() {
        return key;
    }

    /**
     * To set key of statistics
     * @param key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * To clear stored statistics
     */
    public synchronized void clearStatistics(){
        this.inFlowStatistics =null;
        this.outFlowStatistics=null;
    }
}
"
org/apache/synapse/config/xml/ConfigurationSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.io.OutputStream;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import org.apache.synapse.config.SynapseConfiguration;
import org.apache.axiom.om.OMElement;

/**
 * This interface defines the configuration serializers of Synapse
 */
public interface ConfigurationSerializer {

    /**
     * Serializes the given configuraiton to an OMElement
     *
     * @param synCfg Configuration to be serialized
     * @return OMElement describing the configuraiton
     */
    OMElement serializeConfiguration(SynapseConfiguration synCfg);

    /**
     * Get the tag QName of the element
     *
     * @return QName describing the element name
     */
    QName getTagQName();

}
"
org/apache/synapse/mediators/db/AbstractDBMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.commons.dbcp.BasicDataSource;
import org.apache.commons.logging.Log;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.AbstractDBMediatorFactory;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import javax.sql.DataSource;
import javax.xml.namespace.QName;
import java.math.BigDecimal;
import java.sql.*;
import java.sql.Date;
import java.util.*;

/**
 * This abstract DB mediator will perform common DB connection pooling etc. for all DB mediators
 */
public abstract class AbstractDBMediator extends AbstractMediator implements ManagedLifecycle {

    /** Hold JDBC properties */
    protected Map dataSourceProps = new HashMap();
    /** The DataSource to get DB connections */
    private DataSource dataSource = null;
    /** Statements */
    List statementList = new ArrayList();

    /**
     * Initializes the mediator. Does nothing right now. If DataSource lookup is supported, could
     * do the IC lookup here
     * @param se the Synapse environment reference
     */
    public void init(SynapseEnvironment se) {
        // do nothing
    }

    /**
     * Destroys the mediator. If we are using our custom DataSource, then shut down the connections
     */
    public void destroy() {
        if (getDataSource() instanceof BasicDataSource) {
            try {
                ((BasicDataSource) getDataSource()).close();
                log.info(""Successfully shut down DB connection pool for URL : "" + getDSName());
            } catch (SQLException e) {
                log.warn(""Error shutting down DB connection pool for URL : "" + getDSName());
            }
        }
    }

    /**
     * Process each SQL statement against the current message
     * @param synCtx the current message
     * @return true, always
     */
    public boolean mediate(MessageContext synCtx) {

        String name = (this instanceof DBLookupMediator ? ""DBLookup"" : ""DBReport"");
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : "" + name + "" mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        for (Iterator iter = statementList.iterator(); iter.hasNext(); ) {
            processStatement((Statement) iter.next(), synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : "" + name + "" mediator"");
        }
        return true;
    }

    /**
     * Subclasses must specify how each SQL statement is processed
     * @param query the SQL statement
     * @param msgCtx current message
     */
    abstract protected void processStatement(Statement query, MessageContext msgCtx);

    /**
     * Return the name or (hopefully) unique connection URL specific to the DataSource being used
     * This is used for logging purposes only
     * @return a unique name or URL to refer to the DataSource being used
     */
    protected String getDSName() {
        return (String) dataSourceProps.get(AbstractDBMediatorFactory.URL_Q);
    }

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void addDataSourceProperty(QName name, String value) {
        dataSourceProps.put(name, value);
    }

    public void addDataSourceProperty(String name, String value) {
        dataSourceProps.put(name, value);
    }

    public Map getDataSourceProps() {
        return dataSourceProps;
    }

    public void addStatement(Statement stmnt) {
        statementList.add(stmnt);
    }

    public List getStatementList() {
        return statementList;
    }

    /**
     * Return a Prepared statement for the given Statement object, which is ready to be executed
     * @param stmnt
     * @param msgCtx
     * @return
     * @throws SQLException
     */
    protected PreparedStatement getPreparedStatement(Statement stmnt, MessageContext msgCtx) throws SQLException {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        Log serviceLog = msgCtx.getServiceLog();

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Getting a connection from DataSource "" + getDSName() +
                "" and preparing statement : "" + stmnt.getRawStatement());
        }
        Connection con = getDataSource().getConnection();
        PreparedStatement ps = con.prepareStatement(stmnt.getRawStatement());

        // set parameters if any
        List params = stmnt.getParameters();
        int column = 1;

        for (Iterator pi = params.iterator(); pi.hasNext(); ) {

            Statement.Parameter param = (Statement.Parameter) pi.next();
            String value = (param.getPropertyName() != null ?
                param.getPropertyName() :
                Axis2MessageContext.getStringValue(param.getXpath(), msgCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting as parameter : "" + column + "" value : "" + value +
                    "" as JDBC Type : "" + param.getType() + ""(see java.sql.Types for valid types)"");
            }

            switch (param.getType()) {
                // according to J2SE 1.5 /docs/guide/jdbc/getstart/mapping.html
                case Types.CHAR:
                case Types.VARCHAR:
                case Types.LONGVARCHAR: {
                    ps.setString(column++, value);
                    break;
                }
                case Types.NUMERIC:
                case Types.DECIMAL: {
                    ps.setBigDecimal(column++, new BigDecimal(value));
                    break;
                }
                case Types.BIT: {
                    ps.setBoolean(column++, Boolean.parseBoolean(value));
                    break;
                }
                case Types.TINYINT: {
                    ps.setByte(column++, Byte.parseByte(value));
                    break;
                }
                case Types.SMALLINT: {
                    ps.setShort(column++, Short.parseShort(value));
                    break;
                }
                case Types.INTEGER: {
                    ps.setInt(column++, Integer.parseInt(value));
                    break;
                }
                case Types.BIGINT: {
                    ps.setLong(column++, Long.parseLong(value));
                    break;
                }
                case Types.REAL: {
                    ps.setFloat(column++, Float.parseFloat(value));
                    break;
                }
                case Types.FLOAT: {
                    ps.setDouble(column++, Double.parseDouble(value));
                    break;
                }
                case Types.DOUBLE: {
                    ps.setDouble(column++, Double.parseDouble(value));
                    break;
                }
                // skip BINARY, VARBINARY and LONGVARBINARY
                case Types.DATE: {
                    ps.setDate(column++, Date.valueOf(value));
                    break;
                }
                case Types.TIME: {
                    ps.setTime(column++, Time.valueOf(value));
                    break;
                }
                case Types.TIMESTAMP: {
                    ps.setTimestamp(column++, Timestamp.valueOf(value));
                    break;
                }
                // skip CLOB, BLOB, ARRAY, DISTINCT, STRUCT, REF, JAVA_OBJECT
                default: {
                    String msg = ""Trying to set an un-supported JDBC Type : "" + param.getType() +
                        "" against column : "" + column + "" and statement : "" + stmnt.getRawStatement() +
                        "" used by a DB mediator against DataSource : "" + getDSName() +
                        "" (see java.sql.Types for valid type values)"";
                    handleException(msg, msgCtx);
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Successfully prepared statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName());
        }
        return ps;
    }
}
"
org/apache/synapse/mediators/transform/HeaderMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.List;

/**
 * The header mediator is able to set a given value as a SOAP header, or remove a given
 * header from the current message instance. This supports the headers currently
 * supported by the HeaderType class. If an expression is supplied, its runtime value
 * is evaluated using the current message. Unless the action is set to remove, the
 * default behaviour of this mediator is to set a header value.
 */
public class HeaderMediator extends AbstractMediator {

    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;

    /** The qName of the header @see HeaderType */
    private QName qName = null;
    /** The literal value to be set as the header (if one was specified) */
    private String value = null;
    /** Set the header (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;
    /** An expression which should be evaluated, and the result set as the header value */
    private AXIOMXPath expression = null;

    /**
     * Sets/Removes a SOAP header on the current message
     *
     * @param synCtx the current message which is altered as necessary
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Header mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (action == ACTION_SET) {

            String value = (getValue() != null ? getValue() :
                    Axis2MessageContext.getStringValue(expression, synCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Set SOAP header : "" + qName + "" to : "" + value);
            }

            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {

                // is this a ""well known"" Synapse header?
                if (SynapseConstants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_FROM.equals(qName.getLocalPart())) {
                    synCtx.setFrom(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(value);
                } else if (SynapseConstants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(new EndpointReference(value));
                } else {
                    addCustomHeader(synCtx);
                }
            } else {
                addCustomHeader(synCtx);
            }

        } else {

             if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Removing SOAP Header : "" + qName);
            }

            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {

                // is this a ""well known"" Synapse header?
                if (SynapseConstants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(null);
                } else if (SynapseConstants.HEADER_FROM.equals(qName.getLocalPart())) {
                    synCtx.setFrom(null);
                } else if (SynapseConstants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(null);
                } else if (SynapseConstants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(null);
                } else if (SynapseConstants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(null);
                } else {
                    SOAPEnvelope envelope = synCtx.getEnvelope();
                    if (envelope != null) {
                        SOAPHeader header = envelope.getHeader();
                        if (header != null) {
                            removeFromHeaderList(header.
                                getHeaderBlocksWithNSURI(""""));
                        }
                    }
                }

            } else {
                SOAPEnvelope envelope = synCtx.getEnvelope();
                if (envelope != null) {
                    SOAPHeader header = envelope.getHeader();
                    if (header != null) {
                        removeFromHeaderList(header.
                            getHeaderBlocksWithNSURI(qName.getNamespaceURI()));
                    }
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Header mediator"");
        }
        return true;
    }

    private void addCustomHeader(MessageContext synCtx) {
        SOAPEnvelope env = synCtx.getEnvelope();
        if (env == null) {
            return;
        }
        SOAPFactory fac = (SOAPFactory) env.getOMFactory();
        SOAPHeader header = env.getHeader();
        if (header == null) {
            header = fac.createSOAPHeader(env);
        }
        SOAPHeaderBlock hb = header.addHeaderBlock(qName.getLocalPart(),
                fac.createOMNamespace(qName.getNamespaceURI(), qName.getPrefix()));
        hb.setText(value);
    }

    private void removeFromHeaderList(List headersList) {
        if (headersList == null || headersList.isEmpty()) {
            return;
        }
        for ( Iterator iter = headersList.iterator();iter.hasNext();) {
            Object o = iter.next();
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                if (header.getLocalName().equals(qName.getLocalPart())) {
                    header.detach();
                }
            } else if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                if (omElem.getLocalName().equals(qName.getLocalPart())) {
                    omElem.detach();
                }
            }
        }
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }

    public QName getQName() {
        return qName;
    }

    public void setQName(QName qName) {
        this.qName = qName;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }
}
"
org/apache/synapse/util/SimpleMapImpl.java,false,"package org.apache.synapse.util;

import java.io.ByteArrayOutputStream;

import java.util.HashMap;
import java.util.Iterator;

import javax.activation.DataHandler;
import javax.xml.namespace.QName;

import org.apache.axiom.attachments.ByteArrayDataSource;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMText;


public class SimpleMapImpl extends HashMap implements SimpleMap {
	private static final OMNamespace attrNS = OMAbstractFactory.getOMFactory().createOMNamespace("""", """");
	private static final String TYPE = ""type"";

	private static final String NAME = ""name"";

	private static final String ENTRY = ""entry"";

	private static final String SHORT = ""short"";

	private static final String LONG = ""long"";

	private static final String DOUBLE = ""double"";
	private static final String INTEGER = ""int"";
	private static final String FLOAT = ""float"";

	private static final String BYTEARRAY = ""byte[]"";

	private static final String BYTE = ""byte"";

	private static final String STRING = ""string"";

	private static final String BOOLEAN = ""boolean"";

	private static final String CHAR = ""char"";

	private static final long serialVersionUID = 1L;

	public SimpleMapImpl() {
		super();
	}

	public Object get(String name) {
		return this.get((Object) name);
	}

	public boolean getBoolean(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Boolean) {
			return ((Boolean) o).booleanValue();
		} else {
			throw new RuntimeException(""getBoolean("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Boolean"");
		}
	}

	public byte getByte(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Byte) {
			return ((Byte) o).byteValue();
		} else {
			throw new RuntimeException(""getByte("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Byte"");
		}
	}

	public byte[] getBytes(String name) {
		Object o = this.get((Object) name);
		if (o instanceof byte[]) {
			return (byte[]) o;
		} else {
			throw new RuntimeException(""getByteArray("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of byte[]"");
		}
	}

	public char getChar(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Character) {
			return ((Character) o).charValue();
		} else {
			throw new RuntimeException(""getChar("" + name + ""): ""
					+ o.getClass().getName()
					+ "" is not an instance of Character"");
		}
	}

	public double getDouble(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Double) {
			return ((Double) o).doubleValue();
		} else {
			throw new RuntimeException(""getDouble("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Double"");
		}
	}

	public float getFloat(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Float) {
			return ((Float) o).floatValue();
		} else {
			throw new RuntimeException(""getFloat("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Float"");
		}
	}

	public int getInt(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Integer) {
			return ((Integer) o).intValue();
		} else {
			throw new RuntimeException(""getInt("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Integer"");
		}
	}

	public long getLong(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Long) {
			return ((Long) o).longValue();
		} else {
			throw new RuntimeException(""getLong("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Long"");
		}
	}

	public short getShort(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Short) {
			return ((Short) o).shortValue();
		} else {
			throw new RuntimeException(""getShort("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Short"");
		}
	}

	public String getString(String name) {
		Object o = this.get((Object) name);
		if (o instanceof String) {
			return ((String) o);
		} else {
			throw new RuntimeException(""getString("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of String"");
		}
	}

	public void put(String name, Object value) {
		this.put((Object) name, value);
	}

	public void putBoolean(String name, boolean b) {
		this.put((Object) name, new Boolean(b));

	}

	public void putByte(String name, byte b) {
		this.put((Object) name, new Byte(b));

	}

	public void putBytes(String name, byte[] bytes) {
		this.put((Object) name, bytes);

	}

	public void putChar(String name, char c) {
		this.put((Object) name, new Character(c));

	}

	public void putDouble(String name, double d) {
		this.put((Object) name, new Double(d));

	}

	public void putFloat(String name, float fl) {
		this.put((Object) name, new Float(fl));

	}

	public void putInt(String name, int i) {
		this.put((Object) name, new Integer(i));

	}

	public void putLong(String name, long l) {
		this.put((Object) name, new Long(l));

	}

	public void putShort(String name, short s) {
		this.put((Object) name, new Short(s));

	}

	public void putString(String name, String value) {
		this.put((Object) name, value);

	}

	public OMElement getOMElement() {
		return getOMElement(OMAbstractFactory.getOMFactory());
	}

	public OMElement getOMElement(OMFactory fac) {
		OMElement mapElement = fac.createOMElement(PayloadHelper.MAPELT);
		
		for (Iterator it = this.keySet().iterator(); it.hasNext();) {
			OMElement entry = fac.createOMElement(new QName(
					PayloadHelper.AXIOMPAYLOADNS, ENTRY), mapElement);
			
			
			Object key = it.next();
			System.out.println(""key ""+key);
			if (key instanceof String) {
				Object o = this.get(key);
				System.out.println(""key ""+key);
				entry.addAttribute(NAME, (String) key, attrNS);
				if (o instanceof Character) {
					entry.addAttribute(TYPE, CHAR, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Boolean) {
					entry.addAttribute(TYPE, BOOLEAN, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof String) {
					entry.addAttribute(TYPE, STRING, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Byte) {
					entry.addAttribute(TYPE, BYTE, attrNS);
					entry.setText(((Byte) o).toString());
				} else if (o instanceof byte[]) {
					entry.addAttribute(TYPE, BYTEARRAY, attrNS);
					OMText text = fac.createOMText(new DataHandler(
							new ByteArrayDataSource((byte[]) o)), true);
					entry.addChild(text);
				} else if (o instanceof Float) {
					entry.addAttribute(TYPE, FLOAT, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Double) {
					entry.addAttribute(TYPE, DOUBLE, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Long) {
					entry.addAttribute(TYPE, LONG, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Short) {
					entry.addAttribute(TYPE, SHORT, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Integer) {
					entry.addAttribute(TYPE, INTEGER, attrNS);
					entry.setText(o.toString());
				}

			} else {
				// shouldn't be any non-string keys. Ignore!
			}
		}

		return mapElement;
	}

	// create an instance from an OMElement (if its the right shape!!!)
	public SimpleMapImpl(OMElement el) {
		super();
		if (el.getQName().equals(PayloadHelper.MAPELT)) {
			for (Iterator it = el.getChildElements(); it.hasNext(); ) {
				OMElement child = (OMElement)it.next();
				if (child.getLocalName().equals(ENTRY)) {
					String name = child.getAttributeValue(new QName("""",NAME));
					String type = child.getAttributeValue(new QName("""", TYPE));
					try {
					if (type==null || name == null) {
						//bad!
						continue;
					}
					OMNode data = child.getFirstOMChild();
					if (data.getType()!=OMNode.TEXT_NODE) {
						continue; // BAD!
					}
					OMText text = (OMText)data;
					 if (type.equals(INTEGER)) {
						this.put((Object)name, new Integer(text.getText()));
					} else if (type.equals(CHAR)) {
						this.put((Object)name, new Character((text.getText().charAt(0))));
					} else if (type.equals(DOUBLE)) {
						this.put((Object)name, new Double(text.getText()));
					} else if (type.equals(FLOAT)) {
						this.put((Object)name, new Float(text.getText()));
					} else if (type.equals(BYTE)) {
						this.put((Object)name, new Byte(text.getText().getBytes()[0]));
					} else if (type.equals(SHORT)) {
						this.put((Object)name, new Short(text.getText()));
					} else if (type.equals(LONG)) {
						this.put((Object)name, new Long(text.getText()));
					} else if (type.equals(STRING)) {
						this.put((Object)name, text.getText());
					} else if (type.equals(BYTEARRAY)) {
						DataHandler dh = (DataHandler)text.getDataHandler();
						ByteArrayOutputStream baos = new ByteArrayOutputStream();
						dh.writeTo(baos);
						this.put((Object)name, baos.toByteArray());
					}
					} catch (Exception e) {
						e.printStackTrace();
						// ignore errors
					}
					 
				}
			}
		}
	}

}
"
org/apache/synapse/config/xml/DropMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

public class DropMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DropMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DropMediator mediator = (DropMediator) m;
        OMElement drop = fac.createOMElement(""drop"", synNS);
        saveTracingState(drop,mediator);

        if (parent != null) {
            parent.addChild(drop);
        }
        return drop;
    }

    public String getMediatorClassName() {
        return DropMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/DBLookupMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.db.DBLookupMediator;

/**
 * <dblookup>
 *   <connection>
 *     <jdbc>
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     </jdbc>
 *   </connection>
 *   <query setAttribute=""queue_name"">
 *     <sql>select queue from table where device_id = ?</sql>
 *     <parameter [property="""" | xpath=""""] type=""int|string""/>*
 *   </query>+
 * </dblookup>
 */
public class DBLookupMediatorSerializer extends AbstractDBMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DBLookupMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DBLookupMediator mediator = (DBLookupMediator) m;
        OMElement dbLookup = fac.createOMElement(""dblookup"", synNS);
        saveTracingState(dbLookup,mediator);
        serializeDBInformation(mediator, dbLookup);

        if (parent != null) {
            parent.addChild(dbLookup);
        }
        return dbLookup;
    }

    public String getMediatorClassName() {
        return DBLookupMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/SynapseMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.base.SynapseMediator;

import javax.xml.namespace.QName;

/**
 * Builds the main mediator (@see SynapseConfiguration) of the Synapse instance
 *
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorFactory extends AbstractListMediatorFactory {

    private final static QName RULES_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""rules"");

    public QName getTagQName() {
        return RULES_Q;
    }

    public Mediator createMediator(OMElement elem) {
        SynapseMediator sm = new SynapseMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sm,elem);

        addChildren(elem, sm);
        return sm;
    }

}
"
org/apache/synapse/config/xml/LogMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

/**
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""] [separator=""string""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof LogMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        LogMediator mediator = (LogMediator) m;
        OMElement log = fac.createOMElement(""log"", synNS);
        saveTracingState(log,mediator);

        if (mediator.getLogLevel() != LogMediator.SIMPLE) {
            log.addAttribute(fac.createOMAttribute(
                ""level"", nullNS,
                    mediator.getLogLevel() == LogMediator.HEADERS ? ""headers"" :
                    mediator.getLogLevel() == LogMediator.FULL ? ""full"" :
                    mediator.getLogLevel() == LogMediator.CUSTOM ? ""custom"" : ""simple""
                ));
        }

        if (mediator.getSeparator() != LogMediator.DEFAULT_SEP) {
            log.addAttribute(fac.createOMAttribute(
                ""separator"", nullNS, mediator.getSeparator()));
        }

        super.serializeProperties(log, mediator.getProperties());

        if (parent != null) {
            parent.addChild(log);
        }
        return log;
    }

    public String getMediatorClassName() {
        return LogMediator.class.getName();
    }
}
"
org/apache/synapse/metrics/MetricsConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;
/*
 * 
 */

public final class MetricsConstants {
    public static String GLOBAL_REQUEST_COUNTER = ""__GLOBAL_REQUEST_COUNTER__"";
    public static String REQUEST_RECEIVED_TIME = ""__REQUEST_RECEIVED_TIME__"";
}
"
org/apache/synapse/config/xml/XMLConfigurationBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.io.InputStream;

import org.apache.axiom.om.*;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.SynapseConfiguration;

import javax.xml.stream.XMLStreamException;

/**
 * Builds a Synapse Configuration from an XML input stream
 */
public class XMLConfigurationBuilder {

    private static Log log = LogFactory.getLog(XMLConfigurationBuilder.class);

    public static SynapseConfiguration getConfiguration(InputStream is) throws XMLStreamException {

        log.info(""Generating the Synapse configuration model by parsing the XML configuration"");
        
        OMElement definitions = new StAXOMBuilder(is).getDocumentElement();
        definitions.build();

        return ConfigurationFactoryAndSerializerFinder.getInstance().getConfiguration(definitions);
        
    }
}"
org/apache/synapse/config/xml/ConfigurationFactoryAndSerializerFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.XMLToObjectMapper;
import sun.misc.Service;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import java.io.OutputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * This class is based on J2SE Service Provider model
 * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
 * <p/>
 * It deals with both the problem of turning an XML into a Synapse config and vice-versa
 */
public class ConfigurationFactoryAndSerializerFinder implements XMLToObjectMapper {

    private static final Log log = LogFactory
            .getLog(ConfigurationFactoryAndSerializerFinder.class);

    private static final Class[] configurationFactories = {
            SynapseXMLConfigurationFactory.class,
    };


    private static ConfigurationFactoryAndSerializerFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap();

    private static Map serializerMap = new HashMap();

    public static synchronized ConfigurationFactoryAndSerializerFinder getInstance() {
        if (instance == null) {
            instance = new ConfigurationFactoryAndSerializerFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private ConfigurationFactoryAndSerializerFinder() {

        factoryMap = new HashMap();

        for (int i = 0; i < configurationFactories.length; i++) {
            Class c = configurationFactories[i];
            try {
                ConfigurationFactory fac = (ConfigurationFactory) c.newInstance();
                factoryMap.put(fac.getTagQName(), c);
                serializerMap.put(fac.getTagQName(), fac.getSerializerClass());
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     * <p/>
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        // register MediatorFactory extensions
        Iterator it = Service.providers(ConfigurationFactory.class);
        while (it.hasNext()) {
            ConfigurationFactory cf = (ConfigurationFactory) it.next();
            QName tag = cf.getTagQName();
            factoryMap.put(tag, cf.getClass());
            serializerMap.put(tag, cf.getSerializerClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorFactory "" + cf.getClass() + "" to handle "" + tag);
            }
        }
    }

    /**
     * This method returns a Processor given an OMElement. This will be used
     * recursively by the elements which contain processor elements themselves
     * (e.g. rules)
     *
     * @param element
     * @return Processor
     */
    public SynapseConfiguration getConfiguration(OMElement element) {

        String localName = element.getLocalName();
        QName qName = null;
        if (element.getNamespace() != null) {
            qName = new QName(element.getNamespace().getNamespaceURI(), localName);
        } else {
            qName = new QName(localName);
        }
        if (log.isDebugEnabled()) {
            log.debug(""getConfiguration("" + qName + "")"");
        }
        Class cls = (Class) factoryMap.get(qName);


        if (cls == null) {
            String msg = ""Unknown Configuration type "" +
                    ""referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            ConfigurationFactory cf = (ConfigurationFactory) cls.newInstance();
            return cf.getConfiguration(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * @param synCfg
     * @return
     */
    public static OMElement serializeConfiguration(SynapseConfiguration synCfg) {
        if (synCfg.getDefaultQName() == null) {
            return serializeConfiguration(synCfg, XMLConfigConstants.DEFINITIONS_ELT);
        } else {
            return serializeConfiguration(synCfg, synCfg.getDefaultQName());
        }
    }

    /**
     * This method will serialize the config using the supplied QName
     * (looking up the right class to do it)
     *
     * @param synCfg
     * @param qName
     * @throws XMLStreamException
     */
    public static OMElement serializeConfiguration(SynapseConfiguration synCfg, QName qName) {

        Class cls = (Class) serializerMap.get(qName);
        if (cls == null) {
            String msg = ""Unknown Configuration type "" +
                    ""referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            ConfigurationSerializer cs = (ConfigurationSerializer) cls.newInstance();
            return cs.serializeConfiguration(synCfg);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * This method exposes all the ConfigurationFactories and its Extensions
     *
     * @return Map of factories
     */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /**
     * This method exposes all the ConfigurationSerializer and its Extensions
     *
     * @return Map of serializers
     */
    public static Map getSerializerMap() {
        return serializerMap;
    }

    /**
     * Allow the mediator factory finder to act as an XMLToObjectMapper for Mediators
     * (i.e. Sequence Mediator) loaded dynamically from a Registry
     *
     * @param om
     * @return
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getConfiguration((OMElement) om);
        } else {
            handleException(""Invalid configuration XML : "" + om);
        }
        return null;
    }
}
"
org/apache/synapse/mediators/builtin/CacheMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.description.Parameter;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.core.axis2.Axis2Sender;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.util.MessageHelper;
import org.wso2.caching.Cache;
import org.wso2.caching.CachedObject;
import org.wso2.caching.CachingConstants;
import org.wso2.caching.digest.DigestGenerator;

/**
 *
 */
public class CacheMediator extends AbstractMediator {

    private String id = null;
    private String scope = CachingConstants.SCOPE_PER_HOST;
    private DigestGenerator digestGenerator = CachingConstants.DEFAULT_XML_IDENTIFIER;
    private int inMemoryCacheSize = CachingConstants.DEFAULT_CACHE_SIZE;
    // if this is 0 then no disk cache, and if there is no size specified in the config
    // factory will asign a default value to enable disk based caching
    private int diskCacheSize = 0;
    private long timeout = 0L;
    private SequenceMediator onCacheHitSequence = null;
    private String onCacheHitRef = null;
    private String cacheObjKey = CachingConstants.CACHE_OBJECT; // default per-host
    private static final String CACHE_OBJ_PREFIX = ""synapse.cache_obj_"";

    public boolean mediate(MessageContext synCtx) {

        // tracing and debuggin related mediation initiation
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Cache mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        AxisConfiguration axisCfg = synCtx.getConfiguration().getAxisConfiguration();
        if (axisCfg == null) {
            handleException(""Unable to perform caching, ""
                + "" AxisConfiguration cannot be found"", synCtx);
            return false; // never executes.. but keeps IDE happy
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Looking up cache at scope : "" +
                scope + "" with ID : "" + cacheObjKey);
        }

        // look up cache
        Parameter param = axisCfg.getParameter(cacheObjKey);
        Cache cache = null;
        if (param != null && param.getValue() instanceof Cache) {
            cache = (Cache) param.getValue();

        } else {
            synchronized (axisCfg) {
                // check again after taking the lock to make sure no one else did it before us
                param = axisCfg.getParameter(cacheObjKey);
                if (param != null && param.getValue() instanceof Cache) {
                    cache = (Cache) param.getValue();

                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Creating/recreating the cache object"");
                    }
                    cache = new Cache();
                    try {
                        axisCfg.addParameter(cacheObjKey, cache);
                    } catch (AxisFault af) {
                        auditWarn(""Unable to create a cache with ID : "" + cacheObjKey, synCtx);
                    }
                }
            }
        }

        boolean result = true;
        if (synCtx.isResponse()) {
            processResponseMessage(traceOrDebugOn, traceOn, synCtx, cache);

        } else {
            result = processRequestMessage(synCtx, traceOrDebugOn, traceOn, cache);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Cache mediator"");
        }
        return result;
    }

    /**
     * Process a response message through this cache mediator. This finds the Cache used, and
     * updates it for the corresponding request hash
     * @param traceOrDebugOn is trace or debug logging on?
     * @param traceOn is tracing on?
     * @param synCtx the current message (response)
     * @param cache the cache
     */
    private void processResponseMessage(boolean traceOrDebugOn, boolean traceOn,
        MessageContext synCtx, Cache cache) {

        Object requestHash = synCtx.getProperty(CachingConstants.REQUEST_HASH_KEY);

        if (requestHash != null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Storing the response message into the cache at scope : ""
                    + scope + "" with ID : "" + cacheObjKey + "" for request hash : "" + requestHash);
            }

            Object obj = cache.getResponseForKey(requestHash);

            if (obj != null && obj instanceof CachedObject) {

                CachedObject cachedObj = (CachedObject) obj;
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Storing the response for the message with ID : ""
                        + synCtx.getMessageID() + "" with request hash ID : "" +
                        cachedObj.getRequestHash() + "" in the cache : "" + cacheObjKey);
                }

                cachedObj.setResponseEnvelope(
                    MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()));

                // this is not required yet can commented this for perf improvements
                // in the future there can be a situation where user sends the request with the
                // response hash (if client side caching is on) in which case we can compare that
                // response hash with the given response hash and respond with not-modified http header
                cachedObj.setResponseHash(digestGenerator.getDigest(
                    ((Axis2MessageContext) synCtx).getAxis2MessageContext()));

                cachedObj.setExpireTime(
                    System.currentTimeMillis() + cachedObj.getTimeout());

            } else {
                auditWarn(""A response message without a valid mapping to the "" +
                    ""request hash found. Unable to store the response in cache"", synCtx);
            }

        } else {
            auditWarn(""A response message without a mapping to the "" +
                ""request hash found. Unable to store the response in cache"", synCtx);
        }
    }

    /**
     * Processes a request message through the cache mediator. Generates the request hash and
     * looks up for a hit, if found; then the specified named or anonymous sequence is executed
     * or marks this message as a response and sends back directly to client.
     * @param synCtx incoming request message
     * @param traceOrDebugOn is tracing or debug logging on?
     * @param traceOn is tracing on?
     * @param cache the cache
     * @return should this mediator terminate further processing?
     */
    private boolean processRequestMessage(MessageContext synCtx, boolean traceOrDebugOn, boolean traceOn, Cache cache) {

        Object requestHash = digestGenerator
            .getDigest(((Axis2MessageContext) synCtx).getAxis2MessageContext());
        synCtx.setProperty(CachingConstants.REQUEST_HASH_KEY, requestHash);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Generated request hash : "" + requestHash);
        }

        if (cache.containsKey(requestHash) &&
            cache.getResponseForKey(requestHash) instanceof CachedObject) {

            // get the response from the cache and attach to the context and change the
            // direction of the message
            CachedObject cachedObj = (CachedObject) cache.getResponseForKey(requestHash);

            if (!cachedObj.isExpired() && cachedObj.getResponseEnvelope() != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Cache-hit for message ID : "" + synCtx.getMessageID());
                }

                // mark as a response and replace envelope from cache
                synCtx.setResponse(true);
                try {
                    synCtx.setEnvelope(cachedObj.getResponseEnvelope());
                } catch (AxisFault axisFault) {
                    handleException(
                        ""Error setting response envelope from cache : "" + cacheObjKey, synCtx);
                }

                // take specified action on cache hit
                if (onCacheHitSequence != null) {
                    // if there is an onCacheHit use that for the mediation
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Delegating message to the onCachingHit "" +
                            ""Anonymous sequence"");
                    }
                    onCacheHitSequence.mediate(synCtx);

                } else if (onCacheHitRef != null) {

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Delegating message to the onCachingHit "" +
                            ""sequence : "" + onCacheHitRef);
                    }
                    synCtx.getSequence(onCacheHitRef).mediate(synCtx);

                } else {

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Request message "" + synCtx.getMessageID() +
                            "" has served from the cache : "" + cacheObjKey);
                    }
                    // send the response back if there is not onCacheHit is specified
                    synCtx.setTo(null);
                    Axis2Sender.sendBack(synCtx);
                }
                // stop any following mediators from executing
                return false;

            } else {
                // cache exists, but has expired...
                cachedObj.clearCache();
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Existing cached response has expired. Reset cache element"");
                }
            }

        } else {

            // if not found in cache, check if we can cache this request
            if (cache.getCache().size() == inMemoryCacheSize) {
                cache.removeExpiredResponses();
                if (cache.getCache().size() == inMemoryCacheSize) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""In-memory cache is full. Unable to cache"");
                    }
                } else {
                    storeRequestToCache(synCtx, requestHash, cache);
                }
            } else {
                storeRequestToCache(synCtx, requestHash, cache);
            }
        }
        return true;
    }

    /**
     * Store request message to the cache
     * @param synCtx the request message
     * @param requestHash the request hash that has already been computed
     * @param cache the cache
     */
    private void storeRequestToCache(MessageContext synCtx, Object requestHash, Cache cache) {
        CachedObject cachedObj = new CachedObject();
        cachedObj.setRequestEnvelope(MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()));
        cachedObj.setRequestHash(requestHash);
        cachedObj.setTimeout(timeout);
        cache.addResponseWithKey(requestHash, cachedObj);
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
        this.cacheObjKey = CACHE_OBJ_PREFIX + id;
    }

    public String getScope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public DigestGenerator getDigestGenerator() {
        return digestGenerator;
    }

    public void setDigestGenerator(DigestGenerator digestGenerator) {
        this.digestGenerator = digestGenerator;
    }

    public int getInMemoryCacheSize() {
        return inMemoryCacheSize;
    }

    public void setInMemoryCacheSize(int inMemoryCacheSize) {
        this.inMemoryCacheSize = inMemoryCacheSize;
    }

    public int getDiskCacheSize() {
        return diskCacheSize;
    }

    public void setDiskCacheSize(int diskCacheSize) {
        this.diskCacheSize = diskCacheSize;
    }

    public long getTimeout() {
        return timeout;
    }

    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }

    public SequenceMediator getOnCacheHitSequence() {
        return onCacheHitSequence;
    }

    public void setOnCacheHitSequence(SequenceMediator onCacheHitSequence) {
        this.onCacheHitSequence = onCacheHitSequence;
    }

    public String getOnCacheHitRef() {
        return onCacheHitRef;
    }

    public void setOnCacheHitRef(String onCacheHitRef) {
        this.onCacheHitRef = onCacheHitRef;
    }
}
"
org/apache/synapse/core/axis2/SynapseCallbackReceiver.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFault;
import org.apache.axiom.soap.SOAPFaultReason;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.async.AxisCallback;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.MessageReceiver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.sandesha2.client.SandeshaClientConstants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.transport.nhttp.NhttpConstants;

import java.util.*;

/**
 * This is the message receiver that receives the responses for outgoing messages sent out
 * by Synapse. It holds a callbackStore that maps the [unique] messageID of each message to
 * a callback object that gets executed on timeout or when a response is recived (before timeout)
 *
 * The AnonymousServiceFactory uses this MessageReceiver for all Anonymous services created by it.
 * This however - effectively - is a singleton class
 */
public class SynapseCallbackReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseCallbackReceiver.class);

    /** This is the synchronized callbackStore that maps outgoing messageID's to callback objects */
    private Map callbackStore;  // this will be made thread safe within the constructor

    /**
     * Create the *single* instance of this class that would be used by all anonymous services
     * used for outgoing messaging.
     * @param synCfg the Synapse configuration
     */
    public SynapseCallbackReceiver(SynapseConfiguration synCfg) {

        callbackStore = Collections.synchronizedMap(new HashMap());

        // create the Timer object and a TimeoutHandler task
        TimeoutHandler timeoutHandler = new TimeoutHandler(callbackStore);
        
        Timer timeOutTimer = synCfg.getSynapseTimer();
        long timeoutHandlerInterval = SynapseConstants.DEFAULT_TIMEOUT_HANDLER_INTERVAL;
        try {
            timeoutHandlerInterval = Long.parseLong(
                System.getProperty(SynapseConstants.TIMEOUT_HANDLER_INTERVAL));
        } catch (Exception ignore) {}

        // schedule timeout handler to run every n seconds (n : specified or defaults to 15s)
        timeOutTimer.schedule(timeoutHandler, 0, timeoutHandlerInterval);
    }


    public void addCallback(String MsgID, AxisCallback callback) {
        callbackStore.put(MsgID, callback);
    }

    /**
     * Everytime a response message is received this method gets invoked. It will then select
     * the outgoing *Synapse* message context for the reply we received, and determine what action
     * to take at the Synapse level
     *
     * @param messageCtx the Axis2 message context of the reply received
     * @throws AxisFault
     */
    public void receive(MessageContext messageCtx) throws AxisFault {

        String messageID = null;

        if (messageCtx.getOptions() != null && messageCtx.getOptions().getRelatesTo() != null) {
            // never take a chance with a NPE at this stage.. so check at each level :-)
            Options options = messageCtx.getOptions();
            if (options != null) {
                RelatesTo relatesTo = options.getRelatesTo();
                if (relatesTo != null) {
                    messageID = relatesTo.getValue();
                }
            }
        } else if (messageCtx.getProperty(SandeshaClientConstants.SEQUENCE_KEY) == null) {
            messageID = (String) messageCtx.getProperty(SynapseConstants.RELATES_TO_FOR_POX);
        }

        if (messageID != null) {
            AxisCallback callback = (AxisCallback) callbackStore.remove(messageID);

            RelatesTo[] relates = messageCtx.getRelationships();
            if (relates != null && relates.length > 1) {
                // we set a relates to to the response message so that if WSA is not used, we
                // could still link back to the original message. But if WSA was used, this
                // gets duplicated, and we should remove it
                removeDuplicateRelatesTo(messageCtx, relates);
            }
            
            if (callback != null) {
                handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());
                
            } else {
                // TODO invoke a generic synapse error handler for this message
                log.warn(""Synapse received a response for the request with message Id : "" +
                    messageID + "" But a callback has not been registered to process this response"");
            }

        } else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){
            // TODO invoke a generic synapse error handler for this message
            log.warn(""Synapse received a response message without a message Id"");
        }
    }

    /**
     * Handle the response or error (during a failed send) message received for an outgoing request
     *
     * @param response         the Axis2 MessageContext that has been received and has to be handled
     * @param synapseOutMsgCtx the corresponding (outgoing) Synapse MessageContext for the above
     *                         Axis2 MC, that holds Synapse specific information such as the error
     *                         handler stack and local properties etc.
     * @throws AxisFault 
     */
    private void handleMessage(MessageContext response,
        org.apache.synapse.MessageContext synapseOutMsgCtx) throws AxisFault {

        Object o = response.getProperty(NhttpConstants.SENDING_FAULT);
        if (o != null && Boolean.TRUE.equals(o)) {

            // there is a sending fault. propagate the fault to fault handlers.

            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                SOAPEnvelope envelope = response.getEnvelope();
                if (envelope != null) {
                    SOAPFault fault = envelope.getBody().getFault();
                    if (fault != null) {
                        Exception e = fault.getException();
                        if (e == null) {
                            e = new Exception(fault.toString());
                        }
                        // set an error code to the message context, so that error sequences can
                        // filter using that property to determine the cause of error
                        synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE,
                            SynapseConstants.SENDING_FAULT);
                        SOAPFaultReason faultReason = fault.getReason();
                        if (faultReason != null) {
                            synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
                                    faultReason.getText());
                        }
                        ((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);
                    }
                }
            }

        } else {

            // there can always be only one instance of an Endpoint in the faultStack of a message
            // if the send was successful, so remove it before we proceed any further
            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (faultStack !=null && !faultStack.isEmpty()
                && faultStack.peek() instanceof Endpoint) {
                faultStack.pop();
            }
            if (log.isDebugEnabled()) {
                log.debug(""Synapse received an asynchronous response message"");
                log.debug(""Received To: "" +
                        (response.getTo() != null ? response.getTo().getAddress() : ""null""));
                log.debug(""SOAPAction: "" +
                        (response.getSoapAction() != null ? response.getSoapAction() : ""null""));
                log.debug(""WSA-Action: "" +
                        (response.getWSAAction() != null ? response.getWSAAction() : ""null""));
                String[] cids = response.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (int i = 0; i < cids.length; i++) {
                        log.debug(""Attachment : "" + cids[i]);
                    }
                }
                log.debug(""Body : \n"" + response.getEnvelope());
            }
            MessageContext axisOutMsgCtx =
                    ((Axis2MessageContext) synapseOutMsgCtx).getAxis2MessageContext();

            response.setServiceContext(null);
            response.setOperationContext(axisOutMsgCtx.getOperationContext());
            response.getAxisMessage().setParent(
                axisOutMsgCtx.getOperationContext().getAxisOperation());
            response.setAxisService(axisOutMsgCtx.getAxisService());

            // set properties on response
            response.setServerSide(true);
            response.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            response.setProperty(MessageContext.TRANSPORT_OUT,
                    axisOutMsgCtx.getProperty(MessageContext.TRANSPORT_OUT));
            response.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    axisOutMsgCtx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));
            response.setTransportIn(axisOutMsgCtx.getTransportIn());
            response.setTransportOut(axisOutMsgCtx.getTransportOut());

            // If request is REST assume that the response is REST too
            response.setDoingREST(axisOutMsgCtx.isDoingREST());
            if (axisOutMsgCtx.isDoingMTOM()) {
                response.setDoingMTOM(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }
            if (axisOutMsgCtx.isDoingSwA()) {
                response.setDoingSwA(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }

            // clear the message type property thats used by the message formatter later on
            // to decide whether to write as SOAP/POX etc..
            response.removeProperty(org.apache.axis2.Constants.Configuration.MESSAGE_TYPE);
            
            // compare original received message (axisOutMsgCtx) soap version with the response
            // if they are different change to original version 
            if(axisOutMsgCtx.isSOAP11() != response.isSOAP11()) {
            	if(axisOutMsgCtx.isSOAP11()) {
            		SOAPUtils.convertSOAP12toSOAP11(response);
            	} else {
            		SOAPUtils.convertSOAP11toSOAP12(response);
            	}
            }

            if (axisOutMsgCtx.getMessageID() != null) {
                response.setRelationships(
                        new RelatesTo[]{new RelatesTo(axisOutMsgCtx.getMessageID())});
            }

            // create the synapse message context for the response
            Axis2MessageContext synapseInMessageContext =
                    new Axis2MessageContext(
                            response,
                            synapseOutMsgCtx.getConfiguration(),
                            synapseOutMsgCtx.getEnvironment());

            synapseInMessageContext.setResponse(true);
            synapseInMessageContext.setTo(
                new EndpointReference(AddressingConstants.Final.WSA_ANONYMOUS_URL));
            synapseInMessageContext.setTracingState(synapseOutMsgCtx.getTracingState());

            // set the properties of the original MC to the new MC
            Iterator iter = synapseOutMsgCtx.getPropertyKeySet().iterator();

            while (iter.hasNext()) {
                Object key = iter.next();
                synapseInMessageContext.setProperty(
                        (String) key, synapseOutMsgCtx.getProperty((String) key));
            }

            // send the response message through the synapse mediation flow
            try {
                synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);
            } catch (SynapseException syne) {
                Stack stack = synapseInMessageContext.getFaultStack();
                if (stack != null &&
                        !stack.isEmpty()) {
                    ((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);
                } else {
                    log.error(""Synapse encountered an exception, "" +
                            ""No error handlers found - [Message Dropped]\n"" + syne.getMessage());
                }
            }
        }
    }

    /**
     * It is possible for us (Synapse) to cause the creation of a duplicate relatesTo as we
     * try to hold onto the outgoing message ID even for POX messages using the relates to
     * Now once we get a response, make sure we remove any trace of this before we proceed any
     * further
     * @param mc the message context from which a possibly duplicated relatesTo should be removed
     * @param relates the existing relatedTo array of the message
     */
    private void removeDuplicateRelatesTo(MessageContext mc, RelatesTo[] relates) {

        int insertPos = 0;
        RelatesTo[] newRelates = new RelatesTo[relates.length];

        for (int i = 0; i < relates.length; i++) {
            RelatesTo current = relates[i];
            boolean found = false;
            for (int j = 0; j < newRelates.length && j < insertPos; j++) {
                if (newRelates[j].equals(current) ||
                        newRelates[j].getValue().equals(current.getValue())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newRelates[insertPos++] = current;
            }
        }

        RelatesTo[] trimmedRelates = new RelatesTo[insertPos];
        System.arraycopy(newRelates, 0, trimmedRelates, 0, insertPos);
        mc.setRelationships(trimmedRelates);
    }
}
"
org/apache/synapse/config/xml/SwitchMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.SwitchMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Constructs a Switch mediator instance from the given XML configuration
 * <p/>
 * <pre>
 * &lt;switch source=""xpath""&gt;
 *   &lt;case regex=""string""&gt;
 *     mediator+
 *   &lt;/case&gt;+
 *   &lt;default&gt;
 *     mediator+
 *   &lt;/default&gt;?
 * &lt;/switch&gt;
 * </pre>
 */
public class SwitchMediatorFactory extends AbstractMediatorFactory {

    private static final QName SWITCH_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""switch"");
    private static final QName CASE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""case"");
    private static final QName DEFAULT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""default"");

    public Mediator createMediator(OMElement elem) {

        SwitchMediator switchMediator = new SwitchMediator();
        OMAttribute source = elem.getAttribute(ATT_SOURCE);
        if (source == null) {
            String msg = ""A 'source' XPath attribute is required for a switch mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            try {
                AXIOMXPath sourceXPath = new AXIOMXPath(source.getAttributeValue());
                org.apache.synapse.config.xml.OMElementUtils.addNameSpaces(sourceXPath, elem, log);
                switchMediator.setSource(sourceXPath);

            } catch (JaxenException e) {
                String msg = ""Invalid XPath for attribute 'source' : "" + source.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(switchMediator, elem);
        Iterator iter = elem.getChildrenWithName(CASE_Q);
        while (iter.hasNext()) {
            OMElement caseElem = (OMElement) iter.next();
            SwitchCase aCase = new SwitchCase();
            OMAttribute regex = caseElem.getAttribute(ATT_REGEX);
            if (regex == null) {
                String msg = ""The 'regex' attribute is required for a switch case definition"";
                log.error(msg);
                throw new SynapseException(msg);
            }
            try {
                aCase.setRegex(Pattern.compile(regex.getAttributeValue()));
            } catch (PatternSyntaxException pse) {
                String msg = ""Invalid Regular Expression for attribute 'regex' : "" + regex.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator(caseElem));
            switchMediator.addCase(aCase);
        }
        iter = elem.getChildrenWithName(DEFAULT_Q);
        while (iter.hasNext()) {
            SwitchCase aCase = new SwitchCase();
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator((OMElement) iter.next()));
            switchMediator.setDefaultCase(aCase);
            break; // add only the *first* default if multiple are specified, ignore rest if any
        }
        return switchMediator;
    }

    public QName getTagQName() {
        return SWITCH_Q;
    }
}
"
org/apache/synapse/util/MessageHelper.java,true,"package org.apache.synapse.util;

import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.attachments.Attachments;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.AxisFault;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 *
 */
public class MessageHelper {

    /**
     * This method will simulate cloning the message context and creating an exact copy of the
     * passed message. One should use this method with care; that is because, inside the new MC,
     * most of the attributes of the MC like opCtx and so on are still kept as references inside
     * the axis2 MessageContext for performance improvements. (Note: U dont have to worrie
     * about the SOAPEnvelope, it is a cloned copy and not a reference from any other MC)
     *
     * @param synCtx - this will be cloned 
     * @return cloned Synapse MessageContext
     * @throws AxisFault if there is a failure in creating the new Synapse MC or in a failure in
     *          clonning the underlying axis2 MessageContext
     * 
     * @see MessageHelper#cloneAxis2MessageContext 
     */
    public static MessageContext cloneMessageContext(MessageContext synCtx) throws AxisFault {

        // creates the new MessageContext and clone the internal axis2 MessageContext
        // inside the synapse message context and place that in the new one
        MessageContext newCtx = synCtx.getEnvironment().createMessageContext();
        Axis2MessageContext axis2MC = (Axis2MessageContext) newCtx;
        axis2MC.setAxis2MessageContext(
            cloneAxis2MessageContext(((Axis2MessageContext) synCtx).getAxis2MessageContext()));

        // set the parent corelation details to the cloned MC -
        //                              for the use of aggregation like tasks
        newCtx.setProperty(EIPConstants.AGGREGATE_CORELATION, synCtx.getMessageID());

        // copying the core parameters of the synapse MC
        newCtx.setTo(synCtx.getTo());
        newCtx.setReplyTo(synCtx.getReplyTo());
        newCtx.setSoapAction(synCtx.getSoapAction());
        newCtx.setWSAAction(synCtx.getWSAAction());

        // copy all the synapse level properties to the newCtx
        for (Object o : synCtx.getPropertyKeySet()) {
            // If there are non String keyed properties neglect them rathern than trow exception
            if (o instanceof String) {
                newCtx.setProperty((String) o, synCtx.getProperty((String) o));
            }
        }

        return newCtx;
    }

    /**
     * This method will simulate cloning the message context and creating an exact copy of the
     * passed message. One should use this method with care; that is because, inside the new MC,
     * most of the attributes of the MC like opCtx and so on are still kept as references. Otherwise
     * there will be perf issues. But ..... this may reveal in some conflicts in the cloned message
     * if you try to do advanced mediations with the cloned message, in which case you should
     * mannually get a clone of the changing part of the MC and set that cloned part to your MC.
     * Changing the MC after doing that will solve most of the issues. (Note: U dont have to worrie
     * about the SOAPEnvelope, it is a cloned copy and not a reference from any other MC)
     *
     * @param mc - this will be cloned for getting an exact copy
     * @return cloned MessageContext from the given mc
     * @throws AxisFault if there is a failure in copying the certain attributes of the
     *          provided message context
     */
    public static org.apache.axis2.context.MessageContext cloneAxis2MessageContext(
        org.apache.axis2.context.MessageContext mc) throws AxisFault {

        org.apache.axis2.context.MessageContext newMC = clonePartially(mc);
        newMC.setEnvelope(cloneSOAPEnvelope(cloneSOAPEnvelope(mc.getEnvelope())));
        
        newMC.setServiceContext(mc.getServiceContext());
        newMC.setOperationContext(mc.getOperationContext());
        newMC.setAxisMessage(mc.getAxisMessage());
        if (newMC.getAxisMessage() != null) {
            newMC.getAxisMessage().setParent(mc.getAxisOperation());
        }
        newMC.setAxisService(mc.getAxisService());

        // copying transport related parts from the original
        newMC.setTransportIn(mc.getTransportIn());
        newMC.setTransportOut(mc.getTransportOut());
        newMC.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
            mc.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));

        newMC.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
            getClonedTransportHeaders(mc));

        return newMC;
    }

    public static Map getClonedTransportHeaders(org.apache.axis2.context.MessageContext msgCtx) {
        
        Map headers = (Map) msgCtx.
            getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
        Map clonedHeaders = new HashMap();

        if (headers != null && headers.isEmpty()) {
            for (Object o : headers.keySet()) {
                String headerName = (String) o;
                clonedHeaders.put(headerName, headers.get(headerName));
            }
        }

        return clonedHeaders;
    }

    public static org.apache.axis2.context.MessageContext clonePartially(
        org.apache.axis2.context.MessageContext ori) throws AxisFault {

        org.apache.axis2.context.MessageContext newMC
            = new org.apache.axis2.context.MessageContext();
        
        // do not copy options from the original
        newMC.setConfigurationContext(ori.getConfigurationContext());
        newMC.setMessageID(UUIDGenerator.getUUID());
        newMC.setTo(ori.getTo());
        newMC.setSoapAction(ori.getSoapAction());

        newMC.setProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING,
                ori.getProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA));

        newMC.setDoingREST(ori.isDoingREST());
        newMC.setDoingMTOM(ori.isDoingMTOM());
        newMC.setDoingSwA(ori.isDoingSwA());

        // if the original request carries any attachments, copy them to the clone
        // as well, except for the soap part if any
        Attachments attachments = ori.getAttachmentMap();
        if (attachments != null && attachments.getAllContentIDs().length > 0) {
            String[] cIDs = attachments.getAllContentIDs();
            String soapPart = attachments.getSOAPPartContentID();
            for (String cID : cIDs) {
                if (!cID.equals(soapPart)) {
                    newMC.addAttachment(cID, attachments.getDataHandler(cID));
                }
            }
        }

        for (Object o : ori.getOptions().getProperties().keySet()) {
            String key = (String) o;
            newMC.getOptions().setProperty(key, ori.getOptions().getProperty(key));
        }

        for (Object o1 : ori.getProperties().keySet()) {
            String key = (String) o1;
            newMC.setProperty(key, ori.getProperty(key));
        }

        newMC.setServerSide(false);

        return newMC;
    }

    /**
     * This method will clone the provided SOAPEnvelope and returns the cloned envelope
     * as an exact copy of the provided envelope
     *
     * @param envelope - this will be cloned to get the new envelope
     * @return cloned SOAPEnvelope from the provided one
     */
    public static SOAPEnvelope cloneSOAPEnvelope(SOAPEnvelope envelope) {
        SOAPEnvelope newEnvelope;
        if (SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI
            .equals(envelope.getBody().getNamespace().getNamespaceURI())) {
            newEnvelope = OMAbstractFactory.getSOAP11Factory().getDefaultEnvelope();
        } else {
            newEnvelope = OMAbstractFactory.getSOAP12Factory().getDefaultEnvelope();
        }

        if (envelope.getHeader() != null) {
            Iterator itr = envelope.getHeader().cloneOMElement().getChildren();
            while (itr.hasNext()) {
                newEnvelope.getHeader().addChild((OMNode) itr.next());
            }
        }

        if (envelope.getBody() != null) {
            Iterator itr = envelope.getBody().cloneOMElement().getChildren();
            while (itr.hasNext()) {
                newEnvelope.getBody().addChild((OMNode) itr.next());
            }
        }

        return newEnvelope;
    }

    /**
     * Removes Submission and Final WS-Addressing headers and return the SOAPEnvelope from the given
     * message context
     *
     * @param axisMsgCtx the Axis2 Message context
     * @return the resulting SOAPEnvelope
     */
    public static SOAPEnvelope removeAddressingHeaders(
        org.apache.axis2.context.MessageContext axisMsgCtx) {

        SOAPEnvelope env = axisMsgCtx.getEnvelope();
        SOAPHeader soapHeader = env.getHeader();
        ArrayList addressingHeaders;

        if (soapHeader != null) {
            addressingHeaders =
                soapHeader.getHeaderBlocksWithNSURI(AddressingConstants.Submission.WSA_NAMESPACE);

            if (addressingHeaders != null && addressingHeaders.size() != 0) {
                detachAddressingInformation(addressingHeaders);

            } else {
                addressingHeaders =
                    soapHeader.getHeaderBlocksWithNSURI(AddressingConstants.Final.WSA_NAMESPACE);
                if (addressingHeaders != null && addressingHeaders.size() != 0) {
                    detachAddressingInformation(addressingHeaders);
                }
            }
        }
        return env;
    }

    /**
     * Remove WS-A headers
     *
     * @param headerInformation headers to be removed
     */
    private static void detachAddressingInformation(ArrayList headerInformation) {
        for (Object o : headerInformation) {
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                headerBlock.detach();
            } else if (o instanceof OMElement) {
                // work around for a known addressing bug which sends non SOAPHeaderBlock objects
                OMElement om = (OMElement) o;
                OMNamespace ns = om.getNamespace();
                if (ns != null && (
                    AddressingConstants.Submission.WSA_NAMESPACE.equals(ns.getNamespaceURI()) ||
                        AddressingConstants.Final.WSA_NAMESPACE.equals(ns.getNamespaceURI()))) {
                    om.detach();
                }
            }
        }
    }

}
"
org/apache/synapse/config/xml/AggregateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.eip.aggregator.AggregateMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * &lt;aggregate&gt;
 *  &lt;corelateOn expression=""XPATH-expression""/&gt;
 *  &lt;completeCondition timeout=""time-in-seconds""&gt;
 *   &lt;messageCount min=""int-min"" max=""int-max""/&gt;
 *  &lt;/completeCondition&gt;
 *  &lt;onComplete expression=""XPATH-expression"" sequence=""sequence-ref""&gt;
 *   (mediator +)?
 *  &lt;/onComplete&gt;
 *  &lt;invalidate sequence=""sequence-ref"" timeout=""time-in-seconds""&gt;
 *   (mediator +)?
 *  &lt;/invalidate&gt;
 * &lt;/aggregate&gt;
 */
public class AggregateMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(AggregateMediatorFactory.class);

    private static final QName AGGREGATE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""aggregate"");
    private static final QName CORELATE_ON_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""corelateOn"");
    private static final QName COMPLETE_CONDITION_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""completeCondition"");
    private static final QName MESSAGE_COUNT_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""messageCount"");
    private static final QName ON_COMPLETE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""onComplete"");
    private static final QName INVALIDATE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""invalidate"");

    private static final QName TIME_TO_LIVE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""timeToLive"");
    private static final QName EXPRESSION_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""expression"");
    private static final QName TIMEOUT_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""timeout"");
    private static final QName MIN_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""min"");
    private static final QName MAX_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""max"");
    private static final QName TYPE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""type"");
    private static final QName SEQUENCE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""sequence"");

    public Mediator createMediator(OMElement elem) {

        AggregateMediator mediator = new AggregateMediator();
        processTraceState(mediator, elem);
        // todo: need to fix
        OMAttribute timeToLive = elem.getAttribute(TIME_TO_LIVE_Q);
        if (timeToLive != null) {
            mediator.setTimeToInvalidate(Long.parseLong(timeToLive.getAttributeValue()) * 1000);
        }

        OMElement corelateOn = elem.getFirstChildWithName(CORELATE_ON_Q);
        if (corelateOn != null) {
            OMAttribute corelateExpr = corelateOn.getAttribute(EXPRESSION_Q);
            if (corelateExpr != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(corelateExpr.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, corelateOn, log);
                    mediator.setCorelateExpression(xp);
                } catch (JaxenException e) {
                    handleException(""Unable to load the corelate XPATH expression"", e);
                }
            }
        }

        OMElement completeCond = elem.getFirstChildWithName(COMPLETE_CONDITION_Q);
        if (completeCond != null) {
            OMAttribute completeTimeout = completeCond.getAttribute(TIMEOUT_Q);
            if (completeTimeout != null) {
                mediator.setCompleteTimeout(
                        Long.parseLong(completeTimeout.getAttributeValue()) * 1000);
            }

            OMElement messageCount = completeCond.getFirstChildWithName(MESSAGE_COUNT_Q);
            if (messageCount != null) {
                OMAttribute min = messageCount.getAttribute(MIN_Q);
                if (min != null) {
                    mediator.setMinMessagesToComplete(Integer.parseInt(min.getAttributeValue()));
                }

                OMAttribute max = messageCount.getAttribute(MAX_Q);
                if (max != null) {
                    mediator.setMaxMessagesToComplete(Integer.parseInt(max.getAttributeValue()));
                }
            }
        }

        OMElement invalidate = elem.getFirstChildWithName(INVALIDATE_Q);
        if (invalidate != null) {
            OMAttribute sequenceRef = invalidate.getAttribute(SEQUENCE_Q);
            if (sequenceRef != null) {
                mediator.setInvalidMsgSequenceRef(sequenceRef.getAttributeValue());
            } else if (invalidate.getFirstElement() != null) {
                mediator.setInvalidMsgSequence(
                        (new SequenceMediatorFactory()).createAnonymousSequence(invalidate));
            }

            OMAttribute timeout = invalidate.getAttribute(TIMEOUT_Q);
            if (timeout != null) {
                mediator.setInvlidateToDestroyTime(Long.parseLong(timeout.getAttributeValue()));
            } else {
                mediator.setInvlidateToDestroyTime(300);
            }
        }

        OMElement onComplete = elem.getFirstChildWithName(ON_COMPLETE_Q);
        if (onComplete != null) {

            OMAttribute aggregateExpr = onComplete.getAttribute(EXPRESSION_Q);
            if (aggregateExpr != null) {
                try {
                    AXIOMXPath xp = new AXIOMXPath(aggregateExpr.getAttributeValue());
                    OMElementUtils.addNameSpaces(xp, onComplete, log);
                    mediator.setAggregationExpression(xp);
                } catch (JaxenException e) {
                    handleException(""Unable to load the aggregating XPATH"", e);
                }
            }

            OMAttribute onCompleteSequence = onComplete.getAttribute(SEQUENCE_Q);
            if (onCompleteSequence != null) {
                mediator.setOnCompleteSequenceRef(onCompleteSequence.getAttributeValue());
            } else if (onComplete.getFirstElement() != null) {
                mediator.setOnCompleteSequence(
                        (new SequenceMediatorFactory()).createAnonymousSequence(onComplete));
            } else {
                SequenceMediator sequence = new SequenceMediator();
                sequence.addChild(new DropMediator());
                mediator.setOnCompleteSequence(sequence);
            }
        }
        return mediator;
    }

    public QName getTagQName() {
        return AGGREGATE_Q;
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.config.xml.XMLConfigConstants;

import javax.xml.namespace.QName;
import java.util.ArrayList;

/**
 * Factroy of all load balance algorithms. ESBSendMediatorFactroy will use this to create the
 * appropriate algorithm implementation.
 */
public class LoadbalanceAlgorithmFactory {

    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement, ArrayList endpoints) {

        LoadbalanceAlgorithm algorithm = null;

        String algorithmName = ""roundRobin"";
        OMAttribute algoAttribute = loadbalanceElement.getAttribute(new QName(null, XMLConfigConstants.ALGORITHM_NAME));
        if(algoAttribute != null) {
            algorithmName = algoAttribute.getAttributeValue();
        }

        if(algorithmName.equalsIgnoreCase(""roundRobin"")) {
                algorithm = new RoundRobin(endpoints);
        }

        return algorithm;
    }
}
"
org/apache/synapse/mediators/MediatorProperty.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.config.xml.XMLConfigConstants;

import javax.xml.namespace.QName;

/**
 * A mediator property is a name-value or name-expression pair which could be supplied
 * for certain mediators. If expressions are supplied they are evaluated at the runtime
 * against the current message into literal String values.
 */
public class MediatorProperty {

    public static final QName PROPERTY_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");
    public static final QName ATT_NAME_Q  = new QName(XMLConfigConstants.NULL_NAMESPACE, ""name"");
    public static final QName ATT_VALUE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""value"");
    public static final QName ATT_EXPR_Q  = new QName(XMLConfigConstants.NULL_NAMESPACE, ""expression"");

    private String name;
    private String value;
    private AXIOMXPath expression;

    public MediatorProperty() {}

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public AXIOMXPath getExpression() {
        return expression;
    }

    public void setExpression(AXIOMXPath expression) {
        this.expression = expression;
    }

    public String getEvaluatedExpression(MessageContext synCtx) {
        return Axis2MessageContext.getStringValue(expression, synCtx);
    }

}
"
org/apache/synapse/mediators/eip/splitter/CloneMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.splitter;

import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.util.MessageHelper;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.OperationContext;

import java.util.ArrayList;
import java.util.List;

/**
 * This mediator will clone the message in to different messages and mediated as specified in the
 * target elements.
 */
public class CloneMediator extends AbstractMediator {

    /**
     * This variable specifies whether to continue the parent message (i.e. message which is
     * sbjuected to cloning) or not
     */
    private boolean continueParent = false;

    /**
     * Holds the list of targets to which cloned copies of the message will be given for mediation
     */
    private List targets = new ArrayList();

    /**
     * This will implement the mediate method of the Mediator interface and will provide the
     * functionality of cloning message in to the specified targets and mediation
     *
     * @param synCtx - MessageContext which is subjected to the cloning
     * @return boolean true if this needs to be further mediated (continueParent=true) false
     *         otherwise
     */
    public boolean mediate(MessageContext synCtx) {

        // tracing and debuggin related mediation initiation
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Clone mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // get the targets list, clone the message for the number of targets and then
        // mediate the cloned messages using the targets
        if (targets.size() != 0) {

            for (int i = 0; i < targets.size(); i++) {
                // clone message context for this target
                MessageContext newContext = getClonedMessageContext(synCtx, i, targets.size());
                Object o = targets.get(i);

                if (o instanceof Target) {
                    Target target = (Target) o;
                    target.mediate(newContext);
                }
            }
        }

        // finalize tracing and debugging
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Clone mediator"");
        }

        // if the continuation of the parent message is stopped from here set the RESPONSE_WRITTEN
        // property to SKIP to skip the blank http response 
        OperationContext opCtx
            = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();
        if (!continueParent && opCtx != null) {
            opCtx.setProperty(Constants.RESPONSE_WRITTEN,""SKIP"");
        }

        // if continue parent is true mediators after the clone will be called for the further
        // mediation of the message which is subjected for clonning (parent message)
        return continueParent;
    }

    /**
     * This private method is used to clone the MC in to a new MC
     *
     * @param synCtx          - MessageContext which is subjected to the clonning
     * @param messageSequence - int clonning message number
     * @param messageCount    - int complete count of cloned messages
     * @return MessageContext which is cloned from the given parameters
     */
    private MessageContext getClonedMessageContext(MessageContext synCtx, int messageSequence,
        int messageCount) {

        MessageContext newCtx = null;
        try {
            // clones the message context
            newCtx = MessageHelper.cloneMessageContext(synCtx);
        } catch (AxisFault axisFault) {
            handleException(""Error creating a new message context"", axisFault, synCtx);
        }

        // Sets the property MESSAGE_SEQUENCE to the MC for aggragation purposes 
        newCtx.setProperty(EIPConstants.MESSAGE_SEQUENCE,
            String.valueOf(messageSequence) + EIPConstants.MESSAGE_SEQUENCE_DELEMITER + messageCount);

        return newCtx;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public boolean isContinueParent() {
        return continueParent;
    }

    public void setContinueParent(boolean continueParent) {
        this.continueParent = continueParent;
    }

    public List getTargets() {
        return targets;
    }

    public void setTargets(List targets) {
        this.targets = targets;
    }

    public void addTarget(Target target) {
        this.targets.add(target);
    }

}
"
org/apache/synapse/config/xml/SwitchCase.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A SwitchCase define a case element of Switch Mediator and It has a list mediator and
 * a regex that is matched by its owning SwitchMediator for selection.
 * If any SwitchCase has selected ,Then the list mediator of it, will responsible
 * for message mediation
 */

public class SwitchCase {

    /** The regular expression pattern to be used */
    private Pattern regex = null;
    /** The list mediator for which responsible message mediation  */
    private AnonymousListMediator caseMediator;

    /**
     * To delegate message mediation to list mediator
     *
     * @param synCtx
     * @return boolean value
     */
    public boolean mediate(MessageContext synCtx) {
        if (caseMediator != null) {
            return caseMediator.mediate(synCtx);
        }
        return true;
    }

    /**
     * To get list mediator of this case element
     *
     * @return List mediator of  switch case
     */
    public AnonymousListMediator getCaseMediator() {
        return caseMediator;
    }

    /**
     * To set the list mediator
     *
     * @param caseMediator
     */
    public void setCaseMediator(AnonymousListMediator caseMediator) {
        this.caseMediator = caseMediator;
    }

    /**
     * To get the regular expression pattern
     *
     * @return Pattern
     */
    public Pattern getRegex() {
        return regex;
    }

    /**
     * To set the regular expression pattern
     *
     * @param regex
     */
    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    /**
     * To evaluate regular expression pattern to a get switch case
     *
     * @param value
     * @return boolean value
     */
    public boolean matches(String value) {
        Matcher matcher = regex.matcher(value);
        if(matcher == null){
            return false;
        }
        boolean retVal = matcher.matches();
        return retVal;
    }
}
"
