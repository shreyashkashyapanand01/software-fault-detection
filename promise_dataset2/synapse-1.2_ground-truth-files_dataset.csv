File,Bug,SRC
org/apache/synapse/endpoints/LoadbalanceEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.axis2.clustering.ClusterManager;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.algorithms.AlgorithmContext;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;

import java.util.List;

/**
 * Load balance endpoint can have multiple endpoints. It will route messages according to the
 * specified load balancing algorithm. This will assume that all immediate child endpoints are
 * identical in state (state is replicated) or state is not maintained at those endpoints. If an
 * endpoint is failing, the failed endpoint is marked as inactive and the message to the next
 * endpoint obtained using the load balancing algorithm. If all the endpoints have failed and the
 * parent endpoint is available, onChildEndpointFail(...) method of parent endpoint is called. If
 * parent is not available, this will call next FaultHandler for the message context.
 */
public class LoadbalanceEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(LoadbalanceEndpoint.class);
    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List<Endpoint> endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the load. Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

    /**
     * If this supports load balancing with failover. If true, request will be directed to the next
     * endpoint if the current one is failing.
     */
    private boolean failover = true;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    /**
     * The endpoint context , place holder for keep any runtime states related to the endpoint
     */
    private final EndpointContext endpointContext = new EndpointContext();

    /**
     * The algorithm context , place holder for keep any runtime states related to the load balance
     * algorithm
     */
    private final AlgorithmContext algorithmContext = new AlgorithmContext();

    public void send(MessageContext synMessageContext) {

        if (log.isDebugEnabled()) {
            log.debug(""Start : Load-balance Endpoint"");
        }

        boolean isClusteringEnable = false;
        // get Axis2 MessageContext and ConfigurationContext
        org.apache.axis2.context.MessageContext axisMC =
                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
        ConfigurationContext cc = axisMC.getConfigurationContext();

        //The check for clustering environment

        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
        if (clusterManager != null &&
                clusterManager.getContextManager() != null) {
            isClusteringEnable = true;
        }

        String endPointName = this.getName();
        if (endPointName == null) {

            if (isClusteringEnable) {
                log.warn(""In a clustering environment , the endpoint  name should be specified"" +
                        ""even for anonymous endpoints. Otherwise , the clustering would not be "" +
                        ""functioned correctly if there are more than one anonymous endpoints. "");
            }
            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        if (isClusteringEnable) {

            // if this is a cluster environment , then set configuration context to endpoint context
            if (endpointContext.getConfigurationContext() == null) {
                endpointContext.setConfigurationContext(cc);
                endpointContext.setContextID(endPointName);

            }
            // if this is a cluster environment , then set configuration context to load balance
            //  algorithm context
            if (algorithmContext.getConfigurationContext() == null) {
                algorithmContext.setConfigurationContext(cc);
                algorithmContext.setContextID(endPointName);
            }
        }

        Endpoint endpoint = algorithm.getNextEndpoint(synMessageContext, algorithmContext);
        if (endpoint != null) {

            // We have to build the envelop if we are supporting failover.
            // Failover should sent the original message multiple times if failures occur. So we
            // have to access the envelop multiple times.
            if (failover) {
                synMessageContext.getEnvelope().build();
            }

            endpoint.send(synMessageContext);

        } else {
            // there are no active child endpoints. so mark this endpoint as failed.
            setActive(false, synMessageContext);

            if (parentEndpoint != null) {
                parentEndpoint.onChildEndpointFail(this, synMessageContext);
            } else {
                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true. As this a sessionless load balancing endpoint
     * having one active child endpoint is enough to consider this as active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        boolean active = endpointContext.isActive();
        if (!active && endpoints != null) {
            for (Endpoint endpoint : endpoints) {
                if (endpoint.isActive(synMessageContext)) {
                    active = true;
                    endpointContext.setActive(true);

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }

        if (log.isDebugEnabled()) {
            log.debug(""Endpoint  '"" + name + ""' is in state ' "" + active + "" '"");
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean variable is thread safe.
        endpointContext.setActive(active);
    }

    public boolean isFailover() {
        return failover;
    }

    public void setFailover(boolean failover) {
        this.failover = failover;
    }

    public List<Endpoint> getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List<Endpoint> endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        // resend (to a different endpoint) only if we support failover
        if (failover) {
            send(synMessageContext);
        } else {
            // we are not informing this to the parent endpoint as the failure of this loadbalance
            // endpoint. there can be more active endpoints under this, and current request has
            // failed only because the currently selected child endpoint has failed AND failover is
            // turned off in this load balance endpoint. so just call the next fault handler.
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }
}
"
org/apache/synapse/util/concurrent/SynapseThreadPool.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.concurrent;

import org.apache.synapse.config.SynapseConfiguration;

import java.util.concurrent.*;

/**
 * This is the executor service that will be returned by the env
 */
public class SynapseThreadPool extends ThreadPoolExecutor {

    // default values
    public static final int SYNAPSE_CORE_THREADS  = 20;
    public static final int SYNAPSE_MAX_THREADS   = 100;
    public static final int SYNAPSE_KEEP_ALIVE    = 5;
    public static final int SYNAPSE_THREAD_QLEN   = 10;
    public static final String SYNAPSE_THREAD_GROUP     = ""synapse-thread-group"";
    public static final String SYNAPSE_THREAD_ID_PREFIX = ""SynapseWorker"";

    // property keys
    public static final String SYN_THREAD_CORE     = ""synapse.threads.core"";
    public static final String SYN_THREAD_MAX      = ""synapse.threads.max"";
    public static final String SYN_THREAD_ALIVE    = ""synapse.threads.keepalive"";
    public static final String SYN_THREAD_QLEN     = ""synapse.threads.qlen"";
    public static final String SYN_THREAD_GROUP    = ""synapse.threads.group"";
    public static final String SYN_THREAD_IDPREFIX = ""synapse.threads.idprefix"";

    /**
     * Constructor for the Synapse thread poll
     * 
     * @param corePoolSize    - number of threads to keep in the pool, even if they are idle
     * @param maximumPoolSize - the maximum number of threads to allow in the pool
     * @param keepAliveTime   - this is the maximum time that excess idle threads will wait
     *  for new tasks before terminating.
     * @param unit            - the time unit for the keepAliveTime argument.
     * @param workQueue       - the queue to use for holding tasks before they are executed.
     */
    public SynapseThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
        TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            new SynapseThreadFactory(
                new ThreadGroup(SYNAPSE_THREAD_GROUP), SYNAPSE_THREAD_ID_PREFIX));
    }

    /**
     * Default Constructor for the thread pool and will use all the values as default
     */
    public SynapseThreadPool() {
        this(SYNAPSE_CORE_THREADS, SYNAPSE_MAX_THREADS, SYNAPSE_KEEP_ALIVE,
            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
    }

    /**
     * Constructor for the SynapseThreadPool
     * 
     * @param corePoolSize  - number of threads to keep in the pool, even if they are idle
     * @param maxPoolSize   - the maximum number of threads to allow in the pool
     * @param keepAliveTime - this is the maximum time that excess idle threads will wait
     *  for new tasks before terminating.
     * @param qlen          - Thread Blocking Queue length
     * @param threadGroup    - ThreadGroup name
     * @param threadIdPrefix - Thread id prefix
     */
    public SynapseThreadPool(int corePoolSize, int maxPoolSize, long keepAliveTime, int qlen,
        String threadGroup, String threadIdPrefix) {
        super(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.SECONDS,
            new LinkedBlockingQueue<Runnable>(qlen),
            new SynapseThreadFactory(new ThreadGroup(threadGroup), threadIdPrefix));
    }
}
"
org/apache/synapse/mediators/AbstractMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This is the superclass of all mediators, and defines common logging, tracing other aspects
 * for all mediators who extend from this.
 * elements of a mediator class.
 */
public abstract class AbstractMediator implements Mediator {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected Log log;
    /** The runtime trace log for mediators */
    protected static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** State of tracing for this mediator */
     protected int traceState = SynapseConstants.TRACING_UNSET;

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediator() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * Returns the class name of the mediator
     * @return the class name of the mediator
     */
    public String getType() {
        String cls = getClass().getName();
        int p = cls.lastIndexOf(""."");
        if (p == -1)
            return cls;
        else
            return cls.substring(p + 1);
    }

    /**
     * Returns the tracing state
     * @return the tracing state for this mediator (see SynapseConstants)
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing state variable
     * @param traceState the new tracing state for this mediator (see SynapseConstants)
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    /**
     * This method is used to save previous tracing state and set next the tracing
     * state for a child mediator
     *
     * @param synCtx current message
     */
    public void setEffectiveTraceState(MessageContext synCtx) {
        // if I have been explicitly asked to enable or disable tracing, use it and pass it on
        // else, do nothing -> i.e. let the parents state flow
        if (traceState != SynapseConstants.TRACING_UNSET) {
            synCtx.setTracingState(traceState);
        }
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param parentTraceState parents trace state
     * @return true if tracing should be performed
     */
    public boolean shouldTrace(int parentTraceState){
        return
            (traceState == SynapseConstants.TRACING_ON) ||
            (traceState == SynapseConstants.TRACING_UNSET &&
                parentTraceState == SynapseConstants.TRACING_ON);
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return
            (traceState == SynapseConstants.TRACING_ON) ||
            (traceState == SynapseConstants.TRACING_UNSET &&
                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    /**
     * Perform Trace and Debug logging of a message @WARN
     * @param traceOn is runtime trace on for this message?
     * @param msg the message to log/trace
     */
    protected void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
    }

    /**
     * Perform an audit log message to all logs @ INFO. Writes to the general log, the service log
     * and the trace log (of trace is on)
     * @param msg the log message
     * @param msgContext the message context
     */
    protected void auditLog(String msg, MessageContext msgContext) {
        log.info(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().info(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.info(msg);
        }
    }

    /**
     * Perform an error log message to all logs @ ERROR. Writes to the general log, the service log
     * and the trace log (of trace is on) and throws a SynapseException
     * @param msg the log message
     * @param msgContext the message context
     */
    protected void handleException(String msg, MessageContext msgContext) {
        log.error(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.error(msg);
        }
        throw new SynapseException(msg);
    }

    /**
     * Write an audit entry at WARN and trace and standard logs @WARN
     * @param msg the message to log
     * @param msgContext message context
     */
    protected void auditWarn(String msg, MessageContext msgContext) {
        log.warn(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.warn(msg);
        }
    }

    /**
     * Perform an error log message to all logs @ ERROR. Writes to the general log, the service log
     * and the trace log (of trace is on) and throws a SynapseException
     * @param msg the log message
     * @param e an Exception encountered
     * @param msgContext the message context
     */
    protected void handleException(String msg, Exception e, MessageContext msgContext) {
        log.error(msg, e);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg, e);
        }
        if (shouldTrace(msgContext.getTracingState())) {
            trace.error(msg, e);
        }
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


import java.util.Iterator;

/**
 * This is factory for creating an anonymous list mediator(an unnamed list of mediators )
 *
 */

public abstract class AnonymousListMediatorFactory extends AbstractListMediatorFactory {

    /**
     * To create an anonymous list mediator form OMElement
     * @param el
     * @return List mediator
     */
    public static AnonymousListMediator createAnonymousListMediator(OMElement el) {
        AnonymousListMediator mediator = new AnonymousListMediator();
        {
            addChildren(el, mediator);
        }
        return mediator;
    }

}
"
org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

/**
 * All load balance algorithms must implement this interface. Implementations of this interface can
 * be registered in LoadbalanceManagers.
 */
public interface LoadbalanceAlgorithm {

    /**
     * This method returns the next node according to the algorithm implementation.
     *
     * @param synapseMessageContext SynapseMessageContext of the current message
     * @param algorithmContext The context in which holds run time states related to the algorithm
     * @return Next node for directing the message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext, AlgorithmContext algorithmContext);

    /**
     * Resets the algorithm to its initial position. Initial position depends on the implementation.
     * @param algorithmContext The context in which holds run time states related to the algorithm
     */
    public void reset(AlgorithmContext algorithmContext);
}
"
org/apache/synapse/config/xml/ClassMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ext.ClassMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Class mediator using XML configuration specified
 * <p/>
 * <pre>
 * &lt;class name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot;&gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorFactory extends AbstractMediatorFactory {

    private static final QName CLASS_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""class"");

    public Mediator createMediator(OMElement elem) {

        ClassMediator classMediator = new ClassMediator();

        OMAttribute name = elem.getAttribute(ATT_NAME);
        if (name == null) {
            String msg = ""The name of the actual mediator class is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        Class clazz = null;
        Mediator m = null;
        try {
            clazz = getClass().getClassLoader().loadClass(
                    name.getAttributeValue());
            m = (Mediator) clazz.newInstance();
        } catch (Exception e) {
            String msg = ""Error : "" + name.getAttributeValue();
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }

        for (Iterator it = elem.getChildrenWithName(PROP_Q); it.hasNext();) {
            OMElement child = (OMElement) it.next();

            String propName = child.getAttribute(ATT_NAME).getAttributeValue();
            if (propName == null) {
                handleException(
                    ""A Class mediator property must specify the name attribute"");
            } else {
                if (child.getAttribute(ATT_VALUE) != null) {
                    String value = child.getAttribute(ATT_VALUE).getAttributeValue();
                    classMediator.addProperty(propName, value);
                    PropertyHelper.setInstanceProperty(propName, value, m);
                } else {
                    OMNode omElt = child.getFirstElement();
                    if (omElt != null) {
                        classMediator.addProperty(propName, omElt);
                        PropertyHelper.setInstanceProperty(propName, omElt, m);
                    } else {
                        handleException(""A Class mediator property must specify "" +
                            ""name and value attributes, or a name and a child XML fragment"");
                    }
                }
            }
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        classMediator.setMediator(m);
        processTraceState(classMediator, elem);

        return classMediator;
    }

    public QName getTagQName() {
        return CLASS_Q;
    }
}
"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates {@link LoadbalanceEndpoint} using an XML configuration.
 *
 * &lt;endpoint [name=""name""]&gt;
 *    &lt;loadbalance policy=""load balance algorithm""&gt;
 *       &lt;endpoint&gt;+
 *    &lt;/loadbalance&gt;
 * &lt;/endpoint&gt;
 */
public class LoadbalanceEndpointFactory extends EndpointFactory {

    private static LoadbalanceEndpointFactory instance = new LoadbalanceEndpointFactory();

    private LoadbalanceEndpointFactory() {}

    public static LoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms

        OMElement loadbalanceElement = epConfig.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            LoadbalanceEndpoint loadbalanceEndpoint = new LoadbalanceEndpoint();

            // set endpoint name
            OMAttribute name = epConfig.getAttribute(new QName(
                    org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

            if (name != null) {
                loadbalanceEndpoint.setName(name.getAttributeValue());
            }

            // set endpoints
            ArrayList<Endpoint> endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set if failover is turned off
            String failover = loadbalanceElement.getAttributeValue(new QName(""failover""));
            if (failover != null && failover.equalsIgnoreCase(""false"")) {
                loadbalanceEndpoint.setFailover(false);
            }

            return loadbalanceEndpoint;
        }

        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }
}
"
org/apache/synapse/util/WrappedTextNodeStreamReader.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import java.io.IOException;
import java.io.Reader;
import java.util.Collections;

import javax.xml.XMLConstants;
import javax.xml.namespace.NamespaceContext;
import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

import org.apache.axiom.om.impl.EmptyOMLocation;
import org.apache.axiom.om.impl.llom.util.NamespaceContextImpl;
import org.apache.commons.io.IOUtils;

/**
 * {@link javax.xml.stream.XMLStreamException XMLInputStreamReader} implementation that
 * represents a text node wrapped inside an element. The text data is provided by a
 * {@link java.io.Reader Reader}.
 * <p>
 * It will produce the following sequence of XML events:
 * <ul>
 *   <li>START_DOCUMENT</li>
 *   <li>START_ELEMENT</li>
 *   <li>(CHARACTER)*</li>
 *   <li>END_ELEMENT</li>
 *   <li>END_DOCMENT</li>
 * </ul>
 * The class is implemented as a simple state machine, where the state is identified
 * by the current event type. The initial state is <tt>START_DOCUMENT</tt> and the
 * following transitions are triggered by {@link #next()}:
 * <ul>
 *   <li>START_DOCUMENT &rarr; START_ELEMENT</li>
 *   <li>START_ELEMENT &rarr; END_ELEMENT (if character stream is empty)</li>
 *   <li>START_ELEMENT &rarr; CHARACTERS (if character stream is not empty)</li>
 *   <li>CHARACTERS &rarr; CHARACTERS (if data available in stream)</li>
 *   <li>CHARACTERS &rarr; END_ELEMENT (if end of stream reached)</li>
 *   <li>END_ELEMENT &rarr; END_DOCUMENT</li>
 * </ul>
 * Additionally, {@link #getElementText()} triggers the following transition:
 * <ul>
 *   <li>START_ELEMENT &rarr; END_ELEMENT</li>
 * </ul>
 * Note that since multiple consecutive CHARACTERS events may be returned, this
 * ""parser"" is not coalescing.
 * 
 */
public class WrappedTextNodeStreamReader implements XMLStreamReader {
    /**
     * Location object returned by {@link #getLocation()}.
     * It always returns -1 for the location and null for the publicId and systemId. 
     */
    private final static Location EMPTY_LOCATION = new EmptyOMLocation();
    
    /**
     * The qualified name of the wrapper element.
     */
    private final QName wrapperElementName;
    
    /**
     * The Reader object that represents the text data.
     */
    private final Reader reader;
    
    /**
     * The maximum number of characters to return for each CHARACTER event.
     */
    private final int chunkSize;
    
    /**
     * The type of the current XML event.
     */
    private int eventType = START_DOCUMENT;
    
    /**
     * The character data for the current event. This is only set if the current
     * event is a CHARACTER event. The size of the array is determined by
     * {@link #chunkSize}
     */
    private char[] charData;
    
    /**
     * The length of the character data in {@link #charData}.
     */
    private int charDataLength;
    
    /**
     * The namespace context applicable in the scope of the wrapper element.
     * Beside the default mappings for xml and xmlns, it only contains the
     * mapping for the namespace of the wrapper element.
     * This attribute is initialized lazily by {@link #getNamespaceContext()}.
     */
    private NamespaceContext namespaceContext;
    
    /**
     * Create a new instance.
     * 
     * @param wrapperElementName the qualified name of the wrapper element
     * @param reader the Reader object holding the character data to be wrapped
     * @param chunkSize the maximum number of characters that are returned for each CHARACTER event
     */
    public WrappedTextNodeStreamReader(QName wrapperElementName, Reader reader, int chunkSize) {
        this.wrapperElementName = wrapperElementName;
        this.reader = reader;
        this.chunkSize = chunkSize;
    }
    
    /**
     * Create a new instance with chunk size 4096.
     * 
     * @param wrapperElementName the qualified name of the wrapper element
     * @param reader the Reader object holding the character data to be wrapped
     */
    public WrappedTextNodeStreamReader(QName wrapperElementName, Reader reader) {
        this(wrapperElementName, reader, 4096);
    }

    public Object getProperty(String name) throws IllegalArgumentException {
        // We don't define any properties
        return null;
    }
    
    //
    // Methods to manipulate the parser state
    //
    
    public boolean hasNext() throws XMLStreamException {
        return eventType != END_DOCUMENT;
    }
    
    public int next() throws XMLStreamException {
        // Determine next event type based on current event type. If current event type
        // is START_ELEMENT or CHARACTERS, pull new data from the reader.
        switch (eventType) {
            case START_DOCUMENT:
                eventType = START_ELEMENT;
                break;
            case START_ELEMENT:
                charData = new char[chunkSize];
                // No break here!
            case CHARACTERS:
                try {
                    charDataLength = reader.read(charData);
                }
                catch (IOException ex) {
                    throw new XMLStreamException(ex);
                }
                if (charDataLength == -1) {
                    charData = null;
                    eventType = END_ELEMENT;
                } else {
                    eventType = CHARACTERS;
                }
                break;
            case END_ELEMENT:
                eventType = END_DOCUMENT;
                break;
            default:
                throw new IllegalStateException();
        }
        return eventType;
    }
    
    public int nextTag() throws XMLStreamException {
        // We don't have white space, comments or processing instructions
        throw new XMLStreamException(""Current event is not white space"");
    }

    public int getEventType() {
        return eventType;
    }

    public boolean isStartElement() { return eventType == START_ELEMENT; }
    public boolean isEndElement() { return eventType == END_ELEMENT; }
    public boolean isCharacters() { return eventType == CHARACTERS; }
    public boolean isWhiteSpace() { return false; }
    public boolean hasText() { return eventType == CHARACTERS; }
    public boolean hasName() { return eventType == START_ELEMENT || eventType == END_ELEMENT; }
    
    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
        if (type != eventType
             || (namespaceURI != null && !namespaceURI.equals(getNamespaceURI()))
             || (localName != null && !namespaceURI.equals(getLocalName()))) {
            throw new XMLStreamException(""Unexpected event type"");
        }
    }
    
    public Location getLocation() {
        // We do not support location information
        return EMPTY_LOCATION;
    }
    
    public void close() throws XMLStreamException {
        // Javadoc says that this method should not close the underlying input source,
        // but we need to close the reader somewhere.
        try {
            reader.close();
        }
        catch (IOException ex) {
            throw new XMLStreamException(ex);
        }
    }

    //
    // Methods related to the xml declaration.
    //
    
    public String getEncoding() {
        // Encoding is not known (not relevant?)
        return null;
    }

    public String getCharacterEncodingScheme() {
        // Encoding is not known (not relevant?)
        return null;
    }

    public String getVersion() {
        // Version is not relevant
        return null;
    }

    public boolean standaloneSet() {
        return false;
    }

    public boolean isStandalone() {
        return true;
    }
    
    //
    // Methods related to the namespace context
    //
    
    public NamespaceContext getNamespaceContext() {
        if (namespaceContext == null) {
            namespaceContext = new NamespaceContextImpl(Collections.singletonMap(wrapperElementName.getPrefix(), wrapperElementName.getNamespaceURI()));
        }
        return namespaceContext;
    }
    
    public String getNamespaceURI(String prefix) {
        String namespaceURI = getNamespaceContext().getNamespaceURI(prefix);
        // NamespaceContext#getNamespaceURI and XMLStreamReader#getNamespaceURI have slightly
        // different semantics for unbound prefixes.
        return namespaceURI.equals(XMLConstants.NULL_NS_URI) ? null : prefix;
    }
    
    //
    // Methods related to elements
    //
    
    private void checkStartElement() {
        if (eventType != START_ELEMENT) {
            throw new IllegalStateException();
        }
    }
    
    public String getAttributeValue(String namespaceURI, String localName) {
        checkStartElement();
        return null;
    }

    public int getAttributeCount() {
        checkStartElement();
        return 0;
    }
    
    public QName getAttributeName(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public String getAttributeLocalName(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public String getAttributePrefix(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public String getAttributeNamespace(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public String getAttributeType(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public String getAttributeValue(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }

    public boolean isAttributeSpecified(int index) {
        checkStartElement();
        throw new ArrayIndexOutOfBoundsException();
    }
    
    private void checkElement() {
        if (eventType != START_ELEMENT && eventType != END_ELEMENT) {
            throw new IllegalStateException();
        }
    }
    
    public QName getName() {
        return null;
    }

    public String getLocalName() {
        checkElement();
        return wrapperElementName.getLocalPart();
    }

    public String getPrefix() {
        return wrapperElementName.getPrefix();
    }

    public String getNamespaceURI() {
        checkElement();
        return wrapperElementName.getNamespaceURI();
    }
    
    public int getNamespaceCount() {
        checkElement();
        // There is one namespace declared on the wrapper element
        return 1;
    }

    public String getNamespacePrefix(int index) {
        checkElement();
        if (index == 0) {
            return wrapperElementName.getPrefix();
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    public String getNamespaceURI(int index) {
        checkElement();
        if (index == 0) {
            return wrapperElementName.getNamespaceURI();
        } else {
            throw new IndexOutOfBoundsException();
        }
    }
    
    public String getElementText() throws XMLStreamException {
        if (eventType == START_ELEMENT) {
            // Actually the purpose of this class is to avoid storing
            // the character data entirely in memory, but if the caller
            // wants a String, we don't have the choice...
            try {
                String result = IOUtils.toString(reader);
                eventType = END_ELEMENT;
                return result;
            }
            catch (IOException ex) {
                throw new XMLStreamException(ex);
            }
        } else {
            throw new XMLStreamException(""Current event is not a START_ELEMENT"");
        }
    }

    private void checkCharacters() {
        if (eventType != CHARACTERS) {
            throw new IllegalStateException();
        }
    }
    
    public String getText() {
        checkCharacters();
        return new String(charData, 0, charDataLength);
    }

    public char[] getTextCharacters() {
        checkCharacters();
        return charData;
    }

    public int getTextStart() {
        checkCharacters();
        return 0;
    }

    public int getTextLength() {
        checkCharacters();
        return charDataLength;
    }

    public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) throws XMLStreamException {
        checkCharacters();
        int c = Math.min(charDataLength-sourceStart, length);
        System.arraycopy(charData, sourceStart, target, targetStart, c);
        return c;
    }
    
    //
    // Methods related to processing instructions
    //
    
    public String getPIData() {
        throw new IllegalStateException();
    }

    public String getPITarget() {
        throw new IllegalStateException();
    }
}
"
org/apache/synapse/endpoints/dispatch/DispatcherContext.java,false,"/*
*  Licensed to the Apache Software Foundation (ASF) under one
*  or more contributor license agreements.  See the NOTICE file
*  distributed with this work for additional information
*  regarding copyright ownership.  The ASF licenses this file
*  to you under the Apache License, Version 2.0 (the
*  ""License""); you may not use this file except in compliance
*  with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
package org.apache.synapse.endpoints.dispatch;

import org.apache.axis2.clustering.ClusteringFault;
import org.apache.axis2.clustering.context.Replicator;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Keeps the states of the dispatcher . This hides where those states are kept . For a cluster
 * environment , all states are kept in the axis2 configuration context in order to replicate
 * those states so that other synapse instance in the same cluster can see those changes .
 * This class can be evolved to keep any run time states related to the endpoint .
 * For a non-clustered environment , all data are kept locally.
 * <p/>
 * This class provide the abstraction need to separate the dynamic data from the static data and
 * improve the  high cohesion and provides capability to replicate only required state at a given
 * time. This improves the performance when replicate data.
 */
public class DispatcherContext {

    private static final Log log = LogFactory.getLog(DispatcherContext.class);

    /* The  static constant only for construct key prefix for each property in a dispatcher context
     *as it is need when those property state going to replicate in a cluster env. */
    private static final String SESSION = ""session"";
    private static final String UNDERSCORE_STRING = ""_"";

    /* Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
     * multiple threads (e.g. multiple clients different sessions).*/
    private final Map<String, Endpoint> sessionMap
            = Collections.synchronizedMap(new HashMap<String, Endpoint>());

    /*The axis configuration context-  this will hold the all callers states
     *when doing throttling in a clustered environment. */
    private ConfigurationContext configCtx;

    /* Is this env. support clustering*/
    private boolean isClusteringEnable = false;

    /*The key prefix for each session and this is used when this attribute value being replicated */
    private String keyPrefix;

    /*To keep all defined child endpoints  */
    private final Map<String, Endpoint> endpointsMap = new HashMap<String, Endpoint>();

    /**
     * return the endpoint  for the given session.
     * Null will be returned , if there is no endpoint for given session.
     *
     * @param sessionID The session identifier
     * @return Returns the endpoint for the given session.
     */
    public Endpoint getEndpoint(String sessionID) {

        if (isClusteringEnable) {    // if this is a clustering env.

            if (keyPrefix == null || """".equals(keyPrefix)) {
                handleException(""Cannot find the required key prefix to find the "" +
                        ""shared state of one of  'session'"");
            }
            // gets the value from configuration context (The shared state across all instances)
            Object value = this.configCtx.getPropertyNonReplicable(this.keyPrefix + sessionID);
            if (value != null && value instanceof String) {
                if (log.isDebugEnabled()) {
                    log.debug(""Retrieving the endpoint from the session id "" + value);
                }
                return endpointsMap.get(value.toString());
            }

        } else {

            synchronized (sessionMap) {
                if (log.isDebugEnabled()) {
                    log.debug(""Retrieving the endpoint from the session id "" + sessionID);
                }
                return sessionMap.get(sessionID);
            }
        }

        return null;
    }

    /**
     * Sets the given endpoint mapping with given the session id.
     *
     * @param sessionID The session identifier
     * @param endpoint  The endpoint
     */
    public void setEndpoint(String sessionID, Endpoint endpoint) {

        if (isClusteringEnable) {  // if this is a clustering env.

            String endpointName;
            if (endpoint instanceof IndirectEndpoint) {
                endpointName = ((IndirectEndpoint) endpoint).getKey();
            } else {
                endpointName = endpoint.getName();
            }

            if (endpointName == null) {
                if (log.isDebugEnabled() && isClusteringEnable()) {
                    log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
                }
                endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
            }
            
            if (keyPrefix != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Adding the enpoint "" + endpointName + "" with the session id ""
                            + keyPrefix + sessionID + "" for replication to the session"");
                }
                // replicates the state so that all instances across cluster can see this state
                setAndReplicateState(keyPrefix + sessionID, endpointName);
            }

        } else {

            synchronized (sessionMap) {
                if (log.isDebugEnabled()) {
                    log.debug(""Adding the endpoint "" + endpoint
                            + "" with the session id "" + sessionID + "" to the session"");
                }
                sessionMap.put(sessionID, endpoint);
            }
        }

    }

    /**
     * Removes the endpoint for the given session.
     *
     * @param id The session identifier
     */
    public void removeSession(String id) {

        if (isClusteringEnable) {   // if this is a clustering env.

            if (keyPrefix != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Removing and replicating "" +
                            ""the session with the session id "" + keyPrefix + id);
                }
                //Removes the endpoint name and then replicates the current
                //state so that all instances
                removeAndReplicateState(keyPrefix + id);
            }

        } else {

            synchronized (sessionMap) {
                if (log.isDebugEnabled()) {
                    log.debug(""Removing the session with the session id "" + id);
                }
                sessionMap.remove(id);
            }
        }
    }

    /**
     * Get the configuration context instance . This is only available for cluster env.
     *
     * @return Returns the ConfigurationContext instance
     */
    public ConfigurationContext getConfigurationContext() {
        return configCtx;
    }

    /**
     * Sets the  ConfigurationContext instance . This is only used for cluster env.
     * By setting this , indicates that this is a cluster env.
     *
     * @param configCtx The ConfigurationContext instance
     */
    public void setConfigurationContext(ConfigurationContext configCtx) {

        if (configCtx == null) {
            handleException(""The ConfigurationContext cannot be null"" +
                    "" when system in a cluster environment"");
        }

        this.configCtx = configCtx;
        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
    }

    /**
     * Sets the identifier for this dispatcher context , so that , this can be identified
     * uniquely across the cluster. The id will be the name of the endpoint
     *
     * @param contextID The Id for this dispatcher context
     */
    public void setContextID(String contextID) {

        if (contextID == null || """".equals(contextID)) {
            handleException(""The Context ID cannot be null when system in a cluster environment"");
        }

        //Making required key for each property in the dispatcher context - Those will be used when
        //replicating states
        StringBuffer buffer = new StringBuffer();
        buffer.append(contextID);
        buffer.append(UNDERSCORE_STRING);
        buffer.append(SESSION);
        buffer.append(UNDERSCORE_STRING);
        keyPrefix = buffer.toString();

    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     */
    protected void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     * @param e   The exception
     */
    protected void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Helper method to replicates states of the property with given key
     * Sets property and  replicates the current state  so that all instances
     * across cluster can see this state
     *
     * @param key   The key of the property
     * @param value The value of the property
     */
    private void setAndReplicateState(String key, Object value) {

        if (configCtx != null && key != null && value != null) {

            try {
                if (log.isDebugEnabled()) {
                    log.debug(""Start replicating the property with key : "" +
                            key + "" value : "" + value);
                }

                Object prop = configCtx.getPropertyNonReplicable(key);
                if (prop == null) {
                    configCtx.setProperty(key, value);
                    Replicator.replicate(configCtx, new String[]{key});
                }

                if (log.isDebugEnabled()) {
                    log.debug(""Completed replication of the property with key: "" + key);
                }

            } catch (ClusteringFault clusteringFault) {
                handleException(""Error during the replicating states "", clusteringFault);
            }
        }
    }

    /**
     * Helper method to replicates states of the property with given key
     * Removes the property and then replicates the current state so that all instances
     * across cluster can see this state
     *
     * @param key The key of the property
     */
    private void removeAndReplicateState(String key) {

        if (configCtx != null && key != null) {

            try {
                if (log.isDebugEnabled()) {
                    log.debug(""Start replicating the property removal with key : "" + key);
                }

                configCtx.removeProperty(key);
                Replicator.replicate(configCtx, new String[]{key});

                if (log.isDebugEnabled()) {
                    log.debug(""Completed replication of the property removal with key : "" + key);
                }

            } catch (ClusteringFault clusteringFault) {
                handleException(""Error during the replicating states "", clusteringFault);
            }
        }
    }

    /**
     * Returns whether clustering is enable or not
     *
     * @return True - enable , false -> this is not a cluster env.
     */
    public boolean isClusteringEnable() {
        return isClusteringEnable;
    }

    /**
     * Sets the defined child endpoints
     *
     * @param endpoints The endpoint list
     */
    public void setEndpoints(List<Endpoint> endpoints) {

        if (endpoints != null) {

            for (Endpoint endpoint : endpoints) {

                String endpointName;
                if (endpoint instanceof IndirectEndpoint) {
                    endpointName = ((IndirectEndpoint) endpoint).getKey();
                } else {
                    endpointName = endpoint.getName();
                }
                
                if (endpointName == null) {
                    if (log.isDebugEnabled() && isClusteringEnable()) {
                        log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
                    }
                    endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
                }

                if (log.isDebugEnabled()) {
                    log.debug(""Adding an endpoint with the name/key ""
                            + endpointName + "" to the endpoints map"");
                }
                endpointsMap.put(endpointName, endpoint);
            }
        }
    }
}"
org/apache/synapse/util/UUIDGenerator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

/**
 * This is a thread-safe version of the Axiom UUIDGenerator
 * to be used until it is fixed in the next Axiom release
 */
public class UUIDGenerator {
    /** This class will give UUIDs for axis2. */

    private static String baseUUID = null;
    private static long incrementingValue = 0;

    private static Random myRand = null;
    private static boolean useNano = false;

    /**
     * MD5 a random string with localhost/date etc will return 128 bits construct a string of 18
     * characters from those bits.
     *
     * @return string
     */
    public static String getUUID() {
        if (baseUUID == null) {
            baseUUID = getInitialUUID();
            baseUUID = ""urn:uuid:"" + baseUUID;
        }
        if (++incrementingValue >= Long.MAX_VALUE) {
            incrementingValue = 0;
        }

        if (useNano) {
            return baseUUID + (System.nanoTime() + incrementingValue) +
                Integer.toString(myRand.nextInt());
        } else {

            return baseUUID + (System.currentTimeMillis() + incrementingValue +
                Integer.toString(myRand.nextInt()));
        }

    }

    protected static String getInitialUUID() {

        try {
            if (System.class.getMethod(""nanoTime"", new Class[0]) != null) {
                useNano = true;
            }
        } catch (NoSuchMethodException ignore) {}

        if (myRand == null) {
            myRand = new Random();
        }
        long rand = myRand.nextLong();
        String sid;
        try {
            sid = InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            sid = Thread.currentThread().getName();
        }
        StringBuffer sb = new StringBuffer();
        sb.append(sid);
        sb.append("":"");
        sb.append(Long.toString(rand));
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            //System.out.println(""Error: "" + e);
            //todo heve to be properly handle
        }
        md5.update(sb.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb2 = new StringBuffer();
        for (int j = 0; j < array.length; ++j) {
            int b = array[j] & 0xFF;
            sb2.append(Integer.toHexString(b));
        }
        int begin = myRand.nextInt();
        if (begin < 0) begin = begin * -1;
        begin = begin % 8;
        return sb2.toString().substring(begin, begin + 18).toUpperCase();
    }
}
"
org/apache/synapse/config/xml/AbstractDBMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMText;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.db.AbstractDBMediator;
import org.apache.synapse.mediators.db.Statement;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamConstants;
import java.sql.Types;
import java.util.Iterator;

/**
 * Base class for serializers for database related mediators.
 * 
 * <dbreport | dblookup | .. etc>
 *   <connection>
 *     <pool>
 *     (
 *       <driver/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     |
 *       <dsName/>
 *       <icClass/>
 *       <url/>
 *       <user/>
 *       <password/>
 *     )
 *       <property name=""name"" value=""value""/>*
 *     </pool>
 *   </connection>
 *   <statement>
 *     <sql>insert into table values (?, ?, ..) OR select target from destinations where src = ?</sql>
 *     <parameter (value=""const"" | expression=""xpath"") type=""INTEGER|VARCHAR|...""/>*
 *     <result name=""propName"" column=""target | number""/>*
 *   </statement>+
 * </dbreport | dblookup | .. etc>
 *
 * Supported properties
 * autocommit = true | false
 * isolation = Connection.TRANSACTION_NONE
 *           | Connection.TRANSACTION_READ_COMMITTED
 *           | Connection.TRANSACTION_READ_UNCOMMITTED
 *           | Connection.TRANSACTION_REPEATABLE_READ
 *           | Connection.TRANSACTION_SERIALIZABLE
 * initialsize = int
 * maxactive = int
 * maxidle = int
 * maxopenstatements = int
 * maxwait = long
 * minidle = int
 * poolstatements = true | false
 * testonborrow = true | false
 * testonreturn = true | false
 * testwhileidle = true | false
 * validationquery = String
 */
public abstract class AbstractDBMediatorSerializer extends AbstractMediatorSerializer {

    protected void serializeDBInformation(AbstractDBMediator mediator, OMElement dbParent) {

        OMElement connElt = fac.createOMElement(""connection"", synNS);
        OMElement poolElt = fac.createOMElement(""pool"", synNS);

        Iterator iter = mediator.getDataSourceProps().keySet().iterator();
        while (iter.hasNext()) {

            Object o = iter.next();
            String value = (String) mediator.getDataSourceProps().get(o);

            if (o instanceof QName) {
                QName name = (QName) o;
                OMElement elt = fac.createOMElement(name.getLocalPart(), synNS);
                elt.setText(value);
                poolElt.addChild(elt);

            } else if (o instanceof String) {
                OMElement elt = fac.createOMElement(
                    AbstractDBMediatorFactory.PROP_Q.getLocalPart(), synNS);
                elt.addAttribute(fac.createOMAttribute(""name"", nullNS, (String) o));
                elt.addAttribute(fac.createOMAttribute(""value"", nullNS, value));
                poolElt.addChild(elt);
            }
        }

        connElt.addChild(poolElt);
        dbParent.addChild(connElt);

        // process statements
        Iterator statementIter = mediator.getStatementList().iterator();
        while (statementIter.hasNext()) {

            Statement statement = (Statement) statementIter.next();
            OMElement stmntElt = fac.createOMElement(
                AbstractDBMediatorFactory.STMNT_Q.getLocalPart(), synNS);

            OMElement sqlElt = fac.createOMElement(
                AbstractDBMediatorFactory.SQL_Q.getLocalPart(), synNS);
            OMText sqlText = fac.createOMText(statement.getRawStatement(), XMLStreamConstants.CDATA);
            sqlElt.addChild(sqlText);
            stmntElt.addChild(sqlElt);

            // serialize parameters of the statement
            for (Iterator it = statement.getParameters().iterator(); it.hasNext(); ) {

                Statement.Parameter param = (Statement.Parameter) it.next();
                OMElement paramElt = fac.createOMElement(
                    AbstractDBMediatorFactory.PARAM_Q.getLocalPart(), synNS);

                if (param.getPropertyName() != null) {
                    paramElt.addAttribute(
                        fac.createOMAttribute(""value"", nullNS, param.getPropertyName()));
                }
                if (param.getXpath() != null) {
                    SynapseXPathSerializer.serializeXPath(param.getXpath(), paramElt, ""expression"");
                }

                switch (param.getType()) {
                    case Types.CHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""CHAR""));
                        break;
                    }
                    case Types.VARCHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""VARCHAR""));
                        break;
                    }
                    case Types.LONGVARCHAR: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""LONGVARCHAR""));
                        break;
                    }
                    case Types.NUMERIC: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""NUMERIC""));
                        break;
                    }
                    case Types.DECIMAL: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DECIMAL""));
                        break;
                    }
                    case Types.BIT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""BIT""));
                        break;
                    }
                    case Types.TINYINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TINYINT""));
                        break;
                    }
                    case Types.SMALLINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""SMALLINT""));
                        break;
                    }
                    case Types.INTEGER: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""INTEGER""));
                        break;
                    }
                    case Types.BIGINT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""BIGINT""));
                        break;
                    }
                    case Types.REAL: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""REAL""));
                        break;
                    }
                    case Types.FLOAT: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""FLOAT""));
                        break;
                    }
                    case Types.DOUBLE: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DOUBLE""));
                        break;
                    }
                    case Types.DATE: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""DATE""));
                        break;
                    }
                    case Types.TIME: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TIME""));
                        break;
                    }
                    case Types.TIMESTAMP: {
                        paramElt.addAttribute(fac.createOMAttribute(""type"", nullNS, ""TIMESTAMP""));
                        break;
                    }
                    default: {
                        throw new SynapseException(""Unknown or unsupported JDBC type : "" +
                            param.getType());                            
                    }
                }

                stmntElt.addChild(paramElt);
            }

            // serialize any optional results of the statement
            for (Iterator it = statement.getResultsMap().keySet().iterator(); it.hasNext(); ) {

                String name = (String) it.next();
                String columnStr = (String) statement.getResultsMap().get(name);

                OMElement resultElt = fac.createOMElement(
                    AbstractDBMediatorFactory.RESULT_Q.getLocalPart(), synNS);

                resultElt.addAttribute(
                    fac.createOMAttribute(""name"", nullNS, name));
                resultElt.addAttribute(
                    fac.createOMAttribute(""column"", nullNS, columnStr));

                stmntElt.addChild(resultElt);
            }

            dbParent.addChild(stmntElt);
        }
    }
}
"
org/apache/synapse/endpoints/SALoadbalanceEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.axis2.clustering.ClusterManager;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.OperationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.algorithms.AlgorithmContext;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.DispatcherContext;

import java.util.ArrayList;
import java.util.List;

/**
 * SALoadbalanceEndpoint supports session affinity based load balancing. Each of this endpoint
 * maintains a list of dispatchers. These dispatchers will be updated for both request (for client
 * initiated sessions) and response (for server initiated sessions). Once updated, each dispatcher
 * will check if has already encountered that session. If not, it will update the
 * session -> endpoint map. To update sessions for response messages, all SALoadbalanceEndpoint
 * objects are kept in a global property. When a message passes through SALoadbalanceEndpoints, each
 * endpoint appends its ""Synapse unique ID"" to the operation context. Once the response for that
 * message arrives, response sender checks first endpoint of the endpoint sequence from the
 * operation context and get that endpoint from the above mentioned global property. Then it will
 * invoke updateSession(...) method of that endpoint. After that, each endpoint will call
 * updateSession(...) method of their appropriate child endpoint, so that all the sending endpoints
 * for the session will be updated.
 * <p/>
 * This endpoint gets the target endpoint first from the dispatch manager, which will ask all listed
 * dispatchers for a matching session. If a matching session is found it will just invoke the
 * send(...) method of that endpoint. If not it will find an endpoint using the load balancing
 * policy and send to that endpoint.
 */
public class SALoadbalanceEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(SALoadbalanceEndpoint.class);

    private static final String FIRST_MESSAGE_IN_SESSION = ""first_message_in_session"";
    public static final String ENDPOINT_LIST = ""endpointList"";
    public static final String ROOT_ENDPOINT = ""rootendpoint"";
    public static final String ENDPOINT_NAME_LIST = ""endpointNameList"";
    public static final String WARN_MESSAGE = ""In a clustering environment, the endpoint "" +
            ""name should be specified even for anonymous endpoints. Otherwise the clustering "" +
            ""would not function properly, if there are more than one anonymous endpoints."";

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
     * interface could be used.
     */
    private List<Endpoint> endpoints = null;

    /**
     * Algorithm used for selecting the next endpoint to direct the first request of sessions.
     * Default is RoundRobin.
     */
    private LoadbalanceAlgorithm algorithm = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Although any endpoint
     * can be the parent, only SALoadbalanceEndpoint should be used here. Use of any other endpoint
     * would invalidate the session.
     */
    private Endpoint parentEndpoint = null;

    /**
     * Dispatcher used for session affinity.
     */
    private Dispatcher dispatcher = null;

    /**
     * The dispatcher context, place holder for keeping any runtime states that are used when
     * finding endpoint for the session
     */
    private final DispatcherContext dispatcherContext = new DispatcherContext();

    /**
     * The endpoint context, place holder for keeping any runtime states related to the endpoint
     */
    private final EndpointContext endpointContext = new EndpointContext();

    /**
     * The algorithm context, place holder for keeping any runtime states related to the load
     * balance algorithm
     */
    private final AlgorithmContext algorithmContext = new AlgorithmContext();


    public void send(MessageContext synMessageContext) {

        if (log.isDebugEnabled()) {
            log.debug(""Start : Session Affinity Load-balance Endpoint "" + name);
        }

        boolean isClusteringEnable = false;
        // get Axis2 MessageContext and ConfigurationContext
        org.apache.axis2.context.MessageContext axisMC =
                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
        ConfigurationContext cc = axisMC.getConfigurationContext();

        //The check for clustering environment
        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
        if (clusterManager != null &&
                clusterManager.getContextManager() != null) {
            isClusteringEnable = true;
        }

        String endpointName = this.getName();
        if (endpointName == null) {
            if (isClusteringEnable) {
                log.warn(WARN_MESSAGE);
            }
            if (log.isDebugEnabled()) {
                log.debug(""Using the name for the anonymous endpoint as : '""
                        + SynapseConstants.ANONYMOUS_ENDPOINT + ""'"");
            }
            endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        if (isClusteringEnable) {

            // if this is a cluster environment, then set configuration context to endpoint context
            if (endpointContext.getConfigurationContext() == null) {

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the ConfigurationContext to "" +
                            ""the EndpointContext with the name "" + endpointName +
                            "" for replicating data on the cluster"");
                }
                endpointContext.setConfigurationContext(cc);
                endpointContext.setContextID(endpointName);
            }

            // if this is a cluster environment, then set configuration context to load balance
            //  algorithm context
            if (algorithmContext.getConfigurationContext() == null) {

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the ConfigurationContext to "" +
                            ""the AlgorithmContext with the name "" + endpointName +
                            "" for replicating data on the cluster"");
                }
                algorithmContext.setConfigurationContext(cc);
                algorithmContext.setContextID(endpointName);
            }

            // if this is a cluster environment, then set configuration context to session based
            // endpoint dispatcher
            if (dispatcherContext.getConfigurationContext() == null) {

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the ConfigurationContext to "" +
                            ""the DispatcherContext with the name "" + endpointName +
                            "" for replicating data on the cluster"");
                }
                dispatcherContext.setConfigurationContext(cc);
                dispatcherContext.setContextID(endpointName);

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the endpoints to the DispatcherContext : "" + endpoints);
                }
                dispatcherContext.setEndpoints(endpoints);
            }
        }

        // first check if this session is associated with a session. if so, get the endpoint
        // associated for that session.
        Endpoint endpoint = dispatcher.getEndpoint(synMessageContext, dispatcherContext);
        if (endpoint == null) {

            // there is no endpoint associated with this session. get a new endpoint using the
            // load balance policy.
            endpoint = algorithm.getNextEndpoint(synMessageContext, algorithmContext);

            // this is a start of a new session. so update session map.
            if (dispatcher.isServerInitiatedSession()) {

                if (log.isDebugEnabled()) {
                    log.debug(""Adding a new server initiated session for the current message"");
                }

                // add this endpoint to the endpoint sequence of operation context.
                Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synMessageContext;
                OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();

                if (isClusteringEnable) {
                    // If running on a cluster keep endpoint names, because it is heavy to
                    // replicate endpoint itself

                    Object o = opCtx.getPropertyNonReplicable(ENDPOINT_NAME_LIST);
                    List<String> epNameList;
                    if (o instanceof List) {
                        epNameList = (List<String>) o;
                        epNameList.add(endpointName);
                    } else {
                        // this is the first endpoint in the heirachy. so create the queue and
                        // insert this as the first element.
                        epNameList = new ArrayList<String>();
                        epNameList.add(endpointName);
                        opCtx.setNonReplicableProperty(ROOT_ENDPOINT, this);
                    }
                    
                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {

                        String name;
                        if (endpoint instanceof IndirectEndpoint) {
                            name = ((IndirectEndpoint) endpoint).getKey();
                        } else {
                            name = endpoint.getName();
                        }

                        if (name == null) {
                            log.warn(WARN_MESSAGE);
                            name = SynapseConstants.ANONYMOUS_ENDPOINT;
                        }
                        epNameList.add(name);
                    }

                    if (log.isDebugEnabled()) {
                        log.debug(""Operating on a cluster. Setting the endpoint name list to "" +
                                ""the OperationContext : "" + epNameList);
                    }
                    opCtx.setProperty(ENDPOINT_NAME_LIST, epNameList);

                } else {
                    
                    Object o = opCtx.getProperty(ENDPOINT_LIST);
                    List<Endpoint> endpointList;
                    if (o instanceof List) {
                        endpointList = (List<Endpoint>) o;
                        endpointList.add(this);
                    } else {
                        // this is the first endpoint in the heirachy. so create the queue and
                        // insert this as the first element.
                        endpointList = new ArrayList<Endpoint>();
                        endpointList.add(this);
                        opCtx.setProperty(ENDPOINT_LIST, endpointList);
                    }
                    
                    // if the next endpoint is not a session affinity one, endpoint sequence ends
                    // here. but we have to add the next endpoint to the list.
                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
                        endpointList.add(endpoint);
                    }
                }

            } else {
                dispatcher.updateSession(synMessageContext, dispatcherContext, endpoint);
            }

            // this is the first request. so an endpoint has not been bound to this session and we
            // are free to failover if the currently selected endpoint is not working. but for
            // failover to work, we have to build the soap envelope.
            synMessageContext.getEnvelope().build();

            // we should also indicate that this is the first message in the session. so that
            // onFault(...) method can resend only the failed attempts for the first message.
            synMessageContext.setProperty(FIRST_MESSAGE_IN_SESSION, Boolean.TRUE);
        }

        if (endpoint != null) {

            // endpoints given by session dispatchers may not be active. therefore, we have check
            // it here.
            if (endpoint.isActive(synMessageContext)) {
                if (log.isDebugEnabled()) {
                    log.debug(""Using the endpoint on the session with ""
                            + ((endpoint instanceof IndirectEndpoint) ? ""key : ""
                            + ((IndirectEndpoint) endpoint).getKey() : ""name : ""
                            + endpoint.getName()) + "" for sending the message"");
                }
                endpoint.send(synMessageContext);
            } else {
                informFailure(synMessageContext);
            }

        } else {

            // all child endpoints have failed. so mark this also as failed.
            if (log.isDebugEnabled()) {
                log.debug(""Marking the Endpoint as failed, "" +
                        ""because all child endpoints has been failed"");
            }
            setActive(false, synMessageContext);
            informFailure(synMessageContext);
        }
    }

    /**
     * This will be called for the response of the first message of each server initiated session.
     *
     * @param responseMsgCtx
     * @param endpointList
     * @param isClusteringEnable
     */
    public void updateSession(MessageContext responseMsgCtx, List endpointList,
                              boolean isClusteringEnable) {

        Endpoint endpoint = null;

        if (isClusteringEnable) {
            // if this is a clustering env. only keep endpoint names, because, it is heavy to
            // replicate endpoint itself
            String epNameObj = (String) endpointList.remove(0);
            for (Endpoint ep : endpoints) {
                if (ep != null) {

                    String name;
                    if (ep instanceof IndirectEndpoint) {
                        name = ((IndirectEndpoint) ep).getKey();
                    } else {
                        name = ep.getName();
                    }

                    if (name != null && name.equals(epNameObj)) {
                        endpoint = ep;
                        break;
                    }
                }
            }

        } else {
            endpoint = (Endpoint) endpointList.remove(0);
        }

        if (endpoint != null) {

            dispatcher.updateSession(responseMsgCtx, dispatcherContext, endpoint);
            if (endpoint instanceof SALoadbalanceEndpoint) {
                ((SALoadbalanceEndpoint) endpoint).updateSession(
                        responseMsgCtx, endpointList, isClusteringEnable);
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public LoadbalanceAlgorithm getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
        this.algorithm = algorithm;
    }

    /**
     * This is active in below conditions:
     * If a session is not started AND at least one child endpoint is active.
     * If a session is started AND the binding endpoint is active.
     * <p/>
     * This is not active for all other conditions.
     *
     * @param synMessageContext MessageContext of the current message. This is used to determine the
     *                          session.
     * @return true is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        // todo: implement above
        boolean active;
        Endpoint endpoint = dispatcher.getEndpoint(synMessageContext, dispatcherContext);
        if (endpoint == null) { // If a session is not started
            active = endpointContext.isActive();
            if (!active && endpoints != null) {
                for (Endpoint ep : endpoints) {
                    if (ep != null) {
                        active = ep.isActive(synMessageContext);
                        if (active) {    //AND at least one child endpoint is active
                            endpointContext.setActive(active);
                            // don't break the loop though we found one active endpoint. calling isActive()
                            // on all child endpoints will update their active state. so this is a good
                            // time to do that.
                        }
                    }
                }
            }
        } else {
            //If a session is started AND the binding endpoint is active.
            active = endpoint.isActive(synMessageContext);
            if (active) {
                endpointContext.setActive(active);
            }
        }

        if (log.isDebugEnabled()) {
            log.debug(""SALoadbalanceEndpoint with name '"" + getName() + ""' is in ""
                    + (active ? ""active"" : ""inactive"") + "" state"");
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        endpointContext.setActive(active);
    }

    public List<Endpoint> getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List<Endpoint> endpoints) {
        this.endpoints = endpoints;
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public Dispatcher getDispatcher() {
        return dispatcher;
    }

    public void setDispatcher(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    /**
     * It is logically incorrect to failover a session affinity endpoint after the session has started.
     * If we redirect a message belonging to a particular session, new endpoint is not aware of the
     * session. So we can't handle anything more at the endpoint level. Therefore, this method just
     * deactivate the failed endpoint and give the fault to the next fault handler.
     * <p/>
     * But if the session has not started (i.e. first message), the message will be resend by binding
     * it to a different endpoint.
     *
     * @param endpoint          Failed endpoint.
     * @param synMessageContext MessageContext of the failed message.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        Object o = synMessageContext.getProperty(FIRST_MESSAGE_IN_SESSION);

        if (o != null && Boolean.TRUE.equals(o)) {

            // this is the first message. so unbind the sesion with failed endpoint and start
            // new one by resending.
            dispatcher.unbind(synMessageContext, dispatcherContext);
            send(synMessageContext);

        } else {

            // session has already started. we can't failover.
            informFailure(synMessageContext);
        }
    }

    private void informFailure(MessageContext synMessageContext) {

        log.warn(""Failed to send using the selected endpoint, becasue it is inactive"");
        
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);
        } else {
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

}
"
org/apache/synapse/config/xml/HeaderMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.HeaderMediator;

import javax.xml.namespace.QName;

/**
 * Serializer for {@link HeaderMediator} instances.
 * 
 * @see HeaderMediatorFactory
 */
public class HeaderMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof HeaderMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        HeaderMediator mediator = (HeaderMediator) m;
        OMElement header = fac.createOMElement(""header"", synNS);
        saveTracingState(header,mediator);

        QName qName = mediator.getQName();
        if (qName != null) {
            if (qName.getNamespaceURI() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS,
                    (qName.getPrefix() != null && !"""".equals(qName.getPrefix())
                        ? qName.getPrefix() + "":"" : """") + 
                    qName.getLocalPart()));
                header.declareNamespace(qName.getNamespaceURI(), qName.getPrefix());
            } else {
                header.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, qName.getLocalPart()));
            }
        }

        if (mediator.getAction() == HeaderMediator.ACTION_REMOVE) {
            header.addAttribute(fac.createOMAttribute(
                ""action"", nullNS, ""remove""));
        } else {
            if (mediator.getValue() != null) {
                header.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

            } else if (mediator.getExpression() != null) {

                SynapseXPathSerializer.serializeXPath(
                    mediator.getExpression(), header, ""expression"");

            } else {
                handleException(""Value or expression required for a set header mediator"");
            }
        }

        if (parent != null) {
            parent.addChild(header);
        }
        return header;
    }

    public String getMediatorClassName() {
        return HeaderMediator.class.getName();
    }
}
"
org/apache/synapse/core/SynapseEnvironment.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.util.TemporaryData;

import java.util.concurrent.ExecutorService;

/**
 * The SynapseEnvironment allows access into the the host SOAP engine. It allows
 * the sending of messages, classloader access etc.
 */
public interface SynapseEnvironment {

    /**
     * This method injects a new message into the Synapse engine. This is used by
     * the underlying SOAP engine to inject messages into Synapse for mediation.
     * e.g. The SynapseMessageReceiver used by Axis2 invokes this to inject new messages
     *
     * @param smc - Synapse MessageContext to be injected
     * @return boolean true if the message processing should be continued
     *  and false if it should be aborted
     */
    public boolean injectMessage(MessageContext smc);

    /**
     * This method injects a new message into the Synapse engine for the mediation
     * by the specified sequence. This is used by custom mediation tasks like splitting message
     * in EIP mediations. This method will do the mediation asynchronously using a separate
     * thread from the environment thread pool
     *
     * @param smc - Synapse message context to be injected
     * @param seq - Sequence to be used for mediation
     */
    public void injectAsync(MessageContext smc, SequenceMediator seq);

    /**
     * This method allows a message to be sent through the underlying SOAP engine. This will
     * send request messages on (forward), and send the response messages back to the client
     *
     * @param endpoint  - Endpoint to be used for sending
     * @param smc       - Synapse MessageContext to be sent
     */
    public void send(EndpointDefinition endpoint, MessageContext smc);

    /**
     * Creates a new Synapse <code>MessageContext</code> instance.
     *
     * @return a MessageContext
     */
    public MessageContext createMessageContext();

    /**
     * Creates a new <code>TemporaryData</code> instance for the temp storage requirements
     *
     * @return a TemporaryData created from the parameters provided in the synapse.properties
     */
    public TemporaryData createTemporaryData();

    /**
     * This method returns the StatisticsCollector.
     *
     * @return Returns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector();

    /**
     * To set the StatisticsCollector to the environment
     *
     * @param statisticsCollector - StatisticsCollector to be set
     */
    public void setStatisticsCollector(StatisticsCollector statisticsCollector);

    /**
     * This is used by anyone who needs access to a SynapseThreadPool.
     * It offers the ability to start work.
     * 
     * @return Returns the ExecutorService
     */
     public ExecutorService getExecutorService();

    /**
     * Has the Synapse Environment properly initialized?
     * @return true if the environment is ready for processing
     */
    public boolean isInitialized();

    /**
     * Set the environment as ready for message processing
     * @param state true means ready for processing
     */
    public void setInitialized(boolean state);
}
"
org/apache/synapse/mediators/transform/XSLTMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axiom.om.impl.dom.DOOMAbstractFactory;
import org.apache.axiom.om.impl.dom.jaxp.DocumentBuilderFactoryImpl;
import org.apache.axiom.om.util.ElementHelper;
import org.apache.axiom.om.util.StAXUtils;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.impl.builder.StAXSOAPModelBuilder;
import org.apache.axis2.AxisFault;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.apache.synapse.util.AXIOMUtils;
import org.apache.synapse.util.TemporaryData;
import org.apache.synapse.util.TextFileDataSource;
import org.jaxen.JaxenException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The XSLT mediator performs an XSLT transformation requested, using
 * the current message. The source attribute (if available) specifies the source element
 * on which the transformation would be applied. It will default to the first child of
 * the messages' SOAP body, if it is omitted.
 *
 * Additional properties passed into this mediator would become parameters for XSLT.
 * Additional features passed into this mediator would become features except for
 * ""http://ws.apache.org/ns/synapse/transform/feature/dom"" for the Transformer Factory, which
 * is used to decide between using DOM and Streams during the transformation process. By default
 * this is turned on as an optimization, but should be set to false if issues are detected
 *
 *  Note: Set the TransformerFactory system property to generate and use translets
 *  -Djavax.xml.transform.TransformerFactory=org.apache.xalan.xsltc.trax.TransformerFactoryImpl
 * 
 */
public class XSLTMediator extends AbstractMediator {

    /**
     * The feature for which deciding swiching between DOM and Stream during the
     * transformation process
     */
    public static final String USE_DOM_SOURCE_AND_RESULTS =
        ""http://ws.apache.org/ns/synapse/transform/feature/dom"";
    /**
     * The resource key/name which refers to the XSLT to be used for the transformation
     */
    private String xsltKey = null;

    /** Variable to hold source XPath string to use for debugging */
    private String sourceXPathString = null;

    /**
     * The (optional) XPath expression which yields the source element for a transformation
     */
    private SynapseXPath source = null;

    /**
     * The name of the message context property to store the transformation result  
     */
    private String targetPropertyName = null;

    /**
     * Any parameters which should be passed into the XSLT transformation
     */
    private List<MediatorProperty> properties = new ArrayList<MediatorProperty>();

    /**
     * Any features which should be set to the TransformerFactory by explicitly
     */
    private List<MediatorProperty> explicitFeatures = new ArrayList<MediatorProperty>();

    /**
     * The Template instance used to create a Transformer object. This is  thread-safe
     *
     * @see javax.xml.transform.Templates
     */
    private Templates cachedTemplates = null;

    /**
     * The TransformerFactory instance which use to create Templates...This is not thread-safe.
     * @see javax.xml.transform.TransformerFactory
     */
    private final TransformerFactory transFact = TransformerFactory.newInstance();

    /**
     * Lock used to ensure thread-safe creation and use of the above Transformer
     */
    private final Object transformerLock = new Object();

    /**
     *  Is it need to use DOMSource and DOMResult?
     */
    private boolean useDOMSourceAndResults = false;

    /**
     * Default XPath for the selection of the element for the evaluation of the XSLT over
     */
    public static final String DEFAULT_XPATH = ""s11:Body/child::*[position()=1] | "" +
            ""s12:Body/child::*[position()=1]"";

    public XSLTMediator() {
        // create the default XPath
        try {
            this.source = new SynapseXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            String msg = ""Error creating default source XPath expression : "" + DEFAULT_XPATH;
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * Transforms this message (or its element specified as the source) using the
     * given XSLT transformation
     *
     * @param synCtx the current message where the transformation will apply
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : XSLT mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            performXSLT(synCtx, traceOrDebugOn, traceOn);

        } catch (Exception e) {
            handleException(""Unable to perform XSLT transformation using : "" + xsltKey +
                "" against source XPath : "" +
                (sourceXPathString == null ? DEFAULT_XPATH : "" source XPath : "" +
                 sourceXPathString), e, synCtx);

        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : XSLT mediator"");
        }

        return true;
    }

    /**
     * Perform actual XSLT transformation
     * @param synCtx current message
     * @param traceOrDebugOn is trace or debug on?
     * @param traceOn is trace on?
     */
    private void performXSLT(MessageContext synCtx, final boolean traceOrDebugOn,
        final boolean traceOn) {

        boolean reCreate = false;
        OMNode sourceNode = getTransformSource(synCtx);
        TemporaryData tempTargetData = null;
        OutputStream osForTarget;
        boolean isSoapEnvelope = (sourceNode == synCtx.getEnvelope());
        boolean isSoapBody = (sourceNode == synCtx.getEnvelope().getBody());

        if (traceOrDebugOn) {
            trace.trace(""Transformation source : "" + sourceNode.toString());
        }

        Source transformSrc;
        Result transformTgt = null;

        if (useDOMSourceAndResults) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Using a DOMSource for transformation"");
            }

            // for fast transformations create a DOMSource - ** may not work always though **
            transformSrc = new DOMSource(
                ((Element) ElementHelper.importOMElement((OMElement) sourceNode,
                DOOMAbstractFactory.getOMFactory())).getOwnerDocument());
            DocumentBuilderFactoryImpl.setDOOMRequired(true);

            try {
                transformTgt = new DOMResult(
                    DocumentBuilderFactoryImpl.newInstance().newDocumentBuilder().newDocument());
            } catch (ParserConfigurationException e) {
                handleException(""Error creating a DOMResult for the transformation,"" +
                    "" Consider setting optimization feature : "" + USE_DOM_SOURCE_AND_RESULTS +
                    "" off"", e, synCtx);
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Using byte array serialization for transformation"");
            }

            transformSrc = AXIOMUtils.asSource(sourceNode);
            
            tempTargetData = synCtx.getEnvironment().createTemporaryData();
            osForTarget = tempTargetData.getOutputStream();
            transformTgt = new StreamResult(osForTarget);
        }

        if (transformTgt == null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Was unable to get a javax.xml.transform.Result created"");
            }
            return;
        }

        // build transformer - if necessary
        Entry dp = synCtx.getConfiguration().getEntryDefinition(xsltKey);

        // if the xsltKey refers to a dynamic resource
        if (dp != null && dp.isDynamic()) {
            if (!dp.isCached() || dp.isExpired()) {
                reCreate = true;
            }
        }

        synchronized (transformerLock) {
            if (reCreate || cachedTemplates == null) {
                try {
                    cachedTemplates = transFact.newTemplates(
                        SynapseConfigUtils.getStreamSource(synCtx.getEntry(xsltKey)));
                    if (cachedTemplates == null) {
                        handleException(""Error compiling the XSLT with key : "" + xsltKey, synCtx);
                    }
                } catch (Exception e) {
                    handleException(""Error creating XSLT transformer using : ""
                        + xsltKey, e, synCtx);
                }
            }
        }

        try {
            // perform transformation
            Transformer transformer = cachedTemplates.newTransformer();
            if (!properties.isEmpty()) {
                // set the parameters which will pass to the Transformation
                for (MediatorProperty prop : properties) {
                    if (prop != null) {
                        if (prop.getValue() != null) {
                            transformer.setParameter(prop.getName(), prop.getValue());
                        } else {
                            transformer.setParameter(prop.getName(),
                                    prop.getExpression().stringValueOf(synCtx));
                        }
                    }
                }
            }

            transformer.setErrorListener(new ErrorListener() {

                public void warning(TransformerException e) throws TransformerException {

                    if (traceOrDebugOn) {
                        traceOrDebugWarn(
                                traceOn, ""Warning encountered during transformation : "" + e);
                    }
                }
                
                public void error(TransformerException e) throws TransformerException {
                    log.error(""Error occured in XSLT transformation : "" + e);
                    throw e;
                }
                
                public void fatalError(TransformerException e) throws TransformerException {
                    log.error(""Fatal error occured in the XSLT transformation : "" + e);
                    throw e;
                }
            });
            
            transformer.transform(transformSrc, transformTgt);

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Transformation completed - processing result"");
            }

            // get the result OMElement
            OMElement result = null;
            if (transformTgt instanceof DOMResult) {

                Node node = ((DOMResult) transformTgt).getNode();
                if (node == null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, (""Transformation result (DOMResult) was null""));
                    }
                    return;
                }

                Node resultNode = node.getFirstChild();
                if (resultNode == null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, (""Transformation result (DOMResult) was empty""));
                    }
                    return;
                }

                result = ElementHelper.importOMElement(
                    (OMElement) resultNode, OMAbstractFactory.getOMFactory());

            } else {

                String outputMethod = transformer.getOutputProperty(OutputKeys.METHOD);
                String encoding = transformer.getOutputProperty(OutputKeys.ENCODING);

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""output method: "" + outputMethod
                            + ""; encoding: "" + encoding);
                }
                
                if (""text"".equals(outputMethod)) {
                    result = handleNonXMLResult(tempTargetData, Charset.forName(encoding),
                                                traceOrDebugOn, traceOn);
                } else {
                    try {
                        XMLStreamReader reader = StAXUtils.createXMLStreamReader(
                            tempTargetData.getInputStream());
                        if (isSoapEnvelope) {
                            result = new StAXSOAPModelBuilder(reader).getSOAPEnvelope();
                        } else {
                            result = new StAXOMBuilder(reader).getDocumentElement();
                        }                        
    
                    } catch (XMLStreamException e) {
                        handleException(
                            ""Error building result element from XSLT transformation"", e, synCtx);
    
                    } catch (IOException e) {
                        handleException(""Error reading temporary data"", e, synCtx);
                    }
                }
            }

            if (result == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Transformation result was null"");
                }
                return;
            } else {
                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Transformation result : "" + result.toString());
                }
            }

            if (targetPropertyName != null) {
                // add result XML as a message context property to the message
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Adding result as message context property : "" +
                        targetPropertyName);
                }
                synCtx.setProperty(targetPropertyName, result);
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Replace "" +
                        (isSoapEnvelope ? ""SOAP envelope"" : isSoapBody ? ""SOAP body"" : ""node"")
                        + "" with result"");
                }

                if (isSoapEnvelope) {
                    try {
                        synCtx.setEnvelope((SOAPEnvelope) result);
                    } catch (AxisFault ex) {
                        handleException(""Unable to replace SOAP envelope with result"", ex, synCtx);
                    }

                } else if (isSoapBody) {
                    for (Iterator iter = synCtx.getEnvelope().getBody().getChildElements();
                        iter.hasNext(); ) {
                        OMElement child = (OMElement) iter.next();
                        child.detach();
                    }

                    for (Iterator iter = result.getChildElements(); iter.hasNext(); ) {
                        OMElement child = (OMElement) iter.next();
                        synCtx.getEnvelope().getBody().addChild(child);
                    }

                } else {
                    sourceNode.insertSiblingAfter(result);
                    sourceNode.detach();
                }
            }

        } catch (TransformerException e) {
            handleException(""Error performing XSLT transformation using : "" + xsltKey, e, synCtx);
        }
    }

    /**
     * Return the OMNode to be used for the transformation. If a source XPath is not specified,
     * this will default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which the transformation should be performed
     */
    private OMNode getTransformSource(MessageContext synCtx) {
                                
        try {
            Object o = source.evaluate(synCtx);
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                        + source + "" did not result in an OMNode"", synCtx);
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression : "" + source, e, synCtx);
        }
        return null;
    }

    public SynapseXPath getSource() {
        return source;
    }

    public void setSource(SynapseXPath source) {
        this.source = source;
    }

    public String getXsltKey() {
        return xsltKey;
    }

    public void setXsltKey(String xsltKey) {
        this.xsltKey = xsltKey;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }
    
    /**
     * to add a feature which need to set to the TransformerFactory
     * @param  featureName The name of the feature
     * @param isFeatureEnable should this feature enable?
     */
    
    public void addFeature(String featureName, boolean isFeatureEnable) {
        try {
            MediatorProperty mp = new MediatorProperty();
            mp.setName(featureName);
            if (isFeatureEnable) {
                mp.setValue(""true"");
            } else {
                mp.setValue(""false"");
            }
            explicitFeatures.add(mp);
            if (USE_DOM_SOURCE_AND_RESULTS.equals(featureName)) {
                useDOMSourceAndResults = isFeatureEnable;
            } else {
                transFact.setFeature(featureName, isFeatureEnable);
            }
        } catch (TransformerConfigurationException e) {
            String msg = ""Error occured when setting features to the TransformerFactory"";
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * If the transformation results in a non-XML payload, use standard wrapper elements
     * to wrap the text payload so that other mediators could still process the result
     * @param tempData the encoded text payload
     * @param charset the encoding of the payload
     * @param traceOrDebugOn is tracing on debug logging on?
     * @param traceOn is tracing on?
     * @return an OMElement wrapping the text payload
     */
    private OMElement handleNonXMLResult(TemporaryData tempData, Charset charset,
        boolean traceOrDebugOn, boolean traceOn) {

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Processing non SOAP/XML (text) transformation result"");
        }
        if (traceOn && trace.isTraceEnabled()) {
            trace.trace(""Wrapping text transformation result"");
        }

        return TextFileDataSource.createOMSourcedElement(tempData, charset);
    }

    /**
     *
     * @return Returns the features explicitly  set to the TransformerFactory through this mediator
     */
    public List<MediatorProperty> getFeatures(){
        return explicitFeatures;
    }

    public void addAllProperties(List<MediatorProperty> list) {
        properties.addAll(list);
    }

    public List<MediatorProperty> getProperties() {
        return properties;
    }

    public void setSourceXPathString(String sourceXPathString) {
        this.sourceXPathString = sourceXPathString;
    }

    public String getTargetPropertyName() {
        return targetPropertyName;
    }

    public void setTargetPropertyName(String targetPropertyName) {
        this.targetPropertyName = targetPropertyName;
    }
    
}

	
"
org/apache/synapse/registry/url/SimpleURLRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry.url;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMException;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.registry.AbstractRegistry;
import org.apache.synapse.registry.Registry;
import org.apache.synapse.registry.RegistryEntry;
import org.apache.synapse.registry.RegistryEntryImpl;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.Properties;

/**
 * A Simple HTTP GET based registry which will work with a Web Server / WebDAV
 * <p/>
 * This saves the root server URL, and appends the a given key to construct the
 * full URL to locate resources
 */
public class SimpleURLRegistry extends AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(SimpleURLRegistry.class);

    private static final int MAX_KEYS = 200;
    private String root = """";

    public OMNode lookup(String key) {

        log.debug(""==> Repository fetch of resource with key : "" + key);

        URL url = SynapseConfigUtils.getURLFromPath(root + key);
        if (url == null) {
            return null;
        }

        BufferedInputStream inputStream;
        try {
            URLConnection connection = url.openConnection();
            connection.connect();
            inputStream = new BufferedInputStream(connection.getInputStream());
        } catch (IOException e) {
            return null;
        }

        OMNode result = null;

        if (inputStream != null) {

            try {

                XMLStreamReader parser = XMLInputFactory.newInstance().
                        createXMLStreamReader(inputStream);
                StAXOMBuilder builder = new StAXOMBuilder(parser);
                result = builder.getDocumentElement();

            } catch (OMException ignored) {

                if (log.isDebugEnabled()) {
                    log.debug(""The resource at the provided URL isn't "" +
                            ""well-formed XML,So,takes it as a text"");
                }

                try {
                    inputStream.close();
                } catch (IOException e) {
                    log.error(""Error in closing the input stream. "", e);
                }
                result = SynapseConfigUtils.readNonXML(url);

            } catch (XMLStreamException ignored) {

                if (log.isDebugEnabled()) {
                    log.debug(""The resource at the provided URL isn't "" +
                            ""well-formed XML,So,takes it as a text"");
                }

                try {
                    inputStream.close();
                } catch (IOException e) {
                    log.error(""Error in closing the input stream. "", e);
                }
                result = SynapseConfigUtils.readNonXML(url);

            } finally {

                try {
                    inputStream.close();
                } catch (IOException e) {
                    log.error(""Error in closing the input stream."", e);
                }

            }

        }
        return result;
    }

    public RegistryEntry getRegistryEntry(String key) {
        if (log.isDebugEnabled()) {
            log.debug(""Perform RegistryEntry lookup for key : "" + key);
        }
        try {
            URL url = SynapseConfigUtils.getURLFromPath(root + key);
            if (url == null) {
                return null;
            }
            URLConnection urlc = url.openConnection();
            urlc.setReadTimeout(30000);
            urlc.setRequestProperty(""Connection"", ""Close"");

            RegistryEntryImpl wre = new RegistryEntryImpl();
            wre.setKey(key);
            wre.setName(url.getFile());
            wre.setType(new URI(urlc.getContentType()));
            wre.setDescription(""Resource at : "" + url.toString());
            wre.setLastModified(urlc.getLastModified());
            wre.setVersion(urlc.getLastModified());
            if (urlc.getExpiration() > 0) {
                wre.setCachableDuration(
                        urlc.getExpiration() - System.currentTimeMillis());
            } else {
                wre.setCachableDuration(getCachableDuration(key));
            }
            return wre;

        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference "" + root + key, e);
        } catch (IOException e) {
            handleException(""IO Error reading from URL "" + root + key, e);
        } catch (URISyntaxException e) {
            handleException(""URI Syntax error reading from URL "" + root + key, e);
        }
        return null;
    }

    public void init(Properties properties) {
        super.init(properties);
        String value = properties.getProperty(""root"");
        if (value != null) {

            // if the root is folder, it should always end with '/'
            // therefore, property keys do not have to begin with '/', which could be misleading
            try {
                URL url = new URL(value);
                if (url.getProtocol().equals(""file"")) {
                    if (!value.endsWith(""/"")) {
                        value = value + ""/"";
                    }
                }
            } catch (MalformedURLException e) {
                // don't do any thing if this is not a valid URL
            }
            root = value;
        } else {
            handleException("""");
        }

    }


    public void delete(String path) {
        //TODO
    }

    public void newResource(String path, boolean isDirectory) {
        //TODO
    }

    public void updateResource(String path, Object value) {
        //TODO
    }

    public void updateRegistryEntry(RegistryEntry entry) {
        //TODO
    }


    public long getCachableDuration(String rootPath) {
        String cachableDuration = (String) properties.get(""cachableDuration"");
        return cachableDuration == null ? 1500 : Long.parseLong(cachableDuration);
    }

    public RegistryEntry[] getChildren(RegistryEntry entry) {
        URL url;
        if (entry == null) {
            RegistryEntryImpl entryImpl = new RegistryEntryImpl();
            entryImpl.setKey("""");
            entry = entryImpl;
        }
        url = SynapseConfigUtils.getURLFromPath(root + entry.getKey());
        if (url == null) {
            return null;
        }
        if (url.getProtocol().equals(""file"")) {

            File file = new File(url.getFile());
            if (!file.isDirectory()) {
                return null;
            }
            InputStream inStream = null;
            try {
                inStream = (InputStream) url.getContent();

                BufferedReader reader = new BufferedReader(new InputStreamReader(inStream));
                ArrayList entryList = new ArrayList();
                String key = """";
                while ((key = reader.readLine()) != null) {
                    RegistryEntryImpl registryEntryImpl = new RegistryEntryImpl();
                    if (entry.getKey().equals("""")) {
                        registryEntryImpl.setKey(key);
                    } else {
                        if (entry.getKey().endsWith(""/"")) {
                            registryEntryImpl.setKey(entry.getKey() + key);
                        } else {
                            registryEntryImpl.setKey(entry.getKey() + ""/"" + key);
                        }
                    }

                    entryList.add(registryEntryImpl);
                }

                RegistryEntry[] entries = new RegistryEntry[entryList.size()];
                for (int i = 0; i < entryList.size(); i++) {
                    entries[i] = (RegistryEntry) entryList.get(i);
                }
                return entries;

            } catch (Exception e) {
                throw new SynapseException(""Error in reading the URL."");
            }

        } else {
            throw new SynapseException(""Invalid protocol."");
        }
    }

    public RegistryEntry[] getDescendants(RegistryEntry entry) {

        ArrayList list = new ArrayList();
        RegistryEntry[] entries = getChildren(entry);
        if (entries != null) {
            for (int i = 0; i < entries.length; i++) {

                if (list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        }

        RegistryEntry[] descendants = new RegistryEntry[list.size()];
        for (int i = 0; i < list.size(); i++) {
            descendants[i] = (RegistryEntry) list.get(i);
        }

        return descendants;
    }

    private void fillDescendants(RegistryEntry parent, ArrayList list) {

        RegistryEntry[] entries = getChildren(parent);
        if (entries != null) {
            for (int i = 0; i < entries.length; i++) {

                if (list.size() > MAX_KEYS) {
                    break;
                }

                fillDescendants(entries[i], list);
            }
        } else {
            list.add(parent);
        }
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/ClassMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.ClassMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * <pre>
 * &lt;class name=""class-name""&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/class&gt;
 * </pre>
 */
public class ClassMediatorSerializer extends AbstractMediatorSerializer  {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ClassMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        ClassMediator mediator = (ClassMediator) m;
        OMElement clazz = fac.createOMElement(""class"", synNS);
        saveTracingState(clazz, mediator);

        if (mediator.getMediator() != null && mediator.getMediator().getClass().getName() != null) {
            clazz.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, mediator.getMediator().getClass().getName()));
        } else {
            handleException(""Invalid class mediator. The class name is required"");
        }

        Iterator itr = mediator.getProperties().keySet().iterator();
        while(itr.hasNext()) {
            String propName = (String) itr.next();
            Object o = mediator.getProperties().get(propName);
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));

            if (o instanceof String) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, (String) o));
            } else {
                prop.addChild((OMNode) o);
            }
            clazz.addChild(prop);
        }

        if (parent != null) {
            parent.addChild(clazz);
        }
        return clazz;
    }

    public String getMediatorClassName() {
        return ClassMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/builtin/RMSequenceMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;
import org.wso2.mercury.util.MercuryClientConstants;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class RMSequenceMediator extends AbstractMediator {

    private SynapseXPath correlation = null;
    private SynapseXPath lastMessage = null;
    private Boolean single = null;
    private String version = null;

    private static final String WSRM_SpecVersion_1_0 = ""Spec_2005_02"";
    private static final String WSRM_SpecVersion_1_1 = ""Spec_2007_02"";
    // set sequence expiry time to 5 minutes
    private static final long SEQUENCE_EXPIRY_TIME = 300000;
    private static Map sequenceMap = Collections.synchronizedMap(new HashMap());

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : RMSequence mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (!(synCtx instanceof Axis2MessageContext)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Only axis2 message contexts are supported"");
            }

        } else {
            Axis2MessageContext axis2MessageCtx = (Axis2MessageContext) synCtx;
            org.apache.axis2.context.MessageContext orgMessageCtx =
                axis2MessageCtx.getAxis2MessageContext();

            cleanupSequenceMap();

            String version = getVersionValue();
            orgMessageCtx.getOptions().setProperty(
                SynapseConstants.MERCURY_SPEC_VERSION, version);

            if (isSingle()) {
                String sequenceID = UUIDGenerator.getUUID();
                String offeredSeqID = UUIDGenerator.getUUID();

                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.MERCURY_SEQUENCE_KEY, sequenceID);
                orgMessageCtx.getOptions().setProperty(
                    MercuryClientConstants.SEQUENCE_OFFER, offeredSeqID);
                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.MERCURY_LAST_MESSAGE, ""true"");

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Using WS-RM version "" + version +
                        "" and a single message sequence : "" + sequenceID +
                        "" and offering sequence : "" + offeredSeqID);
                }

            } else {

                String correlationValue = getCorrelationValue(synCtx);
                boolean lastMessage = isLastMessage(synCtx);
                String offeredSeqID = null;

                if (!sequenceMap.containsKey(correlationValue)) {
                    offeredSeqID = UUIDGenerator.getUUID();
                    orgMessageCtx.getOptions().setProperty(
                        MercuryClientConstants.SEQUENCE_OFFER, offeredSeqID);
                }

                String sequenceID = retrieveSequenceID(correlationValue);
                orgMessageCtx.getOptions().setProperty(
                    SynapseConstants.MERCURY_SEQUENCE_KEY, sequenceID);

                if (lastMessage) {
                    orgMessageCtx.getOptions().setProperty(
                        SynapseConstants.MERCURY_LAST_MESSAGE, ""true"");
                    sequenceMap.remove(correlationValue);
                }

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Correlation value : "" + correlationValue +
                        "" last message = "" + lastMessage + "" using sequence : "" + sequenceID +
                        (offeredSeqID != null ? "" offering sequence : "" + offeredSeqID : """"));
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : RMSequence mediator"");
        }
        return true;
    }

    private String retrieveSequenceID(String correlationValue) {
        String sequenceID = null;
        if (!sequenceMap.containsKey(correlationValue)) {
            sequenceID = UUIDGenerator.getUUID();
            if (log.isDebugEnabled()) {
                log.debug(""setting sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
            Entry sequenceEntry = new Entry();
            sequenceEntry.setValue(sequenceID);
            sequenceEntry.setExpiryTime(System.currentTimeMillis() + SEQUENCE_EXPIRY_TIME);
            sequenceMap.put(correlationValue, sequenceEntry);
        } else {
            sequenceID = (String) ((Entry) sequenceMap.get(correlationValue)).getValue();
            if (log.isDebugEnabled()) {
                log.debug(""got sequenceID "" + sequenceID + "" for correlation "" + correlationValue);
            }
        }
        return sequenceID;
    }

    private String getCorrelationValue(MessageContext smc) {
        OMElement node = null;
        try {
            node = (OMElement) getCorrelation().selectSingleNode(smc);

            if (node != null) {
                return node.getText();
            } else {
                handleException(""XPath expression : "" + getCorrelation() +
                    "" did not return any node"", smc);
            }

        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression to determine correlation : "" +
                getCorrelation(), e, smc);
        }
        return null; // never called
    }

    private String getVersionValue() {
        if (XMLConfigConstants.SEQUENCE_VERSION_1_1.equals(getVersion())) {
            return WSRM_SpecVersion_1_1;
        } else {
            return WSRM_SpecVersion_1_0;
        }
    }

    private boolean isLastMessage(MessageContext smc) {
        if (getLastMessage() == null) {
            return false;
        } else {
            try {
                return getLastMessage().booleanValueOf(smc);
            } catch (JaxenException e) {
                handleException(""Error evaluating XPath expression to determine if last message : "" +
                    getLastMessage(), e, smc);
            }
            return false;
        }
    }

    private synchronized void cleanupSequenceMap() {
        Iterator itKey = sequenceMap.keySet().iterator();
        while (itKey.hasNext()) {
            Object key = itKey.next();
            Entry sequenceEntry = (Entry) sequenceMap.get(key);
            if (sequenceEntry.isExpired()) {
                sequenceMap.remove(key);
            }
        }
    }

    public boolean isSingle() {
        if (getSingle() != null && getSingle().booleanValue()) {
            return true;

        } else {
            return false;
        }
    }

    public SynapseXPath getCorrelation() {
        return correlation;
    }

    public void setCorrelation(SynapseXPath correlation) {
        this.correlation = correlation;
    }

    public SynapseXPath getLastMessage() {
        return lastMessage;
    }

    public void setLastMessage(SynapseXPath lastMessage) {
        this.lastMessage = lastMessage;
    }

    public Boolean getSingle() {
        return single;
    }

    public void setSingle(Boolean single) {
        this.single = single;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }
}
"
org/apache/synapse/config/xml/CalloutMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CalloutMediator;

/**
 * <pre>
 * &lt;callout serviceURL=""string"" [action=""string""]&gt;
 *      &lt;configuration [axis2xml=""string""] [repository=""string""]/&gt;?
 *      &lt;source xpath=""expression"" | key=""string""&gt;
 *      &lt;target xpath=""expression"" | key=""string""/&gt;
 * &lt;/callout&gt;
 * </pre>
 */
public class CalloutMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof CalloutMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        CalloutMediator mediator = (CalloutMediator) m;
        OMElement callout = fac.createOMElement(""callout"", synNS);
        saveTracingState(callout, mediator);

        callout.addAttribute(fac.createOMAttribute(""serviceURL"", nullNS, mediator.getServiceURL()));
        if (mediator.getAction() != null) {
            callout.addAttribute(fac.createOMAttribute(""action"", nullNS, mediator.getAction()));
        }

        if (mediator.getClientRepository() != null || mediator.getAxis2xml() != null) {
            OMElement config = fac.createOMElement(""configuration"", synNS);
            if (mediator.getClientRepository() != null) {
                config.addAttribute(fac.createOMAttribute(
                        ""repository"", nullNS, mediator.getClientRepository()));
            }
            if (mediator.getAxis2xml() != null) {
                config.addAttribute(fac.createOMAttribute(
                        ""axis2xml"", nullNS, mediator.getAxis2xml()));
            }
            callout.addChild(config);
        }

        OMElement source = fac.createOMElement(""source"", synNS, callout);
        if (mediator.getRequestXPath() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getRequestXPath(), source, ""xpath"");
        } else if (mediator.getRequestKey() != null) {
            source.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, mediator.getRequestKey()));
        }

        OMElement target = fac.createOMElement(""target"", synNS, callout);
        if (mediator.getTargetXPath() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getTargetXPath(), target, ""xpath"");
        } else if (mediator.getTargetKey() != null) {
            target.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, mediator.getTargetKey()));
        }

        if (parent != null) {
            parent.addChild(callout);
        }
        return callout;
    }

    public String getMediatorClassName() {
        return CalloutMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/OutMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

public class OutMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof OutMediator)) {
            handleException(""Unsupported mediator passed out for serialization : "" + m.getType());
        }

        OutMediator mediator = (OutMediator) m;
        OMElement out = fac.createOMElement(""out"", synNS);
        saveTracingState(out,mediator);
        serializeChildren(out, mediator.getList());

        if (parent != null) {
            parent.addChild(out);
        }
        return out;
    }

    public String getMediatorClassName() {
        return OutMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/db/DBLookupMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.synapse.MessageContext;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Connection;
import java.util.Iterator;

/**
 * Simple database table lookup mediator. Designed only for read/lookup
 */
public class DBLookupMediator extends AbstractDBMediator {

    protected void processStatement(Statement stmnt, MessageContext msgCtx) {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        // execute the prepared statement, and extract the first result row and
        // set as message context properties, any results that have been specified
        Connection con = null;
        try {
            PreparedStatement ps = getPreparedStatement(stmnt, msgCtx);
            con = ps.getConnection();
            ResultSet rs = ps.executeQuery();

            if (rs.next()) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Processing the first row returned : "" + stmnt.getRawStatement());
                }

                Iterator propNameIter = stmnt.getResultsMap().keySet().iterator();
                while (propNameIter.hasNext()) {

                    String propName = (String) propNameIter.next();
                    String columnStr = (String) stmnt.getResultsMap().get(propName);

                    Object obj = null;
                    try {
                        int colNum = Integer.parseInt(columnStr);
                        obj = rs.getObject(colNum);
                    } catch (NumberFormatException ignore) {
                        obj = rs.getObject(columnStr);
                    }

                    if (obj != null) {
                        if (traceOrDebugOn) {
                            traceOrDebug(traceOn, ""Column : "" + columnStr +
                                "" returned value : "" + obj +
                                "" Setting this as the message property : "" + propName);
                        }
                        msgCtx.setProperty(propName, obj.toString());
                    } else {
                        if (traceOrDebugOn) {
                            traceOrDebugWarn(traceOn, ""Column : "" + columnStr +
                                "" returned null Skip setting message property : "" + propName);
                        }
                    }
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Statement : ""
                        + stmnt.getRawStatement() + "" returned 0 rows"");
                }
            }
            
        } catch (SQLException e) {
            handleException(""Error executing statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName(), e, msgCtx);
        } finally {
            if (con != null) {
                try {
                    con.close();
                } catch (SQLException ignore) {}
            }
        }
    }

}
"
org/apache/synapse/endpoints/AddressEndpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.axis2.clustering.ClusterManager;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;

/**
 * This class represents an actual endpoint to send the message. It is responsible for sending the
 * message, performing retries if a failure occurred and informing the parent endpoint if a failure
 * couldn't be recovered.
 */
public class AddressEndpoint extends DefaultEndpoint {

    /**
     * The endpoint context , place holder for keep any runtime states related to the endpoint
     */
    private final EndpointContext endpointContext = new EndpointContext();

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {

        boolean active = endpointContext.isActive();
        if (!active) {

            long recoverOn = endpointContext.getRecoverOn();
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
                endpointContext.setActive(true);
                endpointContext.setRecoverOn(0);                       

            }
        }

        if (log.isDebugEnabled()) {
            log.debug(""AddressEndpoint with name '"" + getName() + ""' is in ""
                    + (active ? ""active"" : ""inactive"") + "" state"");
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public synchronized void setActive(boolean active, MessageContext synMessageContext) {

        // this is synchronized as recoverOn can be set to unpredictable values if two threads call
        // this method simultaneously.

        if (!active) {
            EndpointDefinition endpoint = getEndpoint();
            if (endpoint.getSuspendOnFailDuration() != -1) {
                // Calculating a new value by adding suspendOnFailDuration to current time.
                // as the endpoint is set as failed
                endpointContext.setRecoverOn(
                        System.currentTimeMillis() + endpoint.getSuspendOnFailDuration());
            } else {
                endpointContext.setRecoverOn(Long.MAX_VALUE);
            }
        }

        this.endpointContext.setActive(active);
    }

    /**
     * Sends the message through this endpoint. This method just handles statistics related
     * functions and gives the message to the Synapse environment to send. It does not add any
     * endpoint specific details to the message context. These details are added only to the cloned
     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
     * context for resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Address Endpoint"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean isClusteringEnable = false;
        // get Axis2 MessageContext and ConfigurationContext
        org.apache.axis2.context.MessageContext axisMC =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
        ConfigurationContext cc = axisMC.getConfigurationContext();

        //The check for clustering environment

        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
        if (clusterManager != null &&
                clusterManager.getContextManager() != null) {
            isClusteringEnable = true;
        }

        String endPointName = this.getName();
        if (endPointName == null) {

            if (traceOrDebugOn && isClusteringEnable) {
                log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
            }
            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        if (isClusteringEnable) {

            // if this is a cluster environment , then set configuration context to endpoint context
            if (endpointContext.getConfigurationContext() == null) {
                endpointContext.setConfigurationContext(cc);
                endpointContext.setContextID(endPointName); // The context ID
            }
        }

        EndpointDefinition endpoint = getEndpoint();
        // Setting Required property to collect the End Point statistics
        boolean statisticsEnable
                = (SynapseConstants.STATISTICS_ON == endpoint.getStatisticsState());
        if (statisticsEnable) {
            EndPointStatisticsStack endPointStatisticsStack = null;
            Object statisticsStackObj =
                    synCtx.getProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS);
            if (statisticsStackObj == null) {
                endPointStatisticsStack = new EndPointStatisticsStack();
                synCtx.setProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS,
                        endPointStatisticsStack);
            } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
            }
            if (endPointStatisticsStack != null) {
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statisticsEnable, isFault);
            }
        }

        if (endpoint.getAddress() != null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Sending message to endpoint : "" +
                        endPointName + "" resolves to address = "" + endpoint.getAddress());
                traceOrDebug(traceOn, ""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                        synCtx.getSoapAction() : ""null""));
                traceOrDebug(traceOn, ""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));

                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Envelope : \n"" + synCtx.getEnvelope());
                }
            }
        }

        // register this as the immediate fault handler for this message.
        synCtx.pushFaultHandler(this);

        // add this as the last endpoint to process this message. it is used by statistics code.
        synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);

        synCtx.getEnvironment().send(endpoint, synCtx);
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        setActive(false, synCtx);
        super.onFault(synCtx);
    }
}
"
org/apache/synapse/registry/Registry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.synapse.config.Entry;

import java.util.Map;
import java.util.Properties;

/**
 * This is the interface to a Registry from Synapse.
 */
public interface Registry {

    /**
     * Initializes the registry with given properties
     *
     * @param properties The configuration properties
     */
    public void init(Properties properties);

    /**
     * Perform an actual lookup for for an XML resource as an OMNode for the given key
     *
     * @param key the key for the registry lookup
     * @return the XML content from the registry as an OMNode
     */
    public OMNode lookup(String key);

    /**
     * This is the publicly used interface to the registry. It will fetch
     * the content from the registry and cache if required.
     *
     * @param entry the registry Entry
     * @return the value from the registry or local cache
     * @see AbstractRegistry
     */
    public Object getResource(Entry entry);

    /**
     * Get the registry entry for the given key
     *
     * @param key the registry key
     * @return The registry entry for the given key
     */
    public RegistryEntry getRegistryEntry(String key);

    /**
     * Returns the child elements of a given registry entry
     *
     * @param entry - parent registry entry
     * @return Array of child registry entries of the given parent registry entry
     */
    public RegistryEntry[] getChildren(RegistryEntry entry);

    /**
     * Returns all descendant entries of the given registry entry
     *
     * @param entry - parent registry entry
     * @return Array of decendant registry entries of the given registry entry
     */
    public RegistryEntry[] getDescendants(RegistryEntry entry);

    /**
     * Return the name of the implementation class
     *
     * @return name of the registry provider implementation class name
     */
    public String getProviderClass();

    /**
     * Return the list of configuration properties set on this instance
     *
     * @return a Map of configuration properties
     */
    public Properties getConfigurationProperties();

    /**
     * Deletes a resource in the given path
     *
     * @param path The path the of resource
     */
    public void delete(String path);

    /**
     * Creates a new resource in the given path
     *
     * @param path        The new resource path
     * @param isDirectory Whether resource is a collection or not
     */
    public void newResource(String path, boolean isDirectory);

    /**
     * Updates the value of a resource
     *
     * @param path  The resource to be updated
     * @param value The value to be set
     */
    public void updateResource(String path, Object value);

    /**
     * Updates the registry enrty (metadata about a resource)
     *
     * @param entry The registry entry
     */
    public void updateRegistryEntry(RegistryEntry entry);
}
"
org/apache/synapse/mediators/AbstractListMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;

import java.util.ArrayList;
import java.util.List;

/**
 * This is the base class for all List mediators
 *
 * @see ListMediator
 */
public abstract class AbstractListMediator extends AbstractMediator
    implements ListMediator, ManagedLifecycle {

    /** the list of child mediators held. These are executed sequentially */
    protected List<Mediator> mediators = new ArrayList<Mediator>();

    public boolean mediate(MessageContext synCtx) {

        int parentsEffectiveTraceState = synCtx.getTracingState();
        // if I have been explicitly asked to enable or disable tracing, set it to the message
        // to pass it on; else, do nothing -> i.e. let the parents state flow
        setEffectiveTraceState(synCtx);
        int myEffectiveTraceState = synCtx.getTracingState();

        try {
            if (isTraceOrDebugOn(isTraceOn(synCtx))) {
                traceOrDebug(isTraceOn(synCtx), ""Sequence <"" + getType() + ""> :: mediate()"");
            }

            for (Mediator mediator : mediators) {

                // ensure correct trace state after each invocation of a mediator
                synCtx.setTracingState(myEffectiveTraceState);
                if (!mediator.mediate(synCtx)) {
                    return false;
                }
            }
        } finally {
            synCtx.setTracingState(parentsEffectiveTraceState);
        }
        return true;
    }

    public List getList() {
        return mediators;
    }

    public boolean addChild(Mediator m) {
        return mediators.add(m);
    }

    public boolean addAll(List<Mediator> c) {
        return mediators.addAll(c);
    }

    public Mediator getChild(int pos) {
        return mediators.get(pos);
    }

    public boolean removeChild(Mediator m) {
        return mediators.remove(m);
    }

    public Mediator removeChild(int pos) {
        return mediators.remove(pos);
    }

    /**
     * Initialize child mediators recursively
     * @param se synapse environment
     */
    public void init(SynapseEnvironment se) {

        if (log.isDebugEnabled()) {
            log.debug(""Initializing child mediators"");
        }

        for (Object mediator : mediators) {
            Mediator m = (Mediator) mediator;

            if (m instanceof ManagedLifecycle) {
                ((ManagedLifecycle) m).init(se);
            }
        } 
    }

    /**
     * Destroy child mediators recursively
     */
    public void destroy() {
        if (log.isDebugEnabled()) {
            log.debug(""Destroying child mediators"");
        }

        for (Mediator mediator : mediators) {

            if (mediator instanceof ManagedLifecycle) {
                ((ManagedLifecycle) mediator).destroy();
            }
        } 
    }
}
"
org/apache/synapse/core/axis2/ProxyServiceMessageReceiver.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This is the MessageReceiver set to act on behalf of Proxy services.
 */
public class ProxyServiceMessageReceiver extends SynapseMessageReceiver {

    private static final Log log = LogFactory.getLog(ProxyServiceMessageReceiver.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** The name of the Proxy Service */
    private String name = null;
    /** The proxy service */
    private ProxyService proxy = null;

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        boolean traceOn = proxy.getTraceState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        String remoteAddr = (String) mc.getProperty(
            org.apache.axis2.context.MessageContext.REMOTE_ADDR);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Proxy Service "" + name + "" received a new message"" +
                (remoteAddr != null ? "" from : "" + remoteAddr : ""...""));
            traceOrDebug(traceOn, (""Message To: "" +
                (mc.getTo() != null ? mc.getTo().getAddress() : ""null"")));
            traceOrDebug(traceOn, (""SOAPAction: "" +
                (mc.getSoapAction() != null ? mc.getSoapAction() : ""null"")));
            traceOrDebug(traceOn, (""WSA-Action: "" +
                (mc.getWSAAction() != null ? mc.getWSAAction() : ""null"")));

            if (traceOn && trace.isTraceEnabled()) {
                String[] cids = mc.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (String cid : cids) {
                        trace.trace(""With attachment content ID : "" + cid);
                    }
                }
                trace.trace(""Envelope : "" + mc.getEnvelope());
            }
        }

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);

        // get service log for this message and attach to the message context also set proxy name
        Log serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX + name);
        ((Axis2MessageContext) synCtx).setServiceLog(serviceLog);

        synCtx.setProperty(SynapseConstants.PROXY_SERVICE, name);
        synCtx.setTracingState(proxy.getTraceState());

        try {
            // Setting property to collect the proxy service statistics
            boolean statsOn = (SynapseConstants.STATISTICS_ON == proxy.getStatisticsState());
            if (statsOn) {
                ProxyServiceStatisticsStack proxyServiceStatisticsStack
                        = new ProxyServiceStatisticsStack();
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                proxyServiceStatisticsStack.put(name, System.currentTimeMillis(),
                        !synCtx.isResponse(), statsOn, isFault);
                synCtx.setProperty(SynapseConstants.PROXY_STATS,
                        proxyServiceStatisticsStack);
            }

            Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();
            if (mandatorySeq != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Start mediating the message in the "" +
                        ""pre-mediate state using the mandatory sequence"");
                }

                if(!mandatorySeq.mediate(synCtx)) {
                    if(log.isDebugEnabled()) {
                        log.debug(""Request message for the proxy service "" + name + "" dropped in "" +
                                ""the pre-mediation state by the mandatory sequence : \n"" + synCtx);
                    }
                    return;
                }
            }

            // setup fault sequence - i.e. what happens when something goes wrong with this message
            if (proxy.getTargetFaultSequence() != null) {

                Mediator faultSequence = synCtx.getSequence(proxy.getTargetFaultSequence());
                if (faultSequence != null) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn,
                            ""Setting the fault-sequence to : "" + faultSequence);
                    }
                    synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(proxy.getTargetFaultSequence())));

                } else {
                    // when we can not find the reference to the fault sequence of the proxy
                    // service we should not throw an exception because still we have the global
                    // fault sequence and the message mediation can still continue
                    traceOrDebug(traceOn, ""Unable to find fault-sequence : "" +
                        proxy.getTargetFaultSequence() + ""; using default fault sequence"");
                    synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(SynapseConstants.FAULT_SEQUENCE_KEY)));
                }

            } else if (proxy.getTargetInLineFaultSequence() != null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Setting specified anonymous fault-sequence for proxy"");
                }
                synCtx.pushFaultHandler(
                    new MediatorFaultHandler(proxy.getTargetInLineFaultSequence()));
            }

            boolean inSequenceResult = true;

            // Using inSequence for the incoming message mediation
            if (proxy.getTargetInSequence() != null) {

                Mediator inSequence = synCtx.getSequence(proxy.getTargetInSequence());
                if (inSequence != null) {
                    traceOrDebug(traceOn, ""Using sequence named : ""
                        + proxy.getTargetInSequence() + "" for incoming message mediation"");
                    inSequenceResult = inSequence.mediate(synCtx);

                } else {
                    handleException(""Unable to find in-sequence : "" + proxy.getTargetInSequence(), synCtx);
                }

            } else if (proxy.getTargetInLineInSequence() != null) {
                traceOrDebug(traceOn, ""Using the anonymous "" +
                    ""in-sequence of the proxy service for mediation"");
                inSequenceResult = proxy.getTargetInLineInSequence().mediate(synCtx);
            }

            // if inSequence returns true, forward message to endpoint
            if(inSequenceResult) {
                if (proxy.getTargetEndpoint() != null) {
                    Endpoint endpoint = synCtx.getEndpoint(proxy.getTargetEndpoint());

                    if (endpoint != null) {
                        traceOrDebug(traceOn, ""Forwarding message to the endpoint : ""
                            + proxy.getTargetEndpoint());
                        endpoint.send(synCtx);

                    } else {
                        handleException(""Unable to find the endpoint specified : "" +
                            proxy.getTargetEndpoint(), synCtx);
                    }

                } else if (proxy.getTargetInLineEndpoint() != null) {
                    traceOrDebug(traceOn, ""Forwarding the message to the anonymous "" +
                        ""endpoint of the proxy service"");
                    proxy.getTargetInLineEndpoint().send(synCtx);
                }
            }

        } catch (SynapseException syne) {

            if (!synCtx.getFaultStack().isEmpty()) {
                warn(traceOn, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(traceOn, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
    }

    /**
     * Set the name of the corresponding proxy service
     *
     * @param name the proxy service name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Set reference to actual proxy service
     * @param proxy
     */
    public void setProxy(ProxyService proxy) {
        this.proxy = proxy;
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }

    private void handleException(String msg, MessageContext msgContext) {
        log.error(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().error(msg);
        }
        if (proxy.getTraceState() == SynapseConstants.TRACING_ON) {
            trace.error(msg);
        }
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/ConfigurationFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.config.SynapseConfiguration;

/**
 * This interface defines the configuration factories of Synapse
 */
public interface ConfigurationFactory {

    /**
     * Get the tag QName of the element piece that will be
     * build using the factory
     *
     * @return QName describing the element
     */
    QName getTagQName();

    /**
     * Get (basically builds) the configuration of Synapse built up from
     * an OMElement using the defined factory
     *
     * @param element OMElement describing the configuration to be build
     * @return SynapseConfiguration build using the relevant factory
     */
    SynapseConfiguration getConfiguration(OMElement element);

    /**
     * Get the class which serializes the specified element
     *
     * @return Class defining the Serializer
     */
    Class getSerializerClass();
}
"
org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.context.ServiceGroupContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisServiceGroup;
import org.apache.axis2.description.WSDL2Constants;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.util.MessageHelper;

import javax.xml.namespace.QName;
import java.util.ArrayList;

/**
 * This is a simple client that handles both in only and in out
 */
public class Axis2FlexibleMEPClient {

    private static final Log log = LogFactory.getLog(Axis2FlexibleMEPClient.class);

    /**
     * Based on the Axis2 client code. Sends the Axis2 Message context out and returns
     * the Axis2 message context for the response.
     *
     * Here Synapse works as a Client to the service. It would expect 200 ok, 202 ok and
     * 500 internal server error as possible responses.
     *
     * @param endpoint the endpoint being sent to, maybe null
     * @param synapseOutMessageContext the outgoing synapse message
     * @throws AxisFault on errors
     */
    public static void send(

        EndpointDefinition endpoint,
        org.apache.synapse.MessageContext synapseOutMessageContext) throws AxisFault {

        boolean separateListener    = false;
        boolean wsSecurityEnabled   = false;
        String wsSecPolicyKey       = null;
        boolean wsRMEnabled         = false;
        String wsRMPolicyKey        = null;
        boolean wsAddressingEnabled = false;
        String wsAddressingVersion  = null;

        if (endpoint != null) {
            separateListener    = endpoint.isUseSeparateListener();
            wsSecurityEnabled   = endpoint.isSecurityOn();
            wsSecPolicyKey      = endpoint.getWsSecPolicyKey();
            wsRMEnabled         = endpoint.isReliableMessagingOn();
            wsRMPolicyKey       = endpoint.getWsRMPolicyKey();
            wsAddressingEnabled = endpoint.isAddressingOn() || wsSecurityEnabled || wsRMEnabled;
            wsAddressingVersion = endpoint.getAddressingVersion();
        }

        if (log.isDebugEnabled()) {
            log.debug(
                ""Sending [add = "" + wsAddressingEnabled +
                ""] [sec = "" + wsSecurityEnabled +
                ""] [rm = "" + wsRMEnabled +
                (endpoint != null ?
                    ""] [mtom = "" + endpoint.isUseMTOM() +
                    ""] [swa = "" + endpoint.isUseSwa() +
                    ""] [format = "" + endpoint.getFormat() +
                    ""] [force soap11="" + endpoint.isForceSOAP11() +
                    ""] [force soap12="" + endpoint.isForceSOAP12() +
                    ""] [pox="" + endpoint.isForcePOX() +
                    ""] [get="" + endpoint.isForceGET() +
                    ""] [encoding="" + endpoint.getCharSetEncoding() : """") +
                ""] [to "" + synapseOutMessageContext.getTo() + ""]"");
        }

        // save the original message context wihout altering it, so we can tie the response
        MessageContext originalInMsgCtx
            = ((Axis2MessageContext) synapseOutMessageContext).getAxis2MessageContext();

        // create a new MessageContext to be sent out as this should not corrupt the original
        // we need to create the response to the original message later on
        MessageContext axisOutMsgCtx = cloneForSend(originalInMsgCtx);

        // set all the details of the endpoint only to the cloned message context
        // so that we can use the original message context for resending through different endpoints
        if (endpoint != null) {

            if (SynapseConstants.FORMAT_POX.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(true);

            } else if (SynapseConstants.FORMAT_GET.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(true);
                axisOutMsgCtx.setProperty(Constants.Configuration.HTTP_METHOD,
                    Constants.Configuration.HTTP_METHOD_GET);
                
            } else if (SynapseConstants.FORMAT_SOAP11.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(false);
                axisOutMsgCtx.removeProperty(org.apache.axis2.Constants.Configuration.MESSAGE_TYPE);
                if (axisOutMsgCtx.getSoapAction() == null && axisOutMsgCtx.getWSAAction() != null) {
                    axisOutMsgCtx.setSoapAction(axisOutMsgCtx.getWSAAction());
                }
                if(!axisOutMsgCtx.isSOAP11()) {
                    SOAPUtils.convertSOAP12toSOAP11(axisOutMsgCtx);
                }
                
            } else if (SynapseConstants.FORMAT_SOAP12.equals(endpoint.getFormat())) {
                axisOutMsgCtx.setDoingREST(false);
                axisOutMsgCtx.removeProperty(org.apache.axis2.Constants.Configuration.MESSAGE_TYPE);                
                if (axisOutMsgCtx.getSoapAction() == null && axisOutMsgCtx.getWSAAction() != null) {
                    axisOutMsgCtx.setSoapAction(axisOutMsgCtx.getWSAAction());
                }
                if(axisOutMsgCtx.isSOAP11()) {
                    SOAPUtils.convertSOAP11toSOAP12(axisOutMsgCtx);
                }                
                
            }

            if (endpoint.isUseMTOM()) {
                axisOutMsgCtx.setDoingMTOM(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingMTOM(true);

            } else if (endpoint.isUseSwa()) {
                axisOutMsgCtx.setDoingSwA(true);
                // fix / workaround for AXIS2-1798
                axisOutMsgCtx.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
                axisOutMsgCtx.setDoingSwA(true);
            }

            if (endpoint.getCharSetEncoding() != null) {
                axisOutMsgCtx.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING,
                        endpoint.getCharSetEncoding());
            }
            
            if (endpoint.getAddress() != null) {
                axisOutMsgCtx.setTo(new EndpointReference(endpoint.getAddress()));
            }

            if (endpoint.isUseSeparateListener()) {
                axisOutMsgCtx.getOptions().setUseSeparateListener(true);
            }
        }

        if (wsAddressingEnabled) {
            
            if (wsAddressingVersion != null &&
                    SynapseConstants.ADDRESSING_VERSION_SUBMISSION.equals(wsAddressingVersion)) {

                axisOutMsgCtx.setProperty(AddressingConstants.WS_ADDRESSING_VERSION,
                        AddressingConstants.Submission.WSA_NAMESPACE);

            } else if (wsAddressingVersion != null &&
                    SynapseConstants.ADDRESSING_VERSION_FINAL.equals(wsAddressingVersion)) {

                axisOutMsgCtx.setProperty(AddressingConstants.WS_ADDRESSING_VERSION,
                        AddressingConstants.Final.WSA_NAMESPACE);
            }
            
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.FALSE);
        } else {
            axisOutMsgCtx.setProperty
                    (AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);
        }

        ConfigurationContext axisCfgCtx = axisOutMsgCtx.getConfigurationContext();
        AxisConfiguration axisCfg       = axisCfgCtx.getAxisConfiguration();

        AxisService anoymousService =
            AnonymousServiceFactory.getAnonymousService(synapseOutMessageContext.getConfiguration(),
            axisCfg, wsAddressingEnabled, wsRMEnabled, wsSecurityEnabled);
        ServiceGroupContext sgc = new ServiceGroupContext(
            axisCfgCtx, (AxisServiceGroup) anoymousService.getParent());
        ServiceContext serviceCtx = sgc.getServiceContext(anoymousService);

        boolean outOnlyMessage = ""true"".equals(synapseOutMessageContext.getProperty(
                SynapseConstants.OUT_ONLY)) || WSDL2Constants.MEP_URI_IN_ONLY.equals(
                originalInMsgCtx.getOperationContext()
                        .getAxisOperation().getMessageExchangePattern());

        // get a reference to the DYNAMIC operation of the Anonymous Axis2 service
        AxisOperation axisAnonymousOperation = anoymousService.getOperation(
            outOnlyMessage ?
                new QName(AnonymousServiceFactory.OUT_ONLY_OPERATION) :
                new QName(AnonymousServiceFactory.OUT_IN_OPERATION));

        Options clientOptions = new Options();
        clientOptions.setUseSeparateListener(separateListener);
        // if RM is requested,
        if (wsRMEnabled) {
            // if a WS-RM policy is specified, use it
            if (wsRMPolicyKey != null) {
                clientOptions.setProperty(
                    SynapseConstants.SANDESHA_POLICY,
                    getPolicy(synapseOutMessageContext, wsRMPolicyKey));
            }
            copyRMOptions(originalInMsgCtx, clientOptions);
        }

        // if security is enabled,
        if (wsSecurityEnabled) {
            // if a WS-Sec policy is specified, use it
            if (wsSecPolicyKey != null) {
                clientOptions.setProperty(
                    SynapseConstants.RAMPART_POLICY,
                    getPolicy(synapseOutMessageContext, wsSecPolicyKey));
            }
            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (axisOutMsgCtx.getEnvelope().getHeader() == null) {
                SOAPFactory fac = axisOutMsgCtx.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(axisOutMsgCtx.getEnvelope());
            }
        }

        OperationClient mepClient = axisAnonymousOperation.createClient(serviceCtx, clientOptions);
        mepClient.addMessageContext(axisOutMsgCtx);
        axisOutMsgCtx.setAxisMessage(
            axisAnonymousOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));

        if (!outOnlyMessage) {
            // always set a callback as we decide if the send it blocking or non blocking within
            // the MEP client. This does not cause an overhead, as we simply create a 'holder'
            // object with a reference to the outgoing synapse message context
            // synapseOutMessageContext
            AsyncCallback callback = new AsyncCallback(synapseOutMessageContext);
            if (endpoint != null) {
                // set the timeout time and the timeout action to the callback, so that the
                // TimeoutHandler can detect timed out callbacks and take approprite action.
                callback.setTimeOutOn(System.currentTimeMillis() + endpoint.getTimeoutDuration());
                callback.setTimeOutAction(endpoint.getTimeoutAction());
            } else {
                callback.setTimeOutOn(System.currentTimeMillis());
            }
            mepClient.setCallback(callback);
        }

        // with the nio transport, this causes the listener not to write a 202
        // Accepted response, as this implies that Synapse does not yet know if
        // a 202 or 200 response would be written back.
        originalInMsgCtx.getOperationContext().setProperty(
            org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");

        mepClient.execute(true);        
   }

    private static MessageContext cloneForSend(MessageContext ori) throws AxisFault {

        MessageContext newMC = MessageHelper.clonePartially(ori);

        newMC.setEnvelope(ori.getEnvelope());        
        removeAddressingHeaders(newMC);

        newMC.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
            ori.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS));

        return newMC;
    }

    private static void copyRMOptions(MessageContext oriContext, Options targetOptions) {
        Options oriOptions = oriContext.getOptions();
        if (oriOptions.getProperty(SynapseConstants.MERCURY_LAST_MESSAGE) != null) {
            targetOptions.setProperty(SynapseConstants.MERCURY_LAST_MESSAGE,
                    oriOptions.getProperty(SynapseConstants.MERCURY_LAST_MESSAGE));
        }
        if (oriOptions.getProperty(SynapseConstants.MERCURY_SPEC_VERSION) != null) {
            targetOptions.setProperty(SynapseConstants.MERCURY_SPEC_VERSION,
                    oriOptions.getProperty(SynapseConstants.MERCURY_SPEC_VERSION));
        }
        if (oriOptions.getProperty(SynapseConstants.MERCURY_SEQUENCE_KEY) != null) {
            targetOptions.setProperty(SynapseConstants.MERCURY_SEQUENCE_KEY,
                    oriOptions.getProperty(SynapseConstants.MERCURY_SEQUENCE_KEY));
        }
        // todo:[ruwan] migrate to Mercury
//        if (oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID) != null) {
//            targetOptions.setProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID,
//                    oriOptions.getProperty(SandeshaClientConstants.OFFERED_SEQUENCE_ID));
//        }
    }

    /**
     * Get the Policy object for the given name from the Synapse configuration at runtime
     * @param synCtx the current synapse configuration to get to the synapse configuration
     * @param propertyKey the name of the property which holds the Policy required
     * @return the Policy object with the given name, from the configuration
     */
    private static Policy getPolicy(org.apache.synapse.MessageContext synCtx, String propertyKey) {
        Object property = synCtx.getEntry(propertyKey);
        if (property != null && property instanceof OMElement) {
            return PolicyEngine.getPolicy((OMElement) property);
        } else {
            handleException(""Cannot locate policy from the property : "" + propertyKey);
        }
        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Removes Submission and Final WS-Addressing headers and return the SOAPEnvelope
     * from the given message context
     * @param axisMsgCtx the Axis2 Message context
     * @return the resulting SOAPEnvelope
     */
    public static SOAPEnvelope removeAddressingHeaders(MessageContext axisMsgCtx) {

        SOAPEnvelope env = axisMsgCtx.getEnvelope();
        SOAPHeader soapHeader = env.getHeader();
        ArrayList addressingHeaders;

        if (soapHeader != null) {
            addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                AddressingConstants.Submission.WSA_NAMESPACE);

            if (addressingHeaders != null && addressingHeaders.size() != 0) {
                detachAddressingInformation(addressingHeaders);

            } else {
                addressingHeaders = soapHeader.getHeaderBlocksWithNSURI(
                    AddressingConstants.Final.WSA_NAMESPACE);
                if (addressingHeaders != null && addressingHeaders.size() != 0) {
                    detachAddressingInformation(addressingHeaders);
                }
            }
        }
        return env;
    }

    /**
     * Remove WS-A headers
     * @param headerInformation headers to be removed
     */
    private static void detachAddressingInformation(ArrayList headerInformation) {
        for (Object o : headerInformation) {
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                headerBlock.detach();
            } else if (o instanceof OMElement) {
                // work around for a known addressing bug which sends non SOAPHeaderBlock objects
                OMElement om = (OMElement) o;
                OMNamespace ns = om.getNamespace();
                if (ns != null && (
                    AddressingConstants.Submission.WSA_NAMESPACE.equals(ns.getNamespaceURI()) ||
                        AddressingConstants.Final.WSA_NAMESPACE.equals(ns.getNamespaceURI()))) {
                    om.detach();
                }
            }
        }
    }
}
"
org/apache/synapse/mediators/builtin/ValidateMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.OMNode;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.util.AXIOMUtils;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Validate a message or an element against a schema
 * <p/>
 * This internally uses the Xerces2-j parser, which cautions a lot about thread-safety and
 * memory leaks. Hence this initial implementation will create a single parser instance
 * for each unique mediator instance, and re-use it to validate multiple messages - even
 * concurrently - by synchronizing access
 */
public class ValidateMediator extends AbstractListMediator {

    /**
     * A list of property keys, referring to the schemas to be used for the validation
     */
    private List<String> schemaKeys = new ArrayList<String>();

    /**
     * An XPath expression to be evaluated against the message to find the element to be validated.
     * If this is not specified, the validation will occur against the first child element of the
     * SOAP body
     */
    private SynapseXPath source = null;

    /**
     * A Map containing features to be passed to the actual validator (Xerces)
     */
    private List<MediatorProperty> explicityFeatures = new ArrayList<MediatorProperty>();

    /**
     * This is the actual schema instance used to create a new schema
     * This is a thred-safe instance.
     */
    private Schema cachedSchema;

    /**
     * Lock used to ensure thread-safe creation and use of the above Validator
     */
    private final Object validatorLock = new Object();

    /**
     * The SchemaFactory used to create new schema instances.
     */
    private  SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

//    private static final String DEFAULT_XPATH = ""//s11:Envelope/s11:Body/child::*[position()=1] | "" +
//        ""//s12:Envelope/s12:Body/child::*[position()=1]"";

    public static final String DEFAULT_XPATH = ""s11:Body/child::*[position()=1] | "" +
        ""s12:Body/child::*[position()=1]"";
    
    public ValidateMediator() {
        // create the default XPath
        try {
            this.source = new SynapseXPath(DEFAULT_XPATH);
            this.source.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            this.source.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            String msg = ""Error creating default source XPath expression : "" + DEFAULT_XPATH;
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Validate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // Input source for the validation
        Source validateSrc = getValidationSource(synCtx, traceOrDebugOn, traceOn);

        // flag to check if we need to initialize/re-initialize the schema
        boolean reCreate = false;
        // if any of the schemas are not loaded, or have expired, load or re-load them
        for (String propKey : schemaKeys) {
            Entry dp = synCtx.getConfiguration().getEntryDefinition(propKey);
            if (dp != null && dp.isDynamic()) {
                if (!dp.isCached() || dp.isExpired()) {
                    reCreate = true;       // request re-initialization of Validator
                }
            }
        }

        // This is the reference to the DefaultHandler instance
        MyErrorHandler errorHandler = new MyErrorHandler();

        // do not re-initialize schema unless required
        synchronized (validatorLock) {
            if (reCreate || cachedSchema == null) {

                factory.setErrorHandler(errorHandler);
                StreamSource[] sources = new StreamSource[schemaKeys.size()];
                int i = 0;
                for (String propName : schemaKeys) {
                    sources[i++] = SynapseConfigUtils.getStreamSource(synCtx.getEntry(propName));
                }

                try {
                    cachedSchema = factory.newSchema(sources);
                } catch (SAXException e) {
                    handleException(""Error creating a new schema objects for "" +
                        ""schemas : "" + schemaKeys.toString(), e, synCtx);
                }

                if (errorHandler.isValidationError()) {
                    //reset the errorhandler state
                    errorHandler.setValidationError(false);

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Error creating a new schema objects for "" +
                            ""schemas : "" + schemaKeys.toString());
                    }
                }
            }
        }

        // no need to synchronize, schema instances are thread-safe
        try {
            Validator validator = cachedSchema.newValidator();
            validator.setErrorHandler(errorHandler);

            // perform actual validation
            validator.validate(validateSrc);

            if (errorHandler.isValidationError()) {

                if (traceOrDebugOn) {
                    String msg = ""Validation of element returned by XPath : "" + source +
                        "" failed against the given schema(s) "" + schemaKeys +
                        ""with error : "" + errorHandler.getSaxParseException().getMessage() +
                        "" Executing 'on-fail' sequence"";
                    traceOrDebug(traceOn, msg);

                    // write a warning to the service log
                    synCtx.getServiceLog().warn(msg);

                    if (traceOn && trace.isTraceEnabled()) {
                        log.debug(""Failed message envelope : "" + synCtx.getEnvelope());
                    }
                }

                // set error message and detail (stack trace) into the message context
                synCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
                    errorHandler.getSaxParseException().getMessage());
                synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION,
                    errorHandler.getSaxParseException());
                synCtx.setProperty(SynapseConstants.ERROR_DETAIL,
                    FaultHandler.getStackTrace(errorHandler.getSaxParseException()));

                // super.mediate() invokes the ""on-fail"" sequence of mediators
                return super.mediate(synCtx);
            }
        } catch (SAXException e) {
            handleException(""Error validating "" + source + "" element"", e, synCtx);
        } catch (IOException e) {
            handleException(""Error validating "" + source + "" element"", e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Validation of element returned by the XPath expression : ""
                + source + "" succeeded against the given schemas and the current message"");
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Validate mediator"");
        }

        return true;
    }

    /**
     * Get the validation Source for the message context
     *
     * @param synCtx the current message to validate
     * @param traceOrDebugOn is tracing or debugging on?
     * @param traceOn is tracing on?
     * @return the validation Source for the current message
     */
    private Source getValidationSource(MessageContext synCtx,
        boolean traceOrDebugOn, boolean traceOn) {

        try {
            OMNode validateSource = getValidateSource(synCtx);
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Validation source : "" + validateSource.toString());
            }

            return AXIOMUtils.asSource(validateSource);

        } catch (Exception e) {
            handleException(""Error accessing source element : "" + source, e, synCtx);
        }
        return null; // never reaches here
    }

    /**
     * This class handles validation errors to be used for the error reporting
     */
    private class MyErrorHandler extends DefaultHandler {

        private boolean validationError = false;
        private SAXParseException saxParseException = null;

        public void error(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void fatalError(SAXParseException exception) throws SAXException {
            validationError = true;
            saxParseException = exception;
        }

        public void warning(SAXParseException exception) throws SAXException {
        }

        public boolean isValidationError() {
            return validationError;
        }

        public SAXParseException getSaxParseException() {
            return saxParseException;
        }
        
        /**
         * To set explicitly validation error condition
         * @param validationError  is occur validation error?
         */
        public void setValidationError(boolean validationError) {
            this.validationError = validationError;
        }
    }

    /**
     * Return the OMNode to be validated. If a source XPath is not specified, this will
     * default to the first child of the SOAP body i.e. - //*:Envelope/*:Body/child::*
     *
     * @param synCtx the message context
     * @return the OMNode against which validation should be performed
     */
    private OMNode getValidateSource(MessageContext synCtx) {

        try {
            Object o = source.evaluate(synCtx);
            if (o instanceof OMNode) {
                return (OMNode) o;
            } else if (o instanceof List && !((List) o).isEmpty()) {
                return (OMNode) ((List) o).get(0);  // Always fetches *only* the first
            } else {
                handleException(""The evaluation of the XPath expression ""
                    + source + "" did not result in an OMNode : "" + o, synCtx);
            }
        } catch (JaxenException e) {
            handleException(""Error evaluating XPath expression : "" + source, e, synCtx);
        }
        return null;
    }

    // setters and getters

    /**
     * Get a mediator feature. The common use case is a feature for the
     * underlying Xerces validator
     *
     * @param key property key / feature name
     * @return property string value (usually true|false)
     */
    public Object getFeature(String key) {
        for (MediatorProperty prop : explicityFeatures) {
            if (key.equals(prop.getName())) {
                return prop.getValue();
            }
        }
        return null;
    }

    /**
     * add a feature which need to set for the Schema Factory
     *
     * @param  featureName The name of the feature
     * @param isFeatureEnable should this feature enable?(true|false)
     * @see #getFeature(String)
     * @throws SAXException on an unknown feature
     */
   public void addFeature(String featureName, boolean isFeatureEnable) throws SAXException {
        MediatorProperty mp = new MediatorProperty();
        mp.setName(featureName);
        if (isFeatureEnable) {
            mp.setValue(""true"");
        } else {
            mp.setValue(""false"");
        }
        explicityFeatures.add(mp);
        factory.setFeature(featureName, isFeatureEnable);
    }

    /**
     * Set a list of local property names which refer to a list of schemas to be
     * used for validation
     *
     * @param schemaKeys list of local property names
     */
    public void setSchemaKeys(List<String> schemaKeys) {
        this.schemaKeys = schemaKeys;
    }

    /**
     * Set the given XPath as the source XPath
     * @param source an XPath to be set as the source
     */
    public void setSource(SynapseXPath source) {
       this.source = source;
    }

    /**
     * Get the source XPath which yields the source element for validation
     * @return the XPath which yields the source element for validation
     */
    public SynapseXPath getSource() {
        return source;
    }

    /**
     * The keys for the schema resources used for validation
     * @return schema registry keys
     */
    public List<String> getSchemaKeys() {
        return schemaKeys;
    }

    /**
     * Features for the actual Xerces validator
     * @return explicityFeatures to be passed to the Xerces validator
     */
    public List<MediatorProperty> getFeatures() {
        return explicityFeatures;
    }
}
"
org/apache/synapse/config/xml/XMLConfigurationSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.SynapseConfiguration;

import javax.xml.stream.XMLStreamException;
import java.io.OutputStream;

/**
 * Serialize a SynapseConfiguration into an OutputStream
 */
public class XMLConfigurationSerializer {

    private static final Log log = LogFactory.getLog(XMLConfigurationSerializer.class);

    /**
     * Order of entries is irrelevant, however its nice to have some order.
     * @param synCfg
     * @param outputStream
     * @throws XMLStreamException
     */
    public static void serializeConfiguration(SynapseConfiguration synCfg,
        OutputStream outputStream) throws XMLStreamException {

        log.info(""Serializing the XML Configuration to the output stream"");
        
        OMElement definitions
                = ConfigurationFactoryAndSerializerFinder.serializeConfiguration(synCfg);
        definitions.serialize(outputStream);
    }
    
}
"
org/apache/synapse/endpoints/EndpointContext.java,true,"/*
*  Licensed to the Apache Software Foundation (ASF) under one
*  or more contributor license agreements.  See the NOTICE file
*  distributed with this work for additional information
*  regarding copyright ownership.  The ASF licenses this file
*  to you under the Apache License, Version 2.0 (the
*  ""License""); you may not use this file except in compliance
*  with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
package org.apache.synapse.endpoints;

import org.apache.axis2.clustering.ClusteringFault;
import org.apache.axis2.clustering.context.Replicator;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

/**
 * Keeps the states of the endpoint.This hides where those states are kept .For a cluster
 * environment,all states are kept in the axis2 configuration context in order to replicate those
 * states so that other synapse instance in the same cluster can see those changes . This class can
 * be evolved to keep any run time states related to the endpoint .For a non-clustered environment,
 * all data are kept locally.
 * <p/>
 * This class provide the abstraction need to separate the dynamic data from the static data and
 * improve the  high cohesion and provides capability to replicate only required state at
 * a given time. This improves the performance when replicate data.
 */
public class EndpointContext {

    private static final Log log = LogFactory.getLog(EndpointContext.class);

    /* The  static constant only for construct key prefix for each property in endpoint context
     * as it is need when those property state going to replicate in a cluster env. */
    private static final String ACTIVE = ""active"";
    private static final String RECOVER_ON = ""recover_on"";
    private static final String UNDERSCORE_STRING = ""_"";

    /* Determines if this endpoint is active or not. This variable have to be loaded always from the
     * memory as multiple threads could access it.*/
    private boolean active = true;

    /* Time to recover a failed endpoint.*/
    private long recoverOn = Long.MAX_VALUE;

    /* The axis configuration context-  this will hold the all callers states
     * when doing throttling in a clustered environment. */
    private ConfigurationContext configCtx;

    /* The key for 'active' attribute and this is used when this attribute value being replicated */
    private String activePropertyKey;
    /* The key for 'recoverOn' attribute and this is used when this attribute value being
     * replicated */
    private String recoverOnPropertyKey;

    /* Is this env. support clustering*/
    private boolean isClusteringEnable = false;

    /**
     * Checks if the endpoint is active (failed or not)
     *
     * @return Returns true if the endpoint is active , otherwise , false will be returned
     */
    public boolean isActive() {

        if (this.isClusteringEnable) {  // if this is a clustering env.

            if (this.activePropertyKey == null || """".equals(this.activePropertyKey)) {
                handleException(""Cannot find the required key to find the "" +
                        ""shared state of 'active' attribute"");
            }

            // gets the value from configuration context (The shared state across all instances )
            Object value = this.configCtx.getPropertyNonReplicable(this.activePropertyKey);
            if (value == null) {
                return true;
            }
            if (value instanceof Boolean) {
                return ((Boolean) value).booleanValue();
            } else if (value instanceof String) {
                return Boolean.parseBoolean((String) value);
            } else {
                handleException(""Unsupported object type for value"" + value);
            }

        } else {
            return active;
        }

        throw new SynapseException(""Invalid states in endpoint context"");

    }

    /**
     * Sets if endpoint active or not.
     *
     * @param active True for make endpoint active , false for make it inactive
     */
    public synchronized void setActive(boolean active) {

        if (this.isClusteringEnable) {  // if this is a clustering env.
            // replicates the state so that all instances across cluster can see this state
            setAndReplicateState(this.activePropertyKey, active);
        } else {
            this.active = active;
        }

    }

    /**
     * Time to recover a failed endpoint.
     *
     * @return Returns time to recover a failed endpoint.
     */
    public long getRecoverOn() {

        if (this.isClusteringEnable) {    // if this is a clustering env.

            if (this.recoverOnPropertyKey == null || """".equals(this.recoverOnPropertyKey)) {
                handleException(""Cannot find the required key to find the "" +
                        ""shared state of 'recoveOn' attribute"");
            }

            // gets the value from configuration context (The shared state across all instances )
            Object value = this.configCtx.getPropertyNonReplicable(this.recoverOnPropertyKey);
            if (value == null) {
                return Long.MAX_VALUE;
            }
            if (value instanceof Long) {
                return ((Long) value).longValue();
            } else if (value instanceof String) {
                try {
                    return Long.parseLong((String) value);
                } catch (NumberFormatException e) {
                    return Long.MAX_VALUE;
                }
            } else {
                handleException(""Unsupported object type for value"" + value);
            }

        } else {
            return recoverOn;
        }
        throw new SynapseException(""Invalid states in endpoint context"");
    }

    /**
     * Sets time to recover a failed endpoint.
     *
     * @param recoverOn The value for recover time
     */
    public void setRecoverOn(long recoverOn) {

        if (this.isClusteringEnable) { // if this is a clustering env.
            // replicates the state so that all instances across cluster can see this state
            setAndReplicateState(this.recoverOnPropertyKey, recoverOn);
        } else {
            this.recoverOn = recoverOn;
        }
    }

    /**
     * Get the configuration context instance . This is only available for cluster env.
     *
     * @return Returns the ConfigurationContext instance
     */
    public ConfigurationContext getConfigurationContext() {
        return configCtx;
    }

    /**
     * Sets the  ConfigurationContext instance . This is only used for cluster env.
     * By setting this , indicates that this is a cluster env.
     *
     * @param configCtx The ConfigurationContext instance
     */
    public void setConfigurationContext(ConfigurationContext configCtx) {

        if (configCtx == null) {
            handleException(""The ConfigurationContext cannot be null"" +
                    "" when system in a cluster environment"");
        }

        this.configCtx = configCtx;
        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
    }

    /**
     * Sets the identifier for this endpoint context , so that , this can be identified
     * uniquely across the cluster. The id will be the name of the endpoint
     *
     * @param contextID The Id for this endpoint context
     */
    public void setContextID(String contextID) {

        if (contextID == null || """".equals(contextID)) {
            handleException(""The Context ID cannot be null when system in a cluster environment"");
        }

        //Making required key for each property in the endpoint context - Those will be used when
        //replicating states
        StringBuffer buffer = new StringBuffer();
        buffer.append(contextID);
        buffer.append(UNDERSCORE_STRING);
        String prefix = buffer.toString();

        this.recoverOnPropertyKey = prefix + RECOVER_ON;
        this.activePropertyKey = prefix + ACTIVE;

    }


    /**
     * Helper method to replicates states of the property with given key
     * replicates  the given state so that all instances across cluster can see this state
     *
     * @param key   The key of the property
     * @param value The value of the property
     */
    private void setAndReplicateState(String key, Object value) {

        if (configCtx != null && key != null && value != null) {

            try {
                if (log.isDebugEnabled()) {
                    log.debug(""Start replicating the property with key : "" + key +
                            "" value : "" + value);
                }

                configCtx.setProperty(key, value);
                Replicator.replicate(configCtx, new String[]{key});

                if (log.isDebugEnabled()) {
                    log.debug(""Completed replication of the property with key : "" + key);
                }

            } catch (ClusteringFault clusteringFault) {
                handleException(""Error during the replicating states "", clusteringFault);
            }
        }
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     */
    protected void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     * @param e   The exception
     */
    protected void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}"
org/apache/synapse/config/Entry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import java.net.URL;

/**
 * Represents an Entry contained in the local registry used by Synapse
 *
 * @see org.apache.synapse.config.SynapseConfiguration#localRegistry
 */
public class Entry {

    private static final Log log = LogFactory.getLog(Entry.class);

    /** The key of the entry */
    private String key;
    /** The type of the entry */
    private int type;
    /** Source URL of the entry if it is a URL_SRC */
    private URL src;
    /** The value of the entry. This can be either an OMElement or an String */
    private Object value;
    /** An XML to Object mapper - if one is available */
    private XMLToObjectMapper mapper;
    /** The version of the cached resource */
    private long version;
    /** The local expiry time for the cached resource */
    private long expiryTime;

    public Entry() {}
    
    public Entry(String key) {
        this.key = key;
    }

    public int getType() {
        return type;
    }

    public boolean isRemote() {
        return type == REMOTE_ENTRY;
    }

    public boolean isURLSource() {
        return type == URL_SRC;
    }

    public boolean isInlineXML() {
        return type == INLINE_XML;
    }

    public boolean isInlineText() {
        return type == INLINE_TEXT;
    }

    public void setType(int type) {
        if (type <= 4 && type >= 0) {
            this.type = type;
        } else {
            handleException(""Invalid entry type for the static entry"");
        }
    }

    public URL getSrc() {
        return src;
    }

    public void setSrc(URL src) {
        this.src = src;
    }

    public String getKey() {
        return this.key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * Gets the value of the entry. String if the type is INLINE_TEXT or VALUE_TYPE,
     * OMElement otherwise.
     * @return Either an OMElement or a String
     */
    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    /**
     *
     * @return mapper
     */
    public XMLToObjectMapper getMapper() {
        return mapper;
    }

    /**
     *
     * @param mapper
     */
    public void setMapper(XMLToObjectMapper mapper) {
        this.mapper = mapper;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public long getExpiryTime() {
        return expiryTime;
    }

    public void setExpiryTime(long expiryTime) {
        this.expiryTime = expiryTime;
    }

    public boolean isExpired() {
        if (getType() == REMOTE_ENTRY && getExpiryTime() > 0) {
            return System.currentTimeMillis() > expiryTime;
        } else {
            return false;
        }
    }

    public boolean isCached() {
        return value != null;
    }

    public void clearCache() {
        if (this.isDynamic()) {
            value = null;
            expiryTime = System.currentTimeMillis();
        }
    }

    public boolean isDynamic() {
        return type == REMOTE_ENTRY;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public static final int INLINE_TEXT = 0;
    public static final int INLINE_XML = 1;
    public static final int URL_SRC = 2;
    public static final int REMOTE_ENTRY = 3;
}
"
org/apache/synapse/config/xml/ResourceMapFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.util.Iterator;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.ResourceMap;

/**
 * Creates a ResourceMap object based on a set of <tt>&lt;resource&gt;</tt> elements:
 * <pre>
 * &lt;resource location=""..."" key=""...""/&gt;*
 * </pre>
 */
public class ResourceMapFactory {
    private static final Log log = LogFactory.getLog(ResourceMapFactory.class);
    
    public static ResourceMap createResourceMap(OMElement elem) {
        ResourceMap resourceMap = null;
        Iterator it = elem.getChildrenWithName(
            new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""resource""));
        while (it.hasNext()) {
            // Lazily create the ResourceMap, so that when no <resource> 
            // elements are found, the method returns null.
            if (resourceMap == null) {
                resourceMap = new ResourceMap();
            }
            OMElement resourceElem = (OMElement)it.next();
            OMAttribute location = resourceElem.getAttribute
                (new QName(XMLConfigConstants.NULL_NAMESPACE, ""location""));
            if (location == null) {
                handleException(""The 'location' attribute is required for a resource definition"");
            }
            OMAttribute key = resourceElem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
            if (key == null) {
                handleException(""The 'key' attribute is required for a resource definition"");
            }
            resourceMap.addResource(location.getAttributeValue(), key.getAttributeValue());
        }
        return resourceMap;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/ValidateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.List;

/**
 * Serializer for {@link ValidateMediator} instances.
 * 
 * @see ValidateMediatorSerializer
 */
public class ValidateMediatorSerializer extends AbstractListMediatorSerializer
    implements MediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof ValidateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        ValidateMediator mediator = (ValidateMediator) m;
        OMElement validate = fac.createOMElement(""validate"", synNS);
        saveTracingState(validate, mediator);

        if (mediator.getSource() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getSource(), validate, ""source"");
        }

        for (String key : mediator.getSchemaKeys()) {
            OMElement schema = fac.createOMElement(""schema"", synNS, validate);
            schema.addAttribute(fac.createOMAttribute(""key"", nullNS, key));
        }

        List<MediatorProperty> features = mediator.getFeatures();
        if (!features.isEmpty()) {
            for (MediatorProperty mp : features) {
                OMElement feature = fac.createOMElement(""feature"", synNS, validate);
                if (mp.getName() != null) {
                    feature.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
                } else {
                    handleException(""The Feature name is missing"");
                }
                if (mp.getValue() != null) {
                    feature.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));
                } else {
                    handleException(""The Feature value is missing"");
                }
            }
        }
        OMElement onFail = fac.createOMElement(""on-fail"", synNS, validate);
        serializeChildren(onFail, mediator.getList());

        if (parent != null) {
            parent.addChild(validate);
        }
        return validate;
    }

    public String getMediatorClassName() {
        return ValidateMediator.class.getName();
    }

}
"
org/apache/synapse/util/PayloadHelper.java,false,"package org.apache.synapse.util;

import java.util.Iterator;

import javax.activation.DataHandler;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamReader;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMText;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.axiom.soap.SOAP11Version;
import org.apache.axiom.soap.SOAPBody;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPVersion;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.SimpleMap;

public class PayloadHelper {
	
	// this has to match org.apache.axis2.base.transport.BaseConstants 
	// at some future point we will merge this into Axiom as a common parent
	public final static String AXIOMPAYLOADNS = ""http://ws.apache.org/commons/ns/payload"";

	public final static QName BINARYELT = new QName(AXIOMPAYLOADNS, ""binary"",
			""ax"");

	public final static QName TEXTELT = new QName(AXIOMPAYLOADNS, ""text"", ""ax"");

	public final static QName MAPELT = new QName(AXIOMPAYLOADNS, ""map"", ""ax"");

	public final static int XMLPAYLOADTYPE = 0, BINARYPAYLOADTYPE = 1,
			TEXTPAYLOADTYPE = 2, MAPPAYLOADTYPE = 3;

	public static final Log log = LogFactory.getLog(PayloadHelper.class);

	// gets a indication of the payload type. Default is XML
	// You cannot set the payload type. Instead, it is set automatically when
	// the payload is set
	public static int getPayloadType(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el.getQName().equals(BINARYELT))
			return BINARYPAYLOADTYPE;
		else if (el.getQName().equals(TEXTELT))
			return TEXTPAYLOADTYPE;
		else if (el.getQName().equals(MAPELT))
			return MAPPAYLOADTYPE;
		else
			return XMLPAYLOADTYPE; // default XML
	}

	public static int getPayloadType(MessageContext mc) {
		if (mc.getEnvelope() == null)
			return 0;
		return getPayloadType(mc.getEnvelope());
	}

	// XML Payload is carried as the first (and only) child of the body
	public static OMElement getXMLPayload(SOAPEnvelope envelope) {
		SOAPBody body = envelope.getBody();
		if (body == null) {
			log.error(""No body found"");
			return null;
		}
		OMElement bodyEl = body.getFirstElement();
		if (bodyEl == null) {
			log.error(""No body child found"");
			return null;
		}
		return bodyEl;
	}

	public static void setXMLPayload(SOAPEnvelope envelope, OMElement element) {
		SOAPBody body = envelope.getBody();
		if (body == null) {

			SOAPVersion version = envelope.getVersion();
			if (version.getEnvelopeURI().equals(
					SOAP11Version.SOAP_ENVELOPE_NAMESPACE_URI)) {
				body = OMAbstractFactory.getSOAP11Factory().createSOAPBody();
			} else {
				body = OMAbstractFactory.getSOAP12Factory().createSOAPBody();
			}
			if (envelope.getHeader() != null) {
				envelope.getHeader().insertSiblingAfter(body);
			} else {
				envelope.addChild(body);
			}
		} else {
			for (Iterator it = body.getChildren(); it.hasNext();) {
				OMNode node = (OMNode) it.next();
				node.discard();
			}
		}
		body.addChild(element);
	}

	public static void setXMLPayload(MessageContext mc, OMElement element) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setXMLPayload(mc.getEnvelope(), element);
	}

	// Binary Payload is carried in a wrapper element with QName BINARYELT
	public static DataHandler getBinaryPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(BINARYELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		OMNode textNode = el.getFirstOMChild();
		if (textNode.getType() != OMNode.TEXT_NODE) {
			log.error(""Text Node not found"");
			return null;
		}
		OMText text = (OMText) textNode;
		DataHandler dh = null;
		try {
			dh = (DataHandler) text.getDataHandler();
		} catch (ClassCastException ce) {
			log.error(""cannot get DataHandler"" + ce.getMessage());
			return null;
		}
		return dh;

	}

	public static DataHandler getBinaryPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getBinaryPayload(mc.getEnvelope());
	}

	public static void setBinaryPayload(SOAPEnvelope envelope, DataHandler dh) {
		OMFactory fac = envelope.getOMFactory();
		OMElement binaryElt = envelope.getOMFactory()
				.createOMElement(BINARYELT);
		OMText text = fac.createOMText(dh, true);
		binaryElt.addChild(text);
		setXMLPayload(envelope, binaryElt);
	}

	public static void setBinaryPayload(MessageContext mc, DataHandler dh) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setBinaryPayload(mc.getEnvelope(), dh);

	}

	// Text payload is carried in a wrapper element with QName TEXTELT
	public static String getTextPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(TEXTELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		OMNode textNode = el.getFirstOMChild();
		if (textNode.getType() != OMNode.TEXT_NODE) {
			log.error(""Text Node not found"");
			return null;
		}
		OMText text = (OMText) textNode;
		return text.getText();
	}

	public static String getTextPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getTextPayload(mc.getEnvelope());
	}

	public static void setTextPayload(SOAPEnvelope envelope, String text) {
		OMFactory fac = envelope.getOMFactory();
		OMElement textElt = envelope.getOMFactory().createOMElement(TEXTELT);
		OMText textNode = fac.createOMText(text);
		textElt.addChild(textNode);
		setXMLPayload(envelope, textElt);
	}

	public static void setTextPayload(MessageContext mc, String text) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setTextPayload(mc.getEnvelope(), text);
	}

	// Map payload must be a Map of String->int, boolean, float, double, char,
	// short, byte, byte[], long, String
	public static SimpleMap getMapPayload(SOAPEnvelope envelope) {
		OMElement el = getXMLPayload(envelope);
		if (el == null)
			return null;
		if (!el.getQName().equals(MAPELT)) {
			log.error(""Wrong QName"" + el.getQName());
			return null;
		}
		SimpleMap map = new SimpleMapImpl(el);
		return map;
	}

	public static SimpleMap getMapPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getMapPayload(mc.getEnvelope());
	}

	public static void setMapPayload(SOAPEnvelope envelope, SimpleMap map) {

		if (map instanceof SimpleMapImpl) {
			SimpleMapImpl impl = (SimpleMapImpl) map;
			OMElement mapElt = impl.getOMElement(envelope.getOMFactory());
			if (mapElt == null) {
				log.debug(""null map element returned"");
				return;
			}
			setXMLPayload(envelope, mapElt);
		} else {
			throw new SynapseException(""cannot handle any other instance of SimpleMap at this point TODO"");
		}
	}

	public static void setMapPayload(MessageContext mc, SimpleMap map) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
		}
		setMapPayload(mc.getEnvelope(), map);
	}
	
	public static XMLStreamReader getStAXPayload(SOAPEnvelope envelope) {
		 
		OMElement el = getXMLPayload(envelope);
		if (el==null) {
			return null;
		}
		return el.getXMLStreamReader();
	}
	public static XMLStreamReader getStAXPayload(MessageContext mc) {
		if (mc.getEnvelope() == null) {
			log.error(""null envelope"");
			return null;
		}
		return getStAXPayload(mc.getEnvelope());
	}
	public static void setStAXPayload(SOAPEnvelope envelope, XMLStreamReader streamReader) {
		StAXOMBuilder builder = new StAXOMBuilder(envelope.getOMFactory(), streamReader);
		OMElement el = builder.getDocumentElement();
		setXMLPayload(envelope, el);
	}
	public static void setStAXPayload(MessageContext mc, XMLStreamReader streamReader) {
		if (mc.getEnvelope() == null) {
			try {
				mc.setEnvelope(OMAbstractFactory.getSOAP12Factory()
						.createSOAPEnvelope());
			} catch (Exception e) {
				throw new SynapseException(e);
			}
			setStAXPayload(mc.getEnvelope(), streamReader);
		}
	
	}
	
	
}
"
org/apache/synapse/config/xml/ProxyServiceFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axis2.description.WSDL2Constants;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.util.PolicyInfo;

import javax.xml.namespace.QName;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

/**
 * Factory for {@link ProxyService} instances.
 * <p/>
 * Configuration syntax:
 * <pre>
 * &lt;proxy name=""string"" [transports=""(http |https |jms )+|all""] [pinnedServers=""(serverName )+"" [trace=""enable|disable""]>
 *    &lt;description>..&lt;/description>?
 *    &lt;target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       &lt;endpoint>...&lt;/endpoint>?
 *       &lt;inSequence>...&lt;/inSequence>?
 *       &lt;outSequence>...&lt;/outSequence>?
 *       &lt;faultSequence>...&lt;/faultSequence>?
 *    &lt;/target>?
 *    &lt;publishWSDL uri="".."" key=""string"">
 *       ( &lt;wsdl:definition>...&lt;/wsdl:definition> | &lt;wsdl20:description>...&lt;/wsdl20:description> )?
 *       &lt;resource location=""..."" key=""...""/>*
 *    &lt;/publishWSDL>?
 *    &lt;enableSec/>?
 *    &lt;enableRM/>?
 *    &lt;policy key=""string""/>?
 *    &lt;policy key=""string"" type=(in | out)/>?
 *       // optional service parameters
 *    &lt;parameter name=""string"">
 *       text | xml
 *    &lt;/parameter>?
 * &lt;/proxy>
 * </pre>
 */
public class ProxyServiceFactory {

    private static final Log log = LogFactory.getLog(ProxyServiceFactory.class);

    public static ProxyService createProxy(OMElement elem) {

        ProxyService proxy = null;

        OMAttribute name = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name == null) {
            handleException(""The 'name' attribute is required for a Proxy service definition"");
        } else {
            proxy = new ProxyService(name.getAttributeValue());
        }

        OMAttribute statistics = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE,
                XMLConfigConstants.STATISTICS_ATTRIB_NAME));
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    proxy.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    proxy.setStatisticsState(org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }

        OMAttribute trans = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""transports""));
        if (trans != null) {
            String transports = trans.getAttributeValue();
            if (transports == null || ProxyService.ALL_TRANSPORTS.equals(transports)) {
                // default to all transports using service name as destination
            } else {
                StringTokenizer st = new StringTokenizer(transports, "" ,"");
                ArrayList transportList = new ArrayList();
                while (st.hasMoreTokens()) {
                    String token = st.nextToken();
                    if (token.length() != 0) {
                        transportList.add(token);
                    }
                }
                proxy.setTransports(transportList);
            }
        }

        OMAttribute pinnedServers = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""pinnedServers""));
        if (pinnedServers != null) {
            String pinnedServersValue = pinnedServers.getAttributeValue();
            if (pinnedServersValue == null) {
                // default to all servers
            } else {
                StringTokenizer st = new StringTokenizer(pinnedServersValue, "" ,"");
                List pinnedServersList = new ArrayList();
                while (st.hasMoreTokens()) {
                    String token = st.nextToken();
                    if (token.length() != 0) {
                      pinnedServersList.add(token);
                    }
                }
                proxy.setPinnedServers(pinnedServersList);
            }
        }
        
        OMAttribute trace = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.TRACE_ATTRIB_NAME));
        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(XMLConfigConstants.TRACE_ENABLE)) {
                    proxy.setTraceState(org.apache.synapse.SynapseConstants.TRACING_ON);
                } else if (traceValue.equals(XMLConfigConstants.TRACE_DISABLE)) {
                    proxy.setTraceState(org.apache.synapse.SynapseConstants.TRACING_OFF);
                }
            }
        }
        OMAttribute startOnLoad = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""startOnLoad""));
        if (startOnLoad != null) {
            proxy.setStartOnLoad(Boolean.valueOf(startOnLoad.getAttributeValue()).booleanValue());
        } else {
            proxy.setStartOnLoad(true);
        }

        // setting the description of the proxy service
        OMElement descriptionElement = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""description""));
        if (descriptionElement != null) {
            proxy.setDescription(descriptionElement.getText().trim());
        }

        // read definition of the target of this proxy service. The target could be an 'endpoint'
        // or a named sequence. If none of these are specified, the messages would be mediated
        // by the Synapse main mediator
        OMElement target = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target""));
        if (target != null) {
            boolean isTargetOk = false;
            SequenceMediatorFactory mediatorFactory = new SequenceMediatorFactory();
            OMAttribute inSequence = target.getAttribute(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""inSequence""));
            if (inSequence != null) {
                proxy.setTargetInSequence(inSequence.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement inSequenceElement = target.getFirstChildWithName(
                        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""inSequence""));
                if (inSequenceElement != null) {
                    proxy.setTargetInLineInSequence(
                            mediatorFactory.createAnonymousSequence(inSequenceElement));
                    isTargetOk = true;
                }
            }
            OMAttribute outSequence = target.getAttribute(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""outSequence""));
            if (outSequence != null) {
                proxy.setTargetOutSequence(outSequence.getAttributeValue());
            } else {
                OMElement outSequenceElement = target.getFirstChildWithName(
                        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""outSequence""));
                if (outSequenceElement != null) {
                    proxy.setTargetInLineOutSequence(
                            mediatorFactory.createAnonymousSequence(outSequenceElement));
                }
            }
            OMAttribute faultSequence = target.getAttribute(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""faultSequence""));
            if (faultSequence != null) {
                proxy.setTargetFaultSequence(faultSequence.getAttributeValue());
            } else {
                OMElement faultSequenceElement = target.getFirstChildWithName(
                        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""faultSequence""));
                if (faultSequenceElement != null) {
                    proxy.setTargetInLineFaultSequence(
                            mediatorFactory.createAnonymousSequence(faultSequenceElement));
                }
            }
            OMAttribute tgtEndpt = target.getAttribute(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""endpoint""));
            if (tgtEndpt != null) {
                proxy.setTargetEndpoint(tgtEndpt.getAttributeValue());
                isTargetOk = true;
            } else {
                OMElement endpointElement = target.getFirstChildWithName(
                        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint""));
                if (endpointElement != null) {
                    proxy.setTargetInLineEndpoint(
                            EndpointFactory.getEndpointFromElement(endpointElement, true));
                    isTargetOk = true;
                }
            }
            if(!isTargetOk) {
                handleException(""Target of the proxy service must declare "" +
                        ""either an inSequence or endpoint or both"");
            }
        } else {
            handleException(""Target is required for a Proxy service definition"");
        }

        // read the WSDL, Schemas and Policies and set to the proxy service
        OMElement wsdl = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""publishWSDL""));
        if (wsdl != null) {
            OMAttribute wsdlkey = wsdl.getAttribute(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
            if (wsdlkey != null) {
                proxy.setWSDLKey(wsdlkey.getAttributeValue());
            } else {
                OMAttribute wsdlURI = wsdl.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""uri""));
                if (wsdlURI != null) {
                    try {
                        proxy.setWsdlURI(new URI(wsdlURI.getAttributeValue()));
                    } catch (URISyntaxException e) {
                        String msg = ""Error creating uri for proxy service wsdl"";
                        log.error(msg);
                        handleException(msg, e);
                    }
                } else {
                    OMElement wsdl11 = wsdl.getFirstChildWithName(
                            new QName(WSDLConstants.WSDL1_1_NAMESPACE, ""definitions""));
                    if (wsdl11 != null) {
                        proxy.setInLineWSDL(wsdl11);
                    } else {
                        OMElement wsdl20 = wsdl.getFirstChildWithName(
                                new QName(WSDL2Constants.WSDL_NAMESPACE, ""description""));
                        if (wsdl20 != null) {
                            proxy.setInLineWSDL(wsdl20);
                        }
                    }
                }
            }
            proxy.setResourceMap(ResourceMapFactory.createResourceMap(wsdl));
        }

        Iterator policies = elem.getChildrenWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""policy""));
        while (policies.hasNext()) {
            Object o = policies.next();
            if (o instanceof OMElement) {
                OMElement policy = (OMElement) o;
                OMAttribute key = policy.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
                OMAttribute type = policy.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""type""));
                OMAttribute operationName = policy.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""operationName""));
                OMAttribute operationNS = policy.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""operationNamespace""));

                if (key != null) {

                    PolicyInfo pi = new PolicyInfo(key.getAttributeValue());

                    if (type != null && type.getAttributeValue() != null) {
                        if (""in"".equals(type.getAttributeValue())) {
                            pi.setType(PolicyInfo.MESSAGE_TYPE_IN);
                        } else if (""out"".equals(type.getAttributeValue())) {
                            pi.setType(PolicyInfo.MESSAGE_TYPE_OUT);
                        } else {
                            handleException(""Undefined policy type for the policy with key : ""
                                    + key.getAttributeValue());
                        }
                    }

                    if (operationName != null && operationName.getAttributeValue() != null) {
                        if (operationNS != null && operationNS.getAttributeValue() != null) {
                            pi.setOperation(new QName(operationNS.getAttributeValue(),
                                    operationName.getAttributeValue()));
                        } else {
                            pi.setOperation(new QName(operationName.getAttributeValue()));
                        }
                    }

                    proxy.addPolicyInfo(pi);

                } else {
                    handleException(""Policy element does not specify the policy key"");
                }
            } else {
                handleException(""Invalid 'policy' element found under element 'policies'"");
            }
        }

        Iterator props = elem.getChildrenWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter""));
        while (props.hasNext()) {
            Object o = props.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(
                        new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
                OMElement propertyValue = prop.getFirstElement();
                if (pname != null) {
                    if (propertyValue != null) {
                        proxy.addParameter(pname.getAttributeValue(), propertyValue);
                    } else {
                        proxy.addParameter(pname.getAttributeValue(), prop.getText().trim());
                    }
                } else {
                    handleException(""Invalid property specified for proxy service : "" + name);
                }
            } else {
                handleException(""Invalid property specified for proxy service : "" + name);
            }
        }

        if (elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableRM"")) != null) {
            proxy.setWsRMEnabled(true);
        }

        if (elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableSec"")) != null) {
            proxy.setWsSecEnabled(true);
        }

        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

}
"
org/apache/synapse/endpoints/utils/EndpointDefinition.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.utils;

import org.apache.synapse.SynapseConstants;


/**
 * Endpoint definition contains the information about an web services endpoint. It is used by leaf
 * level endpoints to keep these information (e.g. AddressEndpoint and WSDLEndpoint). An
 * EndpointDefinition object is used by only one endpoint and they cannot be looked up in the
 * registry.
 */
public class EndpointDefinition {

    /**
     * The simple address this endpoint resolves to - if explicitly specified
     */
    private String address = null;
    /**
     * Should messages be sent in an WS-RM Sequence ?
     */
    private boolean reliableMessagingOn = false;
    /**
     * Should messages be sent using WS-A?
     */
    private boolean addressingOn = false;
    /**
     * The addressing namespace version
     */
    private String addressingVersion = null;
    /**
     * Should messages be sent using WS-Security?
     */
    private boolean securityOn = false;
    /**
     * The ""key"" for any WS-RM Policy overrides to be used
     */
    private String wsRMPolicyKey = null;
    /**
     * The ""key"" for any Rampart Security Policy to be used
     */
    private String wsSecPolicyKey = null;
    /**
     * use a separate listener - implies addressing is on *
     */
    private boolean useSeparateListener = false;
    /**
     * force REST (POST) on *
     */
    private boolean forcePOX = false;
    /**
     * force REST (GET) on *
     */
    private boolean forceGET = false;
    /**
     * force SOAP11 on *
     */
    private boolean forceSOAP11 = false;
    /**
     * force SOAP11 on *
     */
    private boolean forceSOAP12 = false;
    /**
     * use MTOM *
     */
    private boolean useMTOM = false;
    /**
     * use SWA *
     */
    private boolean useSwa = false;
    /**
     * Endpoint message format. pox/soap11/soap12
     */
    private String format = null;
    
    /**
     * The charset encoding for messages sent to the endpoint.
     */
    private String charSetEncoding;
    
    /**
     * timeout duration for waiting for a response. if the user has set some timeout action and
     * the timeout duration is not set, default is set to 0 seconds. note that if the user has
     * not set any timeout configuration, default timeout action is set to NONE, which won't do
     * anything for timeouts.
     */
    private long timeoutDuration = 0;

    /**
     * action to perform when a timeout occurs (NONE | DISCARD | DISCARD_AND_FAULT) *
     */
    private int timeoutAction = SynapseConstants.NONE;

    /**
     * Leaf level endpoints will be suspended for the specified time by this variable, after a
     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to
     * suspended forever.
     */
    private long suspendOnFailDuration = -1;

    /**
     * To decide to whether statistics should have collected or not
     */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;

    /**
     * The variable that indicate tracing on or off for the current mediator
     */
    private int traceState = SynapseConstants.TRACING_UNSET;

    /**
     * This should return the absolute EPR address referenced by the named endpoint. This may be
     * possibly computed.
     *
     * @return an absolute address to be used to reference the named endpoint
     */
    public String getAddress() {
        return address;
    }

    /**
     * Set an absolute URL as the address for this named endpoint
     *
     * @param address the absolute address to be used
     */
    public void setAddress(String address) {
        this.address = address;
    }

    /**
     * Is RM turned on on this endpoint?
     *
     * @return true if on
     */
    public boolean isReliableMessagingOn() {
        return reliableMessagingOn;
    }

    /**
     * Request that RM be turned on/off on this endpoint
     *
     * @param reliableMessagingOn
     */
    public void setReliableMessagingOn(boolean reliableMessagingOn) {
        this.reliableMessagingOn = reliableMessagingOn;
    }

    /**
     * Is WS-A turned on on this endpoint?
     *
     * @return true if on
     */
    public boolean isAddressingOn() {
        return addressingOn;
    }

    /**
     * Request that WS-A be turned on/off on this endpoint
     *
     * @param addressingOn
     */
    public void setAddressingOn(boolean addressingOn) {
        this.addressingOn = addressingOn;
    }

    /**
     * Get the addressing namespace version
     *
     * @return the adressing version
     */
    public String getAddressingVersion() {
        return addressingVersion;
    }

    /**
     * Set the addressing namespace version
     *
     * @param addressingVersion
     */
    public void setAddressingVersion(String addressingVersion) {
        this.addressingVersion = addressingVersion;
    }

    /**
     * Is WS-Security turned on on this endpoint?
     *
     * @return true if on
     */
    public boolean isSecurityOn() {
        return securityOn;
    }

    /**
     * Request that WS-Sec be turned on/off on this endpoint
     *
     * @param securityOn
     */
    public void setSecurityOn(boolean securityOn) {
        this.securityOn = securityOn;
    }

    /**
     * Return the Rampart Security configuration policys' 'key' to be used (See Rampart)
     *
     * @return the ORampart Security configuration policys' 'key' to be used (See Rampart)
     */
    public String getWsSecPolicyKey() {
        return wsSecPolicyKey;
    }

    /**
     * Set the Rampart Security configuration policys' 'key' to be used (See Rampart)
     *
     * @param wsSecPolicyKey the Rampart Security configuration policys' 'key' to be used
     */
    public void setWsSecPolicyKey(String wsSecPolicyKey) {
        this.wsSecPolicyKey = wsSecPolicyKey;
    }

    /**
     * Get the WS-RM configuration policys' 'key' to be used
     *
     * @return the WS-RM configuration policys' 'key' to be used
     */
    public String getWsRMPolicyKey() {
        return wsRMPolicyKey;
    }

    /**
     * Set the WS-RM configuration policys' 'key' to be used
     *
     * @param wsRMPolicyKey the WS-RM configuration policys' 'key' to be used
     */
    public void setWsRMPolicyKey(String wsRMPolicyKey) {
        this.wsRMPolicyKey = wsRMPolicyKey;
    }

    public void setUseSeparateListener(boolean b) {
        this.useSeparateListener = b;
    }

    public boolean isUseSeparateListener() {
        return useSeparateListener;
    }

    public void setForcePOX(boolean forcePOX) {
        this.forcePOX = forcePOX;
    }

    public boolean isForcePOX() {
        return forcePOX;
    }

    public boolean isForceGET() {
        return forceGET;
    }

    public void setForceGET(boolean forceGET) {
        this.forceGET = forceGET;
    }

    public void setForceSOAP11(boolean forceSOAP11) {
        this.forceSOAP11 = forceSOAP11;
    }

    public boolean isForceSOAP11() {
        return forceSOAP11;
    }

    public void setForceSOAP12(boolean forceSOAP12) {
        this.forceSOAP12 = forceSOAP12;
    }

    public boolean isForceSOAP12() {
        return forceSOAP12;
    }

    public boolean isUseMTOM() {
        return useMTOM;
    }

    public void setUseMTOM(boolean useMTOM) {
        this.useMTOM = useMTOM;
    }

    public boolean isUseSwa() {
        return useSwa;
    }

    public void setUseSwa(boolean useSwa) {
        this.useSwa = useSwa;
    }

    public long getTimeoutDuration() {
        return timeoutDuration;
    }

    /**
     * Set the timeout duration.
     * 
     * @param timeoutDuration a duration in milliseconds
     */
    public void setTimeoutDuration(long timeoutDuration) {
        this.timeoutDuration = timeoutDuration;
    }

    public int getTimeoutAction() {
        return timeoutAction;
    }

    public void setTimeoutAction(int timeoutAction) {
        this.timeoutAction = timeoutAction;
    }

    public String getFormat() {
        return format;
    }

    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * Get the charset encoding for messages sent to the endpoint.
     *
     * @return charSetEncoding
     */
    public String getCharSetEncoding() {
        return charSetEncoding;
    }

    /**
     * Set the charset encoding for messages sent to the endpoint.
     * 
     * @param charSetEncoding the charset encoding or <code>null</code> 
     */
    public void setCharSetEncoding(String charSetEncoding) {
        this.charSetEncoding = charSetEncoding;
    }

    /**
     * Get the suspend on fail duration.
     *
     * @return suspendOnFailDuration
     */
    public long getSuspendOnFailDuration() {
        return suspendOnFailDuration;
    }

    /**
     * Set the suspend on fail duration.
     *
     * @param suspendOnFailDuration a duration in milliseconds
     */
    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
        this.suspendOnFailDuration = suspendOnFailDuration;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState Indicates whether statictics is enable or not
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    public int getTraceState() {
        return traceState;
    }

    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }
}
"
org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.builtin.LogMediator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.util.Iterator;

public class SynapseXMLConfigurationFactory implements ConfigurationFactory {
    
    private static Log log = LogFactory.getLog(SynapseXMLConfigurationFactory.class);

    public SynapseConfiguration getConfiguration(OMElement definitions) {
        
        if (!definitions.getQName().equals(XMLConfigConstants.DEFINITIONS_ELT)) {
            throw new SynapseException(
                    ""Wrong QName for this config factory "" + definitions.getQName());
        }

        SynapseConfiguration config = new SynapseConfiguration();
        config.setDefaultQName(definitions.getQName());

        SequenceMediator rootSequence = new SequenceMediator();
        rootSequence.setName(org.apache.synapse.SynapseConstants.MAIN_SEQUENCE_KEY);

        Iterator iter = definitions.getChildren();
        
        while (iter.hasNext()) {
            Object o = iter.next();
            if (o instanceof OMElement) {
                OMElement elt = (OMElement) o;
                if (XMLConfigConstants.SEQUENCE_ELT.equals(elt.getQName())) {
                    String key = elt.getAttributeValue(
                            new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
                    // this could be a sequence def or a mediator of the main sequence
                    if (key != null) {
                        Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                        rootSequence.addChild(m);
                    } else {
                        defineSequence(config, elt);
                    }
                } else if (XMLConfigConstants.ENDPOINT_ELT.equals(elt.getQName())) {
                    defineEndpoint(config, elt);
                } else if (XMLConfigConstants.ENTRY_ELT.equals(elt.getQName())) {
                    defineEntry(config, elt);
                } else if (XMLConfigConstants.PROXY_ELT.equals(elt.getQName())) {
                    defineProxy(config, elt);
                } else if (XMLConfigConstants.REGISTRY_ELT.equals(elt.getQName())) {
                    defineRegistry(config, elt);
                } else if (XMLConfigConstants.TASK_ELT.equals(elt.getQName())) {
                    defineStartup(config, elt);
                } else {
                    Mediator m = MediatorFactoryFinder.getInstance().getMediator(elt);
                    rootSequence.addChild(m);
                }
            }
        }

        if (config.getLocalRegistry().isEmpty() && config.getProxyServices().isEmpty() &&
                rootSequence.getList().isEmpty() && config.getRegistry() != null) {
            OMNode remoteConfigNode = config.getRegistry().lookup(""synapse.xml"");
            try {
                config = XMLConfigurationBuilder.getConfiguration(SynapseConfigUtils
                    .getStreamSource(remoteConfigNode).getInputStream());
            } catch (XMLStreamException xse) {
                throw new SynapseException(""Problem loading remote synapse.xml "", xse);
            }

        }

        // if there is no sequence named main defined locally look for the set of mediators in
        // the root level before trying to look in the registry (hence config.getMainSequence
        // can not be used here)
        if (!config.getLocalRegistry().containsKey(SynapseConstants.MAIN_SEQUENCE_KEY)) {
            // if the root tag does not contain any mediators & registry does not have a
            // entry with key main then use the defualt main sequence
            if (rootSequence.getList().isEmpty() && config.getMainSequence() == null) {
                setDefaultMainSequence(config);
            } else {
                config.addSequence(rootSequence.getName(), rootSequence);
            }
        } else if (!rootSequence.getList().isEmpty()) {
            handleException(""Invalid Synapse Configuration : Conflict in resolving the \""main\"" "" +
                    ""mediator\n\tSynapse Configuration cannot have sequence named \""main\"" and "" +
                    ""toplevel mediators simultaniously"");
        }

        if (config.getFaultSequence() == null) {
            setDefaultFaultSequence(config);
        }

        return config;
    }

    private static void defineRegistry(SynapseConfiguration config, OMElement elem) {
        if (config.getRegistry() != null) {
            handleException(""Only one remote registry can be defined within a configuration"");
        }
        config.setRegistry(RegistryFactory.createRegistry(elem));
    }

    private static void defineStartup(SynapseConfiguration config, OMElement elem) {
        Startup startup = StartupFinder.getInstance().getStartup(elem);
        if (config.getStartup(startup.getName()) != null) {
            handleException(""Duplicate startup with name : "" + startup.getName());
        }
        config.addStartup(startup);
    }

    private static void defineProxy(SynapseConfiguration config, OMElement elem) {
        ProxyService proxy = ProxyServiceFactory.createProxy(elem);
        if (config.getProxyService(proxy.getName()) != null) {
            handleException(""Duplicate proxy service with name : "" + proxy.getName());
        }
        config.addProxyService(proxy.getName(), proxy);
    }

    private static void defineEntry(SynapseConfiguration config, OMElement elem) {
        Entry entry = EntryFactory.createEntry(elem);
        if (config.getLocalRegistry().get(entry.getKey()) != null) {
            handleException(""Duplicate registry entry definition for key : "" + entry.getKey());
        }
        config.addEntry(entry.getKey(), entry);
    }

    public static void defineSequence(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name) != null) {
                handleException(""Duplicate sequence definition : "" + name);
            }
            Mediator mediator = MediatorFactoryFinder.getInstance().getMediator(ele);
            config.addSequence(name, mediator);
            // mandatory sequence is treated as a speciall sequence because it will be fetched for
            // each and every message and keeps a direct reference to that from the configuration
            // this also limits the ability of the mandatory sequence to be dynamic
            if (SynapseConstants.MANDATORY_SEQUENCE_KEY.equals(name)) {
                config.setMandatorySequence(mediator);
            }
        } else {
            handleException(""Invalid sequence definition without a name"");
        }
    }

    public static void defineEndpoint(SynapseConfiguration config, OMElement ele) {

        String name = ele.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
        if (name != null) {
            if (config.getLocalRegistry().get(name.trim()) != null) {
                handleException(""Duplicate endpoint definition : "" + name);
            }
            Endpoint endpoint = EndpointFactory.getEndpointFromElement(ele, false);
            config.addEndpoint(name.trim(), endpoint);
        } else {
            handleException(""Invalid endpoint definition without a name"");
        }
    }

    /**
     * Return the main sequence if one is not defined. This implementation defaults to
     * a simple sequence with a <send/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultMainSequence(SynapseConfiguration config) {
        SequenceMediator main = new SequenceMediator();
        main.setName(SynapseConstants.MAIN_SEQUENCE_KEY);
        main.addChild(new LogMediator());
        main.addChild(new DropMediator());
        config.addSequence(SynapseConstants.MAIN_SEQUENCE_KEY, main);
    }

    /**
     * Return the fault sequence if one is not defined. This implementation defaults to
     * a simple sequence :
     * <log level=""full"">
     *   <property name=""MESSAGE"" value=""Executing default ""fault"" sequence""/>
     *   <property name=""ERROR_CODE"" expression=""get-property('ERROR_CODE')""/>
     *   <property name=""ERROR_MESSAGE"" expression=""get-property('ERROR_MESSAGE')""/>
     * </log>
     * <drop/>
     *
     * @param config the configuration to be updated
     */
    private static void setDefaultFaultSequence(SynapseConfiguration config) {
        SequenceMediator fault = new SequenceMediator();
        fault.setName(org.apache.synapse.SynapseConstants.FAULT_SEQUENCE_KEY);
        LogMediator log = new LogMediator();
        log.setLogLevel(LogMediator.FULL);

        MediatorProperty mp = new MediatorProperty();
        mp.setName(""MESSAGE"");
        mp.setValue(""Executing default \""fault\"" sequence"");
        log.addProperty(mp);

        mp = new MediatorProperty();
        mp.setName(""ERROR_CODE"");
        try {
            mp.setExpression(new SynapseXPath(""get-property('ERROR_CODE')""));
        } catch (JaxenException ignore) {}
        log.addProperty(mp);

        mp = new MediatorProperty();
        mp.setName(""ERROR_MESSAGE"");
        try {
            mp.setExpression(new SynapseXPath(""get-property('ERROR_MESSAGE')""));
        } catch (JaxenException ignore) {}
        log.addProperty(mp);

        fault.addChild(log);
        fault.addChild(new DropMediator());
        config.addSequence(org.apache.synapse.SynapseConstants.FAULT_SEQUENCE_KEY, fault);
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }


    public QName getTagQName() {

        return XMLConfigConstants.DEFINITIONS_ELT;
    }

    public Class getSerializerClass() {
        return SynapseXMLConfigurationSerializer.class;
    }

}
"
org/apache/synapse/util/xpath/SynapseXPath.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.xpath;

import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.impl.llom.OMDocumentImpl;
import org.apache.axiom.om.impl.llom.OMElementImpl;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.jaxen.*;
import org.jaxen.util.SingletonList;

import java.util.List;

/**
 * <p>XPath that has been used inside Synapse xpath processing. This has a extension function named
 * <code>get-property</code> which is use to retrieve message context properties with the given
 * name from the function</p>
 *
 * <p>For example the following function <code>get-property('prop')</code> can be evaluatedd using
 * an XPath to retrieve the message context property value with the name <code>prop</code>.</p>
 *
 * <p>Apart from that this XPath has a certain set of XPath variables associated with it. They are
 * as follows;
 * <dl>
 *   <dt><tt>body</tt></dt>
 *   <dd>The SOAP 1.1 or 1.2 body element.</dd>
 *   <dt><tt>header</tt></dt>
 *   <dd>The SOAP 1.1 or 1.2 header element.</dd>
 * </dl>
 * </p>
 *
 * <p>Also there are some XPath prefixes defined in <code>SynapseXPath</code> to access various
 * properties using XPath variables, where the variable name represents the particular prefix and
 * the property name as the local part of the variable. Those variables are;
 * <dl>
 *   <dt><tt>ctx</tt></dt>
 *   <dd>Prefix for Synapse MessageContext properties</dd>
 *   <dt><tt>axis2</tt></dt>
 *   <dd>Prefix for Axis2 MessageContext properties</dd>
 *   <dt><tt>trp</tt></dt>
 *   <dd>Prefix for the transport headers</dd>
 * </dl>
 * </p>
 *
 * <p>This XPath is Thread Safe, and provides a special set of evaluate functions for the
 * <code>MessageContext</code> and <code>SOAPEnvelope</code> as well as a method to retrieve
 * string values of the evaluated XPaths</p>
 *
 * @see org.apache.axiom.om.xpath.AXIOMXPath
 * @see #getContext(Object)
 * @see org.apache.synapse.util.xpath.SynapseXPathFunctionContext
 * @see org.apache.synapse.util.xpath.SynapseXPathVariableContext
 */
public class SynapseXPath extends AXIOMXPath {
    private static final long serialVersionUID = 7639226137534334222L;
    
    private static final Log log = LogFactory.getLog(SynapseXPath.class);

    /**
     * <p>Initializes the <code>SynapseXPath</code> with the given <code>xpathString</code> as the
     * XPath</p>
     *
     * @param xpathString xpath in its string format
     * @throws JaxenException in case of an initialization failure
     */
    public SynapseXPath(String xpathString) throws JaxenException {
        super(xpathString);
    }

    /**
     * <P>Evaluates the XPath expression against the MessageContext of the current message and
     * returns a String representation of the result</p>
     *
     * @param synCtx the source message which holds the MessageContext against full context
     * @return a String representation of the result of evaluation
     */
    public String stringValueOf(MessageContext synCtx) {

        try {

            Object result = evaluate(synCtx);

            if (result == null) {
                return null;
            }

            StringBuffer textValue = new StringBuffer();
            if (result instanceof List) {

                List list = (List) result;
                for (Object o : list) {

                    if (o == null && list.size() == 1) {
                        return null;
                    }

                    if (o instanceof OMTextImpl) {
                        textValue.append(((OMTextImpl) o).getText());
                    } else if (o instanceof OMElementImpl) {

                        String s = ((OMElementImpl) o).getText();

                        if (s.trim().length() == 0) {
                            s = o.toString();
                        }
                        textValue.append(s);

                    } else if (o instanceof OMDocumentImpl) {

                        textValue.append(
                            ((OMDocumentImpl) o).getOMDocumentElement().toString());
                    }
                }

            } else {
                textValue.append(result.toString());
            }

            return textValue.toString();

        } catch (JaxenException je) {
            handleException(""Evaluation of the XPath expression "" + this.toString() +
                "" resulted in an error"", je);
        }

        return null;
    }

    public void addNamespace(OMNamespace ns) throws JaxenException {
        addNamespace(ns.getPrefix(), ns.getNamespaceURI());
    }

    /**
     * Create a {@link Context} wrapper for the provided object.
     * This methods implements the following class specific behavior:
     * <dl>
     *   <dt>{@link MessageContext}</dt>
     *   <dd>The XPath expression is evaluated against the SOAP envelope
     *       and the functions and variables defined by
     *       {@link SynapseXPathFunctionContext} and
     *       {@link SynapseXPathVariableContext} are
     *       available.</dd>
     *   <dt>{@link SOAPEnvelope}</dt>
     *   <dd>The variables defined by {@link SynapseXPathVariableContext}
     *       are available.</dd>
     * </dl>
     * For all other object types, the behavior is identical to
     * {@link BaseXPath#getContext(Object)}.
     * <p>
     * Note that the behavior described here also applies to all evaluation
     * methods such as {@link #evaluate(Object)} or {@link #selectSingleNode(Object)},
     * given that these methods all use {@link #getContext(Object)}.
     * 
     * @see SynapseXPathFunctionContext#getFunction(String, String, String)
     * @see SynapseXPathVariableContext#getVariableValue(String, String, String)
     */
    @Override
    protected Context getContext(Object obj) {
        if (obj instanceof MessageContext) {
            MessageContext synCtx = (MessageContext)obj;
            ContextSupport baseContextSupport = getContextSupport();
            ContextSupport contextSupport =
                new ContextSupport(baseContextSupport.getNamespaceContext(),
                                   new SynapseXPathFunctionContext(baseContextSupport.getFunctionContext(), synCtx),
                                   new SynapseXPathVariableContext(baseContextSupport.getVariableContext(), synCtx),
                                   baseContextSupport.getNavigator());
            Context context = new Context(contextSupport);
            context.setNodeSet(new SingletonList(synCtx.getEnvelope()));
            return context;
        } else if (obj instanceof SOAPEnvelope) {
            SOAPEnvelope env = (SOAPEnvelope)obj;
            ContextSupport baseContextSupport = getContextSupport();
            ContextSupport contextSupport =
                new ContextSupport(baseContextSupport.getNamespaceContext(),
                                   baseContextSupport.getFunctionContext(),
                                   new SynapseXPathVariableContext(baseContextSupport.getVariableContext(), env),
                                   baseContextSupport.getNavigator());
            Context context = new Context(contextSupport);
            context.setNodeSet(new SingletonList(env));
            return context;
        } else {
            return super.getContext(obj);
        }
    }

    private void handleException(String msg, Throwable e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}"
org/apache/synapse/config/xml/SynapseMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SynapseMediator;

/**
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SynapseMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SynapseMediator mediator = (SynapseMediator) m;
        OMElement rules = fac.createOMElement(""rules"", synNS);
        saveTracingState(rules,mediator);

        serializeChildren(rules, mediator.getList());

        if (parent != null) {
            parent.addChild(rules);
        }
        return rules;
    }

    public String getMediatorClassName() {
        return SynapseMediator.class.getName();
    }
}
"
org/apache/synapse/core/axis2/ResourceMap.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.xml.sax.InputSource;

import javax.xml.stream.XMLStreamException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A resource map.
 * 
 * Instances of this class are used to resolve resources using registry entries.
 * This is useful for XML documents that can reference other documents (e.g. WSDL documents
 * importing XSD or other WSDL documents). A <code>ResourceMap</code> object contains a set of
 * (location, registry key) mappings. The <code>resolve</code> method can be used to
 * get retrieve the registry entry registered for a given location as an {@link InputSource}
 * object.
 */
public class ResourceMap {
    private static final Log log = LogFactory.getLog(ResourceMap.class);
    
    private final Map<String,String> resources = new LinkedHashMap<String,String>();
    
    /**
     * Add a resource.
     * 
     * @param location the location as it appears in referencing documents
     * @param key the registry key that points to the referenced document
     */
    public void addResource(String location, String key) {
        resources.put(location, key);
    }
    
    /**
     * Get the (location, registry key) mappings.
     * 
     * @return a map containing the (location, registry key) pairs
     */
    public Map<String,String> getResources() {
        return Collections.unmodifiableMap(resources);
    }
    
    /**
     * Resolve a resource for a given location.
     * 
     * @param synCfg the Synapse configuration (used to access the registry)
     * @param location the location of of the resource at is appears in the referencing document
     * @return an <code>InputSource</code> object for the referenced resource
     */
    public InputSource resolve(SynapseConfiguration synCfg, String location) {
        String key = (String)resources.get(location);
        if (key == null) {
            if (log.isDebugEnabled()) {
                log.debug(""No resource mapping is defined for location '"" + location + ""'"");
            }
            return null;
        } else {
            if (log.isDebugEnabled()) {
                log.debug(""Resolving location '"" + location + ""' to registry item '"" + key + ""'"");
            }
            synCfg.getEntryDefinition(key);
            Object keyObject = synCfg.getEntry(key);
            if (keyObject instanceof OMElement) {
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                try {
                    ((OMElement)keyObject).serialize(baos);
                }
                catch (XMLStreamException ex) {
                    String msg = ""Unable to serialize registry item '"" + key + ""' for location '"" +
                        location + ""'"";
                    log.error(msg);
                    throw new SynapseException(msg, ex);
                }
                return new InputSource(new ByteArrayInputStream(baos.toByteArray()));
            } else {
                String msg = ""Registry item '"" + key + ""' for location '"" +
                    location + ""' is not an OMElement"";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }
}
"
org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import javax.xml.namespace.QName;

public class SoapSessionDispatcher implements Dispatcher {

    private static final Log log = LogFactory.getLog(SoapSessionDispatcher.class);

    private static final QName QNAME_SERVICE_GROUP_ID
            = new QName(""http://ws.apache.org/namespaces/axis2"", ""ServiceGroupId"", ""axis2"");

    /**
     * Gives the endpoint based on the service group context ID of the request message.
     *
     * @param synCtx Request MessageContext, possibly containing a service group context ID.
     * @return Endpoint associated with the soap session, if current message is a soap session
     *         message and if current message is not the first message of the session. Returns null,
     *         if an Endpoint could not be found for the session.
     */
    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {

        Endpoint endpoint = null;
        SOAPHeader header = synCtx.getEnvelope().getHeader();
        
        if (header != null) {
            OMElement sgcElm = header.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);

            if (sgcElm != null) {
                String sgcID = sgcElm.getText();

                if (sgcID != null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Using the ServiceGroupId SOAP header value ""
                                + sgcID + "" to retrieve endpoint on the session"");
                    }
                    endpoint = dispatcherContext.getEndpoint(sgcID);
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find the ServiceQroupId SOAP "" +
                        ""header to retrieve the endpoint on the session"");
            }
        }

        return endpoint;
    }

    /**
     * As this is a server initiated session, this method will only be called for response messages.
     * It extracts the service group context ID (if available) from the message and updates the
     * session (service group context ID) -> endpoint map.
     *
     * @param synCtx   MessageContext of the response message.
     * @param endpoint Endpoint to associate with the session.
     */
    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
        Endpoint endpoint) {

        if (endpoint == null || dispatcherContext == null) {
            return;
        }
        // get the service group context id
        // check if service group context id is a key of any entry
        // if not, add an entry <service group context id, endpoint>


        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if (header != null) {
            OMElement replyTo = header.getFirstChildWithName(
                    AddressingConstants.Final.QNAME_WSA_REPLY_TO);

            if (replyTo != null) {
                OMElement referenceParameters = replyTo.getFirstChildWithName(new QName(
                        ""http://www.w3.org/2005/08/addressing"", ""ReferenceParameters"", ""wsa""));

                if (referenceParameters != null) {
                    OMElement sgcElm
                            = referenceParameters.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);

                    if (sgcElm != null) {
                        // synchronized to avoid possible replacement of sessions
                        String sgcID = sgcElm.getText();

                        if (sgcID != null) {
                            if (log.isDebugEnabled()) {
                                log.debug(""Using the ServiceGroupId value ""
                                        + sgcID + "" to update the endpoint session"");
                            }
                            dispatcherContext.setEndpoint(sgcID, endpoint);
                        }
                    } else if (log.isDebugEnabled()) {
                        log.debug(""Couldn't find the WSA ServiceQroupId on the "" +
                                ""ReferenceParameters of the Reply-To header to update the session"");
                    }
                } else if (log.isDebugEnabled()) {
                    log.debug(""Couldn't find the WSA ReferenceParameters in the Reply-To "" +
                            ""header to retrieve the ServiceQroupId"");
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find the WSA Reply-To header to retrieve the ServiceQroupId"");
            }
        }
    }

    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if (header != null) {
            OMElement sgcIDElm = header.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);

            if (sgcIDElm != null) {
                String sgcID = sgcIDElm.getText();

                if (sgcID != null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Using the ServiceGroupId value ""
                                + sgcID + "" to unbind session"");
                    }
                    dispatcherContext.removeSession(sgcID);
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find the ServiceQroupId SOAP header to unbind the session"");
            }
        }
    }

    /**
     * Soap session is initiated by the server. So this method always returns true.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/mediators/base/SequenceMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;

import java.util.Stack;

/**
 * The Sequence mediator either refers to a named Sequence mediator instance
 * or is a *Named* list/sequence of other (child) Mediators
 * <p/>
 * If this instance defines a sequence mediator, then the name is required, and
 * an errorHandler sequence name optional. If this instance refers to another (defined)
 * sequence mediator, the errorHandler will not have a meaning, and if an error in
 * encountered in the referred sequence, its errorHandler would execute.
 */
public class SequenceMediator extends AbstractListMediator {

    /** The name of the this sequence */
    private String name = null;
    /** The local registry key which is used to pick a sequence definition*/
    private String key = null;
    /** The name of the error handler which is used to handle error during the mediation */
    private String errorHandler = null;
    /** is this definition dynamic */
    private boolean dynamic = false;
    /** flag to ensure that each and every sequence is initialized and destroyed atmost once */
    private boolean initialized = false;
    /** the registry key to load this definition if dynamic */
    private String registryKey = null;

    /** To decide to whether statistics should have collected or not  */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;

    /**
     * If this mediator refers to another named Sequence, execute that. Else
     * execute the list of mediators (children) contained within this. If a referenced
     * named sequence mediator instance cannot be found at runtime, an exception is
     * thrown. This may occur due to invalid configuration of an erroneous runtime
     * change of the synapse configuration. It is the responsibility of the
     * SynapseConfiguration builder to ensure that dead references are not present.
     *
     * @param synCtx the synapse message
     * @return as per standard mediator result
     */
    public boolean mediate(MessageContext synCtx) {

        boolean statsOn = SynapseConstants.STATISTICS_ON == statisticsState;
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Sequence ""
                + (name == null ? (key == null ? ""<anonymous"" : ""key=<"" + key) : ""<"" + name) + "">"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (key == null) {

            // The onError sequence for handling errors which may occur during the
            // mediation through this sequence
            Mediator errorHandlerMediator = null;

            // Setting Required property to collect the sequence statistics
            if (statsOn) {
                StatisticsStack sequenceStack = (StatisticsStack)
                    synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
                if (sequenceStack == null) {
                    sequenceStack = new SequenceStatisticsStack();
                    synCtx.setProperty(SynapseConstants.SEQUENCE_STATS, sequenceStack);
                }
                String seqName = (name == null ? SynapseConstants.ANONYMOUS_SEQUENCE : name);
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                sequenceStack.put(seqName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statsOn, isFault);
            }
            try {

                // push the errorHandler sequence into the current message as the fault handler
                if (errorHandler != null) {
                    errorHandlerMediator = synCtx.getSequence(errorHandler);

                    if (errorHandlerMediator != null) {
                        if (traceOrDebugOn) {
                            traceOrDebug(traceOn, ""Setting the onError handler : "" +
                                errorHandler + "" for the sequence : "" + name);
                        }
                        synCtx.pushFaultHandler(
                                new MediatorFaultHandler(errorHandlerMediator));
                    } else {
                        auditWarn(""onError handler : "" + errorHandler + "" for sequence : "" +
                            name + "" cannot be found"", synCtx);
                    }
                }

                boolean result = super.mediate(synCtx);

                // if we pushed an error handler, pop it from the fault stack
                // before we exit normally without an exception
                if (errorHandlerMediator != null) {
                    Stack faultStack = synCtx.getFaultStack();
                    if (faultStack != null && !faultStack.isEmpty()) {
                        Object o = faultStack.peek();

                        if (o instanceof MediatorFaultHandler &&
                            errorHandlerMediator.equals(
                                ((MediatorFaultHandler) o).getFaultMediator())) {
                            faultStack.pop();
                        }
                    }
                }

                if (traceOrDebugOn) {
                    if (traceOn && trace.isTraceEnabled()) {
                        trace.trace(""Message : "" + synCtx.getEnvelope());
                    }

                    traceOrDebug(traceOn,
                        ""End : Sequence <"" + (name == null ? ""anonymous"" : name) + "">"");
                }

                return result;

            } finally {

                //If this sequence is finished it's task normally
                if (statsOn) {
                    StatisticsUtils.processSequenceStatistics(synCtx);
                }
                //If this sequence is a IN or OUT sequence of a proxy service
                StatisticsUtils.processProxyServiceStatistics(synCtx);
            }

        } else {

            Mediator m = synCtx.getSequence(key);
            if (m == null) {
                handleException(""Sequence named "" + key + "" cannot be found"", synCtx);

            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Executing with key "" + key);
                }

                boolean result = m.mediate(synCtx);

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""End : Sequence key=<"" + key + "">"");
                }
                return result;
            }
        }

        return false;
    }

    /**
     * This method will ensure that each and every sequence wil only be initialized atmost once
     * @param se - enviorenment to be initialized
     */
    public synchronized void init(SynapseEnvironment se) {
        if (!initialized) {
            super.init(se);
            initialized = true;
        }
    }

    public synchronized void destroy() {
        if (initialized) {
            super.destroy();
            initialized = false;
        }
    }

    /**
     * To get the name of the sequence
     * @return the name of the sequence
     */
    public String getName() {
        return name;
    }

    /**
     * setting the name of the sequence
     * @param name the name of the this sequence
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * To get the key which is used to pick the sequence definition from the local registry
     * @return  return the key which is used to pick the sequence definition from the local registry
     */
    public String getKey() {
        return key;
    }

    /**
     * To set the local registry key in order to pick the sequence definition
     * @param key the local registry key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     *
     * @return  Returns the errorhandler sequence name
     */
    public String getErrorHandler() {
        return errorHandler;
    }

    /**
     *
     * @param errorHandler to used handle error will appear during the
     *        mediation through this sequence
     */
    public void setErrorHandler(String errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState  To indicate statistics collecting state
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    /**
     * Is this a dynamic sequence?
     * @return true if dynamic
     */
    public boolean isDynamic() {
        return dynamic;
    }

    /**
     * Mark this as a dynamic sequence
     * @param dynamic true if this is a dynamic sequence
     */
    public void setDynamic(boolean dynamic) {
        this.dynamic = dynamic;
    }

    /**
     * Return the registry key used to load this sequence dynamically
     * @return  registry key
     */
    public String getRegistryKey() {
        return registryKey;
    }

    /**
     * To get the registry key used to load this sequence dynamically
     * @param registryKey  returns the registry key which point to this sequence
     */
    public void setRegistryKey(String registryKey) {
        this.registryKey = registryKey;
    }
}
"
org/apache/synapse/startup/Task.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup;

/**
 * Defines the Task for a SimpleQuartzStartup.
 */
public interface Task {

    /**
     * Execute method will be invoked by the SimpleQuartzStartup.
     */
    public void execute();
}
"
org/apache/synapse/config/xml/LogMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import javax.xml.namespace.QName;

/**
 * Created a Log mediator that logs messages using commons-logging.
 *
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorFactory extends AbstractMediatorFactory  {

    private static final QName LOG_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""log"");
    private static final String SIMPLE  = ""simple"";
    private static final String HEADERS = ""headers"";
    private static final String FULL    = ""full"";
    private static final String CUSTOM  = ""custom"";
    private static final QName ATT_LEVEL = new QName(""level"");
    private static final QName ATT_SEPERATOR = new QName(""separator"");

    public QName getTagQName() {
        return LOG_Q;
    }

    public Mediator createMediator(OMElement elem) {

        LogMediator logMediator = new LogMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(logMediator,elem);
        
        // Set the high level set of properties to be logged (i.e. log level)
        OMAttribute level = elem.getAttribute(ATT_LEVEL);
        if (level != null) {
            String levelstr = level.getAttributeValue();
            if (SIMPLE.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.SIMPLE);
            } else if (HEADERS.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.HEADERS);
            } else if (FULL.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.FULL);
            } else if (CUSTOM.equals(levelstr)) {
                logMediator.setLogLevel(LogMediator.CUSTOM);
            }
        }

        // check if a custom separator has been supplied, if so use it
        OMAttribute separator = elem.getAttribute(ATT_SEPERATOR);
        if (separator != null) {
            logMediator.setSeparator(separator.getAttributeValue());
        }

        logMediator.addAllProperties(MediatorPropertyFactory.getMediatorProperties(elem));

        return logMediator;
    }
}
"
org/apache/synapse/mediators/transform/FaultMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMDocument;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.soap.*;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.xpath.SynapseXPath;

import javax.xml.namespace.QName;
import java.net.URI;
import java.util.Iterator;

/**
 * This transforms the current message instance into a SOAP Fault message. The
 * SOAP version for the fault message could be explicitly specified. Else if the
 * original message was SOAP 1.1 the fault will also be SOAP 1.1 else, SOAP 1.2
 *
 * This class exposes methods to set SOAP 1.1 and 1.2 fault elements and uses
 * these as required.
 *
 * Directs the fault messages' ""To"" EPR to the ""FaultTo"" or the ""ReplyTo"" or to
 * null of the original SOAP message
 */
public class FaultMediator extends AbstractMediator {

    public static final String WSA_ACTION = ""Action"";
    /** Make a SOAP 1.1 fault */
    public static final int SOAP11 = 1;
    /** Make a SOAP 1.2 fault */
    public static final int SOAP12 = 2;
    /** Make a POX fault */
    public static final int POX = 3;
    /** Holds the SOAP version to be used to make the fault, if specified */
    private int soapVersion;

    // -- fault elements --
    /** The fault code QName to be used */
    private QName faultCodeValue = null;
    /** An XPath expression that will give the fault code QName at runtime */
    private SynapseXPath faultCodeExpr = null;
    /** The fault reason to be used */
    private String faultReasonValue = null;
    /** An XPath expression that will give the fault reason string at runtime */
    private SynapseXPath faultReasonExpr = null;
    /** The fault node URI to be used */
    private URI faultNode = null;
    /** The fault role URI to be used - if applicable */
    private URI faultRole = null;
    /** The fault detail to be used */
    private String faultDetail = null;
    /** An XPath expression that will give the fault code QName at runtime */    
    private SynapseXPath faultDetailExpr = null;

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Fault mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        switch (soapVersion) {
            case SOAP11:
                return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
            case SOAP12:
                return makeSOAPFault(synCtx, SOAP12, traceOrDebugOn, traceOn);
            case POX:
                return makePOXFault(synCtx, traceOrDebugOn, traceOn);

            default : {
                // if this is a POX or REST message then make a POX fault
                if (synCtx.isDoingPOX() || synCtx.isDoingGET()) {
                    
                    return makePOXFault(synCtx, traceOrDebugOn, traceOn);

                } else {
                    
                    // determine from current message's SOAP envelope namespace
                    SOAPEnvelope envelop = synCtx.getEnvelope();
                    if (envelop != null) {
                        
                        if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                            envelop.getNamespace().getNamespaceURI())) {

                            soapVersion = SOAP12;
                            return makeSOAPFault(synCtx, SOAP12, traceOrDebugOn, traceOn);

                        } else {
                            soapVersion = SOAP11;
                            return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
                        }
                        
                    } else {
                        // default to SOAP 11
                        return makeSOAPFault(synCtx, SOAP11, traceOrDebugOn, traceOn);
                    }
                }
            }
        }
    }

    private boolean makePOXFault(MessageContext synCtx, boolean traceOrDebugOn, boolean traceOn) {

        OMFactory fac = synCtx.getEnvelope().getOMFactory();
        OMElement faultPayload = fac.createOMElement(new QName(""Exception""));

        if (faultDetail != null) {

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting the fault detail : ""
                    + faultDetail + "" as the POX Fault"");
            }

            faultPayload.setText(faultDetail);

        } else if (faultDetailExpr != null) {

            String faultDetail = faultDetailExpr.stringValueOf(synCtx);

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting the fault detail : ""
                        + faultDetail + "" as the POX Fault"");
            }

            faultPayload.setText(faultDetail);
            
        } else if (faultReasonValue != null) {

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting the fault reason : ""
                    + faultReasonValue + "" as the POX Fault"");
            }

            faultPayload.setText(faultReasonValue);

        } else if (faultReasonExpr != null) {

            String faultReason = faultReasonExpr.stringValueOf(synCtx);
            faultPayload.setText(faultReason);

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting the fault reason : ""
                    + faultReason + "" as the POX Fault"");
            }
        }

        SOAPBody body = synCtx.getEnvelope().getBody();
        if (body != null) {

            if (body.getFirstElement() != null) {
                body.getFirstElement().detach();
            }

            synCtx.setFaultResponse(true);
            ((Axis2MessageContext) synCtx).getAxis2MessageContext().setProcessingFault(true);

            if (traceOrDebugOn) {
                String msg = ""Original SOAP Message : "" + synCtx.getEnvelope().toString() +
                    ""POXFault Message created : "" + faultPayload.toString();
                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(msg);
                }
                if (log.isTraceEnabled()) {
                    log.trace(msg);
                }
            }
            
            body.addChild(faultPayload);
        }

        return true;
    }

    /**
     * Actual transformation of the current message into a fault message
     * @param synCtx the current message context
     * @param soapVersion SOAP version of the resulting fault desired
     * @param traceOrDebugOn is trace or debug logging on?
     * @param traceOn is tracing on?
     * @return true, always
     */
    private boolean makeSOAPFault(MessageContext synCtx, int soapVersion,
        boolean traceOrDebugOn, boolean traceOn) {

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Creating a SOAP ""
                    + (soapVersion == SOAP11 ? ""1.1"" : ""1.2"") + "" fault"");
        }

        // get the correct SOAP factory to be used
        SOAPFactory factory = (soapVersion == SOAP11 ?
                OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory());

        // create the SOAP fault document and envelope
        OMDocument soapFaultDocument = factory.createOMDocument();
        SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();
        soapFaultDocument.addChild(faultEnvelope);

        // create the fault element  if it is need
        SOAPFault fault = faultEnvelope.getBody().getFault();
        if(fault == null){
            fault = factory.createSOAPFault();
        }

        // populate it
        setFaultCode(synCtx, factory, fault);
        setFaultResaon(synCtx, factory, fault);
        setFaultNode(factory, fault);
        setFaultRole(factory, fault);
        setFaultDetail(synCtx, factory, fault);

        // set the all headers of original SOAP Envelope to the Fault Envelope
        if (synCtx.getEnvelope() != null) {
            SOAPHeader soapHeader = synCtx.getEnvelope().getHeader();
            if (soapHeader != null) {
                for (Iterator iter = soapHeader.examineAllHeaderBlocks(); iter.hasNext();) {
                    Object o = iter.next();
                    if (o instanceof SOAPHeaderBlock) {
                        SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                        faultEnvelope.getHeader().addChild(header);
                    } else if (o instanceof OMElement) {
                        faultEnvelope.getHeader().addChild((OMElement) o);
                    }
                }
            }
        }

        if (traceOrDebugOn) {
            String msg =
                ""Original SOAP Message : "" + synCtx.getEnvelope().toString() +
                ""Fault Message created : "" + faultEnvelope.toString();
            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(msg);
            }
            if (log.isTraceEnabled()) {
                log.trace(msg);
            }
        }

        // overwrite current message envelope with new fault envelope
        try {
            synCtx.setEnvelope(faultEnvelope);
        } catch (AxisFault af) {
            handleException(""Error replacing current SOAP envelope "" +
                    ""with the fault envelope"", af, synCtx);
        }

        if (synCtx.getFaultTo() != null) {
            synCtx.setTo(synCtx.getFaultTo());
        } else if (synCtx.getReplyTo() != null) {
            synCtx.setTo(synCtx.getReplyTo());
        } else {
            synCtx.setTo(null);
        }

        // set original messageID as relatesTo
        if(synCtx.getMessageID() != null) {
            RelatesTo relatesTo = new RelatesTo(synCtx.getMessageID());
            synCtx.setRelatesTo(new RelatesTo[] { relatesTo });
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Fault mediator"");
        }
        
        return true;
    }

    private void setFaultCode(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {

        QName fault_code = null;

        if (faultCodeValue == null && faultCodeExpr == null) {
            handleException(""A valid fault code QName value or expression is required"", synCtx);
        } else if (faultCodeValue != null) {
            fault_code = faultCodeValue;
        } else {
            fault_code = QName.valueOf(faultCodeExpr.stringValueOf(synCtx));
        }

        SOAPFaultCode code = factory.createSOAPFaultCode();
        switch(soapVersion){
            case SOAP11:
                code.setText(fault_code);
                break;
            case SOAP12:
                SOAPFaultValue value = factory.createSOAPFaultValue(code);
                value.setText(fault_code);
                break;
        }
        fault.setCode(code);
    }

    private void setFaultResaon(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {
        String reasonString = null;

        if (faultReasonValue == null && faultReasonExpr == null) {
            handleException(""A valid fault reason value or expression is required"", synCtx);
        } else if (faultReasonValue != null) {
            reasonString = faultReasonValue;
        } else {
            reasonString = faultReasonExpr.stringValueOf(synCtx);
        }

        SOAPFaultReason reason = factory.createSOAPFaultReason();
        switch(soapVersion){
            case SOAP11:
                reason.setText(reasonString);
                break;
            case SOAP12:
                SOAPFaultText text = factory.createSOAPFaultText();
                text.setText(reasonString);
                reason.addSOAPText(text);
                break;
        }
        fault.setReason(reason);
    }

    private void setFaultNode(SOAPFactory factory, SOAPFault fault) {
        if (faultNode != null) {
            SOAPFaultNode soapfaultNode = factory.createSOAPFaultNode();
            soapfaultNode.setNodeValue(faultNode.toString());
            fault.setNode(soapfaultNode);
        }
    }

    private void setFaultRole(SOAPFactory factory, SOAPFault fault) {
        if (faultRole != null) {
            SOAPFaultRole soapFaultRole = factory.createSOAPFaultRole();
            soapFaultRole.setRoleValue(faultRole.toString());
            fault.setRole(soapFaultRole);
        }
    }

    private void setFaultDetail(MessageContext synCtx, SOAPFactory factory, SOAPFault fault) {
        if (faultDetail != null) {
            SOAPFaultDetail soapFaultDetail = factory.createSOAPFaultDetail();
            soapFaultDetail.setText(faultDetail);
            fault.setDetail(soapFaultDetail);
        } else if (faultDetailExpr != null) {
            SOAPFaultDetail soapFaultDetail = factory.createSOAPFaultDetail();
            soapFaultDetail.setText(faultDetailExpr.stringValueOf(synCtx));
            fault.setDetail(soapFaultDetail);
        } else if (fault.getDetail() != null) {
            // work around for a rampart issue in the following thread
            // http://www.nabble.com/Access-to-validation-error-message-tf4498668.html#a13284520
            fault.getDetail().detach();
        }
    }

    public int getSoapVersion() {
        return soapVersion;
    }

    public void setSoapVersion(int soapVersion) {
        this.soapVersion = soapVersion;
    }

    public QName getFaultCodeValue() {
        return faultCodeValue;
    }

    public void setFaultCodeValue(QName faultCodeValue) {

        if (soapVersion == SOAP11) {
            this.faultCodeValue = faultCodeValue;

        } else if (SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                faultCodeValue.getNamespaceURI()) &&
                (SOAP12Constants.FAULT_CODE_DATA_ENCODING_UNKNOWN.equals(
                        faultCodeValue.getLocalPart()) ||
                        SOAP12Constants.FAULT_CODE_MUST_UNDERSTAND.equals(
                                faultCodeValue.getLocalPart()) ||
                        SOAP12Constants.FAULT_CODE_RECEIVER.equals(
                                faultCodeValue.getLocalPart()) ||
                        SOAP12Constants.FAULT_CODE_SENDER.equals(
                                faultCodeValue.getLocalPart()) ||
                        SOAP12Constants.FAULT_CODE_VERSION_MISMATCH.equals(
                                faultCodeValue.getLocalPart())) ) {

            this.faultCodeValue = faultCodeValue;

        } else {
            handleException(""Invalid Fault code value for a SOAP 1.2 fault : "" + faultCodeValue);
        }
    }

    public SynapseXPath getFaultCodeExpr() {
        return faultCodeExpr;
    }

    public void setFaultCodeExpr(SynapseXPath faultCodeExpr) {
        this.faultCodeExpr = faultCodeExpr;
    }

    public String getFaultReasonValue() {
        return faultReasonValue;
    }

    public void setFaultReasonValue(String faultReasonValue) {
        this.faultReasonValue = faultReasonValue;
    }

    public SynapseXPath getFaultReasonExpr() {
        return faultReasonExpr;
    }

    public void setFaultReasonExpr(SynapseXPath faultReasonExpr) {
        this.faultReasonExpr = faultReasonExpr;
    }

    public URI getFaultNode() {
        return faultNode;
    }

    public void setFaultNode(URI faultNode) {
        if (soapVersion == SOAP11) {
            handleException(""A fault node does not apply to a SOAP 1.1 fault"");
        }
        this.faultNode = faultNode;
    }

    public URI getFaultRole() {
        return faultRole;
    }

    public void setFaultRole(URI faultRole) {
        this.faultRole = faultRole;
    }

    public String getFaultDetail() {
        return faultDetail;
    }

    public void setFaultDetail(String faultDetail) {
        this.faultDetail = faultDetail;
    }

    public SynapseXPath getFaultDetailExpr() {
        return faultDetailExpr;
    }

    public void setFaultDetailExpr(SynapseXPath faultDetailExpr) {
        this.faultDetailExpr = faultDetailExpr;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/AnnotatedCommandMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ext.AnnotatedCommandMediator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a AnnotatedCommand mediator using XML configuration specified
 * <p/>
 * <pre>
 * &lt;annotatedCommand name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot;&gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 *   &lt;property name=&quot;string&quot; expression=&quot;XPATH expression&quot;/&gt;
 * &lt;/annoatedCommand&gt;
 * </pre>
 */
public class AnnotatedCommandMediatorFactory extends AbstractMediatorFactory {

    private static final QName ANNOTATED_COMMAND_Q =
        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""annotatedCommand"");

    public Mediator createMediator(OMElement elem) {

        AnnotatedCommandMediator pojoMediator = new AnnotatedCommandMediator();

        // Class name of the Command object should be present
        OMAttribute name = elem.getAttribute(ATT_NAME);
        if (name == null) {
            String msg = ""The name of the actual POJO command implementation class"" +
                    "" is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        // load the class for the command object
        try {
            pojoMediator.setCommand(
                    getClass().getClassLoader().loadClass(name.getAttributeValue()));
        } catch (ClassNotFoundException e) {
            handleException(""Unable to load the class specified as the command ""
                    + name.getAttributeValue(), e);
        }

        // setting the properties to the command. these properties will be instantiated
        // at the mediation time
        for (Iterator it = elem.getChildElements(); it.hasNext();) {
            OMElement child = (OMElement) it.next();
            if(""property"".equals(child.getLocalName())) {

                String propName = child.getAttribute(ATT_NAME).getAttributeValue();
                if (propName == null) {
                    handleException(
                        ""A POJO command mediator property must specify the name attribute"");
                } else {
                    if (child.getAttribute(ATT_EXPRN) != null) {
                        SynapseXPath xpath = null;
                        try {
                            xpath = SynapseXPathFactory.getSynapseXPath(child, ATT_EXPRN);
                            pojoMediator.addMessageSetterProperty(propName, xpath);
                        } catch (JaxenException e) {
                            handleException(""Error instantiating XPath expression : "" +
                                child.getAttribute(ATT_EXPRN), e);
                        }
                    } else {
                        if (child.getAttribute(ATT_VALUE) != null) {
                            pojoMediator.addStaticSetterProperty(propName,
                                child.getAttribute(ATT_VALUE).getAttributeValue());
                        } else {
                            handleException(""A POJO mediator property must specify either "" +
                                ""name and expression attributes, or name and value attributes"");
                        }
                    }
                }
            }
        }

        return pojoMediator;
    }

    public QName getTagQName() {
        return ANNOTATED_COMMAND_Q;
    }

}

"
org/apache/synapse/core/axis2/DynamicAxisOperation.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.OperationClient;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.async.Callback;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.description.ClientUtils;
import org.apache.axis2.description.OutInAxisOperation;
import org.apache.axis2.description.TransportOutDescription;
import org.apache.axis2.engine.AxisEngine;
import org.apache.axis2.i18n.Messages;
import org.apache.axis2.transport.TransportUtils;
import org.apache.axis2.util.TargetResolver;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.transport.nhttp.NhttpConstants;

import javax.xml.namespace.QName;

/**
 * DynamicAxisOperation which switch dynamically between MEPs
 */
public class DynamicAxisOperation extends OutInAxisOperation {

	public DynamicAxisOperation() {
		super();
	}

	public DynamicAxisOperation(QName name) {
		super(name);
	}

	public OperationClient createClient(ServiceContext sc, Options options) {
		return new DynamicOperationClient(this, sc, options);
	}

	class DynamicOperationClient extends OperationClient {

		DynamicOperationClient(OutInAxisOperation axisOp, ServiceContext sc, Options options) {
            super(axisOp, sc, options);
		}

		/**
         * same as OutInAxisOperationClient
		 */
		public void addMessageContext(MessageContext mc) throws AxisFault {
			mc.setServiceContext(sc);
			if (mc.getMessageID() == null) {
				setMessageID(mc);
			}
			axisOp.registerOperationContext(mc, oc);
		}

		/**
		 * same as OutInAxisOperationClient
		 */
		public MessageContext getMessageContext(String messageLabel) throws AxisFault {
			return oc.getMessageContext(messageLabel);
		}

        /**
         * same as OutInAxisOperationClient
         */
        public void setCallback(Callback callback) {
			this.callback = callback;
		}

		public void executeImpl(boolean block) throws AxisFault {

            // if the MEP is completed, throw a fault
            if (completed) {
				throw new AxisFault(Messages.getMessage(""mepiscomplted""));
			}

            // if the OUT message is not set on the operation context, throw a fault
            MessageContext outMsgCtx = oc.getMessageContext(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
			if (outMsgCtx == null) {
				throw new AxisFault(Messages.getMessage(""outmsgctxnull""));
			}

            ConfigurationContext cfgCtx = sc.getConfigurationContext();

            // set ClientOptions to the current outgoing message
            outMsgCtx.setOptions(options);

			// do Target Resolution
			TargetResolver tr = cfgCtx.getAxisConfiguration().getTargetResolverChain();
            if (tr != null) {
                tr.resolveTarget(outMsgCtx);
            }

            // if the transport to use for sending is not specified, try to find it from the URL
			TransportOutDescription transportOut = options.getTransportOut();
			if (transportOut == null) {
				EndpointReference toEPR =
                    (options.getTo() != null) ? options.getTo() : outMsgCtx.getTo();
				transportOut =
                    ClientUtils.inferOutTransport(cfgCtx.getAxisConfiguration(), toEPR, outMsgCtx);
			}
			outMsgCtx.setTransportOut(transportOut);

			if (options.getTransportIn() == null && outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(ClientUtils.inferInTransport(
                        cfgCtx.getAxisConfiguration(), options, outMsgCtx));
			} else if (outMsgCtx.getTransportIn() == null) {
				outMsgCtx.setTransportIn(options.getTransportIn());
			}

            // add reference parameters to To EPR
            addReferenceParameters(outMsgCtx);

            if (options.isUseSeparateListener()) {

				options.setTransportIn(outMsgCtx.getConfigurationContext()
						.getAxisConfiguration().getTransportIn(Constants.TRANSPORT_HTTP));

				SynapseCallbackReceiver callbackReceiver =
                        (SynapseCallbackReceiver) axisOp.getMessageReceiver();
                
                ((Axis2MessageContext)((AsyncCallback)
                        axisCallback).getSynapseOutMsgCtx()).getAxis2MessageContext().setProperty(
                        NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
                callbackReceiver.addCallback(outMsgCtx.getMessageID(), axisCallback);
                
                EndpointReference replyToFromTransport = outMsgCtx.getConfigurationContext()
                        .getListenerManager().getEPRforService(sc.getAxisService().getName(),
                        axisOp.getName().getLocalPart(), outMsgCtx.getTransportOut().getName());

				if (outMsgCtx.getReplyTo() == null) {
					outMsgCtx.setReplyTo(replyToFromTransport);
				} else {
					outMsgCtx.getReplyTo().setAddress(replyToFromTransport.getAddress());
				}

				outMsgCtx.getConfigurationContext().registerOperationContext(
						outMsgCtx.getMessageID(), oc);

                AxisEngine.send(outMsgCtx);

				// Options object reused so soapAction needs to be removed so
				// that soapAction+wsa:Action on response don't conflict
				options.setAction("""");

			} else {

                SynapseCallbackReceiver callbackReceiver =
                    (SynapseCallbackReceiver) axisOp.getMessageReceiver();
                callbackReceiver.addCallback(outMsgCtx.getMessageID(), axisCallback);
                send(outMsgCtx);
			}
		}

		private void send(MessageContext msgctx) throws AxisFault {

			// create the responseMessageContext and set that its related to the current outgoing
            // message, so that it could be tied back to the original request even if the response
            // envelope does not contain addressing headers
            MessageContext responseMessageContext = new MessageContext();
            responseMessageContext.setMessageID(msgctx.getMessageID());
            responseMessageContext.setProperty(
                    SynapseConstants.RELATES_TO_FOR_POX, msgctx.getMessageID());
            responseMessageContext.setOptions(options);
			addMessageContext(responseMessageContext);

            AxisEngine.send(msgctx);

            // did the engine receive a immediate synchronous response?
            // e.g. sometimes the transport sender may listen for a syncronous reply
			if (msgctx.getProperty(MessageContext.TRANSPORT_IN) != null) {

                responseMessageContext.setOperationContext(msgctx.getOperationContext());                
                responseMessageContext.setAxisMessage(
                    msgctx.getOperationContext().getAxisOperation().
                    getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));
                responseMessageContext.setAxisService(msgctx.getAxisService());

                // set properties on responseMessageContext
                responseMessageContext.setServerSide(true);
                responseMessageContext.setProperty(MessageContext.TRANSPORT_OUT,
                    msgctx.getProperty(MessageContext.TRANSPORT_OUT));
                responseMessageContext.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    msgctx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));

                responseMessageContext.setProperty(
                    org.apache.synapse.SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // If request is REST assume that the responseMessageContext is REST too
                responseMessageContext.setDoingREST(msgctx.isDoingREST());

                responseMessageContext.setProperty(MessageContext.TRANSPORT_IN,
                    msgctx.getProperty(MessageContext.TRANSPORT_IN));
                responseMessageContext.setTransportIn(msgctx.getTransportIn());
                responseMessageContext.setTransportOut(msgctx.getTransportOut());

                // Options object reused above so soapAction needs to be removed so
                // that soapAction+wsa:Action on response don't conflict
                responseMessageContext.setSoapAction("""");

                if (responseMessageContext.getEnvelope() == null) {
                    // If request is REST we assume the responseMessageContext is
                    // REST, so set the variable

                    SOAPEnvelope resenvelope =
                        TransportUtils.createSOAPMessage(responseMessageContext);

                    if (resenvelope != null) {
                        responseMessageContext.setEnvelope(resenvelope);
                        AxisEngine.receive(responseMessageContext);
                        if (responseMessageContext.getReplyTo() != null) {
                            sc.setTargetEPR(responseMessageContext.getReplyTo());
                        }
                    } else {
                        throw new AxisFault(
                                Messages.getMessage(""blockingInvocationExpectsResponse""));
                    }
                }
            }
        }
        
    }
}
"
org/apache/synapse/statistics/impl/ProxyServiceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * The data structure to hold statistics related to the Proxy Services
 *
 */

public class ProxyServiceStatisticsStack implements StatisticsStack {

    private static final Log log = LogFactory.getLog(ProxyServiceStatisticsStack.class);
    /** The name of the proxy service*/
    private String proxyServiceName;
    /** To check whether statistics is enabled or not */
    private boolean isStatisticsEnable = false;
    /** The time which starts to collect statistics for IN flow */
    private long inTimeForInFlow = -1;
    /** The time which starts to collect statistics for OUT flow */
    private long inTimeForOutFlow = -1;
    /** To indicate whether IN Flow is fault or not*/
    private boolean isINFault;
    /** To indicate whether OUT Flow is fault or not*/
    private boolean isOUTFault;

    /**
     * To put a statistics
     * @param key                   - The Name of the proxy service
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (isInFlow) {
            this.proxyServiceName = key;
            this.isStatisticsEnable = isStatisticsEnable;
            this.inTimeForInFlow = initTime;
            this.isINFault = isFault;
        }
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        synchronized (this) {
            if (proxyServiceName != null && isStatisticsEnable && inTimeForInFlow != -1) {
                inTimeForOutFlow = System.currentTimeMillis();
                isOUTFault = isFault;
                statisticsCollector.reportForProxyService(proxyServiceName, false,
                    inTimeForInFlow, inTimeForOutFlow, isINFault);
                inTimeForInFlow = -1;
            } else if (inTimeForOutFlow != -1) {
                statisticsCollector.reportForProxyService(proxyServiceName, true,
                    inTimeForOutFlow, System.currentTimeMillis(), isFault);
                inTimeForOutFlow = -1;
            }
        }
    }

    /**
     * Report a particular statistics to the StatisticsReporter
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (name != null && proxyServiceName != null && proxyServiceName.equals(name)) {
            reportToStatisticsCollector(statisticsCollector, isFault);
        } else {
            handleException(""Invalid ProxyService Name "" + name + "" expected "" + proxyServiceName);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        reportToStatisticsCollector(statisticsCollector, isFault);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/XMLToObjectMapper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.OMNode;

/**
 * Defines the interface which should be implemented by a mapper that could
 * convert a XML resource into a known Object such as WSDL, XSD, etc..
 */
public interface XMLToObjectMapper {

    /**
     * Create an application object from the given OMNode
     * @param om the XML
     * @return a suitable application object
     */
    public Object getObjectFromOMNode(OMNode om);
}
"
org/apache/synapse/SynapseException.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

/**
 * <p>Runtime exception for Synapse code to throw
 */
public class SynapseException extends RuntimeException {

    private static final long serialVersionUID = -7244032125641596311L;

    public SynapseException(String string) {
        super(string);
    }

    public SynapseException(String msg, Throwable e) {
        super(msg, e);
    }

    public SynapseException(Throwable t) {
        super(t);
    }

}
"
org/apache/synapse/config/xml/endpoints/DefaultEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.DefaultEndpoint;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

/**
 * Serializes {@link DefaultEndpoint} to XML.
 *
 * @see DefaultEndpointFactory
 */
public class DefaultEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof DefaultEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement
                = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        DefaultEndpoint defaultEndpoint = (DefaultEndpoint) endpoint;
        String name = defaultEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        EndpointDefinition epAddress = defaultEndpoint.getEndpoint();
        OMElement defaultElement = serializeEndpointDefinition(epAddress);
        endpointElement.addChild(defaultElement);

        return endpointElement;
    }

    protected void serializeSpecificEndpointProperties(EndpointDefinition endpointDefinition, OMElement element) {

        if (SynapseConstants.FORMAT_POX.equals(endpointDefinition.getFormat())) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
        } else if (SynapseConstants.FORMAT_GET.equals(endpointDefinition.getFormat())) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""get""));
        } else if (SynapseConstants.FORMAT_SOAP11.equals(endpointDefinition.getFormat())) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
        } else if (SynapseConstants.FORMAT_SOAP12.equals(endpointDefinition.getFormat())) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));

            // following two kept for backward compatibility
        } else if (endpointDefinition.isForcePOX()) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""pox""));
        } else if (endpointDefinition.isForceGET()) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""get""));
        } else if (endpointDefinition.isForceSOAP11()) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""soap11""));
        } else if (endpointDefinition.isForceSOAP12()) {
            element.addAttribute(fac.createOMAttribute(""format"", null, ""soap12""));
        }

    }

    public OMElement serializeEndpointDefinition(EndpointDefinition endpointDefinition) {
        OMElement element = fac.createOMElement(""default"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        serializeCommonEndpointProperties(endpointDefinition, element);
        serializeSpecificEndpointProperties(endpointDefinition, element);
        return element;
    }
}
"
org/apache/synapse/metrics/MetricsAggregatorModule.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.AxisDescription;
import org.apache.axis2.description.AxisModule;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
/*
 * 
 */

public class MetricsAggregatorModule implements Module {
    // initialize the module
    public void init(ConfigurationContext configContext, AxisModule module) throws AxisFault {
        AxisConfiguration axiConfiguration = configContext.getAxisConfiguration();

        Counter globalRequestCounter = new Counter();
        Parameter globalRequestCounterParameter = new Parameter();
        globalRequestCounterParameter.setName(MetricsConstants.GLOBAL_REQUEST_COUNTER);
        globalRequestCounterParameter.setValue(globalRequestCounter);
        axiConfiguration.addParameter(globalRequestCounterParameter);

    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {}

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation 
    }

    // shutdown the module
    public void shutdown(ConfigurationContext configurationContext) throws AxisFault {}
}
"
org/apache/synapse/startup/quartz/SimpleQuartzSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import java.util.List;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.StartupSerializer;
import org.apache.synapse.config.xml.XMLConfigConstants;

import javax.xml.namespace.QName;

public class SimpleQuartzSerializer implements StartupSerializer {

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS
        = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS
        = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"", ""syn"");

    public OMElement serializeStartup(OMElement parent, Startup s) {

        if (!(s instanceof SimpleQuartz)) {
            throw new SynapseException(""called TaskSerializer on some other "" +
                    ""kind of startup"" + s.getClass().getName());
        }

        SimpleQuartz sq = (SimpleQuartz) s;

        OMElement task = fac.createOMElement(""task"", synNS, parent);
        task.addAttribute(""name"", sq.getName(), nullNS);
        task.addAttribute(""class"", sq.getJobClass(), nullNS);

        List pinnedServers = sq.getPinnedServers();
        if (pinnedServers != null && !pinnedServers.isEmpty()) {
          String pinnedServersStr = """" + pinnedServers.get(0);
          for (int i = 1; i < pinnedServers.size(); i++) {
            pinnedServersStr = pinnedServersStr + "" "" + pinnedServers.get(i);
          }
          task.addAttribute(fac.createOMAttribute(""pinnedServers"", nullNS, pinnedServersStr));
        }
        
        OMElement el = fac.createOMElement(""trigger"", synNS, task);
        if (sq.getInterval() == 1 && sq.getCount() == 1) {
            el.addAttribute(""once"", ""true"", nullNS);
        } else if (sq.getCron() != null) {
            el.addAttribute(""cron"", sq.getCron(), nullNS);
        } else {
            if (sq.getCount() != -1) {
                el.addAttribute(""count"", Integer.toString(sq.getCount()), nullNS);
            }

            if (sq.getInterval() != 0) {
                long interval = sq.getInterval() / 1000;
                el.addAttribute(""interval"", Long.toString(interval), nullNS);
            }
        }
        
        for (Object o : sq.getProperties()) {
            OMElement prop = (OMElement) o;
            task.addChild(prop.cloneOMElement());
        }

        return task;
    }

}
"
org/apache/synapse/core/axis2/SynapseMessageReceiver.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.MessageReceiver;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorFaultHandler;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * This message receiver should be configured in the Axis2 configuration as the
 * default message receiver, which will handle all incoming messages through the
 * synapse mediation
 */
public class SynapseMessageReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseMessageReceiver.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public void receive(org.apache.axis2.context.MessageContext mc) throws AxisFault {

        MessageContext synCtx = MessageContextCreatorForAxis2.getSynapseMessageContext(mc);

        boolean traceOn = synCtx.getMainSequence().getTraceState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Synapse received a new message for message mediation..."");
            traceOrDebug(traceOn, ""Received To: "" +
                (mc.getTo() != null ? mc.getTo().getAddress() : ""null""));
            traceOrDebug(traceOn, ""SOAPAction: "" +
                (mc.getSoapAction() != null ? mc.getSoapAction() : ""null""));
            traceOrDebug(traceOn, ""WSA-Action: "" +
                (mc.getWSAAction() != null ? mc.getWSAAction() : ""null""));

            if (traceOn && trace.isTraceEnabled()) {
                String[] cids = mc.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (int i=0; i<cids.length; i++) {
                        trace.trace(""Attachment : "" + cids[i]);
                    }
                }
                trace.trace(""Envelope : "" + mc.getEnvelope());
            }
        }

        // get service log for this message and attach to the message context
        Log serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX +
            SynapseConstants.SYNAPSE_SERVICE_NAME);
        ((Axis2MessageContext) synCtx).setServiceLog(serviceLog);

        try {
            // set the statistics collection stack for this message
            StatisticsStack synapseServiceStack = new ProxyServiceStatisticsStack();
            boolean isFault = synCtx.getEnvelope().getBody().hasFault();
            synapseServiceStack.put(SynapseConstants.SYNAPSE_SERVICE_NAME,
                System.currentTimeMillis(), !synCtx.isResponse(), true, isFault);
            synCtx.setProperty(SynapseConstants.SERVICE_STATS, synapseServiceStack);

            // set default fault handler
            synCtx.pushFaultHandler(new MediatorFaultHandler(
                        synCtx.getSequence(SynapseConstants.FAULT_SEQUENCE_KEY)));

            // invoke synapse message mediation through the main sequence
            synCtx.getEnvironment().injectMessage(synCtx);

        } catch (SynapseException syne) {

            if (!synCtx.getFaultStack().isEmpty()) {
                warn(traceOn, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(traceOn, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }
}
"
org/apache/synapse/core/axis2/SynapseStartUpServlet.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.core.axis2;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.ServerManager;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;

/**
 * When Synapse is deployed on a WAR container, this is the init servlet that kicks off the
 * Synapse instance, calling on the ServerManager
 */

public class SynapseStartUpServlet extends HttpServlet {

    private static Log log = LogFactory.getLog(SynapseStartUpServlet.class);
    private static final String ALREADY_INITED = ""synapseAlreadyInited"";

    public void init() throws ServletException {
    	ServletConfig servletConfig = getServletConfig();
    	ServletContext servletContext = servletConfig.getServletContext();
        if (Boolean.TRUE.equals(servletContext.getAttribute(ALREADY_INITED))) {
            return;
        }

        ServerManager serverManager = ServerManager.getInstance();
        String synHome = loadParameter(servletConfig, SynapseConstants.SYNAPSE_HOME, false);

        if (synHome == null) {
            log.info(""synapse.home not set; using web application root as default value"");
            String webinfPath = servletContext.getRealPath(""WEB-INF"");
            if (webinfPath == null || !webinfPath.endsWith(""WEB-INF"")) {
                handleException(""Unable to determine web application root directory"");
            } else {
                synHome = webinfPath.substring(0, webinfPath.length()-7);
                log.info(""Setting synapse.home to : "" + synHome);
            }
        }
        serverManager.setSynapseHome(synHome);
        
        serverManager.setSynapseXMLPath(loadParameter(servletConfig, SynapseConstants.SYNAPSE_XML, true));
        String resolveRoot = loadParameter(servletConfig, SynapseConstants.RESOLVE_ROOT, false);
        if (resolveRoot != null) {
            serverManager.setResolveRoot(resolveRoot);
        }
        serverManager.setAxis2Repolocation(loadParameter(servletConfig, org.apache.axis2.Constants.AXIS2_REPO, true));
        serverManager.setAxis2Xml(loadParameter(servletConfig, org.apache.axis2.Constants.AXIS2_CONF, true));
        serverManager.setServerName(loadParameter(servletConfig, SynapseConstants.SERVER_NAME, false));

        serverManager.start();
        servletContext.setAttribute(ALREADY_INITED, Boolean.TRUE);
    }


    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response) throws ServletException, IOException {
    }

    protected void doPost(HttpServletRequest request,
                          HttpServletResponse response) throws ServletException, IOException {
    }

    public void destroy() {
        try {
            ServerManager serverManager = ServerManager.getInstance();
            serverManager.stop();
            getServletContext().removeAttribute(ALREADY_INITED);
        } catch (Exception e) {
            log.error(""Error stopping the Synapse listener manager"", e);
        }
    }

    private String loadParameter(ServletConfig servletConfig, String name, boolean required)
        throws ServletException {

        if (System.getProperty(name) == null) {

            String value = servletConfig.getInitParameter(name);
            log.debug(""Init parameter '"" + name + ""' : "" + value);

            if ((value == null || value.trim().length() == 0) && required) {
                handleException(""A valid system property or init parameter '"" + name + ""' is required"");
            } else {
                return value;
            }
        } else {
            return System.getProperty(name);
        }
        return null;
    }

    private void handleException(String message) throws ServletException {
        log.error(message);
        log(message);
        throw new ServletException(message);
    }
}
"
org/apache/synapse/mediators/annotations/ReadAndUpdate.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.annotations;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Target({FIELD})
@Retention(RUNTIME)
public @interface ReadAndUpdate {

    String value();

}
"
org/apache/synapse/config/xml/FilterMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.filters.FilterMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * <p>Creates a filter mediator instance with the default behavior</p>
 *
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 *
 * <p>or if the filter medaitor needs to support the else behavior as well (i.e. a set of mediators
 * to be executed when the filter evaluates to false).</p>
 *
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   &lt;then [sequence=""string""]&gt;
 *      mediator+
 *   &lt;/then&gt;
 *   &lt;else [sequence=""string""]&gt;
 *      mediator+
 *   &lt;/else&gt;
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorFactory extends AbstractListMediatorFactory {

    private static final QName FILTER_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""filter"");
    private static final QName THEN_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""then"");
    private static final QName ELSE_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""else"");

    public Mediator createMediator(OMElement elem) {
        
        FilterMediator filter = new FilterMediator();

        OMAttribute attXpath  = elem.getAttribute(ATT_XPATH);
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);
        OMAttribute attRegex  = elem.getAttribute(ATT_REGEX);

        if (attXpath != null) {
            if (attXpath.getAttributeValue() != null &&
                attXpath.getAttributeValue().trim().length() == 0) {

                handleException(""Invalid attribute value specified for xpath"");

            } else {

                try {
                    filter.setXpath(SynapseXPathFactory.getSynapseXPath(elem, ATT_XPATH));
                } catch (JaxenException e) {
                    handleException(""Invalid XPath expression for attribute xpath : ""
                        + attXpath.getAttributeValue(), e);
                }
                
            }

        } else if (attSource != null && attRegex != null) {

            if ((attSource.getAttributeValue() != null &&
                attSource.getAttributeValue().trim().length() == 0) || (attRegex.getAttributeValue()
                != null && attRegex.getAttributeValue().trim().length() == 0) ){

                handleException(""Invalid attribute values for source and/or regex specified"");

            } else {
                
                try {
                    filter.setSource(SynapseXPathFactory.getSynapseXPath(elem, ATT_SOURCE));
                } catch (JaxenException e) {

                    handleException(""Invalid XPath expression for attribute source : ""
                        + attSource.getAttributeValue(), e);
                }

                try {
                    filter.setRegex(Pattern.compile(attRegex.getAttributeValue()));
                } catch (PatternSyntaxException pse) {

                    handleException(""Invalid Regular Expression for attribute regex : ""
                        + attRegex.getAttributeValue(), pse);
                }
            }

        } else {

            handleException(""An xpath or (source, regex) attributes are required for a filter"");
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);

        OMElement thenElem = elem.getFirstChildWithName(THEN_Q);

        if (thenElem != null) {

            filter.setThenElementPresent(true);
            OMAttribute sequenceAttr = thenElem.getAttribute(ATT_SEQUENCE);

            if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {

                filter.setThenKey(sequenceAttr.getAttributeValue());

            } else {
                addChildren(thenElem, filter);
            }

            OMElement elseElem = elem.getFirstChildWithName(ELSE_Q);

            if (elseElem != null) {

                sequenceAttr = elseElem.getAttribute(ATT_SEQUENCE);

                if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {

                    filter.setElseKey(sequenceAttr.getAttributeValue());

                } else {

                    AnonymousListMediator listMediator =
                        AnonymousListMediatorFactory.createAnonymousListMediator(elseElem);
                    filter.setElseMediator(listMediator);
                }
            }

        } else {

            filter.setThenElementPresent(false);
            addChildren(elem, filter);
        }

        return filter;
    }

    public QName getTagQName() {
        return FILTER_Q;
    }
}
"
org/apache/synapse/core/axis2/AnonymousServiceFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.description.OutOnlyAxisOperation;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;

import javax.xml.namespace.QName;

/**
 * Returns an anonymous service for the given QoS. If an instance does not already
 * exist, create one and set it to the Axis configuration
 */
public class AnonymousServiceFactory {

    private static final Log log = LogFactory.getLog(AnonymousServiceFactory.class);

    private static final String NONE            = ""__NONE__"";
    private static final String ADDR_ONLY       = ""__ADDR_ONLY__"";
    private static final String RM_AND_ADDR     = ""__RM_AND_ADDR__"";
    private static final String SEC_AND_ADDR    = ""__SEC_AND_ADDR__"";
    private static final String RM_SEC_AND_ADDR = ""__RM_SEC_AND_ADDR__"";

    public static final String OUT_IN_OPERATION   = ""anonOutInOp"";
    public static final String OUT_ONLY_OPERATION = ""anonOutonlyOp"";

    private static SynapseCallbackReceiver synapseCallbackReceiver = null;

    /**
     * Creates an AxisService for the requested QoS for sending out messages
     * Callers must guarantee that if wsRMon or wsSecOn is required, that wsAddrOn is also set
     * @param synCfg Synapse configuration
     * @param axisCfg Axis2 configuration
     * @param wsAddrOn whether addressing is on or not
     * @param wsRMOn whether RM is on ot not
     * @param wsSecOn whether security is on or not
     * @return An Axis service for the requested QoS
     */
    public static AxisService getAnonymousService(SynapseConfiguration synCfg,
                                                  AxisConfiguration axisCfg, boolean wsAddrOn,
                                                  boolean wsRMOn, boolean wsSecOn) {

        String servicekey;
        if (!wsAddrOn) {
            servicekey = NONE;
        } else {
            if (!wsSecOn && !wsRMOn) {
                servicekey = ADDR_ONLY;
            } else if (wsRMOn && !wsSecOn) {
                servicekey = RM_AND_ADDR;
            } else if (wsSecOn && !wsRMOn) {
                servicekey = SEC_AND_ADDR;
            } else {
                servicekey = RM_SEC_AND_ADDR;
            }
        }

        try {
            AxisService service = axisCfg.getService(servicekey);
            if (service == null) {
                synchronized (AnonymousServiceFactory.class) {

                    // fix with double locking, issue found on performance test
                    service = axisCfg.getService(servicekey);
                    if (service != null) {
                        return service;
                    }

                    service = createAnonymousService(synCfg, axisCfg, servicekey);

                    if (wsAddrOn) {
                        service.engageModule(axisCfg.getModule(
                            SynapseConstants.ADDRESSING_MODULE_NAME), axisCfg);

                        if (wsRMOn) {
                            service.engageModule(axisCfg.getModule(
                                SynapseConstants.MERCURY_MODULE_NAME), axisCfg);
                        }
                        if (wsSecOn) {
                            service.engageModule(axisCfg.getModule(
                                SynapseConstants.RAMPART_MODULE_NAME), axisCfg);
                        }
                    }
                    // if WS-A is off, WS-Sec and WS-RM should be too
                }
            }
            return service;
        } catch (AxisFault e) {
            handleException(""Error retrieving anonymous service for QoS : "" + servicekey, e);
        }
        return null;
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Create a new Anonymous Axis service for OUT-IN as default MEP
     * @param synCfg the Synapse Configuration
     * @param axisCfg the Axis2 configuration
     * @param serviceKey key for the service
     * @return an anonymous service named with the given QoS key
     */
    private static AxisService createAnonymousService(SynapseConfiguration synCfg,
        AxisConfiguration axisCfg, String serviceKey) {

        try {
            DynamicAxisOperation dynamicOperation =
                new DynamicAxisOperation(new QName(OUT_IN_OPERATION));
            dynamicOperation.setMessageReceiver(getCallbackReceiver(synCfg));
            AxisMessage inMsg = new AxisMessage();
            inMsg.setName(""in-message"");
            inMsg.setParent(dynamicOperation);
            AxisMessage outMsg = new AxisMessage();
            outMsg.setName(""out-message"");
            outMsg.setParent(dynamicOperation);
            dynamicOperation.addMessage(inMsg, WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
            dynamicOperation.addMessage(outMsg, WSDLConstants.MESSAGE_LABEL_IN_VALUE);

            OutOnlyAxisOperation asyncOperation =
                new OutOnlyAxisOperation(new QName(OUT_ONLY_OPERATION));
            asyncOperation.setMessageReceiver(getCallbackReceiver(synCfg));
            AxisMessage outOnlyMsg = new AxisMessage();
            outOnlyMsg.setName(""out-message"");
            outOnlyMsg.setParent(asyncOperation);
            asyncOperation.addMessage(outMsg, WSDLConstants.MESSAGE_LABEL_OUT_VALUE);

            AxisService axisAnonymousService  = new AxisService(serviceKey);
            axisAnonymousService.addOperation(dynamicOperation);
            axisAnonymousService.addOperation(asyncOperation);
            axisCfg.addService(axisAnonymousService);
            axisCfg.getPhasesInfo().setOperationPhases(dynamicOperation);
            return axisAnonymousService;

        } catch (AxisFault e) {
            handleException(
                ""Error occured while creating an anonymous service for QoS : "" +
                 serviceKey, e);
        }
        return null;
    }

    /**
     * Create a single callback receiver if required, and return its reference
     * @param synCfg the Synapse configuration
     * @return the callback receiver thats created or now exists
     */
    private static synchronized SynapseCallbackReceiver getCallbackReceiver(
        SynapseConfiguration synCfg) {

        if (synapseCallbackReceiver == null) {
            synapseCallbackReceiver = new SynapseCallbackReceiver(synCfg);
        }
        return synapseCallbackReceiver;
    }
}
"
org/apache/synapse/mediators/MediatorWorker.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.*;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This class will be used as the executer for the injectAsync method for the
 * sequence mediation
 */
public class MediatorWorker implements Runnable {

    private static final Log log = LogFactory.getLog(MediatorWorker.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** Mediator to be executed */
    private Mediator seq = null;

    /** MessageContext to be mediated using the mediator */
    private MessageContext synCtx = null;

    /**
     * Constructor of the MediatorWorker which sets the sequence and the message context
     *
     * @param seq    - Sequence Mediator to be set
     * @param synCtx - Synapse MessageContext to be set
     */
    public MediatorWorker(Mediator seq, MessageContext synCtx) {
        this.seq = seq;
        this.synCtx = synCtx;
    }

    /**
     * Constructor od the MediatorWorker which sets the provided message context and the
     * main sequence as the sequence for mediation
     *
     * @param synCtx - Synapse MessageContext to be set
     */
    public MediatorWorker(MessageContext synCtx) {
        this.synCtx = synCtx;
        seq = synCtx.getMainSequence();
    }

    /**
     * Execution method of the thread. This will just call the mediation of the specified
     * Synapse MessageContext using the specified Sequence Mediator
     */
    public void run() {
        try {
            seq.mediate(synCtx);
            //((Axis2MessageContext)synCtx).getAxis2MessageContext().getEnvelope().discard();

        } catch (SynapseException syne) {
            if (!synCtx.getFaultStack().isEmpty()) {
                warn(false, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, syne);

            } else {
                warn(false, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }

        } catch (Exception e) {
            String msg = ""Unexpected error executing task/async inject"";
            log.error(msg, e);
            if (synCtx.getServiceLog() != null) {
                synCtx.getServiceLog().error(msg, e);
            }
            if (!synCtx.getFaultStack().isEmpty()) {
                warn(false, ""Executing fault handler due to exception encountered"", synCtx);
                ((FaultHandler) synCtx.getFaultStack().pop()).handleFault(synCtx, e);

            } else {
                warn(false, ""Exception encountered but no fault handler found - "" +
                    ""message dropped"", synCtx);
            }
        }
        synCtx = null;
        seq = null;
    }

    private void warn(boolean traceOn, String msg, MessageContext msgContext) {
        if (traceOn) {
            trace.warn(msg);
        }
        if (log.isDebugEnabled()) {
            log.warn(msg);
        }
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
    }

}
"
org/apache/synapse/core/axis2/SOAPUtils.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import java.util.Iterator;
import java.util.List;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPFault;
import org.apache.axiom.soap.SOAPFaultCode;
import org.apache.axiom.soap.SOAPFaultReason;
import org.apache.axiom.soap.SOAPFaultText;
import org.apache.axiom.soap.SOAPFaultValue;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.MessageHelper;

public class SOAPUtils {

    private static final Log log = LogFactory.getLog(SOAPUtils.class);

    /**
     * Converts the SOAP version of the message context.  Creates a new envelope of the given SOAP
     * version, copy headers and bodies from the old envelope and sets the new envelope to the same
     * message context.
     *
     * @param axisOutMsgCtx  messageContext where version conversion is done
     * @param soapVersionURI either org.apache.axis2.namespace.Constants.URI_SOAP12_ENV or
     *                       org.apache.axis2.namespace.Constants.URI_SOAP11_ENV
     * @throws AxisFault
     */
    public static void convertSoapVersion(org.apache.axis2.context.MessageContext axisOutMsgCtx,
        String soapVersionURI) throws AxisFault {

        if (org.apache.axis2.namespace.Constants.URI_SOAP12_ENV.equals(soapVersionURI)) {
            convertSOAP11toSOAP12(axisOutMsgCtx);
        } else if (org.apache.axis2.namespace.Constants.URI_SOAP11_ENV.equals(soapVersionURI)) {
            convertSOAP12toSOAP11(axisOutMsgCtx);
        } else {
            throw new SynapseException(""Invalid soapVersionURI:"" + soapVersionURI);
        }
    }

    private static String SOAP_ATR_ACTOR = ""actor"";
    private static String SOAP_ATR_ROLE = ""role"";
    private static String SOAP_ATR_MUST_UNDERSTAND = ""mustUnderstand"";

    /**
     * Converts the version of the the message context to 1.2.
     * <br />
     * <b>Message Changes:</b>
     * <ol>
     *     <li>Convert envelope, header elements</li>
     *     <li>For each header block convert attribute actor to role</li>
     *     <li>For each header block convert mustUnderstand value type</li>
     *     <li>For each header block remove 1.1 namespaced other attributes</li>
     * </ol>
     *
     * <b>Fault Changes:</b>
     * <ol>
     *     <li>Convert fault element</li>
     *     <li>faultcode to Fault/Code</li>
     *     <li>faultstring to First Fault/Reason/Text with lang=en</li>
     * </ol>
     *
     * @param axisOutMsgCtx
     * @throws AxisFault
     */
    public static void convertSOAP11toSOAP12(
        org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {

        if(log.isDebugEnabled()) {
            log.debug(""convert SOAP11 to SOAP12"");
        }

        SOAPEnvelope oldEnvelope = axisOutMsgCtx.getEnvelope();

        SOAPFactory soap12Factory = OMAbstractFactory.getSOAP12Factory();
        SOAPEnvelope newEnvelope  = soap12Factory.getDefaultEnvelope();

        if (oldEnvelope.getHeader() != null) {
            Iterator itr = oldEnvelope.getHeader().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock soapHeader = (SOAPHeaderBlock) omNode;
                    SOAPHeaderBlock newSOAPHeader = soap12Factory.createSOAPHeaderBlock(
                        soapHeader.getLocalName(), soapHeader.getNamespace());
                    Iterator allAttributes = soapHeader.getAllAttributes();

                    while(allAttributes.hasNext()) {
                        OMAttribute attr = (OMAttribute) allAttributes.next();
                        if(attr.getNamespace() != null
                            && SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                            attr.getNamespace().getNamespaceURI())) {
                            String attrName = attr.getLocalName();

                            if(SOAP_ATR_ACTOR.equals(attrName)) {
                                OMAttribute newAtr = omNode.getOMFactory().createOMAttribute(
                                    SOAP_ATR_ROLE, newEnvelope.getNamespace(),
                                    attr.getAttributeValue());
                                newSOAPHeader.addAttribute(newAtr);

                            } else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {
                                boolean isMustUnderstand = soapHeader.getMustUnderstand();
                                newSOAPHeader.setMustUnderstand(isMustUnderstand);

                            } else {
                                log.warn(""removed unsupported attribute from SOAP 1.1 "" +
                                    ""namespace when converting to SOAP 1.2:"" + attrName);
                            }

                        } else {
                            newSOAPHeader.addAttribute(attr);
                        }

                        Iterator itrChildren = soapHeader.getChildren();
                        while (itrChildren.hasNext()) {
                            newSOAPHeader.addChild(((OMNode) itrChildren.next()));
                        }

                        newEnvelope.getHeader().addChild(newSOAPHeader);
                    } // while(allAttributes.hasNext())

                } else {
                    newEnvelope.getHeader().addChild(omNode);
                }

            } // while (itr.hasNext())

        } // if (oldEnvelope.getHeader() != null)

        if (oldEnvelope.getBody() != null) {

            Iterator itrBodyChildren = oldEnvelope.getBody().getChildren();
            while (itrBodyChildren.hasNext()) {
                OMNode omNode = (OMNode) itrBodyChildren.next();

                if (omNode instanceof SOAPFault) {
                    SOAPFault soapFault = (SOAPFault) omNode;
                    if(soapFault != null) {
                        SOAPFault newSOAPFault = soap12Factory.createSOAPFault();
                        newEnvelope.getBody().addChild(newSOAPFault);
                        // get the existing envelope
                        SOAPFaultCode code = soapFault.getCode();
                        if(code != null) {
                            SOAPFaultCode newSOAPFaultCode = soap12Factory.createSOAPFaultCode();
                            newSOAPFault.setCode(newSOAPFaultCode);

                            String value = code.getText();
                            if(value != null) {
                                SOAPFaultValue newSOAPFaultValue
                                    = soap12Factory.createSOAPFaultValue(newSOAPFaultCode);
                                newSOAPFaultValue.setText(value);
                            }

                        }

                        SOAPFaultReason reason = soapFault.getReason();
                        if(reason != null) {
                            SOAPFaultReason newSOAPFaultReason
                                = soap12Factory.createSOAPFaultReason(newSOAPFault);
                            String reasonText = reason.getText();
                            if(reasonText != null) {
                                SOAPFaultText newSOAPFaultText
                                    = soap12Factory.createSOAPFaultText(newSOAPFaultReason);
                                newSOAPFaultText.setLang(""en""); // hard coded
                                newSOAPFaultText.setText(reasonText);
                            }
                            newSOAPFault.setReason(newSOAPFaultReason);
                        }

                    } // if(soapFault != null)

                } else {
                    newEnvelope.getBody().addChild(omNode);

                } // if (omNode instanceof SOAPFault)

            } // while (itrBodyChildren.hasNext())

        } //if (oldEnvelope.getBody() != null)

        axisOutMsgCtx.setEnvelope(newEnvelope);
    }

    /**
     * Converts the version of the the message context to 1.1.
     * <br />
     * <b>Message Changes:</b>
     * <ol>
     *     <li>Convert envelope, header elements</li>
     *     <li>For each header block convert attribute role to actor</li>
     *     <li>For each header block convert mustUnderstand value type</li>
     *     <li>For each header block remove 1.2 namespaced other attributes</li>
     * </ol>
     *
     * <b>Fault Changes:</b>
     * <ol>
     *     <li>Convert fault element</li>
     *     <li>Fault/Code to faultcode</li>
     *     <li>First Fault/Reason/Text to faultstring</li>
     * </ol>
     * @param axisOutMsgCtx
     * @throws AxisFault
     */
    public static void convertSOAP12toSOAP11(
        org.apache.axis2.context.MessageContext axisOutMsgCtx) throws AxisFault {
        
        if (log.isDebugEnabled()) {
            log.debug(""convert SOAP12 to SOAP11"");
        }

        SOAPEnvelope oldEnvelope = axisOutMsgCtx.getEnvelope();

        SOAPFactory soap11Factory = OMAbstractFactory.getSOAP11Factory();
        SOAPEnvelope newEnvelope  = soap11Factory.getDefaultEnvelope();
        if (oldEnvelope.getHeader() != null) {
            Iterator itr = oldEnvelope.getHeader().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPHeaderBlock) {
                    SOAPHeaderBlock soapHeaderBlock = (SOAPHeaderBlock) omNode;
                    SOAPHeaderBlock newSOAPHeader = soap11Factory.createSOAPHeaderBlock(
                        soapHeaderBlock.getLocalName(), soapHeaderBlock.getNamespace());

                    Iterator allAttributes = soapHeaderBlock.getAllAttributes();

                    while(allAttributes.hasNext()) {
                        OMAttribute attr = (OMAttribute) allAttributes.next();
                        if(attr.getNamespace() != null
                            && SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI.equals(
                            attr.getNamespace().getNamespaceURI())) {
                            String attrName = attr.getLocalName();

                            if(SOAP_ATR_ROLE.equals(attrName)) {
                                OMAttribute newAtr = omNode.getOMFactory().createOMAttribute(
                                    SOAP_ATR_ACTOR, newEnvelope.getNamespace(),
                                    attr.getAttributeValue());
                                newSOAPHeader.addAttribute(newAtr);

                            } else if(SOAP_ATR_MUST_UNDERSTAND.equals(attrName)) {
                                boolean isMustUnderstand = soapHeaderBlock.getMustUnderstand();
                                newSOAPHeader.setMustUnderstand(isMustUnderstand);

                            } else {
                                log.warn(""removed unsupported attribute from SOAP 1.2 "" +
                                    ""namespace when converting to SOAP 1.1:"" + attrName);
                            }

                        } else {
                            newSOAPHeader.addAttribute(attr);
                        }

                        Iterator itrChildren = soapHeaderBlock.getChildren();
                        while (itrChildren.hasNext()) {
                            newSOAPHeader.addChild(((OMNode) itrChildren.next()));
                        }

                        newEnvelope.getHeader().addChild(newSOAPHeader);
                    } // while(allAttributes.hasNext())

                } else {
                    newEnvelope.getHeader().addChild(omNode);
                } // if (omNode instanceof SOAPHeaderBlock)

            } // while (itr.hasNext())

        } // if (oldEnvelope.getHeader() != null)

        if (oldEnvelope.getBody() != null) {
            Iterator itr = oldEnvelope.getBody().getChildren();
            while (itr.hasNext()) {
                OMNode omNode = (OMNode) itr.next();

                if (omNode instanceof SOAPFault) {

                    SOAPFault soapFault = (SOAPFault) omNode;
                    if(soapFault != null) {
                        SOAPFault newSOAPFault = soap11Factory.createSOAPFault();
                        newEnvelope.getBody().addChild(newSOAPFault);

                        SOAPFaultCode code = soapFault.getCode();
                        if(code != null) {
                            SOAPFaultCode newSOAPFaultCode
                                = soap11Factory.createSOAPFaultCode(newSOAPFault);

                            SOAPFaultValue value = code.getValue();
                            if(value != null) {
                                soap11Factory.createSOAPFaultValue(newSOAPFaultCode);
                                if(value.getText() != null) {
                                    newSOAPFaultCode.setText(value.getText());
                                }
                            }
                        }

                        SOAPFaultReason reason = soapFault.getReason();
                        if(reason != null) {
                            SOAPFaultReason newSOAPFaultReason
                                = soap11Factory.createSOAPFaultReason(newSOAPFault);

                            List allSoapTexts = reason.getAllSoapTexts();
                            Iterator iterAllSoapTexts = allSoapTexts.iterator();
                            while(iterAllSoapTexts.hasNext()) {
                                SOAPFaultText soapFaultText
                                    = (SOAPFaultText) iterAllSoapTexts.next();
                                SOAPFaultText newSOAPFaultText
                                    = soap11Factory.createSOAPFaultText(newSOAPFaultReason);
                                newSOAPFaultReason.setText(soapFaultText.getText());
                                break;
                            }
                        }

                    } // if(soapFault != null)

                } else {
                    newEnvelope.getBody().addChild(omNode);
                } // if (omNode instanceof SOAPFault)

            } // while (itr.hasNext())

        } // if (oldEnvelope.getBody() != null)
        
        axisOutMsgCtx.setEnvelope(newEnvelope);
    }

}"
org/apache/synapse/mediators/annotations/Execute.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.annotations;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Target({METHOD})
@Retention(RUNTIME)
public @interface Execute {

}
"
org/apache/synapse/config/xml/ValidateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.ValidateMediator;
import org.jaxen.JaxenException;
import org.xml.sax.SAXException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Factory for {@link ValidateMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;validate [source=""xpath""]>
 *   &lt;schema key=""string"">+
 *   &lt;property name=""<validation-feature-name>"" value=""true|false""/>
 *   &lt;on-fail>
 *     mediator+
 *   &lt;/on-fail>
 * &lt;/validate>
 * </pre>
 */
public class ValidateMediatorFactory extends AbstractListMediatorFactory {

    private static final QName VALIDATE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""validate"");
    private static final QName ON_FAIL_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""on-fail"");
    private static final QName SCHEMA_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""schema"");

    public Mediator createMediator(OMElement elem) {

        ValidateMediator validateMediator = new ValidateMediator();

        // process schema element definitions and create DynamicProperties
        List<String> schemaKeys = new ArrayList<String>();
        Iterator schemas = elem.getChildrenWithName(SCHEMA_Q);

        while (schemas.hasNext()) {
            Object o = schemas.next();
            if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                OMAttribute keyAtt = omElem.getAttribute(ATT_KEY);
                if (keyAtt != null) {
                    schemaKeys.add(keyAtt.getAttributeValue());
                } else {
                    handleException(""A 'schema' definition must contain a local property 'key'"");
                }
            } else {
                handleException(""Invalid 'schema' declaration for validate mediator"");
            }
        }

        if (schemaKeys.size() == 0) {
            handleException(""No schemas specified for the validate mediator"");
        } else {
            validateMediator.setSchemaKeys(schemaKeys);
        }

        // process source XPath attribute if present
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);

        if (attSource != null) {
            try {
                validateMediator.setSource(SynapseXPathFactory.getSynapseXPath(elem, ATT_SOURCE));
            } catch (JaxenException e) {
                handleException(""Invalid XPath expression specified for attribute 'source'"", e);
            }
        }

        // process on-fail
        OMElement onFail = null;
        Iterator iterator = elem.getChildrenWithName(ON_FAIL_Q);
        if (iterator.hasNext()) {
            onFail = (OMElement)iterator.next();
        }

        if (onFail != null && onFail.getChildElements().hasNext()) {
            addChildren(onFail, validateMediator);
        } else {
            handleException(""A non-empty <on-fail> child element is required for "" +
                ""the <validate> mediator"");
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(validateMediator,elem);
        // set the features
        Iterator iter = elem.getChildrenWithName(FEATURE_Q);
        while (iter.hasNext()) {
            OMElement featureElem = (OMElement) iter.next();
            OMAttribute attName = featureElem.getAttribute(ATT_NAME);
            OMAttribute attValue = featureElem.getAttribute(ATT_VALUE);
            if (attName != null && attValue != null) {
                String name = attName.getAttributeValue();
                String value = attValue.getAttributeValue();
                if (name != null && value != null) {
                    try {
                        if (""true"".equals(value.trim())) {
                            validateMediator.addFeature(name.trim(), true);
                        } else if (""false"".equals(value.trim())) {
                            validateMediator.addFeature(name.trim(), false);
                        } else {
                            handleException(""The feature must have value true or false"");
                        }
                    } catch (SAXException e) {
                        handleException(""Error setting validation feature : "" + name + "" to : "" + value, e);
                    }
                } else {
                    handleException(""The valid values for both of the name and value are need"");
                }
            } else {
                handleException(""Both of the name and value attribute are required for a feature"");
            }
        }
        return validateMediator;
    }

    public QName getTagQName() {
        return VALIDATE_Q;
    }
}
"
org/apache/synapse/core/axis2/CustomURIResolver.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.ws.commons.schema.resolver.URIResolver;
import org.xml.sax.InputSource;

/**
 * Class that adapts a {@link ResourceMap} to {@link URIResolver}.
 */
public class CustomURIResolver implements URIResolver {
    private ResourceMap resourceMap;
    private SynapseConfiguration synCfg;

    public CustomURIResolver() {
    }
    
    /**
     * Constructor.
     * 
     * @param resourceMap the resource map; may be null if no resource map is configured
     * @param synCfg the Synapse configuration
     */
    public CustomURIResolver(ResourceMap resourceMap,
                                  SynapseConfiguration synCfg) {
        this();
        this.resourceMap = resourceMap;
        this.synCfg = synCfg;
    }
    
    /**
     * Resolve a schema import.
     * This method will first attempt to resolve the location using the configured
     * {@link ResourceMap} object. If this fails (because no {@link ResourceMap} is
     * configured or because {@link ResourceMap#resolve(SynapseConfiguration, String)}
     * returns null, it will resolve the location using
     * {@link SynapseConfigUtils#resolveRelativeURI(String, String)}.
     */
    public InputSource resolveEntity(String targetNamespace, String schemaLocation, String baseUri) {
        InputSource result = null;
        if (resourceMap != null) {
            result = resourceMap.resolve(synCfg, schemaLocation);
        }
        if (result == null) {
            result = new InputSource(SynapseConfigUtils.resolveRelativeURI(baseUri, schemaLocation));
        }
        return result;
    }
}
"
org/apache/synapse/core/axis2/MessageContextCreatorForAxis2.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;

/**
 * The MessageContext needs to be set up and then is used by the SynapseMessageReceiver to inject messages.
 * This class is used by the SynapseMessageReceiver to find the environment. The env is stored in a Parameter to the Axis2 config
 */
public class MessageContextCreatorForAxis2 {

    private static final Log log = LogFactory.getLog(MessageContextCreatorForAxis2.class);

    private static SynapseConfiguration synCfg = null;
    private static SynapseEnvironment   synEnv = null;

    public static MessageContext getSynapseMessageContext(
            org.apache.axis2.context.MessageContext axisMsgCtx) throws AxisFault {

        if (synCfg == null || synEnv == null) {
            String msg = ""Synapse environment has not initialized properly.."";
            log.fatal(msg);
            throw new SynapseException(msg);
        }

        return new Axis2MessageContext(axisMsgCtx, synCfg, synEnv);
    }

    public static void setSynConfig(SynapseConfiguration synCfg) {
        MessageContextCreatorForAxis2.synCfg = synCfg;
    }

    public static void setSynEnv(SynapseEnvironment synEnv) {
        MessageContextCreatorForAxis2.synEnv = synEnv;
    }
}
"
org/apache/synapse/endpoints/FailoverEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.axis2.clustering.ClusterManager;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;

import java.util.List;

/**
 * FailoverEndpoint can have multiple child endpoints. It will always try to send messages to
 * current endpoint. If the current endpoint is failing, it gets another active endpoint from the
 * list and make it the current endpoint. Then the message is sent to the current endpoint and if
 * it fails, above procedure repeats until there are no active endpoints. If all endpoints are
 * failing and parent endpoint is available, this will delegate the problem to the parent endpoint.
 * If parent endpoint is not available it will pop the next FaultHandler and delegate the problem
 * to that.
 */
public class FailoverEndpoint implements Endpoint {

    private static final Log log = LogFactory.getLog(FailoverEndpoint.class);

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;
    /**
     * List of child endpoints. Failover sending is done among these. Any object implementing the
     * Endpoint interface can be a child.
     */
    private List<Endpoint> endpoints = null;

    /**
     * Endpoint for which currently sending the SOAP traffic.
     */
    private Endpoint currentEndpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects. But use of
     * SALoadbalanceEndpoint as the parent is the logical scenario.
     */
    private Endpoint parentEndpoint = null;

    /**
     * The endpoint context , place holder for keep any runtime states related to the endpoint
     */
    private final EndpointContext endpointContext = new EndpointContext();

    public void send(MessageContext synMessageContext) {

        if (log.isDebugEnabled()) {
            log.debug(""Start : Failover Endpoint"");
        }

        boolean isClusteringEnable = false;
        // get Axis2 MessageContext and ConfigurationContext
        org.apache.axis2.context.MessageContext axisMC =
                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
        ConfigurationContext cc = axisMC.getConfigurationContext();

        //The check for clustering environment 

        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
        if (clusterManager != null &&
                clusterManager.getContextManager() != null) {
            isClusteringEnable = true;
        }

        String endPointName = this.getName();
        if (endPointName == null) {

            if (log.isDebugEnabled() && isClusteringEnable) {
                log.warn(""In a clustering environment , the endpoint  name should be specified"" +
                        ""even for anonymous endpoints. Otherwise , the clustering would not be "" +
                        ""functioned correctly if there are more than one anonymous endpoints. "");
            }
            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        if (isClusteringEnable) {
            // if this is a cluster environment , then set configuration context to endpoint context
            if (endpointContext.getConfigurationContext() == null) {
                endpointContext.setConfigurationContext(cc);
                endpointContext.setContextID(endPointName);
            }
        }

        // We have to build the envelop if we are supporting failover.
        // Failover should sent the original message multiple times if failures occur. So we have to
        // access the envelop multiple times.        
        synMessageContext.getEnvelope().build();

        if (currentEndpoint.isActive(synMessageContext)) {
            currentEndpoint.send(synMessageContext);
        } else {

            boolean foundEndpoint = false;
            for (Endpoint endpoint : endpoints) {
                if (endpoint.isActive(synMessageContext)) {
                    foundEndpoint = true;
                    currentEndpoint = endpoint;
                    currentEndpoint.send(synMessageContext);
                    break;
                }
            }

            if (!foundEndpoint) {
                // there are no active child endpoints. so mark this endpoint as failed.
                setActive(false, synMessageContext);

                if (parentEndpoint != null) {
                    parentEndpoint.onChildEndpointFail(this, synMessageContext);
                } else {
                    Object o = synMessageContext.getFaultStack().pop();
                    if (o != null) {
                        ((FaultHandler) o).handleFault(synMessageContext);
                    }
                }
            }
        }
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
     * failed. If so returns false. If at least one child endpoint is in active state, sets this
     * endpoint's state to active and returns true.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        boolean active = endpointContext.isActive();
        if (!active) {
            for (Endpoint endpoint : endpoints) {
                if (endpoint.isActive(synMessageContext)) {
                    active = true;
                    endpointContext.setActive(true);

                    // don't break the loop though we found one active endpoint. calling isActive()
                    // on all child endpoints will update their active state. so this is a good
                    // time to do that.
                }
            }
        }
        
        if (log.isDebugEnabled()) {
            log.debug(""Endpoint  '"" + name + ""' is in state ' "" + active + "" '"");
        }

        return active;
    }

    public void setActive(boolean active, MessageContext synMessageContext) {
        // setting a volatile boolean value is thread safe.
        this.endpointContext.setActive(active);
    }

    public List<Endpoint> getEndpoints() {
        return endpoints;
    }

    public void setEndpoints(List<Endpoint> endpoints) {
        this.endpoints = endpoints;
        if (endpoints.size() > 0) {
            currentEndpoint = endpoints.get(0);
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        send(synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }
}
"
org/apache/synapse/config/xml/StartupFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Startup;

/**
 * Defines the factories which builds startups
 */
public interface StartupFactory {

    /**
     * Create (build from OM) from the specified OMElement
     *
     * @param elem
     *          OMELement describing the Startup
     * @return Startup build from the given element
     */
    public Startup createStartup(OMElement elem);

    /**
     * Get the tag QName of the element
     *
     * @return QName of the element
     */
    public QName getTagQName();

    /**
     * Get the Serializer class for this factory
     *
     * @return Class defining the serialization of the startup
     */
    public Class getSerializerClass();
}
"
org/apache/synapse/util/xpath/SynapseXPathFunctionContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.xpath;

import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.GetPropertyFunction;
import org.jaxen.Function;
import org.jaxen.FunctionContext;
import org.jaxen.UnresolvableException;

/**
 * <p>XPath function context to be used when resolving XPath functions when using the
 * <code>SynapseXPath</code> and this resolves one function except for the standard XPath functions
 * and Jaxen extension functions.</p>
 *
 * <p>The function that has been resolved by this FunctionContext is; <tt>get-property(String)</tt>
 * which is used to retrieve message context properties</p>
 *
 * @see org.jaxen.XPathFunctionContext
 * @see org.apache.synapse.util.xpath.SynapseXPath
 */
public class SynapseXPathFunctionContext implements FunctionContext {
    /** Parent function context */
    private final FunctionContext parent;
    
    /** MessageContext to be used by the function resolver */
    private final MessageContext synCtx;

    /**
     * <p>Initialises the function context</p>
     *
     * @param parent the parent function context
     * @param synCtx message to be used for the function initialization
     *
     * @see org.jaxen.XPathFunctionContext
     */
    public SynapseXPathFunctionContext(FunctionContext parent, MessageContext synCtx) {
        this.parent = parent;
        this.synCtx = synCtx;
    }

    /**
     * Get the function with a given namespace and name.
     * <p>
     * Only the <tt>get-property</tt> function is recognized by this class. Any other
     * function will be resolved using the parent function context.
     * 
     * @param namespaceURI namespace of the function to be resolved
     * @param prefix string prefix to be resolved
     * @param localName string local name of the function
     * @return resolved function
     * @throws UnresolvableException if the function specified does not found
     */
    public Function getFunction(String namespaceURI, String prefix, String localName)
        throws UnresolvableException {

        if (localName != null && SynapseXPathConstants.GET_PROPERTY_FUNCTION.equals(localName)) {
            
            // create an instance of a synapse:get-property()
            // function and set it to the xpath
            GetPropertyFunction getPropertyFunc = new GetPropertyFunction();
            getPropertyFunc.setSynCtx(synCtx);

            return getPropertyFunc;
        }

        // if not the get-property function then try to get it from the parent context
        return parent.getFunction(namespaceURI, prefix, localName);
    }
}
"
org/apache/synapse/config/xml/CloneMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.CloneMediator;
import org.apache.synapse.mediators.eip.Target;

import java.util.Iterator;

/**
 * This will serialize the CloneMediator to the xml configuration as specified bellow
 *
 * <pre>
 *  &lt;clone [continueParent=(true | false)]&gt;
 *   &lt;target [to=""uri""] [soapAction=""qname""] [sequence=""sequence_ref""]
 *          [endpoint=""endpoint_ref""]&gt;
 *     &lt;sequence&gt;
 *       (mediator)+
 *     &lt;/sequence&gt;?
 *     &lt;endpoint&gt;
 *       endpoint
 *     &lt;/endpoint&gt;?
 *   &lt;/target&gt;+
 * &lt;/clone&gt;
 * </pre>
 */
public class CloneMediatorSerializer extends AbstractMediatorSerializer {

    /**
     * This method will implement the serializeMediator method of the MediatorSerializer interface
     * and implements the serialization of CloneMediator to its configuration
     *
     * @param parent OMElement describing the parent element to which the newlly generated
     *          clone element should be attached as a child, if provided
     * @param m Mediator of the type CloneMediator which is subjected to the serialization
     * @return OMElement serialized in to xml from the given parameters
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {

        OMElement cloneElem = fac.createOMElement(""clone"", synNS);
        saveTracingState(cloneElem, m);

        CloneMediator clone = (CloneMediator) m;
        if (clone.isContinueParent()) {
            cloneElem.addAttribute(""continueParent"", Boolean.toString(true), nullNS);
        }

        for (Iterator itr = clone.getTargets().iterator(); itr.hasNext();) {
            Object o = itr.next();
            if (o instanceof Target) {
                cloneElem.addChild(TargetSerializer.serializeTarget((Target) o));
            }
        }

        // attach the serialized element to the parent if specified
        if (parent != null) {
            parent.addChild(cloneElem);
        }

        return cloneElem;
    }

    /**
     * This method will implement the getMediatorClassName method of the
     * MediatorSerializer interface
     * 
     * @return full class name of the Mediator which is serialized by this Serializer
     */
    public String getMediatorClassName() {
        return CloneMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/FilterMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.FilterMediator;

/**
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   mediator+
 * &lt;/filter&gt;
 * </pre>
 *
 * <p>or if the filter medaitor needs to support the else behavior as well (i.e. a set of mediators
 * to be executed when the filter evaluates to false).</p>
 *
 * <pre>
 * &lt;filter (source=""xpath"" regex=""string"") | xpath=""xpath""&gt;
 *   &lt;then [sequence=""string""]&gt;
 *      mediator+
 *   &lt;/then&gt;
 *   &lt;else [sequence=""string""]&gt;
 *      mediator+
 *   &lt;/else&gt;
 * &lt;/filter&gt;
 * </pre>
 */
public class FilterMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FilterMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FilterMediator mediator = (FilterMediator) m;
        OMElement filter = fac.createOMElement(""filter"", synNS);

        if (mediator.getSource() != null && mediator.getRegex() != null) {

            SynapseXPathSerializer.serializeXPath(mediator.getSource(), filter, ""source"");

            filter.addAttribute(fac.createOMAttribute(
                ""regex"", nullNS, mediator.getRegex().pattern()));

        } else if (mediator.getXpath() != null) {

            SynapseXPathSerializer.serializeXPath(mediator.getXpath(), filter, ""xpath"");

        } else {
            handleException(""Invalid filter mediator. "" +
                ""Should have either a 'source' and a 'regex' OR an 'xpath' "");
        }

        saveTracingState(filter, mediator);

        if (mediator.isThenElementPresent()) {

            OMElement thenElem = fac.createOMElement(""then"", synNS);
            filter.addChild(thenElem);

            if (mediator.getThenKey() != null) {
                thenElem.addAttribute(
                    fac.createOMAttribute(""sequence"", nullNS, mediator.getThenKey()));
            } else {
                serializeChildren(thenElem, mediator.getList());
            }

            if (mediator.getElseMediator() != null || mediator.getElseKey() != null) {

                OMElement elseElem = fac.createOMElement(""else"", synNS);
                filter.addChild(elseElem);

                if (mediator.getElseKey() != null) {
                    elseElem.addAttribute(
                        fac.createOMAttribute(""sequence"", nullNS, mediator.getElseKey()));
                } else {
                    serializeChildren(elseElem, mediator.getElseMediator().getList());
                }
            }
            
        } else {
            serializeChildren(filter, mediator.getList());
        }

        if (parent != null) {
            parent.addChild(filter);
        }
        return filter;
    }

    public String getMediatorClassName() {
        return FilterMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/filters/SwitchMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.SwitchCase;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.xpath.SynapseXPath;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The switch mediator implements the functionality of the ""switch"" construct. It first
 * evaluates the given XPath expression into a String value, and performs a match against
 * the given list of cases. This is actually a list of sequences, and depending on the
 * selected case, the selected sequence gets executed.
 */
public class SwitchMediator extends AbstractMediator {

    /** The XPath expression specifying the source element to apply the switch case expressions against   */
    private SynapseXPath source = null;
    /** The list of switch cases    */
    private List cases = new ArrayList();
    /** The default switch case, if any */
    private SwitchCase defaultCase = null;

    /**
     * Iterate over switch cases and find match and execute selected sequence
     *
     * @param synCtx current context
     * @return as per standard semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Switch mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        int parentsEffectiveTraceState = synCtx.getTracingState();
        // if I have been explicitly asked to enable or disable tracing, set it to the message
        // to pass it on; else, do nothing -> i.e. let the parents state flow
        setEffectiveTraceState(synCtx);
        int myEffectiveTraceState = synCtx.getTracingState();

        String sourceText = source.stringValueOf(synCtx);
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""XPath : "" + source + "" evaluates to : "" + sourceText);
        }

        try {
            if ((sourceText == null || cases.isEmpty()) && defaultCase != null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Source XPath evaluated to : null or no switch "" +
                        ""cases found. Executing the default case"");
                }

                return defaultCase.mediate(synCtx);

            } else {
                for (Iterator iter = cases.iterator(); iter.hasNext();) {
                    SwitchCase swCase = (SwitchCase) iter.next();

                    if (swCase != null) {
                        if (swCase.matches(sourceText)) {
                            if (traceOrDebugOn) {
                                traceOrDebug(traceOn, ""Matching case found : "" + swCase.getRegex());
                            }
                            return swCase.mediate(synCtx);
                        }
                    }
                }

                if (defaultCase != null) {
                    // if any of the switch cases did not match
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""None of the switch cases matched - executing default"");
                    }
                    return defaultCase.mediate(synCtx);
                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""None of the switch cases matched - no default case"");
                    }
                }
            }

        } finally {
            synCtx.setTracingState(parentsEffectiveTraceState);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Switch mediator"");
        }
        return true;
    }

    /**
     * Adds the given mediator (Should be a SwitchCaseMediator) to the list of cases
     * of this Switch mediator
     *
     * @param m the SwitchCaseMediator instance to be added
     */
    public void addCase(SwitchCase m) {
        cases.add(m);
    }

    /**
     * Get the list of cases
     *
     * @return the cases list
     */
    public List getCases() {
        return cases;
    }

    /**
     * Return the source XPath expression set
     *
     * @return thje source XPath expression
     */
    public SynapseXPath getSource() {
        return source;
    }

    /**
     * Sets the source XPath expression
     *
     * @param source the XPath expression to be used as the source
     */
    public void setSource(SynapseXPath source) {
        this.source = source;
    }

    /**
     * Get default case
     *
     * @return the default csae
     */
    public SwitchCase getDefaultCase() {
        return defaultCase;
    }

    /**
     * setting the default case ...which contains mediators to invoke when no case condition satisfy
     * @param defaultCase
     */
    public void setDefaultCase(SwitchCase defaultCase) {
        this.defaultCase = defaultCase;
    }
}
"
org/apache/synapse/metrics/Counter.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;
/*
 * This is the basic unit to get Global, Proxy Service or
 * Proxy Opertaion Level hit count. 
 */

public class Counter {

    private long count = 0;

    public synchronized void increment(){
        count++;
    }

    public long getCount() {
        return count;
    }
}
"
org/apache/synapse/config/xml/DBLookupMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.db.DBLookupMediator;

import javax.xml.namespace.QName;

/**
 * Factory for {@link DBLookupMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;dblookup&gt;
 *   &lt;connection&gt;
 *     &lt;pool&gt;
 *      (
 *       &lt;driver/&gt;
 *       &lt;url/&gt;
 *       &lt;user/&gt;
 *       &lt;password/&gt;
 *     |
 *       &lt;dsName/&gt;
 *       &lt;icClass/&gt;
 *       &lt;url/&gt;
 *       &lt;user/&gt;
 *       &lt;password/&gt;
 *     )
 *       &lt;property name=""name"" value=""value""/&gt;*
 *     &lt;/pool&gt;
 *   &lt;/connection&gt;
 *   &lt;statement&gt;
 *     &lt;sql&gt;select something from table where something_else = ?&lt;/sql&gt;
 *     &lt;parameter [value="""" | expression=""""] type=""int|string""/&gt;*
 *     &lt;result name=""string"" column=""int|string""/&gt;*
 *   &lt;/statement&gt;+
 * &lt;/dblookup&gt;
 * </pre>
 */
public class DBLookupMediatorFactory extends AbstractDBMediatorFactory {

    private static final QName DBLOOKUP_Q =
        new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""dblookup"");

    public Mediator createMediator(OMElement elem) {

        DBLookupMediator mediator = new DBLookupMediator();
        buildDataSource(elem, mediator);
        processStatements(elem, mediator);
        return mediator;
    }

    public QName getTagQName() {
        return DBLOOKUP_Q;
    }
}
"
org/apache/synapse/config/xml/SynapseXPathFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * 
 */
public class SynapseXPathFactory {

    private static final Log log = LogFactory.getLog(SynapseXPathFactory.class);

    public static SynapseXPath getSynapseXPath(OMElement elem, QName attribName)
        throws JaxenException {

        SynapseXPath xpath = null;
        OMAttribute xpathAttrib = elem.getAttribute(attribName);

        if (xpathAttrib != null && xpathAttrib.getAttributeValue() != null) {

            xpath = new SynapseXPath(xpathAttrib.getAttributeValue());
            OMElementUtils.addNameSpaces(xpath, elem, log);

        } else {
            handleException(""Couldn't find the XPath attribute with the QName : ""
                + attribName.toString() + "" in the element : "" + elem.toString());
        }       

        return xpath;
    }

    private static void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }
}
"
org/apache/synapse/mediators/eip/aggregator/Aggregate.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.aggregator;

import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.List;
import java.util.ArrayList;
import java.util.TimerTask;

/**
 * An instance of this class is created to manage each aggregation group, and it holds
 * the aggregation properties and the messages collected during aggregation. This class also
 * times out itself after the timeout expires it
 */
public class Aggregate extends TimerTask {

    private static final Log log = LogFactory.getLog(Aggregate.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    private long timeoutMillis = 0;
    /** The time in millis at which this aggregation should be considered as expired */
    private long expiryTimeMillis = 0;
    /** The minimum number of messages to be collected to consider this aggregation as complete */
    private int minCount = -1;
    /** The maximum number of messages that should be collected by this aggregation */
    private int maxCount = -1;
    private String correlation = null;
    /** The AggregateMediator that should be invoked on completion of the aggregation */
    private AggregateMediator aggregateMediator = null;
    private List<MessageContext> messages = new ArrayList<MessageContext>();
    private boolean locked = false;
    private boolean completed = false;

    /**
     * Save aggregation properties and timeout
     *
     * @param corelation representing the corelation name of the messages in the aggregate
     * @param timeoutMillis the timeout duration in milliseconds
     * @param min the minimum number of messages to be aggregated
     * @param max the maximum number of messages to be aggregated
     * @param mediator
     */
    public Aggregate(String corelation, long timeoutMillis, int min,
        int max, AggregateMediator mediator) {
        
        this.correlation = corelation;
        if (timeoutMillis > 0) {
            expiryTimeMillis = System.currentTimeMillis() + timeoutMillis;
        }
        if (min > 0) {
            minCount = min;
        }
        if (max > 0) {
            maxCount = max;
        }
        this.aggregateMediator = mediator;
    }

    /**
     * Add a message to the interlan message list
     *
     * @param synCtx message to be added into this aggregation group
     * @return true if the message was added or false if not
     */
    public synchronized boolean addMessage(MessageContext synCtx) {
        if (maxCount <= 0 || (maxCount > 0 && messages.size() < maxCount)) {
            messages.add(synCtx);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Has this aggregation group completed?
     *
     * @param traceOn is tracing on
     * @param traceOrDebugOn is trace or debug on
     * @param trace trace log to be used
     * @param log log to be used
     *
     * @return boolean true if aggregation is complete
     */
    public synchronized boolean isComplete(boolean traceOn, boolean traceOrDebugOn,
        Log trace, Log log) {

        if (!completed) {

            // if any messages have been collected, check if the completion criteria is met
            if (!messages.isEmpty()) {

                // get total messages for this group, from the first message we have collected
                MessageContext mc = messages.get(0);
                Object prop = mc.getProperty(EIPConstants.MESSAGE_SEQUENCE);
            
                if (prop != null && prop instanceof String) {
                    String[] msgSequence = prop.toString().split(
                            EIPConstants.MESSAGE_SEQUENCE_DELEMITER);
                    int total = Integer.parseInt(msgSequence[1]);

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, trace, log, messages.size() +
                                "" messages of "" + total + "" collected in current aggregation"");
                    }

                    if (messages.size() >= total) {
                        if (traceOrDebugOn) {
                            traceOrDebug(traceOn, trace, log, ""Aggregation complete"");
                        }
                        return true;
                    }
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, trace, log, ""No messages collected in current aggregation"");
                }
            }

            // if the minimum number of messages has been reached, its complete
            if (minCount > 0 && messages.size() >= minCount) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, trace, log,
                            ""Aggregation complete - the minimum : "" + minCount
                                    + "" messages has been reached"");
                }
                return true;
            }

            if (maxCount > 0 && messages.size() >= maxCount) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, trace, log,
                            ""Aggregation complete - the maximum : "" + maxCount
                                    + "" messages has been reached"");
                }

                return true;
            }

            // else, has this aggregation reached its timeout?
            if (expiryTimeMillis > 0 && System.currentTimeMillis() >= expiryTimeMillis) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, trace, log,
                            ""Aggregation complete - the aggregation has timed out"");
                }

                return true;
            }
        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, trace, log,
                        ""Aggregation already completed - this message will not be processed in aggregation"");
            }
        }
        
        return false;
    }

    private void traceOrDebug(boolean traceOn, Log trace, Log log, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

    public long getTimeoutMillis() {
        return timeoutMillis;
    }

    public void setTimeoutMillis(long timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
    }

    public int getMinCount() {
        return minCount;
    }

    public void setMinCount(int minCount) {
        this.minCount = minCount;
    }

    public int getMaxCount() {
        return maxCount;
    }

    public void setMaxCount(int maxCount) {
        this.maxCount = maxCount;
    }

    public String getCorrelation() {
        return correlation;
    }

    public void setCorrelation(String correlation) {
        this.correlation = correlation;
    }

    public List<MessageContext> getMessages() {
        return messages;
    }

    public void setMessages(List<MessageContext> messages) {
        this.messages = messages;
    }

    public long getExpiryTimeMillis() {
        return expiryTimeMillis;
    }

    public void setExpiryTimeMillis(long expiryTimeMillis) {
        this.expiryTimeMillis = expiryTimeMillis;
    }

    public void run() {
        while (true) {
            if (completed) {
                break;
            }
            if (getLock()) {
                if (log.isDebugEnabled()) {
                    log.debug(""Time : "" + System.currentTimeMillis() + "" and this aggregator "" +
                            ""expired at : "" + expiryTimeMillis);
                }
                aggregateMediator.completeAggregate(this);
                break;
            }
        }
    }

    public synchronized boolean getLock() {
        return !locked;
    }

    public void releaseLock() {
        locked = false;
    }

    public boolean isCompleted() {
        return completed;
    }

    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
}
"
org/apache/synapse/SynapseServer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.axis2.Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.File;

/**
 * This is the class invoked by the command line scripts synapse.sh and synapse-daemon.sh to
 * start an instance of Synapse. This class calls on the ServerManager to start up the instance
 *
 * TODO Switch to using commons-cli and move all command line parameter processing etc from the
 * .sh and .bat into this.. for 1.3 release :)
 */
public class SynapseServer {

    private static final Log log = LogFactory.getLog(SynapseServer.class);

    private static final String USAGE_TXT =
        ""Usage: SynapseServer <axis2_repository> <axis2_xml> <synapse_home> <synapse_xml> <resolve_root>"" +
        ""\n Opts: -? this message"";

    public static void printUsage() {
        System.out.println(USAGE_TXT);
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {

        // first check if we should print usage
        if (args.length != 1 && args.length != 4 && args.length != 5 && args.length != 6) {
            printUsage();
        }

        ServerManager serverManager = ServerManager.getInstance();
        serverManager.setAxis2Repolocation(args[0]);
        if (args.length == 1) {
            log.warn(""Configuring server manager using deprecated system properties; please update your configuration"");
            serverManager.setAxis2Xml(System.getProperty(Constants.AXIS2_CONF));
            serverManager.setSynapseHome(System.getProperty(SynapseConstants.SYNAPSE_HOME));
            serverManager.setSynapseXMLPath(System.getProperty(SynapseConstants.SYNAPSE_XML));
            serverManager.setResolveRoot(System.getProperty(SynapseConstants.RESOLVE_ROOT));
        } else if(args.length == 4) {
            serverManager.setAxis2Xml(args[1]);
            serverManager.setSynapseHome(args[2]);
            serverManager.setSynapseXMLPath(args[3]);
            serverManager.setResolveRoot(args[2] + File.separator + ""repository"");
        } else if(args.length == 5) {
            serverManager.setAxis2Xml(args[1]);
            serverManager.setSynapseHome(args[2]);
            serverManager.setSynapseXMLPath(args[3]);
            serverManager.setResolveRoot(args[4]);
        } else if(args.length == 6) {
            serverManager.setAxis2Xml(args[1]);
            serverManager.setSynapseHome(args[2]);
            serverManager.setSynapseXMLPath(args[3]);
            serverManager.setResolveRoot(args[4]);
            serverManager.setServerName(args[5]);
        }
        
        serverManager.start();
        addShutdownHook();
    }

    private static void addShutdownHook() {
        Thread shutdownHook = new Thread() {
            public void run() {
                log.info(""Shutting down Apache Synapse ..."");
                try {
                    ServerManager.getInstance().stop();
                    log.info(""Shutdown complete"");
                    log.info(""Halting JVM"");
                } catch (Exception e) {
                    log.warn(""Error occurred while shutting down Apache Synapse : "" + e);
                }
            }
        };
        Runtime.getRuntime().addShutdownHook(shutdownHook);
    }
}
"
org/apache/synapse/config/xml/EntryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMText;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.net.URL;
import java.net.MalformedURLException;

/**
 * Factory for {@link Entry} instances.
 */
public class EntryFactory implements XMLToObjectMapper {

    private static Log log = LogFactory.getLog(EntryFactory.class);

    public static Entry createEntry(OMElement elem) {

        OMAttribute key = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""key""));
        if (key == null) {
            handleException(""The 'key' attribute is required for a local registry entry"");
            return null;

        } else {

            Entry entry = new Entry(key.getAttributeValue());
            String src  = elem.getAttributeValue(
                    new QName(XMLConfigConstants.NULL_NAMESPACE, ""src""));

            // if a src attribute is present, this is a URL source resource,
            // it would now be loaded from the URL source, as all static properties
            // are initialized at startup
            if (src != null) {
                try {
                    entry.setSrc(new URL(src.trim()));
                    entry.setType(Entry.URL_SRC);
                    entry.setValue(
                        org.apache.synapse.config.SynapseConfigUtils.getObject(entry.getSrc()));
                } catch (MalformedURLException e) {
                    handleException(""The entry with key : "" + key + "" refers to an invalid URL"");
                }

            } else {
                OMNode    nodeValue = elem.getFirstOMChild();
                OMElement elemValue = elem.getFirstElement();

                if (elemValue != null) {
                    entry.setType(Entry.INLINE_XML);
                    entry.setValue(elemValue);
                } else if (nodeValue != null && nodeValue instanceof OMText) {
                    entry.setType(Entry.INLINE_TEXT);
                    entry.setValue(((OMText) nodeValue).getText().trim());
                }
            }
            return entry;
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEntry((OMElement) om);
        } else {
            handleException(""Invalid XML configuration for an Entry. OMElement expected"");
        }
        return null;
    }
}
"
org/apache/synapse/statistics/StatisticsCollector.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.SynapseConstants;

import java.util.*;

/**
 * To collect statistics
 */

public class StatisticsCollector {

    /**  A synchronized map for holding sequence statistics  */
    private Map sequenceStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding end point statistics */
    private Map endpointStatistics = Collections.synchronizedMap(new HashMap());

    /**  A synchronized map for holding proxy services statistics */
    private Map proxyServicesStatistics = Collections.synchronizedMap(new HashMap());

    /**
     * To report the statistics related to a  EndPonit
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForEndPoint(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) endpointStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.ENDPOINT_STATISTICS);
            endpointStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);

    }

    /**
     * To report the statistics related to a  ProxyService
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForProxyService(String keyOfStatistic, boolean isResponse, long inTime,
                                      long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) proxyServicesStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.PROXYSERVICE_STATISTICS);
            proxyServicesStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To report the statistics related to a  Sequence
     *
     * @param keyOfStatistic - key for hold Statistic
     * @param isResponse     - A boolean value that indicate whether message flow is in or out
     * @param inTime         - The processing start time
     * @param outTime        - The processing end time
     * @param isFault        - A boolean value that indicate whether falut has occured or not
     */
    public void reportForSequence(String keyOfStatistic, boolean isResponse, long inTime,
                                  long outTime, boolean isFault) {
        StatisticsHolder statisticsHolder =
                (StatisticsHolder) sequenceStatistics.get(keyOfStatistic);
        if (statisticsHolder == null) {
            statisticsHolder = new StatisticsHolder();
            statisticsHolder.setKey(keyOfStatistic);
            statisticsHolder.setStatisticsCategory(SynapseConstants.SEQUENCE_STATISTICS);
            sequenceStatistics.put(keyOfStatistic, statisticsHolder);
        }
        statisticsHolder.update(isResponse, inTime, outTime, isFault);
    }

    /**
     * To access all sequence statistics
     *
     * @return all sequence statistics
     */
    public Map getSequenceStatistics() {
        return sequenceStatistics;
    }

    /**
     * To access all proxy services statistics
     *
     * @return all proxy services statistics
     */
    public Map getProxyServiceStatistics() {
        return proxyServicesStatistics;
    }

    /**
     * To access all endpoint statistics
     *
     * @return all endpoint statistics
     */
    public Map getEndPointStatistics() {
        return endpointStatistics;
    }

    /**
     * To reset the sequence statistics
     */
    public void resetSequenceStatistics() {
        this.sequenceStatistics.clear();
    }

    /**
     * To reset the proxy service statistics
     */
    public void resetProxyServiceStatistics() {
        this.proxyServicesStatistics.clear();
    }

    /**
     * To reset the endpoint statistics
     */
    public void resetEndPointStatistics() {
        this.endpointStatistics.clear();
    }
}
"
org/apache/synapse/config/xml/MediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

/**
 * Interface which should be implemented by mediator serializers. Does the
 * reverse of the MediatorFactory
 */
public interface MediatorSerializer {

    /**
     * Return the XML representation of this mediator
     * @param m mediator to be serialized
     * @param parent the OMElement to which the serialization should be attached
     * @return the serialized mediator XML
     */
    public OMElement serializeMediator(OMElement parent, Mediator m);

    /**
     * Return the class name of the mediator which can be serialized
     * @return the class name 
     */
    public String getMediatorClassName();
}
"
org/apache/synapse/core/axis2/SynapseDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.HandlerDescription;
import org.apache.axis2.engine.AbstractDispatcher;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.synapse.SynapseConstants;

import javax.xml.namespace.QName;

/**
 * This is the Axis2 Dispatcher which is registered with the Axis2 engine. It dispatches
 * each and every message received to the SynapseMessageReceiver for processing.
 */
public class SynapseDispatcher extends AbstractDispatcher {

    public void initDispatcher() {
        QName qn = new QName(""http://synapse.apache.org"", ""SynapseDispatcher"");
        HandlerDescription hd = new HandlerDescription(qn.getLocalPart());
        super.init(hd);
    }

    public AxisService findService(MessageContext mc) throws AxisFault {
        AxisConfiguration ac = mc.getConfigurationContext().getAxisConfiguration();
        return ac.getService(SynapseConstants.SYNAPSE_SERVICE_NAME);
    }

    public AxisOperation findOperation(AxisService svc, MessageContext mc) throws AxisFault {
        return svc.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);
    }
}
"
org/apache/synapse/mediators/ListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.Mediator;

import java.util.List;

/**
 * The List mediator executes a given sequence/list of child mediators
 */
public interface ListMediator extends Mediator {

    /**
     * Appends the specified mediator to the end of this mediator's (children) list
     * @param m the mediator to be added
     * @return true (as per the general contract of the Collection.add method)
     */
    public boolean addChild(Mediator m);

    /**
     * Appends all of the mediators in the specified collection to the end of this mediator's (children)
     * list, in the order that they are returned by the specified collection's iterator
     * @param c the list of mediators to be added
     * @return true if this list changed as a result of the call
     */
    public boolean addAll(List<Mediator> c);

    /**
     * Returns the mediator at the specified position
     * @param pos index of mediator to return
     * @return the mediator at the specified position in this list
     */
    public Mediator getChild(int pos);

    /**
     * Removes the first occurrence in this list of the specified mediator
     * @param m mediator to be removed from this list, if present
     * @return true if this list contained the specified mediator
     */
    public boolean removeChild(Mediator m);

    /**
     * Removes the mediator at the specified position in this list
     * @param pos the index of the mediator to remove
     * @return the mediator previously at the specified position
     */
    public Mediator removeChild(int pos);

    /**
     * Return the list of mediators of this List mediator instance
     * @return the child/sub mediator list
     */
    public List getList();
}
"
org/apache/synapse/config/xml/SequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

import javax.xml.namespace.QName;

/**
 * Factory for {@link SequenceMediator} instances.
 * <p>
 * It follows the following configuration:
 *
 * <pre>
 * &lt;sequence name=""string"" [onError=""string""] [trace=""enable|disable""]&gt;
 *   mediator+
 * &lt;/sequence&gt;
 * </pre>
 *
 * OR
 *
 * <pre>
 * &lt;sequence key=""name""/&gt;
 * </pre>
 */
public class SequenceMediatorFactory extends AbstractListMediatorFactory {

    private static final QName SEQUENCE_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sequence"");

    public QName getTagQName() {
        return SEQUENCE_Q;
    }

    public SequenceMediator createAnonymousSequence(OMElement elem) {
        SequenceMediator seqMediator = new SequenceMediator();
        OMAttribute e = elem.getAttribute(ATT_ONERROR);
        if (e != null) {
            seqMediator.setErrorHandler(e.getAttributeValue());
        }
        processTraceState(seqMediator, elem);
        addChildren(elem, seqMediator);
        OMAttribute statistics = elem.getAttribute(ATT_STATS);
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }
        return seqMediator;
    }
    
    public Mediator createMediator(OMElement elem) {

        SequenceMediator seqMediator = new SequenceMediator();

        OMAttribute n = elem.getAttribute(ATT_NAME);
        OMAttribute e = elem.getAttribute(ATT_ONERROR);
        if (n != null) {
            seqMediator.setName(n.getAttributeValue());
            if (e != null) {
                seqMediator.setErrorHandler(e.getAttributeValue());
            }
            processTraceState(seqMediator, elem);
            addChildren(elem, seqMediator);

        } else {
            n = elem.getAttribute(ATT_KEY);
            if (n != null) {
                seqMediator.setKey(n.getAttributeValue());
                if (e != null) {
                    String msg = ""A sequence mediator with a reference to another "" +
                        ""sequence can not have 'ErrorHandler'"";
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            } else {
                String msg = ""A sequence mediator should be a named sequence or a reference "" +
                    ""to another sequence (i.e. a name attribute or key attribute is required)"";
                log.error(msg);
                throw new SynapseException(msg);
            }
        }

        OMAttribute statistics = elem.getAttribute(ATT_STATS);
        if (statistics != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (statisticsValue != null) {
                if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_ON);
                } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                    seqMediator.setStatisticsState(
                        org.apache.synapse.SynapseConstants.STATISTICS_OFF);
                }
            }
        }

        return seqMediator;
    }
}
"
org/apache/synapse/statistics/impl/SequenceStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * The data structure to hold statistics related to Sequences
 *
 */

public class SequenceStatisticsStack implements StatisticsStack {

    /** The list to hold SequenceStatistics */
    private List sequenceStatisticsList = new ArrayList();

    /**
     * To put a statistics
     *
     * @param sequenceName       - The name of the sequence
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String sequenceName, long initTime, boolean isInFlow,
                    boolean isStatisticsEnable, boolean isFault) {
        sequenceStatisticsList.add(new SequenceStatistics(sequenceName, initTime,
                isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        int top = sequenceStatisticsList.size();
        if (top > 0) {
            popSequenceStatistics(sequenceStatisticsList.size() - 1, statisticsCollector);
        }
    }

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (!sequenceStatisticsList.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator seqIterator = sequenceStatisticsList.iterator();
                 seqIterator.hasNext();) {
                SequenceStatistics sequenceStatistics =
                        (SequenceStatistics) seqIterator.next();
                if (sequenceStatistics != null) {
                    if (sequenceStatistics.isStatisticsEnable &&
                            sequenceStatistics.sequenceName != null &&
                            sequenceStatistics.sequenceName.equals(name)
                            ) {
                        statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                                !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                                System.currentTimeMillis(), sequenceStatistics.isFault);
                    }
                    tobeRemoved.add(sequenceStatistics);
                }
            }
            sequenceStatisticsList.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        int i = sequenceStatisticsList.size() - 1;
        for (; i >= 0; i--) {
            popSequenceStatistics(i, statisticsCollector);
        }
    }

    /**
     * A helper method to pop a SequenceStatistics
     * @param index
     * @param statisticsCollector
     */
    private void popSequenceStatistics(int index, StatisticsCollector statisticsCollector) {
        if (index >= 0) {
            SequenceStatistics sequenceStatistics =
                    (SequenceStatistics) sequenceStatisticsList.get(index);
            if (sequenceStatistics != null) {
                if (sequenceStatistics.isStatisticsEnable &&
                        sequenceStatistics.sequenceName != null) {
                    statisticsCollector.reportForSequence(sequenceStatistics.sequenceName,
                            !sequenceStatistics.isInFlow, sequenceStatistics.initTime,
                            System.currentTimeMillis(), sequenceStatistics.isFault);
                }
                sequenceStatisticsList.remove(index);
            }
        }
    }

    /**
     * The SequenceStatistics data structure
     */
    class SequenceStatistics {

        /** The name of the Sequence */
        String sequenceName;
        /** The time which starts to collect statistics */
        long initTime;
        /** To check whether IN message flow or not */
        boolean isInFlow;
        /** To check whether statistics is enabled or not */
        boolean isStatisticsEnable;
        /** To indicate whether this is fault or not*/
        private boolean isFault;

        public SequenceStatistics(String sequenceName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean isFault) {
            this.sequenceName = sequenceName;
            this.initTime = initTime;
            isInFlow = inFlow;
            isStatisticsEnable = statisticsEnable;
            this.isFault = isFault;
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            final SequenceStatistics that = (SequenceStatistics) o;

            if (!sequenceName.equals(that.sequenceName)) return false;

            return true;
        }

        public int hashCode() {
            return sequenceName.hashCode();
        }
    }

}
"
org/apache/synapse/config/xml/CacheMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CacheMediator;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.wso2.caching.CachingConstants;
import org.wso2.caching.digest.DigestGenerator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Creates an instance of a Cache mediator using XML configuration specified
 *
 * <pre>
 * &lt;cache [id=""string""] [hashGenerator=""class""] [timeout=""seconds""]
 *      [scope=(per-host | per-mediator)] collector=(true | false) [maxMessageSize=""in-bytes""]&gt;
 *   &lt;onCacheHit [sequence=""key""]&gt;
 *     (mediator)+
 *   &lt;/onCacheHit&gt;?
 *   &lt;implementation type=(memory | disk) maxSize=""int""/&gt;
 * &lt;/cache&gt;
 * </pre>
 */
public class CacheMediatorFactory extends AbstractMediatorFactory {

    private static final QName CACHE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""cache"");
    private static final QName ATT_ID = new QName(""id"");
    private static final QName ATT_COLLECTOR = new QName(""collector"");
    private static final QName ATT_HASH_GENERATOR = new QName(""hashGenerator"");
    private static final QName ATT_MAX_MSG_SIZE = new QName(""maxMessageSize"");
    private static final QName ATT_TIMEOUT = new QName(""timeout"");
    private static final QName ATT_SCOPE = new QName(""scope"");
    private static final QName ATT_SEQUENCE = new QName(""sequence"");
    private static final QName ATT_TYPE = new QName(""type"");
    private static final QName ATT_SIZE = new QName(""maxSize"");
    private static final QName ON_CACHE_HIT_Q =
        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""onCacheHit"");
    private static final QName IMPLEMENTATION_Q =
        new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""implementation"");
    private static final long DEFAULT_TIMEOUT = 5000L;
    private static final int DEFAULT_DISK_CACHE_SIZE = 200;

    public Mediator createMediator(OMElement elem) {

        if (!CACHE_Q.equals(elem.getQName())) {
            handleException(""Unable to create the cache mediator. "" +
                ""Unexpected element as the cache mediator configuration"");
        }

        CacheMediator cache = new CacheMediator();

        OMAttribute idAttr = elem.getAttribute(ATT_ID);
        if (idAttr != null && idAttr.getAttributeValue() != null) {
            cache.setId(idAttr.getAttributeValue());
        }

        OMAttribute scopeAttr = elem.getAttribute(ATT_SCOPE);
        if (scopeAttr != null && scopeAttr.getAttributeValue() != null &&
            isValidScope(scopeAttr.getAttributeValue(), cache.getId())) {
            cache.setScope(scopeAttr.getAttributeValue());
        } else {
            cache.setScope(CachingConstants.SCOPE_PER_HOST);
        }

        OMAttribute collectorAttr = elem.getAttribute(ATT_COLLECTOR);
        if (collectorAttr != null && collectorAttr.getAttributeValue() != null &&
            ""true"".equals(collectorAttr.getAttributeValue())) {

            cache.setCollector(true);
        } else {
            
            cache.setCollector(false);

            OMAttribute hashGeneratorAttr = elem.getAttribute(ATT_HASH_GENERATOR);
            if (hashGeneratorAttr != null && hashGeneratorAttr.getAttributeValue() != null) {
                try {
                    Class generator = Class.forName(hashGeneratorAttr.getAttributeValue());
                    Object o = generator.newInstance();
                    if (o instanceof DigestGenerator) {
                        cache.setDigestGenerator((DigestGenerator) o);
                    } else {
                        handleException(""Specified class for the hashGenerator is not a "" +
                            ""DigestGenerator. It *must* implement "" +
                            ""org.wso2.caching.digest.DigestGenerator interface"");
                    }
                } catch (ClassNotFoundException e) {
                    handleException(""Unable to load the hash generator class"", e);
                } catch (IllegalAccessException e) {
                    handleException(""Unable to access the hash generator class"", e);
                } catch (InstantiationException e) {
                    handleException(""Unable to instantiate the hash generator class"", e);
                }
            }

            OMAttribute timeoutAttr = elem.getAttribute(ATT_TIMEOUT);
            if (timeoutAttr != null && timeoutAttr.getAttributeValue() != null) {
                cache.setTimeout(Long.parseLong(timeoutAttr.getAttributeValue()));
            } else {
                cache.setTimeout(DEFAULT_TIMEOUT);
            }

            OMAttribute maxMessageSizeAttr = elem.getAttribute(ATT_MAX_MSG_SIZE);
            if (maxMessageSizeAttr != null && maxMessageSizeAttr.getAttributeValue() != null) {
                cache.setMaxMessageSize(Integer.parseInt(maxMessageSizeAttr.getAttributeValue()));
            }

            OMElement onCacheHitElem = elem.getFirstChildWithName(ON_CACHE_HIT_Q);
            if (onCacheHitElem != null) {
                OMAttribute sequenceAttr = onCacheHitElem.getAttribute(ATT_SEQUENCE);
                if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {
                    cache.setOnCacheHitRef(sequenceAttr.getAttributeValue());
                } else if (onCacheHitElem.getFirstElement() != null) {
                    cache.setOnCacheHitSequence(
                        new SequenceMediatorFactory().createAnonymousSequence(onCacheHitElem));
                }
            }

            for (Iterator itr = elem.getChildrenWithName(IMPLEMENTATION_Q); itr.hasNext();) {
                OMElement implElem = (OMElement) itr.next();
                OMAttribute typeAttr = implElem.getAttribute(ATT_TYPE);
                OMAttribute sizeAttr = implElem.getAttribute(ATT_SIZE);
                if (typeAttr != null && typeAttr.getAttributeValue() != null) {
                    String type = typeAttr.getAttributeValue();
                    if (CachingConstants.TYPE_MEMORY.equals(type) && sizeAttr != null &&
                        sizeAttr.getAttributeValue() != null) {
                        cache.setInMemoryCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));
                    } else if (CachingConstants.TYPE_DISK.equals(type)) {
                        log.warn(""Disk based and hirearchycal caching is not implemented yet"");
                        if (sizeAttr != null && sizeAttr.getAttributeValue() != null) {
                            cache.setDiskCacheSize(Integer.parseInt(sizeAttr.getAttributeValue()));
                        } else {
                            cache.setDiskCacheSize(DEFAULT_DISK_CACHE_SIZE);
                        }
                    } else {
                        handleException(""unknown implementation type for the Cache mediator"");
                    }
                }
            }
        }

        return cache;
    }

    private boolean isValidScope(String scope, String id) {
        if (CachingConstants.SCOPE_PER_HOST.equals(scope)) {
            return true;
        } else if (CachingConstants.SCOPE_PER_MEDIATOR.equals(scope)) {
            if (id != null) {
                return true;
            } else {
                handleException(""Id is required for a cache wirth scope : "" + scope);
                return false;
            }
        } else if (CachingConstants.SCOPE_DISTRIBUTED.equals(scope)) {
            handleException(""Scope distributed is not supported yet by the Cache mediator"");
            return false;
        } else {
            handleException(""Unknown scope "" + scope + "" for the Cache mediator"");
            return false;
        }
    }

    public QName getTagQName() {
        return CACHE_Q;
    }
}
"
org/apache/synapse/startup/quartz/SimpleQuartzFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.config.xml.PropertyHelper;
import org.apache.synapse.config.xml.StartupFactory;
import org.apache.synapse.Startup;
import org.apache.synapse.SynapseException;

/**
 * &lt;task class=""org.my.synapse.Task"" name=""string""&gt;
 *  &lt;property name=""stringProp"" value=""String""/&gt;
 *  &lt;property name=""xmlProp""&gt;
 *   &lt;somexml&gt;config&lt;/somexml&gt;
 *  &lt;/property&gt;
 *  &lt;trigger ([[count=""10""]? interval=""1000""] | [cron=""0 * 1 * * ?""] | [once=(true | false)])/&gt;
 * &lt;/task&gt;
 */
public class SimpleQuartzFactory implements StartupFactory {

    public final static QName TASK
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""task"");

    private final static QName TRIGGER
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""trigger"");

    private final static QName PROPERTY
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");

    private final static Log log = LogFactory.getLog(SimpleQuartzFactory.class);

    public Startup createStartup(OMElement el) {
        
        if (log.isDebugEnabled()) {
            log.debug(""Creating SimpleQuartz Task"");
        }
        
        if (el.getQName().equals(TASK)) {
            
            SimpleQuartz q = new SimpleQuartz();

            String name = el.getAttributeValue(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));
            if (name != null) {
                q.setName(name);
            } else {
                handleException(""Name for a task is required, missing name in the task"");
            }

            // set the task class
            OMAttribute classAttr = el.getAttribute(new QName(""class""));
            if (classAttr != null && classAttr.getAttributeValue() != null) {
                String classname = classAttr.getAttributeValue();
                try {
                    Class.forName(classname).newInstance();
                } catch (Exception e) {
                    handleException(""Failed to load task class "" + classname, e);
                }
                q.setJobClass(classname);
            } else {
                handleException(""Syntax error in the Task : no task class specified"");
            }
            
            // set pinned server list
            OMAttribute pinnedServers = el.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""pinnedServers""));
            if (pinnedServers != null) {
                String pinnedServersValue = pinnedServers.getAttributeValue();
                if (pinnedServersValue == null) {
                    // default to all servers
                } else {
                    StringTokenizer st = new StringTokenizer(pinnedServersValue, "" ,"");
                    List pinnedServersList = new ArrayList();
                    while (st.hasMoreTokens()) {
                        String token = st.nextToken();
                        if (token.length() != 0) {
                          pinnedServersList.add(token);
                        }
                    }
                    q.setPinnedServers(pinnedServersList);
                }
            }

            // next sort out the property children
            Iterator it = el.getChildrenWithName(PROPERTY);
            while (it.hasNext()) {
                OMElement prop = (OMElement) it.next();
                if (PropertyHelper.isStaticProperty(prop)) {
                    q.addProperty(prop);
                } else {
                    handleException(""Tasks does not support dynamic properties"");
                }
            }

            // setting the trigger to the task
            OMElement trigger = el.getFirstChildWithName(TRIGGER);
            if (trigger != null) {

                OMAttribute count = trigger.getAttribute(new QName(""count""));
                if (count != null) {
                    try {
                        q.setCount(Integer.parseInt(count.getAttributeValue()));
                    } catch (Exception e) {
                        handleException(""Failed to parse trigger count as an integer"", e);
                    }
                }

                OMAttribute once = trigger.getAttribute(new QName(""once""));
                if (once != null && Boolean.TRUE.toString().equals(once.getAttributeValue())) {
                    q.setCount(1);
                    q.setInterval(1);
                }

                OMAttribute repeatInterval = trigger.getAttribute(new QName(""interval""));
                if (repeatInterval == null && q.getCount() > 1) {
                    handleException(""Trigger seems to be "" +
                        ""a simple trigger, but no interval specified"");
                } else if (repeatInterval != null && repeatInterval.getAttributeValue() != null) {
                    try {
                        long repeatIntervalInSeconds = Long.parseLong(repeatInterval.getAttributeValue());
                        long repeatIntervalInMillis = repeatIntervalInSeconds * 1000;
                        q.setInterval(repeatIntervalInMillis);
                    } catch (Exception e) {
                        handleException(""Failed to parse trigger interval as a long value"", e);
                    }
                }

                OMAttribute expr = trigger.getAttribute(new QName(""cron""));
                if (expr == null && q.getInterval() == 0) {
                    q.setCount(1);
                    q.setInterval(1);
                } else if (expr != null && q.getInterval() > 0) {
                    handleException(""Trigger syntax error : "" +
                        ""both cron and simple trigger attributes are present"");
                } else if (expr != null && expr.getAttributeValue() != null) {
                    q.setCron(expr.getAttributeValue());
                }

            } else {
                q.setCount(1);
                q.setInterval(1);
            }

            return q;
        } else {
            handleException(""Syntax error in the task : wrong QName for the task"");
            return null;
        }
    }

    public Class getSerializerClass() {
        return SimpleQuartzSerializer.class;
    }

    public QName getTagQName() {
        return TASK;
    }

    private void handleException(String message, Exception e) {
        log.error(message);
        throw new SynapseException(message, e);
    }

    private void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }

}
"
org/apache/synapse/ServerManager.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.description.TransportInDescription;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.description.AxisModule;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.engine.ListenerManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.format.BinaryBuilder;
import org.apache.synapse.format.PlainTextBuilder;
import org.apache.synapse.transport.nhttp.NhttpConstants;
import org.apache.synapse.util.ClasspathURLStreamHandler;
import org.apache.synapse.util.RMIRegistryController;

import java.io.File;
import java.net.*;
import java.util.Map;

/**
 * This is the core class that starts up a Synapse instance.
 *
 * From the command line scripts synapse.sh and synapse-daemon.sh (though the wrapper.conf)
 * the SynapseServer is invoked which inturn calls on this to start the instance
 *
 * When the WAR deployment is used, the SynapseStartUpServlet servlet calls on this class to
 * initialize Synapse
 */

public class ServerManager {

    private static final Log log = LogFactory.getLog(ServerManager.class);

    /** The singleton server manager instance */
    private static ServerManager instance = new ServerManager();

    /** The Axis2 repository location */
    private String axis2Repolocation;
    /** The path to the axis2.xml file */
    private String axis2Xml;
    /** The synapse home is the home directory of the Synapse installation */
    private String synapseHome;
    /** The path to the synapse.xml file */
    private String synapseXMLPath;
    /** The root directory to resolve paths for registry, default to synapse.home/repository */
    private String resolveRoot;
    /** An optional server name to activate pinned services, tasks etc.. and to differentiate instances on a cluster */
    private String serverName = ""localhost"";

    /** The Axis2 listener Manager */
    private ListenerManager listenerManager;
    /** The Axis2 configuration context used by Synapse */
    private ConfigurationContext configctx;
    /** Reference to the Synapse configuration */
    private SynapseConfiguration synConfig = null;
    private Map callbackStore = null;

    /**
     * return the singleton server manager
     * @return  ServerManager Instance
     */
    public static ServerManager getInstance() {
        return instance;
    }

    /**
     * starting all the listeners
     */
    public void start() {

        // validate if we can start
        validate();

        // Register custom protocol handler classpath://
		try {
			URL.setURLStreamHandlerFactory(new URLStreamHandlerFactoryImpl());
		} catch (Throwable t) {
			log.debug(""Unable to register a URLStreamHandlerFactory - "" +
					""Custom URL protocols may not work properly (e.g. classpath://)"");
		}

        try {
            configctx = ConfigurationContextFactory.
                    createConfigurationContextFromFileSystem(axis2Repolocation, axis2Xml);
            
            addDefaultBuildersAndFormatters(configctx.getAxisConfiguration());
            
            listenerManager = configctx.getListenerManager();
            if (listenerManager == null) {
                listenerManager = new ListenerManager();
                listenerManager.init(configctx);
            }

            for (Object o : configctx.getAxisConfiguration().getTransportsIn().keySet()) {
                
                String trp = (String) o;
                TransportInDescription trsIn = (TransportInDescription)
                    configctx.getAxisConfiguration().getTransportsIn().get(trp);

                String msg = ""Starting transport "" + trsIn.getName();
                if (trsIn.getParameter(""port"") != null) {
                    msg += "" on port "" + trsIn.getParameter(""port"").getValue();
                }
                log.info(msg);

                listenerManager.addListener(trsIn, false);
            }

            // now initialize SynapseConfig
            Parameter synEnv
                = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_ENV);
            Parameter synCfg
                = configctx.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);

            String message = ""Unable to initialize the Synapse Configuration : Cannot find the "";
            if (synCfg == null || synCfg.getValue() == null
                || !(synCfg.getValue() instanceof SynapseConfiguration)) {
                log.fatal(message + ""Synapse Configuration"");
                throw new SynapseException(message + ""Synapse Configuration"");
            } else {
                synConfig = (SynapseConfiguration) synCfg.getValue();
            }

            if (synEnv == null || synEnv.getValue() == null
                || !(synEnv.getValue() instanceof SynapseEnvironment)) {
                log.fatal(message + ""Synapse Environment"");
                throw new SynapseException(message + ""Synapse Environment"");
            } else {

                ((SynapseEnvironment) synEnv.getValue()).setInitialized(true);

                // initialize the startups
                for (Startup stp : ((SynapseConfiguration) synCfg.getValue()).getStartups()) {
                    if (stp != null) {
                        stp.init((SynapseEnvironment) synEnv.getValue());
                    }
                }
            }

            log.info(""Ready for processing"");

        } catch (Throwable t) {
            log.fatal(""Synaps startup failed..."", t);
            throw new SynapseException(""Synapse startup failed"", t);
        }
    }

    private void addDefaultBuildersAndFormatters(AxisConfiguration axisConf) {
        if (axisConf.getMessageBuilder(""text/plain"") == null) {
            axisConf.addMessageBuilder(""text/plain"", new PlainTextBuilder());
        }
        if (axisConf.getMessageBuilder(""application/octet-stream"") == null) {
            axisConf.addMessageBuilder(""application/octet-stream"", new BinaryBuilder());
        }
    }

    /**
     * stop all the listeners
     */
    public void stop() {
        try {
            RMIRegistryController.getInstance().removeLocalRegistry();

            // stop all services
            if (configctx != null && configctx.getAxisConfiguration() != null) {
                Map<String, AxisService> serviceMap = configctx.getAxisConfiguration().getServices();
                for (AxisService svc : serviceMap.values()) {
                    svc.setActive(false);
                }

                // stop all modules
                Map<String, AxisModule> moduleMap = configctx.getAxisConfiguration().getModules();
                for (AxisModule mod : moduleMap.values()) {
                    if (mod.getModule() != null && !""synapse"".equals(mod.getName())) {
                        mod.getModule().shutdown(configctx);
                    }
                }
            }

            // stop all transports
            if (listenerManager != null) {
                listenerManager.stop();
                listenerManager.destroy();
            }
            
            // we need to call this method to clean the temp files we created.
            if (configctx != null) {
                configctx.terminate();
            }
        } catch (Exception e) {
            log.error(""Error stopping the ServerManager"", e);
        }
    }

    /**
     * Expose the number of callbacks in the callback store
     * @return the number of callbacks (messages) waiting for responses
     */
    public int pendingCallbacks() {
        if (callbackStore != null) {
            return callbackStore.size();
        } else {
            return 0;
        }
    }

    private static final class URLStreamHandlerFactoryImpl implements URLStreamHandlerFactory {

        public URLStreamHandler createURLStreamHandler(String protocol) {

            if (protocol == null) {
                throw new IllegalArgumentException(""'protocol' cannot be null"");
            }
            URLStreamHandler urlSH = null;
            if (protocol.equals(""classpath"")) {
                urlSH = new ClasspathURLStreamHandler();
            }
            return urlSH;
        }
    }

    /**
     * Validate core settings for startup
     */
    private void validate() {
        if (synapseHome == null || !new File(synapseHome).exists()) {
            handleFatal(""Synapse home"");
        } else {
            log.info(""Using Synapse home as : "" + synapseHome);
        }

        if (axis2Repolocation == null || !new File(axis2Repolocation).exists()) {
            handleFatal(""Axis2 repository"");
        } else {
            log.info(""Using the Axis2 Repository : "" + new File(axis2Repolocation).getAbsolutePath());
        }

        if (axis2Xml == null || !new File(axis2Xml).exists()) {
            handleFatal(""axis2.xml location"");
        } else {
            log.info(""Using the axis2.xml : "" + new File(axis2Xml).getAbsolutePath());
        }

        if (synapseXMLPath == null || !new File(synapseXMLPath).exists()) {
            handleFatal(""synapse.xml path"");
        }

        if (serverName == null) {
            try {
                serverName = InetAddress.getLocalHost().getHostName();
            } catch (UnknownHostException ignore) {}
            log.info(""The server name was not specified, defaulting to : "" + serverName);
        } else {
            log.info(""Using server name : "" + serverName);
        }

        log.info(""The timeout handler will run every : "" + (getTimeoutHandlerInterval()/1000) + ""s"");
    }

    public void handleFatal(String msgPre) {
        String msg = ""The "" + msgPre + "" must be set as a system property or init-parameter"";
        log.fatal(msg);
        throw new SynapseException(msg);
    }

    // getters and setters
    public ConfigurationContext getConfigurationContext() {
        return configctx;
    }

    public void setCallbackStore(Map callbackStore) {
        this.callbackStore = callbackStore;
    }

    public void setAxis2Repolocation(String axis2Repolocation) {
        if (!new File(axis2Repolocation).isAbsolute() && synapseHome != null) {
            this.axis2Repolocation = synapseHome + File.separator + axis2Repolocation;
        } else {
            this.axis2Repolocation = axis2Repolocation;
        }
    }

    public void setAxis2Xml(String axis2Xml) {
        if (!new File(axis2Xml).isAbsolute() && synapseHome != null) {
            this.axis2Xml = synapseHome + File.separator + axis2Xml;
        } else {
            this.axis2Xml = axis2Xml;
        }
    }

    public String getSynapseHome() {
        return synapseHome;
    }

    public void setSynapseHome(String synapseHome) {
        this.synapseHome = synapseHome;
    }

    public String getResolveRoot() {
        return resolveRoot;
    }

    public void setResolveRoot(String resolveRoot) {
        if (!new File(resolveRoot).isAbsolute() && synapseHome != null) {
            this.resolveRoot = synapseHome + File.separator + resolveRoot;
        } else {
            this.resolveRoot = resolveRoot;
        }
    }

    public String getServerName() {
        return serverName;
    }

    public void setServerName(String serverName) {
        this.serverName = serverName;
    }

    public String getSynapseXMLPath() {
        return synapseXMLPath;
    }

    public void setSynapseXMLPath(String synapseXMLPath) {
        if (!new File(synapseXMLPath).isAbsolute() && synapseHome != null) {
            this.synapseXMLPath = synapseHome + File.separator + synapseXMLPath;
        } else {
            this.synapseXMLPath = synapseXMLPath;
        }
    }

    public int getConnectTimeout() {
        if (synConfig == null) {
            return (int) SynapseConstants.DEFAULT_GLOBAL_TIMEOUT;
        } else {
            return (int) synConfig.getProperty(
                SynapseConstants.CONNECTTIMEOUT, SynapseConstants.DEFAULT_CONNECTTIMEOUT);
        }
    }

    public int getReadTimeout() {
        if (synConfig == null) {
            return SynapseConstants.DEFAULT_READTIMEOUT;
        } else {
            return (int) synConfig.getProperty(
                SynapseConstants.READTIMEOUT, SynapseConstants.DEFAULT_READTIMEOUT);
        }
    }

    public long getTimeoutHandlerInterval() {
        if (synConfig == null) {
            return SynapseConstants.DEFAULT_TIMEOUT_HANDLER_INTERVAL;
        } else {
            return synConfig.getProperty(
                SynapseConstants.TIMEOUT_HANDLER_INTERVAL, SynapseConstants.DEFAULT_TIMEOUT_HANDLER_INTERVAL);
        }
    }

    public long getGlobalTimeoutInterval() {
        if (synConfig == null) {
            return SynapseConstants.DEFAULT_GLOBAL_TIMEOUT;
        } else {
            return synConfig.getProperty(
                SynapseConstants.GLOBAL_TIMEOUT_INTERVAL, SynapseConstants.DEFAULT_GLOBAL_TIMEOUT);
        }
    }
}"
org/apache/synapse/mediators/ext/ClassMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.mediators.AbstractMediator;

import java.util.HashMap;
import java.util.Map;

/**
 * The class mediator delegates the mediation to a single instance of a specified
 * class. The specified class must implement the Mediator interface and optionally
 * may implement the ManagedLifecycle interface. At initialization time, a single
 * instance of the class is instantiated using a public no argument constructor, and
 * any one-time properties (parameter constants specified through the Synapse config)
 * are set on the instance. If each request needs synchronization, the user must
 * implement it within the specified class.
 * 
 * @see Mediator
 */
public class ClassMediator extends AbstractMediator implements ManagedLifecycle {

    /** The reference to the actual class that implments the Mediator interface */
    private Mediator mediator = null;
    /** A list of simple properties that would be set on the class before being used */
    private Map<String, Object> properties = new HashMap<String, Object>();

    /**
	 * Don't use a new instance... do one instance of the object per instance of
	 * this mediator
	 * 
	 * @param synCtx
	 *            the message context
	 * @return as per standard semantics
	 */
	public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Class mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (traceOrDebugOn) {
			traceOrDebug(traceOn, ""invoking : "" + mediator.getClass() + "".mediate()"");
		}

        boolean result;

        try {
			result = mediator.mediate(synCtx);
        } catch (Exception e) {
            // throw Synapse Exception for any exception in class meditor
            // so that the fault handler will be invoked
            throw new SynapseException(""Error occured in the mediation of the class mediator"", e);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Class mediator"");
        }
        
        return result;
    }

	public void destroy() {
        if (log.isDebugEnabled()) {
            log.debug(""Destroying class mediator instance for : "" + mediator.getClass());
        }
        if (mediator instanceof ManagedLifecycle) {
			((ManagedLifecycle) mediator).destroy();
		}
	}

	public void init(SynapseEnvironment se) {
        if (log.isDebugEnabled()) {
            log.debug(""Initializing class mediator instance for : "" + mediator.getClass());
        }
        if (mediator == null) {
            log.warn(""init() called before mediator reference set"");
            return;
		}

		if (mediator instanceof ManagedLifecycle) {
			((ManagedLifecycle) mediator).init(se);
		}
	}

	public void setMediator(Mediator mediator) {
		this.mediator = mediator;
	}

	public Mediator getMediator() {
		return mediator;
	}

    public void addProperty(String name, Object value) {
        properties.put(name, value);
    }

    public Map getProperties() {
        return this.properties;
    }
}
"
org/apache/synapse/core/axis2/AsyncCallback.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.client.async.AxisCallback;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;

/**
 * This class only ""holds"" the Synapse out message context for the Synapse callback message
 * receiver when a response is received or error is encountered
 */
public class AsyncCallback implements AxisCallback {

    /** The corresponding Synapse outgoing message context this instance is holding onto */
    MessageContext synapseOutMsgCtx = null;

    /** Time to timeout this callback */
    private long timeOutOn;

    /** Action to perform when timeout occurs */
    private int timeOutAction = SynapseConstants.NONE;

    public AsyncCallback(MessageContext synapseOutMsgCtx) {
        this.synapseOutMsgCtx = synapseOutMsgCtx;
    }

    public void onMessage(org.apache.axis2.context.MessageContext messageContext) {}

    public void onFault(org.apache.axis2.context.MessageContext messageContext) {}

    public void onError(Exception e) {}

    public void onComplete() {}

    public org.apache.synapse.MessageContext getSynapseOutMsgCtx() {
        return synapseOutMsgCtx;
    }

    public long getTimeOutOn() {
        return timeOutOn;
    }

    public void setTimeOutOn(long timeOutOn) {
        this.timeOutOn = timeOutOn;
    }

    public int getTimeOutAction() {
        return timeOutAction;
    }

    public void setTimeOutAction(int timeOutAction) {
        this.timeOutAction = timeOutAction;
    }
}
"
org/apache/synapse/util/ClasspathURLStreamHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;

import org.apache.commons.lang.StringUtils;

public final class ClasspathURLStreamHandler extends URLStreamHandler {

    public URLConnection openConnection(URL url) {
        return new URLConnectionImpl(url);
    }

    private static final class URLConnectionImpl extends URLConnection {

        public URLConnectionImpl(URL url) {
            super(url);
        }

        public void connect() {}

        public InputStream getInputStream() throws IOException {
            if (StringUtils.isNotEmpty(url.getHost())) {
                throw new MalformedURLException(""No host expected in classpath URLs"");
            }
            InputStream is = ClasspathURLStreamHandler.class.getClassLoader().getResourceAsStream(url.getFile());
            if (is == null) {
                throw new IOException(""Classpath resource not found: "" + url);
            }
            return is;
        }

        public OutputStream getOutputStream() {
            throw new UnsupportedOperationException();
        }
    }
}"
org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import java.util.Map;

/**
 * Dispatches sessions based on HTTP cookies. Session is initiated by the server in the first
 * response when it sends ""Set-Cookie"" HTTP header with the session ID. For all successive messages
 * client should send ""Cookie"" HTTP header with session ID send by the server.
 */
public class HttpSessionDispatcher implements Dispatcher {

    private static final Log log = LogFactory.getLog(HttpSessionDispatcher.class);

    private final static String TRANSPORT_HEADERS = ""TRANSPORT_HEADERS"";
    /*HTTP Headers  */
    private final static String COOKIE = ""Cookie"";
    private final static String SET_COOKIE = ""Set-Cookie"";

    /**
     * Check if ""Cookie"" HTTP header is available. If so, check if that cookie is in the session
     * map. If cookie is available, there is a session for this cookie. return the (server)
     * endpoint for that session.
     *
     * @param synCtx MessageContext possibly containing a ""Cookie"" HTTP header.
     * @return Endpoint Server endpoint for the given HTTP session.
     */
    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {

        Endpoint endpoint = null;

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(COOKIE);

            if (cookie != null && cookie instanceof String) {

                if (log.isDebugEnabled()) {
                    log.debug(""Using the HTTP header 'Cookie: "" + cookie
                            + ""' to retrieve the endpoint in the transport session"");
                }

                Object ep = dispatcherContext.getEndpoint((String) cookie);
                if (ep != null && ep instanceof Endpoint) {
                    endpoint = (Endpoint) ep;
                } else if (log.isDebugEnabled()) {
                    log.debug(""No endpoint found in the transport "" +
                            ""session for the session id "" + cookie);
                }
                
            } else if (log.isDebugEnabled()) {
                log.debug(""No 'Cookie' HTTP headers found to extract the "" +
                        ""endpoint from the transport session"");
            }
        }

        return endpoint;
    }

    /**
     * Searches for ""Set-Cookie"" HTTP header in the message context. If found and that given
     * session ID is not already in the session map update the session map by mapping the cookie
     * to the endpoint.
     *
     * @param synCtx   MessageContext possibly containing the ""Set-Cookie"" HTTP header.
     * @param endpoint Endpoint to be mapped to the session.
     */
    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
        Endpoint endpoint) {

        if (endpoint == null || dispatcherContext == null) {
            return;
        }

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(SET_COOKIE);

            if (cookie != null && cookie instanceof String) {
                
                // extract the first name value pair of the Set-Cookie header, which is considered
                // as the session id which will be sent back from the client with the Cookie header
                // for example;
                //      Set-Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE; Path=/
                // will result in the session id ""JSESSIONID=760764CB72E96A7221506823748CF2AE""
                // and the client is expected to send the Cookie header as;
                //      Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE
                if (log.isDebugEnabled()) {
                    log.debug(""Found the HTTP header 'Set-Cookie: ""
                            + cookie + ""' for updating the session"");
                }
                String sessionId = ((String) cookie).split("";"")[0];

                if (log.isDebugEnabled()) {
                    log.debug(""Using the session id '"" + sessionId +
                            ""' extracted from the Set-Cookie header to update the session "" +
                            ""with the endpoint "" + endpoint);
                }
                dispatcherContext.setEndpoint(sessionId, endpoint);
                
            } else if (log.isDebugEnabled()) {
                log.debug(""No 'Set-Cookie' HTTP header is specified in "" +
                        ""the message to update the session"");
            }
        }
    }

    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {

        org.apache.axis2.context.MessageContext axis2MessageContext =
                ((Axis2MessageContext) synCtx).getAxis2MessageContext();

        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
        if (o != null && o instanceof Map) {
            Map headerMap = (Map) o;
            Object cookie = headerMap.get(COOKIE);

            if (cookie != null && cookie instanceof String) {
                
                if (log.isDebugEnabled()) {
                    log.debug(""Using the HTTP header 'Cookie: ""
                            + cookie + ""' to unbind the session"");
                }
                dispatcherContext.removeSession((String) cookie);
                
            } else if (log.isDebugEnabled()) {
                log.debug(""No 'Cookie' HTTP header is specified in "" +
                        ""the message to unbind the session"");
            }
        }
    }

    /**
     * HTTP sessions are initiated by the server.
     *
     * @return true
     */
    public boolean isServerInitiatedSession() {
        return true;
    }
}
"
org/apache/synapse/endpoints/DefaultEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;

import java.util.Stack;

/**
 * This class represents an endpoint with epr as addressing to header of the message. It is
 * responsible for sending the message to the epr specified in the message To header, performing
 * retries if a failure occurred and informing the parent endpoint if a failure couldn't be
 * recovered.
 */
public class DefaultEndpoint extends FaultHandler implements Endpoint {

    protected Log log;
    
    protected static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
     * of indirect endpoints.
     */
    private String name = null;

    /**
     * Stores the endpoint details for this endpoint. Details include EPR, WS-Addressing
     * information, WS-Security information, etc.
     */
    private EndpointDefinition endpoint = null;

    /**
     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
     */
    private Endpoint parentEndpoint = null;

    public DefaultEndpoint() {
        log = LogFactory.getLog(this.getClass());
    }

    public EndpointDefinition getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(EndpointDefinition endpoint) {
        this.endpoint = endpoint;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    /**
     * This will always return true, because the endpoint epr is dependent on the message being
     * processed
     *
     * @param synMessageContext not being used
     * @return true
     */
    public boolean isActive(MessageContext synMessageContext) {
        return true;
    }

    /**
     * since this is a virtual representation of an endpoint and the epr changes from message
     * to message setting active state doesn't have a meaning
     *
     * @param active            not being used
     * @param synMessageContext not being used
     */
    public synchronized void setActive(boolean active, MessageContext synMessageContext) {
        // no implementation according to the behavior
    }

    /**
     * Sends the message through this endpoint. This method just handles statistics related
     * functions and gives the message to the Synapse environment to send. It does not add any
     * endpoint specific details to the message context. These details are added only to the cloned
     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
     * context for resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Default Endpoint"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        String endPointName = this.getName();
        if (endPointName == null) {
            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
        }

        // Setting Required property to collect the End Point statistics
        boolean statisticsEnable
                = (SynapseConstants.STATISTICS_ON == endpoint.getStatisticsState());
        if (statisticsEnable) {
            EndPointStatisticsStack endPointStatisticsStack = null;
            Object statisticsStackObj =
                    synCtx.getProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS);
            if (statisticsStackObj == null) {
                endPointStatisticsStack = new EndPointStatisticsStack();
                synCtx.setProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS,
                        endPointStatisticsStack);
            } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
            }
            if (endPointStatisticsStack != null) {
                boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                        !synCtx.isResponse(), statisticsEnable, isFault);
            }
        }

        if (synCtx.getTo() != null && synCtx.getTo().getAddress() != null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Sending message to endpoint : "" +
                        endPointName + "" resolves to address = "" + synCtx.getTo().getAddress());
                traceOrDebug(traceOn, ""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                        synCtx.getSoapAction() : ""null""));
                traceOrDebug(traceOn, ""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));

                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Envelope : \n"" + synCtx.getEnvelope());
                }
            }
        }

        // register this as the immediate fault handler for this message.
        synCtx.pushFaultHandler(this);

        // add this as the last endpoint to process this message. it is used by statistics code.
        synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);

        synCtx.getEnvironment().send(endpoint, synCtx);
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // nothing to do as this is a leaf level endpoint
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     *
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
                (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
                        msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     *
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     *
     * @param traceOn is runtime trace on for this message?
     * @param msg     the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }
}
"
org/apache/synapse/util/SimpleMapImpl.java,false,"package org.apache.synapse.util;

import java.io.ByteArrayOutputStream;

import java.util.HashMap;
import java.util.Iterator;

import javax.activation.DataHandler;
import javax.xml.namespace.QName;

import org.apache.axiom.attachments.ByteArrayDataSource;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMText;


public class SimpleMapImpl extends HashMap implements SimpleMap {
	private static final OMNamespace attrNS = OMAbstractFactory.getOMFactory().createOMNamespace("""", """");
	private static final String TYPE = ""type"";

	private static final String NAME = ""name"";

	private static final String ENTRY = ""entry"";

	private static final String SHORT = ""short"";

	private static final String LONG = ""long"";

	private static final String DOUBLE = ""double"";
	private static final String INTEGER = ""int"";
	private static final String FLOAT = ""float"";

	private static final String BYTEARRAY = ""byte[]"";

	private static final String BYTE = ""byte"";

	private static final String STRING = ""string"";

	private static final String BOOLEAN = ""boolean"";

	private static final String CHAR = ""char"";

	private static final long serialVersionUID = 1L;

	public SimpleMapImpl() {
		super();
	}

	public Object get(String name) {
		return this.get((Object) name);
	}

	public boolean getBoolean(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Boolean) {
			return ((Boolean) o).booleanValue();
		} else {
			throw new RuntimeException(""getBoolean("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Boolean"");
		}
	}

	public byte getByte(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Byte) {
			return ((Byte) o).byteValue();
		} else {
			throw new RuntimeException(""getByte("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Byte"");
		}
	}

	public byte[] getBytes(String name) {
		Object o = this.get((Object) name);
		if (o instanceof byte[]) {
			return (byte[]) o;
		} else {
			throw new RuntimeException(""getByteArray("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of byte[]"");
		}
	}

	public char getChar(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Character) {
			return ((Character) o).charValue();
		} else {
			throw new RuntimeException(""getChar("" + name + ""): ""
					+ o.getClass().getName()
					+ "" is not an instance of Character"");
		}
	}

	public double getDouble(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Double) {
			return ((Double) o).doubleValue();
		} else {
			throw new RuntimeException(""getDouble("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Double"");
		}
	}

	public float getFloat(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Float) {
			return ((Float) o).floatValue();
		} else {
			throw new RuntimeException(""getFloat("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Float"");
		}
	}

	public int getInt(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Integer) {
			return ((Integer) o).intValue();
		} else {
			throw new RuntimeException(""getInt("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Integer"");
		}
	}

	public long getLong(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Long) {
			return ((Long) o).longValue();
		} else {
			throw new RuntimeException(""getLong("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Long"");
		}
	}

	public short getShort(String name) {
		Object o = this.get((Object) name);
		if (o instanceof Short) {
			return ((Short) o).shortValue();
		} else {
			throw new RuntimeException(""getShort("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of Short"");
		}
	}

	public String getString(String name) {
		Object o = this.get((Object) name);
		if (o instanceof String) {
			return ((String) o);
		} else {
			throw new RuntimeException(""getString("" + name + ""): ""
					+ o.getClass().getName() + "" is not an instance of String"");
		}
	}

	public void put(String name, Object value) {
		this.put((Object) name, value);
	}

	public void putBoolean(String name, boolean b) {
		this.put((Object) name, new Boolean(b));

	}

	public void putByte(String name, byte b) {
		this.put((Object) name, new Byte(b));

	}

	public void putBytes(String name, byte[] bytes) {
		this.put((Object) name, bytes);

	}

	public void putChar(String name, char c) {
		this.put((Object) name, new Character(c));

	}

	public void putDouble(String name, double d) {
		this.put((Object) name, new Double(d));

	}

	public void putFloat(String name, float fl) {
		this.put((Object) name, new Float(fl));

	}

	public void putInt(String name, int i) {
		this.put((Object) name, new Integer(i));

	}

	public void putLong(String name, long l) {
		this.put((Object) name, new Long(l));

	}

	public void putShort(String name, short s) {
		this.put((Object) name, new Short(s));

	}

	public void putString(String name, String value) {
		this.put((Object) name, value);

	}

	public OMElement getOMElement() {
		return getOMElement(OMAbstractFactory.getOMFactory());
	}

	public OMElement getOMElement(OMFactory fac) {
		OMElement mapElement = fac.createOMElement(PayloadHelper.MAPELT);
		
		for (Iterator it = this.keySet().iterator(); it.hasNext();) {
			OMElement entry = fac.createOMElement(new QName(
					PayloadHelper.AXIOMPAYLOADNS, ENTRY), mapElement);
			
			
			Object key = it.next();
			if (key instanceof String) {
				Object o = this.get(key);
				entry.addAttribute(NAME, (String) key, attrNS);
				if (o instanceof Character) {
					entry.addAttribute(TYPE, CHAR, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Boolean) {
					entry.addAttribute(TYPE, BOOLEAN, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof String) {
					entry.addAttribute(TYPE, STRING, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Byte) {
					entry.addAttribute(TYPE, BYTE, attrNS);
					entry.setText(((Byte) o).toString());
				} else if (o instanceof byte[]) {
					entry.addAttribute(TYPE, BYTEARRAY, attrNS);
					OMText text = fac.createOMText(new DataHandler(
							new ByteArrayDataSource((byte[]) o)), true);
					entry.addChild(text);
				} else if (o instanceof Float) {
					entry.addAttribute(TYPE, FLOAT, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Double) {
					entry.addAttribute(TYPE, DOUBLE, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Long) {
					entry.addAttribute(TYPE, LONG, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Short) {
					entry.addAttribute(TYPE, SHORT, attrNS);
					entry.setText(o.toString());
				} else if (o instanceof Integer) {
					entry.addAttribute(TYPE, INTEGER, attrNS);
					entry.setText(o.toString());
				}

			} else {
				// shouldn't be any non-string keys. Ignore!
			}
		}

		return mapElement;
	}

	// create an instance from an OMElement (if its the right shape!!!)
	public SimpleMapImpl(OMElement el) {
		super();
		if (el.getQName().equals(PayloadHelper.MAPELT)) {
			for (Iterator it = el.getChildElements(); it.hasNext(); ) {
				OMElement child = (OMElement)it.next();
				if (child.getLocalName().equals(ENTRY)) {
					String name = child.getAttributeValue(new QName("""",NAME));
					String type = child.getAttributeValue(new QName("""", TYPE));
					try {
					if (type==null || name == null) {
						//bad!
						continue;
					}
					OMNode data = child.getFirstOMChild();
					if (data.getType()!=OMNode.TEXT_NODE) {
						continue; // BAD!
					}
					OMText text = (OMText)data;
					 if (type.equals(INTEGER)) {
						this.put((Object)name, new Integer(text.getText()));
					} else if (type.equals(CHAR)) {
						this.put((Object)name, new Character((text.getText().charAt(0))));
					} else if (type.equals(DOUBLE)) {
						this.put((Object)name, new Double(text.getText()));
					} else if (type.equals(FLOAT)) {
						this.put((Object)name, new Float(text.getText()));
					} else if (type.equals(BYTE)) {
						this.put((Object)name, new Byte(text.getText().getBytes()[0]));
					} else if (type.equals(SHORT)) {
						this.put((Object)name, new Short(text.getText()));
					} else if (type.equals(LONG)) {
						this.put((Object)name, new Long(text.getText()));
					} else if (type.equals(STRING)) {
						this.put((Object)name, text.getText());
					} else if (type.equals(BYTEARRAY)) {
						DataHandler dh = (DataHandler)text.getDataHandler();
						ByteArrayOutputStream baos = new ByteArrayOutputStream();
						dh.writeTo(baos);
						this.put((Object)name, baos.toByteArray());
					}
					} catch (Exception e) {
						e.printStackTrace();
						// ignore errors
					}
					 
				}
			}
		}
	}

}
"
org/apache/synapse/config/xml/DropMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

/**
 * Serializer for {@link DropMediator} instances.
 * 
 * @see DropMediatorFactory
 */
public class DropMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DropMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DropMediator mediator = (DropMediator) m;
        OMElement drop = fac.createOMElement(""drop"", synNS);
        saveTracingState(drop,mediator);

        if (parent != null) {
            parent.addChild(drop);
        }
        return drop;
    }

    public String getMediatorClassName() {
        return DropMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/DBLookupMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.db.DBLookupMediator;

/**
 * Serializer for {@link DBLookupMediator} instances.
 * 
 * @see DBLookupMediatorSerializer
 */
public class DBLookupMediatorSerializer extends AbstractDBMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DBLookupMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DBLookupMediator mediator = (DBLookupMediator) m;
        OMElement dbLookup = fac.createOMElement(""dblookup"", synNS);
        saveTracingState(dbLookup,mediator);
        serializeDBInformation(mediator, dbLookup);

        if (parent != null) {
            parent.addChild(dbLookup);
        }
        return dbLookup;
    }

    public String getMediatorClassName() {
        return DBLookupMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/SynapseMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.base.SynapseMediator;

import javax.xml.namespace.QName;

/**
 * Builds the main mediator (@see SynapseConfiguration) of the Synapse instance
 *
 * <pre>
 * &lt;rules&gt;
 *   mediator+
 * &lt;rules&gt;
 * </pre>
 */
public class SynapseMediatorFactory extends AbstractListMediatorFactory {

    private final static QName RULES_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""rules"");

    public QName getTagQName() {
        return RULES_Q;
    }

    public Mediator createMediator(OMElement elem) {
        SynapseMediator sm = new SynapseMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sm,elem);

        addChildren(elem, sm);
        return sm;
    }

}
"
org/apache/synapse/config/xml/CalloutMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CalloutMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Factory for {@link CalloutMediator} instances.
 * 
 * <pre>
 * &lt;callout serviceURL=""string"" [action=""string""]&gt;
 *      &lt;configuration [axis2xml=""string""] [repository=""string""]/&gt;?
 *      &lt;source xpath=""expression"" | key=""string""&gt;
 *      &lt;target xpath=""expression"" | key=""string""/&gt;
 * &lt;/callout&gt;
 * </pre>
 */
public class CalloutMediatorFactory extends AbstractMediatorFactory {

    private static final QName TAG_NAME
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""callout"");
    private static final QName ATT_URL = new QName(""serviceURL"");
    private static final QName ATT_ACTION = new QName(""action"");
    private static final QName ATT_AXIS2XML = new QName(""axis2xml"");
    private static final QName ATT_REPOSITORY = new QName(""repository"");
    private static final QName Q_CONFIG
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""configuration"");
    private static final QName Q_SOURCE
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""source"");
    private static final QName Q_TARGET
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    public Mediator createMediator(OMElement elem) {

        CalloutMediator callout = new CalloutMediator();

        OMAttribute attServiceURL = elem.getAttribute(ATT_URL);
        OMAttribute attAction     = elem.getAttribute(ATT_ACTION);
        OMElement   configElt     = elem.getFirstChildWithName(Q_CONFIG);
        OMElement   sourceElt     = elem.getFirstChildWithName(Q_SOURCE);
        OMElement   targetElt     = elem.getFirstChildWithName(Q_TARGET);

        if (attServiceURL != null) {
            callout.setServiceURL(attServiceURL.getAttributeValue());
        } else {
            handleException(""The 'serviceURL' attribute is required for the Callout mediator"");
        }

        if (attAction != null) {
            callout.setAction(attAction.getAttributeValue());
        }

        if (configElt != null) {

            OMAttribute axis2xmlAttr = configElt.getAttribute(ATT_AXIS2XML);
            OMAttribute repoAttr = configElt.getAttribute(ATT_REPOSITORY);

            if (axis2xmlAttr != null && axis2xmlAttr.getAttributeValue() != null) {
                callout.setAxis2xml(axis2xmlAttr.getAttributeValue());
            }

            if (repoAttr != null && repoAttr.getAttributeValue() != null) {
                callout.setClientRepository(repoAttr.getAttributeValue());
            }
        }

        if (sourceElt != null) {
            if (sourceElt.getAttribute(ATT_XPATH) != null) {
                try {
                    callout.setRequestXPath(
                        SynapseXPathFactory.getSynapseXPath(sourceElt, ATT_XPATH));
                } catch (JaxenException e) {
                    handleException(""Invalid source XPath : ""
                        + sourceElt.getAttributeValue(ATT_XPATH));
                }
            } else if (sourceElt.getAttribute(ATT_KEY) != null) {
                callout.setRequestKey(sourceElt.getAttributeValue(ATT_KEY));
            } else {
                handleException(""A 'xpath' or 'key' attribute "" +
                    ""is required for the Callout 'source'"");
            }
        } else {
            handleException(""The message 'source' must be specified for a Callout mediator"");
        }

        if (targetElt != null) {
            if (targetElt.getAttribute(ATT_XPATH) != null) {
                try {
                    callout.setTargetXPath(
                        SynapseXPathFactory.getSynapseXPath(targetElt, ATT_XPATH));
                } catch (JaxenException e) {
                    handleException(""Invalid target XPath : ""
                        + targetElt.getAttributeValue(ATT_XPATH));
                }
            } else if (targetElt.getAttribute(ATT_KEY) != null) {
                callout.setTargetKey(targetElt.getAttributeValue(ATT_KEY));
            } else {
                handleException(""A 'xpath' or 'key' attribute "" +
                    ""is required for the Callout 'target'"");
            }
        } else {
            handleException(""The message 'target' must be specified for a Callout mediator"");
        }

        return callout;
    }

    public QName getTagQName() {
        return TAG_NAME;
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.MessageContext;

/**
 * This mediator represents an unnamed list mediator
 */

public class AnonymousListMediator extends AbstractListMediator {

     public boolean mediate(MessageContext synCtx) {
         return super.mediate(synCtx);
     }
}
"
org/apache/synapse/config/xml/POJOCommandMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.ext.POJOCommandMediator;

/**
 * Serializer for {@link POJOCommandMediator} instances.
 * 
 * @see POJOCommandMediatorFactory
 */
public class POJOCommandMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {
        
        if (!(m instanceof POJOCommandMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        
        POJOCommandMediator mediator = (POJOCommandMediator) m;
        
        OMElement pojoCommand = fac.createOMElement(""pojoCommand"", synNS);
        saveTracingState(pojoCommand, mediator);

        if (mediator.getCommand() != null && mediator.getCommand().getClass().getName() != null) {
            pojoCommand.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, mediator.getCommand().getName()));
        } else {
            handleException(""Invalid POJO Command mediator. The command class name is required"");
        }

        for (String propName : mediator.getStaticSetterProperties().keySet()) {
            Object value = mediator.getStaticSetterProperties().get(propName);
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));

            if (value instanceof String) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, (String) value));
            } else if (value instanceof OMElement) {
                prop.addChild((OMElement) value);
            } else {
                handleException(""Unable to serialize the command "" +
                    ""mediator property with the naem "" + propName + "" : Unknown type"");
            }

            if (mediator.getContextGetterProperties().containsKey(propName)) {
                prop.addAttribute(fac.createOMAttribute(""context-name"", nullNS,
                    mediator.getContextGetterProperties().get(propName)));
            } else if (mediator.getMessageGetterProperties().containsKey(propName)) {
                SynapseXPathSerializer.serializeXPath(
                    mediator.getMessageGetterProperties().get(propName), prop, ""expression"");
            }
            pojoCommand.addChild(prop);
        }

        for (String propName : mediator.getMessageSetterProperties().keySet()) {
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
            SynapseXPathSerializer.serializeXPath(
                mediator.getMessageSetterProperties().get(propName), prop, ""expression"");

            if (mediator.getMessageGetterProperties().containsKey(propName)) {
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadAndUpdateMessage""));
            } else if (mediator.getContextGetterProperties().containsKey(propName)) {
                prop.addAttribute(fac.createOMAttribute(""context-name"", nullNS,
                    mediator.getContextGetterProperties().get(propName)));
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadMessage""));                
            } else {
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadMessage""));                                
            }
            pojoCommand.addChild(prop);
        }

        for (String propName : mediator.getContextSetterProperties().keySet()) {
            OMElement prop = fac.createOMElement(PROP_Q);
            prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
            prop.addAttribute(fac.createOMAttribute(""context-name"", nullNS,
                mediator.getContextSetterProperties().get(propName)));

            if (mediator.getContextGetterProperties().containsKey(propName)) {
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadAndUpdateContext""));
            } else if (mediator.getMessageGetterProperties().containsKey(propName)) {
                SynapseXPathSerializer.serializeXPath(
                    mediator.getMessageGetterProperties().get(propName), prop, ""expression"");
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadContext""));
            } else {
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""ReadContext""));                
            }
            pojoCommand.addChild(prop);
        }

        for (String propName : mediator.getContextGetterProperties().keySet()) {
            if (!isSerialized(propName, mediator)) {
                String value = mediator.getContextGetterProperties().get(propName);
                OMElement prop = fac.createOMElement(PROP_Q);
                prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
                prop.addAttribute(fac.createOMAttribute(""context-name"", nullNS, value));
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""UpdateContext""));
                pojoCommand.addChild(prop);
            }
        }

        for (String propName : mediator.getMessageGetterProperties().keySet()) {
            if (!isSerialized(propName, mediator)) {
                OMElement prop = fac.createOMElement(PROP_Q);
                prop.addAttribute(fac.createOMAttribute(""name"", nullNS, propName));
                SynapseXPathSerializer.serializeXPath(
                    mediator.getMessageGetterProperties().get(propName), prop, ""expression"");
                prop.addAttribute(fac.createOMAttribute(""action"", nullNS, ""UpdateMessage""));
                pojoCommand.addChild(prop);
            }
        }

        if (parent != null) {
            parent.addChild(pojoCommand);
        }
        return pojoCommand;
    }

    private boolean isSerialized(String propName, POJOCommandMediator m) {
        return m.getContextSetterProperties().containsKey(propName) ||
            m.getStaticSetterProperties().containsKey(propName) ||
            m.getMessageSetterProperties().containsKey(propName);
    }

    public String getMediatorClassName() {
        return POJOCommandMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/HeaderMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.transform.HeaderMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Factory for {@link HeaderMediator} instances.
 * <p>
 * Configuration syntax to set a header:
 *   <pre>
 *      &lt;header name=""qname"" (value=""literal"" | expression=""xpath"")/&gt;
 *   </pre>
 *
 * Configuration syntax to remove a header:
 *   <pre>
 *      &lt;header name=""qname"" action=""remove""/&gt;
 *   </pre>
 */
public class HeaderMediatorFactory extends AbstractMediatorFactory  {

    private static final QName HEADER_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""header"");
    private static final QName ATT_ACTION = new QName(""action"");

    public Mediator createMediator(OMElement elem) {

        HeaderMediator headerMediator = new HeaderMediator();
        OMAttribute name   = elem.getAttribute(ATT_NAME);
        OMAttribute value  = elem.getAttribute(ATT_VALUE);
        OMAttribute exprn  = elem.getAttribute(ATT_EXPRN);
        OMAttribute action = elem.getAttribute(ATT_ACTION);

        if (name == null || name.getAttributeValue() == null) {
            String msg = ""A valid name attribute is required for the header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            String nameAtt = name.getAttributeValue();
            int colonPos = nameAtt.indexOf("":"");
            if (colonPos != -1) {
                // has a NS prefix.. find it and the NS it maps into
                String prefix = nameAtt.substring(0, colonPos);
                String namespaceURI = OMElementUtils.getNameSpaceWithPrefix(prefix, elem);
                if (namespaceURI == null) {
                    String msg = ""Invalid namespace prefix '"" + prefix + ""' in name attribute"";
                    log.error(msg);
                    throw new SynapseException(msg);
                } else {
                	headerMediator.setQName(new QName(namespaceURI, nameAtt.substring(colonPos+1), prefix));
                }
            } else {
                // no prefix
                headerMediator.setQName(new QName(nameAtt));
            }
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(headerMediator,elem);

        // The action attribute is optional, if provided and equals to 'remove' the
        // header mediator will act as a header remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            headerMediator.setAction(HeaderMediator.ACTION_REMOVE);
        }

        if (headerMediator.getAction() == HeaderMediator.ACTION_SET &&
            value == null && exprn == null) {
            String msg = ""A 'value' or 'expression' attribute is required for a [set] header mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (value != null && value.getAttributeValue() != null) {
            headerMediator.setValue(value.getAttributeValue());

        } else if (exprn != null && exprn.getAttributeValue() != null) {
            try {
                headerMediator.setExpression(SynapseXPathFactory.getSynapseXPath(elem, ATT_EXPRN));
            } catch (JaxenException je) {
                String msg = ""Invalid XPath expression : "" + exprn.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg, je);
            }
        }

        return headerMediator;
    }

    public QName getTagQName() {
        return HEADER_Q;
    }
}
"
org/apache/synapse/config/xml/CacheMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.CacheMediator;

/**
 * Serializes the Cache mediator to the XML configuration specified
 * <p/>
 * <pre>
 * &lt;cache [id=""string""] [hashGenerator=""class""] [timeout=""seconds""]
 *      [scope=(per-host | per-mediator)] collector=(true | false) [maxMessageSize=""in-bytes""]&gt;
 *   &lt;onCacheHit [sequence=""key""]&gt;
 *     (mediator)+
 *   &lt;/onCacheHit&gt;?
 *   &lt;implementation type=(memory | disk) maxSize=""int""/&gt;
 * &lt;/cache&gt;
 * </pre>
 */
public class CacheMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof CacheMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        CacheMediator mediator = (CacheMediator) m;
        OMElement cache = fac.createOMElement(""cache"", synNS);
        saveTracingState(cache, mediator);

        if (mediator.getId() != null) {
            cache.addAttribute(fac.createOMAttribute(""id"", nullNS, mediator.getId()));
        }

        if (mediator.getScope() != null) {
            cache.addAttribute(fac.createOMAttribute(""scope"", nullNS, mediator.getScope()));
        }

        if (mediator.isCollector()) {
            cache.addAttribute(fac.createOMAttribute(""collector"", nullNS, ""true""));
        } else {

            cache.addAttribute(fac.createOMAttribute(""collector"", nullNS, ""false""));

            if (mediator.getDigestGenerator() != null) {
                cache.addAttribute(fac.createOMAttribute(""hashGenerator"", nullNS,
                    mediator.getDigestGenerator().getClass().getName()));
            }

            if (mediator.getTimeout() != 0) {
                cache.addAttribute(
                    fac.createOMAttribute(""timeout"", nullNS, Long.toString(mediator.getTimeout())));
            }

            if (mediator.getMaxMessageSize() != 0) {
                cache.addAttribute(
                    fac.createOMAttribute(""maxMessageSize"", nullNS,
                        Integer.toString(mediator.getMaxMessageSize())));
            }

            if (mediator.getOnCacheHitRef() != null) {
                OMElement onCacheHit = fac.createOMElement(""onCacheHit"", synNS);
                onCacheHit.addAttribute(
                    fac.createOMAttribute(""sequence"", nullNS, mediator.getOnCacheHitRef()));
                cache.addChild(onCacheHit);
            } else if (mediator.getOnCacheHitSequence() != null) {
                OMElement onCacheHit = fac.createOMElement(""onCacheHit"", synNS);
                new SequenceMediatorSerializer()
                    .serializeChildren(onCacheHit, mediator.getOnCacheHitSequence().getList());
                cache.addChild(onCacheHit);
            }

            if (mediator.getInMemoryCacheSize() != 0) {
                OMElement implElem = fac.createOMElement(""implementation"", synNS);
                implElem.addAttribute(fac.createOMAttribute(""type"", nullNS, ""memory""));
                implElem.addAttribute(fac.createOMAttribute(""maxSize"", nullNS,
                    Integer.toString(mediator.getInMemoryCacheSize())));
                cache.addChild(implElem);
            }

            if (mediator.getDiskCacheSize() != 0) {
                OMElement implElem = fac.createOMElement(""implementation"", synNS);
                implElem.addAttribute(fac.createOMAttribute(""type"", nullNS, ""disk""));
                implElem.addAttribute(fac.createOMAttribute(""maxSize"", nullNS,
                    Integer.toString(mediator.getDiskCacheSize())));
                cache.addChild(implElem);
            }
        }

        if (parent != null) {
            parent.addChild(cache);
        }

        return cache;
    }

    public String getMediatorClassName() {
        return CacheMediator.class.getName();
    }
}
"
org/apache/synapse/core/axis2/SynapseInitializationModule.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.modules.Module;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.MDC;
import org.apache.neethi.Assertion;
import org.apache.neethi.Policy;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.ServerManager;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.SynapseConfigurationBuilder;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * This is the Synapse Module implementation class, which would initialize Synapse when it is
 * deployed onto an Axis2 configuration.
 */
public class SynapseInitializationModule implements Module {

    private static final Log log = LogFactory.getLog(SynapseInitializationModule.class);
    private SynapseConfiguration synCfg;

    public void init(ConfigurationContext configurationContext,
        AxisModule axisModule) throws AxisFault {

        log.info(""Initializing Synapse at : "" + new Date());
        try {
            InetAddress addr = InetAddress.getLocalHost();
            if (addr != null) {
                // Get IP Address
                String ipAddr = addr.getHostAddress();
                if (ipAddr != null) {
                    MDC.put(""ip"", ipAddr);
                }

                // Get hostname
                String hostname = addr.getHostName();
                if (hostname == null) {
                    hostname = ipAddr;
                }
                MDC.put(""host"", hostname);
            }
        } catch (UnknownHostException e) {
            log.warn(""Unable to determine hostname or IP address of the server for logging"", e);
        }

        // this will deploy the mediators in the mediator extensions folder
        log.info(""Loading mediator extensions..."");
        configurationContext.getAxisConfiguration().getConfigurator().loadServices();

        // Initializing the SynapseEnvironment and SynapseConfiguration
        log.info(""Initializing the Synapse configuration ..."");
        synCfg = getConfiguration(configurationContext);

        log.info(""Deploying the Synapse service.."");
        // Dynamically initialize the Synapse Service and deploy it into Axis2
        AxisConfiguration axisCfg = configurationContext.getAxisConfiguration();
        AxisService synapseService = new AxisService(SynapseConstants.SYNAPSE_SERVICE_NAME);
        AxisOperation mediateOperation = new InOutAxisOperation(
            SynapseConstants.SYNAPSE_OPERATION_NAME);
        mediateOperation.setMessageReceiver(new SynapseMessageReceiver());
        synapseService.addOperation(mediateOperation);
        List transports = new ArrayList();
        transports.add(Constants.TRANSPORT_HTTP);
        transports.add(Constants.TRANSPORT_HTTPS);
        synapseService.setExposedTransports(transports);
        axisCfg.addService(synapseService);
        
        // this server name is given by system property SynapseServerName
        // otherwise take host-name
        // if nothing found assume localhost
        String thisServerName = ServerManager.getInstance().getServerName();
        if(thisServerName == null || thisServerName.equals("""")) {
          try {
            InetAddress addr = InetAddress.getLocalHost();
            thisServerName = addr.getHostName();

          } catch (UnknownHostException e) {
            log.warn(""Could not get local host name"", e);
          }
          
          if(thisServerName == null || thisServerName.equals("""")) {
            thisServerName = ""localhost"";
          }
        }
        log.info(""Synapse server name : "" + thisServerName);
        
        log.info(""Deploying Proxy services..."");
        
        for (ProxyService proxy : synCfg.getProxyServices()) {

            // start proxy service if either,
            // pinned server name list is empty
            // or pinned server list has this server name
            List pinnedServers = proxy.getPinnedServers();
            if (pinnedServers != null && !pinnedServers.isEmpty()) {
                if (!pinnedServers.contains(thisServerName)) {
                    log.info(""Server name not in pinned servers list. Not deploying Proxy service : "" + proxy.getName());
                    continue;
                }
            }

            proxy.buildAxisService(synCfg, axisCfg);
            log.info(""Deployed Proxy service : "" + proxy.getName());
            if (!proxy.isStartOnLoad()) {
                proxy.stop(synCfg);
            }
        }
        
        log.info(""Synapse initialized successfully...!"");
    }

    private static SynapseConfiguration getConfiguration(ConfigurationContext cfgCtx) {

        cfgCtx.setProperty(""addressing.validateAction"", Boolean.FALSE);
        AxisConfiguration axisConfiguration = cfgCtx.getAxisConfiguration();
        SynapseConfiguration synapseConfiguration;

        String config = ServerManager.getInstance().getSynapseXMLPath();

        if (config != null) {
            synapseConfiguration = SynapseConfigurationBuilder.getConfiguration(config);
        } else {
            log.warn(""System property or init-parameter '"" + SynapseConstants.SYNAPSE_XML +
                ""' is not specified. Using default configuration.."");
            synapseConfiguration = SynapseConfigurationBuilder.getDefaultConfiguration();
        }

        // Set the Axis2 ConfigurationContext to the SynapseConfiguration
        synapseConfiguration.setAxisConfiguration(cfgCtx.getAxisConfiguration());

        // set the Synapse configuration and environment into the Axis2 configuration
        Parameter synapseCtxParam = new Parameter(SynapseConstants.SYNAPSE_CONFIG, null);
        synapseCtxParam.setValue(synapseConfiguration);
        MessageContextCreatorForAxis2.setSynConfig(synapseConfiguration);

        Parameter synapseEnvParam = new Parameter(SynapseConstants.SYNAPSE_ENV, null);
        Axis2SynapseEnvironment synEnv = new Axis2SynapseEnvironment(cfgCtx, synapseConfiguration);
        synapseEnvParam.setValue(synEnv);
        MessageContextCreatorForAxis2.setSynEnv(synEnv);

        try {
            axisConfiguration.addParameter(synapseCtxParam);
            axisConfiguration.addParameter(synapseEnvParam);

        } catch (AxisFault e) {
            String msg =
                ""Could not set parameters '"" + SynapseConstants.SYNAPSE_CONFIG +
                    ""' and/or '"" + SynapseConstants.SYNAPSE_ENV +
                    ""'to the Axis2 configuration : "" + e.getMessage();
            log.fatal(msg, e);
            throw new SynapseException(msg, e);
        }
        synapseConfiguration.init(synEnv);
        
        return synapseConfiguration;
    }

    public void engageNotify(AxisDescription axisDescription) throws AxisFault {
        // ignore
    }

    public boolean canSupportAssertion(Assertion assertion) {
        return false;
    }

    public void applyPolicy(Policy policy, AxisDescription axisDescription) throws AxisFault {
        // no implementation
    }

    public void shutdown(ConfigurationContext configurationContext)
        throws AxisFault {
        // ignore
    	synCfg.destroy();
    }
}
"
org/apache/synapse/config/xml/MediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;

import javax.xml.namespace.QName;

/**
 * A mediator factory capable of creating an instance of a mediator through a given
 * XML should implement this interface
 */
public interface MediatorFactory {
    /**
     * Creates an instance of the mediator using the OMElement
     * @param elem
     * @return the created mediator
     */
    public Mediator createMediator(OMElement elem);

    /**
     * The QName of this mediator element in the XML config
     * @return QName of the mediator element
     */
    public QName getTagQName();
}
"
org/apache/synapse/mediators/GetPropertyFunction.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.description.AxisOperation;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.jaxen.Context;
import org.jaxen.Function;
import org.jaxen.FunctionCallException;
import org.jaxen.Navigator;
import org.jaxen.function.StringFunction;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.text.Format;
import java.text.SimpleDateFormat;

/**
 * Implements the XPath extension function synapse:get-property(scope,prop-name)
 */
public class GetPropertyFunction implements Function {

    private static final Log log = LogFactory.getLog(GetPropertyFunction.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public static final String NULL_STRING = """";

    /** Synapse Message context*/
    private MessageContext synCtx = null;

    public MessageContext getSynCtx() {
        return synCtx;
    }

    public void setSynCtx(MessageContext synCtx) {
        this.synCtx = synCtx;
    }

    /**
     * Returns the string value of the property which is get from the corresponding context to the provided scope .
     * The default scope is used to get property from the synapse message context
     *
     * @param context the context at the point in the expression when the function is called
     * @param args  arguments of the functions 
     * @return The string value of a property
     * @throws FunctionCallException
     */
    public Object call(Context context, List args) throws FunctionCallException {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (args == null || args.size() == 0) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Property key value for lookup is not specified"");
            }
            return NULL_STRING;

        } else {
            int size = args.size();
            if (size == 1) {
                return evaluate(
                    XMLConfigConstants.SCOPE_DEFAULT, args.get(0), null, context.getNavigator());

            } else if (size == 2) {
                String argOne = StringFunction.evaluate(args.get(0), context.getNavigator());
                if (argOne != null) {
                    if (!XMLConfigConstants.SCOPE_AXIS2.equals(argOne) &&
                        !XMLConfigConstants.SCOPE_DEFAULT.equals(argOne) &&
                        !XMLConfigConstants.SCOPE_TRANSPORT.equals(argOne)) {
                        return evaluate(XMLConfigConstants.SCOPE_DEFAULT, args.get(0),
                            args.get(1), context.getNavigator());
                    } else {
                        return evaluate(args.get(0), args.get(1), null, context.getNavigator());
                    }
                }
            } else if (size == 3) {
                return evaluate(args.get(0), args.get(1), args.get(2), context.getNavigator());
            } else {

                String msg = ""Invalid arguments for synapse:get-property(prop-name) 0r  "" +
                    ""synapse:get-property(scope, prop-name) XPath function "";
                if (traceOn) {
                    trace.error(msg);
                }
                log.error(msg);
                throw new FunctionCallException(msg);
            }
        }
        return NULL_STRING;
    }

    /**
     * Returns the string value of the property using arg one as key and arg two as scope
     *
     * @param scopeObject scope will decide from where property will be picked up from
     *        i.e. axis2, transport, default/synapse
     * @param keyObject the key of the property
     * @param navigator object model which can be used for navigation around
     * @param dateformat The dateformat that need to convert
     * @return The String value of property using arg one as key and arg two as scope
     */
    public Object evaluate(Object scopeObject, Object keyObject, Object dateformat,Navigator navigator) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (synCtx == null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Synapse message context has not been set for the "" +
                    ""XPath extension function 'synapse:get-property(prop-name)'"");
            }
            return null;
        }

        String scope = StringFunction.evaluate(scopeObject, navigator);
        String key = StringFunction.evaluate(keyObject, navigator);

        if (key == null || """".equals(key)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn,
                    ""property-name should be provided when executing synapse:get-property"" +
                    ""(scope,prop-name) or synapse:get-property(prop-name) Xpath function"");
            }
            return NULL_STRING;
        }

        //Irrespective of the scope ,if the dateformat has provided ,
        // should return the Date according to the provided format

        if (SynapseConstants.SYSTEM_DATE.equals(key)) {
            if (dateformat != null) {
                Format formatter = new SimpleDateFormat(dateformat.toString());
                return formatter.format(new java.util.Date());
            } else {
                Format formatter = new SimpleDateFormat();
                return formatter.format(new java.util.Date());
            }
        }

        //return the current system time as a string , don't care scope
        if (SynapseConstants.SYSTEM_TIME.equals(key)) {

            return Long.toString(System.currentTimeMillis());
        }

        if (XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {

            if (SynapseConstants.HEADER_TO.equals(key)) {
                EndpointReference toEPR = synCtx.getTo();
                if (toEPR != null) {
                    return toEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_FROM.equals(key)) {
                EndpointReference fromEPR = synCtx.getFrom();
                if (fromEPR != null) {
                    return fromEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_ACTION.equals(key)) {
                String wsaAction = synCtx.getWSAAction();
                if (wsaAction != null) {
                    return wsaAction;
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_FAULT.equals(key)) {
                EndpointReference faultEPR = synCtx.getFaultTo();
                if (faultEPR != null) {
                    return faultEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_REPLY_TO.equals(key)) {
                EndpointReference replyToEPR = synCtx.getReplyTo();
                if (replyToEPR != null) {
                    return replyToEPR.getAddress();
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.HEADER_MESSAGE_ID.equals(key)) {
                String messageID = synCtx.getMessageID();
                if (messageID != null) {
                    return messageID;
                } else {
                    return NULL_STRING;
                }
            } else if (SynapseConstants.PROPERTY_MESSAGE_FORMAT.equals(key)) {
                if (synCtx.isDoingPOX())
                    return SynapseConstants.FORMAT_POX;
                else if (synCtx.isDoingGET())
                    return SynapseConstants.FORMAT_GET;
                else if (synCtx.isSOAP11())
                    return SynapseConstants.FORMAT_SOAP11;
                else
                    return SynapseConstants.FORMAT_SOAP12;
            } else if (SynapseConstants.PROPERTY_OPERATION_NAME.equals(key) ||
                       SynapseConstants.PROPERTY_OPERATION_NAMESPACE.equals(key)) {
                if (synCtx instanceof Axis2MessageContext) {
                    AxisOperation axisOperation
                        = ((Axis2MessageContext)synCtx).getAxis2MessageContext().getAxisOperation();
                    if (axisOperation != null) {
                        if (SynapseConstants.PROPERTY_OPERATION_NAMESPACE.equals(key)) {
                            return axisOperation.getName().getNamespaceURI();
                        } else {
                            return axisOperation.getName().getLocalPart();
                        }
                    }
                }
            } else {
                Object result = synCtx.getProperty(key);
                if (result != null) {
                    return result;
                } else {
                    return synCtx.getEntry(key);
                }
            }
        } else if (XMLConfigConstants.SCOPE_AXIS2.equals(scope)
            && synCtx instanceof Axis2MessageContext) {

            org.apache.axis2.context.MessageContext axis2MessageContext
                = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            return axis2MessageContext.getProperty(key);

        } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
            && synCtx instanceof Axis2MessageContext) {

            org.apache.axis2.context.MessageContext axis2MessageContext
                = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            Object headers = axis2MessageContext.getProperty(
                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

            if (headers != null && headers instanceof Map) {
                Map headersMap = (Map) headers;
                return headersMap.get(key);
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Invalid scope : '"" + scope + ""' has been set for the "" +
                    ""synapse:get-property(scope,prop-name) XPath function"");
            }
        }
        return NULL_STRING;
    }

    private void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }

}

"
org/apache/synapse/util/TextFileDataSource.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMDataSourceExt;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMOutputFormat;
import org.apache.axiom.om.OMSourcedElement;
import org.apache.axiom.om.ds.OMDataSourceExtBase;
import org.apache.axiom.om.impl.MTOMXMLStreamWriter;
import org.apache.axiom.om.impl.llom.OMSourcedElementImpl;
import org.apache.axiom.om.impl.serialize.StreamingOMSerializer;
import org.apache.axiom.om.util.StAXUtils;
import org.apache.synapse.transport.base.BaseConstants;

import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.nio.charset.Charset;

public class TextFileDataSource extends OMDataSourceExtBase {
    private final TemporaryData temporaryData;
    private final Charset charset;

    public TextFileDataSource(TemporaryData temporaryData, Charset charset) {
        this.temporaryData = temporaryData;
        this.charset = charset;
    }
    
    public static OMSourcedElement createOMSourcedElement(TemporaryData temporaryData, Charset charset) {
        OMFactory fac = OMAbstractFactory.getOMFactory();
        TextFileDataSource txtFileDS = new TextFileDataSource(temporaryData, charset);
        return new OMSourcedElementImpl(BaseConstants.DEFAULT_TEXT_WRAPPER, fac, txtFileDS);
    }

    @Override
    public void serialize(OutputStream out, OMOutputFormat format) throws XMLStreamException {
        XMLStreamWriter writer = new MTOMXMLStreamWriter(out, format);
        serialize(writer);
        writer.flush();
    }

    @Override
    public void serialize(Writer writer, OMOutputFormat format) throws XMLStreamException {
        MTOMXMLStreamWriter xmlWriter =
            new MTOMXMLStreamWriter(StAXUtils.createXMLStreamWriter(writer));
        xmlWriter.setOutputFormat(format);
        serialize(xmlWriter);
        xmlWriter.flush();
    }

    @Override
    public void serialize(XMLStreamWriter xmlWriter) throws XMLStreamException {
        StreamingOMSerializer serializer = new StreamingOMSerializer();
        serializer.serialize(getReader(), xmlWriter);
    }

    public XMLStreamReader getReader() throws XMLStreamException {
        InputStream is;
        try {
            is = temporaryData.getInputStream();
        }
        catch (IOException ex) {
            throw new XMLStreamException(ex);
        }
        return new WrappedTextNodeStreamReader(BaseConstants.DEFAULT_TEXT_WRAPPER, new InputStreamReader(is, charset));
    }

    public Object getObject() {
        return temporaryData;
    }

    public boolean isDestructiveRead() {
        return false;
    }

    public boolean isDestructiveWrite() {
        return false;
    }
    
    public byte[] getXMLBytes(String encoding) throws UnsupportedEncodingException {
        throw new UnsupportedOperationException();
    }

    public void close() {
    }

    public OMDataSourceExt copy() {
        return new TextFileDataSource(temporaryData, charset);
    }
}
"
org/apache/synapse/mediators/db/Statement.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.synapse.SynapseException;
import org.apache.synapse.util.xpath.SynapseXPath;

import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Encapsulates an SQL statement, one or more parameters for it and optionally some information
 * about results that one would like to read.
 */
public class Statement {

    String rawStatement = null;
    List parameters = new ArrayList();
    Map resultsMap = new HashMap();

    public Statement(String rawStatement) {
        this.rawStatement = rawStatement;
    }

    public String getRawStatement() {
        return rawStatement;
    }

    public void addParameter(String propertyName, SynapseXPath xpath, String type){
        parameters.add(new Parameter(propertyName, xpath, type));
    }

    public void addResult(String propertyName, String column) {
        resultsMap.put(propertyName, column);
    }

    public List getParameters() {
        return parameters;
    }

    public Map getResultsMap() {
        return resultsMap;
    }

    public class Parameter {
        String propertyName = null;
        SynapseXPath xpath = null;
        int type = 0;

        Parameter(String value, SynapseXPath xpath, String type) {

            this.propertyName = value;
            this.xpath = xpath; 
            if (""CHAR"".equals(type)) {
                this.type = Types.CHAR;
            } else if (""VARCHAR"".equals(type)) {
                this.type = Types.VARCHAR;
            } else if (""LONGVARCHAR"".equals(type)) {
                this.type = Types.LONGVARCHAR;
            } else if (""NUMERIC"".equals(type)) {
                this.type = Types.NUMERIC;
            } else if (""DECIMAL"".equals(type)) {
                this.type = Types.DECIMAL;
            } else if (""BIT"".equals(type)) {
                this.type = Types.BIT;
            } else if (""TINYINT"".equals(type)) {
                this.type = Types.TINYINT;
            } else if (""SMALLINT"".equals(type)) {
                this.type = Types.SMALLINT;
            } else if (""INTEGER"".equals(type)) {
                this.type = Types.INTEGER;
            } else if (""BIGINT"".equals(type)) {
                this.type = Types.BIGINT;
            } else if (""REAL"".equals(type)) {
                this.type = Types.REAL;
            } else if (""FLOAT"".equals(type)) {
                this.type = Types.FLOAT;
            } else if (""DOUBLE"".equals(type)) {
                this.type = Types.DOUBLE;
            } else if (""DATE"".equals(type)) {
                this.type = Types.DATE;
            } else if (""TIME"".equals(type)) {
                this.type = Types.TIME;
             } else if (""TIMESTAMP"".equals(type)) {
                this.type = Types.TIMESTAMP;
            } else {
                throw new SynapseException(""Unknown or unsupported JDBC type : "" + type);
            }
        }

        public String getPropertyName() {
            return propertyName;
        }

        public SynapseXPath getXpath() {
            return xpath;
        }

        public int getType() {
            return type;
        }
    }
}

"
org/apache/synapse/mediators/ext/AnnotatedCommandMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.synapse.Command;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.annotations.Namespaces;
import org.apache.synapse.mediators.annotations.ReadAndUpdate;
import org.apache.synapse.mediators.annotations.ReadFromMessage;
import org.apache.synapse.mediators.annotations.UpdateMessage;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 */
public class AnnotatedCommandMediator extends POJOCommandMediator {

    protected Map<Field, SynapseXPath> beforeFields;
    protected Map<Method, SynapseXPath> beforeMethods;
    protected Map<Field, SynapseXPath> afterFields;
    protected Map<Method, SynapseXPath> afterMethods;
    
    @Override
    public boolean mediate(MessageContext synCtx) {
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : POJOCommand mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Creating a new instance of POJO class : "" + getCommand().getClass());
        }

        Object commandObject = null;
        try {
            // instantiate a new command object each time
            commandObject = getCommand().newInstance();
        } catch (Exception e) {
            handleException(""Error creating an instance of the POJO command class : "" +
                            getCommand().getClass(), e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Instance created, setting static and dynamic properties"");
        }

        // then set the static/constant properties first
        for (Iterator iter = getStaticSetterProperties().keySet().iterator(); iter.hasNext(); ) {
            String name = (String) iter.next();
            setInstanceProperty(name, (String) getStaticSetterProperties().get(name), commandObject, synCtx);
        }
        
        
        for (Field f : beforeFields.keySet()) {
            SynapseXPath xpath = beforeFields.get(f);
            Object v;
            if (f.getType().equals(String.class)) {
                v = xpath.stringValueOf(synCtx);
            } else {
                throw new UnsupportedOperationException(""non-String types not supportted yet"");
            }
            try {
                f.set(commandObject, v);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        for (Method m : beforeMethods.keySet()) {
            SynapseXPath xpath = beforeMethods.get(m);
            Object v;
            if (m.getParameterTypes().length == 1 && m.getParameterTypes()[0].equals(String.class)) {
                v = xpath.stringValueOf(synCtx);
            } else {
                throw new UnsupportedOperationException(""non-String types not supportted yet"");
            }
            try {
                m.invoke(commandObject, v);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""POJO initialized successfully, invoking the execute() method"");
        }

        // then call the execute method if the Command interface is implemented
        if (commandObject instanceof Command) {
            try {
                ((Command) commandObject).execute();
            } catch (Exception e) {
                handleException(""Error invoking POJO command class : ""
                    + getCommand().getClass(), e, synCtx);
            }

        } else {

            Method exeMethod = null;
            try {
                exeMethod = getCommand().getMethod(""execute"", new Class[]{});
                exeMethod.invoke(commandObject, new Object[]{});
            } catch (NoSuchMethodException e) {
                handleException(""Cannot locate an execute() method on POJO class : "" +
                                getCommand().getClass(), e, synCtx);
            } catch (Exception e) {
                handleException(""Error invoking the execute() method on POJO class : "" +
                                getCommand().getClass(), e, synCtx);
            }
        }

        // TODO: now update the MessageContext from the commandObject
        
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : POJOCommand mediator"");
        }
        return true;
    }
    
    @Override
    public void setCommand(Class commandClass) {
        super.setCommand(commandClass);
        introspectClass(commandClass);
    }

    /**
     * Introspect the command class annotations
     */
    protected void introspectClass(Class<?> commandClass) {

        beforeFields = new HashMap<Field, SynapseXPath>();
        afterFields = new HashMap<Field, SynapseXPath>();
        beforeMethods = new HashMap<Method, SynapseXPath>();
        afterMethods = new HashMap<Method, SynapseXPath>();

        for (Field f : commandClass.getDeclaredFields()) {

            ReadFromMessage readFromMessage = f.getAnnotation(ReadFromMessage.class);
            if (readFromMessage != null) {
                SynapseXPath axiomXpath = createSynapseXPATH(readFromMessage.value(), f.getAnnotation(Namespaces.class));
                beforeFields.put(f, axiomXpath);
            }

            UpdateMessage updateMessage = f.getAnnotation(UpdateMessage.class);
            if (updateMessage != null) {
                SynapseXPath axiomXpath = createSynapseXPATH(updateMessage.value(), f.getAnnotation(Namespaces.class));
                afterFields.put(f, axiomXpath);
            }

            ReadAndUpdate readAndUpdate = f.getAnnotation(ReadAndUpdate.class);
            if (readAndUpdate != null) {
                SynapseXPath axiomXpath = createSynapseXPATH(readAndUpdate.value(), f.getAnnotation(Namespaces.class));
                beforeFields.put(f, axiomXpath);
                afterFields.put(f, axiomXpath);
            }
        }

        for (Method m : commandClass.getDeclaredMethods()) {

            ReadFromMessage readFromMessage = m.getAnnotation(ReadFromMessage.class);
            if (readFromMessage != null) {
                SynapseXPath axiomXpath = createSynapseXPATH(readFromMessage.value(), m.getAnnotation(Namespaces.class));
                beforeMethods.put(m, axiomXpath);
            }

            UpdateMessage updateMessage = m.getAnnotation(UpdateMessage.class);
            if (updateMessage != null) {
                SynapseXPath axiomXpath = createSynapseXPATH(updateMessage.value(), m.getAnnotation(Namespaces.class));
                afterMethods.put(m, axiomXpath);
            }

        }
    }

    /**
     * Create an SynapseXPath from an xpath string
     */
    protected SynapseXPath createSynapseXPATH(String xpath, Namespaces nsAnnotation) {
        
        Map<String, String> namespaces = getNamespaces(nsAnnotation);     
        try {

            SynapseXPath axiomXPath = new SynapseXPath(xpath);
            
            for (String prefix : namespaces.keySet()) {
                axiomXPath.addNamespace(prefix, namespaces.get(prefix));
            }
            
            return axiomXPath;

        } catch (JaxenException e) {
            throw new RuntimeException(""Error creating SynapseXPath: "" + xpath, e);
        }
    }

    /**
     * Creates a Map of namespace prefixes and namespaces from a Namespace annotation
     * and the default Namespace annotation on the command class.
     */
    protected Map<String, String> getNamespaces(Namespaces namespaces) {
        Map<String, String> allNamespaces = new HashMap<String, String>();
        
        Namespaces defaultNamespaces = ((Class<?>)getCommand()).getAnnotation(Namespaces.class);

        // First add any default namespaces
        if (defaultNamespaces != null) {
            for (String namespaceValue : defaultNamespaces.value()) {
                int i = namespaceValue.indexOf(':');
                if (i > 0) {
                    String prefix = namespaceValue.substring(0, i);
                    String namespace = namespaceValue.substring(i+1);
                    allNamespaces.put(prefix, namespace);
                }
            }
        }

        // add any namespaces which will overwrite any previously added default namespaces
        if (namespaces != null) {
            for (String namespaceValue : namespaces.value()) {
                int i = namespaceValue.indexOf(':');
                if (i > 0) {
                    String prefix = namespaceValue.substring(0, i);
                    String namespace = namespaceValue.substring(i+1);
                    allNamespaces.put(prefix, namespace);
                }
            }
        }
        return allNamespaces;
    }

}
"
org/apache/synapse/mediators/MediatorProperty.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.util.xpath.SynapseXPath;

import javax.xml.namespace.QName;

/**
 * A mediator property is a name-value or name-expression pair which could be supplied
 * for certain mediators. If expressions are supplied they are evaluated at the runtime
 * against the current message into literal String values.
 */
public class MediatorProperty {

    public static final QName PROPERTY_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");
    public static final QName ATT_NAME_Q  = new QName(XMLConfigConstants.NULL_NAMESPACE, ""name"");
    public static final QName ATT_VALUE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""value"");
    public static final QName ATT_EXPR_Q  = new QName(XMLConfigConstants.NULL_NAMESPACE, ""expression"");

    private String name;
    private String value;
    private SynapseXPath expression;

    public MediatorProperty() {}

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public SynapseXPath getExpression() {
        return expression;
    }

    public void setExpression(SynapseXPath expression) {
        this.expression = expression;
    }

    public String getEvaluatedExpression(MessageContext synCtx) {
        return expression.stringValueOf(synCtx);
    }

}
"
org/apache/synapse/mediators/eip/splitter/CloneMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.splitter;

import org.apache.synapse.MessageContext;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.util.MessageHelper;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.OperationContext;

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

/**
 * This mediator will clone the message into multiple messages and mediate as specified in the
 * target elements. A target specifies or refers to a sequence or an endpoint, and optionally
 * specifies an Action and/or To address to be set to the cloned message. The number of cloned
 * messages created is the number of targets specified
 */
public class CloneMediator extends AbstractMediator implements ManagedLifecycle {

    /**
     * Continue processing the parent message or not?
     * (i.e. message which is subjected to cloning)
     */
    private boolean continueParent = false;

    /** the list of targets to which cloned copies of the message will be given for mediation */
    private List<Target> targets = new ArrayList<Target>();

    /**
     * This will implement the mediate method of the Mediator interface and will provide the
     * functionality of cloning message into the specified targets and mediation
     *
     * @param synCtx - MessageContext which is subjected to the cloning
     * @return boolean true if this needs to be further mediated (continueParent=true)
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Clone mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // get the targets list, clone the message for the number of targets and then
        // mediate the cloned messages using the targets
        Iterator<Target> iter = targets.iterator();
        int i = 0;
        while (iter.hasNext()) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Submitting "" + (i+1) + "" of "" + targets.size() +
                    "" messages for processing in parallel"");
            }

            iter.next().mediate(getClonedMessageContext(synCtx, i++, targets.size()));
        }

        // if the continuation of the parent message is stopped from here set the RESPONSE_WRITTEN
        // property to SKIP to skip the blank http response 
        OperationContext opCtx
            = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();
        if (!continueParent && opCtx != null) {
            opCtx.setProperty(Constants.RESPONSE_WRITTEN, ""SKIP"");
        }

        // finalize tracing and debugging
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Clone mediator"");
        }

        // if continue parent is true mediators after the clone will be called for the further
        // mediation of the message which is subjected for clonning (parent message)
        return continueParent;
    }

    /**
     * clone the provided message context as a new message, and mark as the messageSequence'th
     * message context of a total of messageCount messages
     *
     * @param synCtx          - MessageContext which is subjected to the cloning
     * @param messageSequence - the position of this message of the cloned set
     * @param messageCount    - total of cloned copies
     * @return MessageContext the cloned message context
     */
    private MessageContext getClonedMessageContext(MessageContext synCtx, int messageSequence,
        int messageCount) {

        MessageContext newCtx = null;
        try {
            newCtx = MessageHelper.cloneMessageContext(synCtx);

            // set the property MESSAGE_SEQUENCE to the MC for aggregation purposes
            newCtx.setProperty(EIPConstants.MESSAGE_SEQUENCE,
                String.valueOf(messageSequence) + EIPConstants.MESSAGE_SEQUENCE_DELEMITER +
                messageCount);            
        } catch (AxisFault axisFault) {
            handleException(""Error cloning the message context"", axisFault, synCtx);
        }

        return newCtx;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public boolean isContinueParent() {
        return continueParent;
    }

    public void setContinueParent(boolean continueParent) {
        this.continueParent = continueParent;
    }

    public List<Target> getTargets() {
        return targets;
    }

    public void setTargets(List<Target> targets) {
        this.targets = targets;
    }

    public void addTarget(Target target) {
        this.targets.add(target);
    }

    public void init(SynapseEnvironment se) {

        for (Target target : targets) {
            SequenceMediator seq = target.getSequence();
            if (seq != null) {
                seq.init(se);
            }
        }
    }

    public void destroy() {
        
        for (Target target : targets) {
            SequenceMediator seq = target.getSequence();
            if (seq != null) {
                seq.destroy();
            }
        }
    }

}
"
org/apache/synapse/registry/RegistryEntry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import java.net.URI;

/**
 * This interface defines the core information to be returned by a Registry implementation
 * about a resource being managed by it. Every Registry implementation *must* provide valid
 * information for the methods marked below as 'required'
 */
public interface RegistryEntry {

    /** The key for the resource - required */
    public String getKey();

    /** A name for the resource - optional */
    public String getName();

    /** The version of the resource - required */
    public long getVersion();

    /** The type of the resource - optional */
    public URI getType();

    /** A description for the resource - optional */
    public String getDescription();

    /** The created time for the resource - optional */
    public long getCreated();

    /** The last updated time for the resource - optional */
    public long getLastModified();

    /** The number of milliseconds this resource could be cached */
    public long getCachableDuration();
}
"
org/apache/synapse/config/xml/DropMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.DropMediator;

import javax.xml.namespace.QName;

/**
 * Factory for {@link DropMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;drop/&gt;
 * </pre>
 */
public class DropMediatorFactory extends AbstractMediatorFactory  {

    private static final QName DROP_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""drop"");

    public Mediator createMediator(OMElement el) {

        Mediator dropMediator = new DropMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(dropMediator,el);

        return dropMediator;
    }

    public QName getTagQName() {
        return DROP_Q;
    }
}
"
org/apache/synapse/startup/quartz/SimpleQuartz.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.quartz;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.ServerManager;
import org.apache.synapse.startup.AbstractStartup;
import org.quartz.CronTrigger;
import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.TriggerUtils;
import org.quartz.impl.DirectSchedulerFactory;

/*
 * This class is instantiated by SimpleQuartzFactory (or by hand)
 * When it is initialized it creates a Quartz Scheduler with a job and a trigger
 * The class it starts is always an instance of SimpleQuartzJob
 * SimpleQuartzJob is there to set the properties and start the actual business-logic class
 * It wraps up any properties that the job needs as in the JobDetail and JDMap
 */
public class SimpleQuartz extends AbstractStartup {

    private static final Log log = LogFactory.getLog(SimpleQuartz.class);
    private static final int THREADPOOLSIZE = 5;

    static {
      try {
        DirectSchedulerFactory.getInstance().createVolatileScheduler(THREADPOOLSIZE);
      } catch (SchedulerException e) {
        throw new SynapseException(""Error initializing scheduler factory"", e);
      }
    }
    
    private String cron;
    private int repeatCount = -1;
    private long repeatInterval; // in milliseconds
    private String className;
    private List pinnedServers;
    private Scheduler sch;
    Set xmlProperties = new HashSet();

    public QName getTagQName() {
        return SimpleQuartzFactory.TASK;
    }

    public void destroy() {
        if (sch != null) {
            try {
                sch.shutdown();
            } catch (SchedulerException e) {
                log.warn(""Error shutting down scheduler"", e);
                throw new SynapseException(""Error shutting down scheduler"", e);
            }
        }
    }

    public void init(SynapseEnvironment synapseEnvironment) {

        // this server name given by system property SynapseServerName
        // otherwise take host-name
        // else assume localhost
        String thisServerName = ServerManager.getInstance().getServerName();
        if(thisServerName == null || thisServerName.equals("""")) {
          try {
            InetAddress addr = InetAddress.getLocalHost();
            thisServerName = addr.getHostName();
  
          } catch (UnknownHostException e) {
            log.warn(""Could not get local host name"", e);
          }
          
          if(thisServerName == null || thisServerName.equals("""")) {
            thisServerName = ""localhost"";
          }
        }
        log.debug(""Synapse server name : "" + thisServerName);
        
        // start proxy service if either,
        // pinned server name list is empty
        // or pinned server list has this server name
        List pinnedServers = getPinnedServers();
        if(pinnedServers != null && !pinnedServers.isEmpty()) {
          if(!pinnedServers.contains(thisServerName)) {
            log.info(""Server name not in pinned servers list. Not starting Task : "" + getName());
            return;
          }
        }
      
      
        try {
            sch = DirectSchedulerFactory.getInstance().getScheduler();
            if (sch == null) {
              DirectSchedulerFactory.getInstance().createVolatileScheduler(THREADPOOLSIZE);
              sch = DirectSchedulerFactory.getInstance().getScheduler();
            }
            
            if(sch == null) {
              throw new NullPointerException(""Scheduler is null"");
            }

            Trigger trigger = null;
            if (cron == null) {
                if (repeatCount >= 0) {
                    trigger = TriggerUtils.makeImmediateTrigger(repeatCount - 1, repeatInterval);
                } else {
                    trigger = TriggerUtils.makeImmediateTrigger(-1, repeatInterval);
                }

            } else {
                CronTrigger cronTrig = new CronTrigger();
                cronTrig.setCronExpression(cron);
                trigger = cronTrig;
            }

            // give the trigger a random name
            trigger.setName(""Trigger"" + String.valueOf((new Random()).nextLong()));
            trigger.setGroup(""synapse.simple.quartz"");
            trigger.setVolatility(true);
            JobDetail jobDetail = new JobDetail();

            // Give the job a name
            jobDetail.setName(name);
            jobDetail.setGroup(""synapse.simple.quartz"");
            jobDetail.setJobClass(SimpleQuartzJob.class);
            JobDataMap jdm = new JobDataMap();
            jdm.put(SimpleQuartzJob.SYNAPSE_ENVIRONMENT, synapseEnvironment);
            jdm.put(SimpleQuartzJob.CLASSNAME, className);
            jdm.put(SimpleQuartzJob.PROPERTIES, xmlProperties);
            jobDetail.setJobDataMap(jdm);

            sch.scheduleJob(jobDetail, trigger);
            sch.start();
            log.info(""Scheduled job "" + jobDetail.getFullName() + "" for class "" + className);

        } catch (Exception e) {
            log.fatal(""Error starting up Scheduler"", e);
            throw new SynapseException(""Error starting up Scheduler"", e);
        }

    }

    public String getJobClass() {
        return className;
    }

    public void setJobClass(String attributeValue) {
        className = attributeValue;

    }

    public void setInterval(long l) {
        repeatInterval = l;

    }

    public long getInterval() {
        return repeatInterval;
    }

    public void setCount(int i) {
        repeatCount = i;
    }

    public int getCount() {
        return repeatCount;
    }

    public void addProperty(OMElement prop) {
        xmlProperties.add(prop);
    }

    public Set getProperties() {
        return xmlProperties;
    }

    public void setCron(String attributeValue) {
        cron = attributeValue;

    }

    public String getCron() {
        return cron;
    }

    public List getPinnedServers() {
      return pinnedServers;
    }

    public void setPinnedServers(List pinnedServers) {
      this.pinnedServers = pinnedServers;
    }

}
"
org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.OperationContext;
import org.apache.axis2.context.ServiceContext;
import org.apache.axis2.description.InOutAxisOperation;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.mediators.MediatorWorker;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.statistics.StatisticsCollector;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.util.UUIDGenerator;
import org.apache.synapse.util.TemporaryData;
import org.apache.synapse.util.concurrent.SynapseThreadPool;

import java.util.concurrent.ExecutorService;

/**
 * This is the Axis2 implementation of the SynapseEnvironment
 */
public class Axis2SynapseEnvironment implements SynapseEnvironment {

    private static final Log log = LogFactory.getLog(Axis2SynapseEnvironment.class);

    private SynapseConfiguration synapseConfig;
    private ConfigurationContext configContext;
    private ExecutorService executorService;
    private boolean initialized = false;

    /** The StatisticsCollector object */
    private StatisticsCollector statisticsCollector;

    public Axis2SynapseEnvironment(SynapseConfiguration synCfg) {
        
        int coreThreads = SynapseThreadPool.SYNAPSE_CORE_THREADS;
        int maxThreads  = SynapseThreadPool.SYNAPSE_MAX_THREADS;
        long keepAlive  = SynapseThreadPool.SYNAPSE_KEEP_ALIVE;
        int qlength     = SynapseThreadPool.SYNAPSE_THREAD_QLEN;
        
        try {
            qlength = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_QLEN));
        } catch (Exception ignore) {}

        try {
            coreThreads = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_CORE));
        } catch (Exception ignore) {}

        try {
            maxThreads = Integer.parseInt(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_MAX));
        } catch (Exception ignore) {}

        try {
            keepAlive = Long.parseLong(synCfg.getProperty(SynapseThreadPool.SYN_THREAD_ALIVE));
        } catch (Exception ignore) {}
        
        this.executorService = new SynapseThreadPool(coreThreads, maxThreads, keepAlive, qlength,
            synCfg.getProperty(SynapseThreadPool.SYN_THREAD_GROUP,
                SynapseThreadPool.SYNAPSE_THREAD_GROUP),
            synCfg.getProperty(SynapseThreadPool.SYN_THREAD_IDPREFIX,
                SynapseThreadPool.SYNAPSE_THREAD_ID_PREFIX));
    }

    public Axis2SynapseEnvironment(ConfigurationContext cfgCtx,
        SynapseConfiguration synapseConfig) {
        this(synapseConfig);
        this.configContext = cfgCtx;
        this.synapseConfig = synapseConfig;
    }

    public boolean injectMessage(final MessageContext synCtx) {
        if (log.isDebugEnabled()) {
            log.debug(""Injecting MessageContext"");
        }
        synCtx.setEnvironment(this);
        if (synCtx.isResponse()) {
            //Process statistics related to a sequence which has send mediator as a child,end point
            StatisticsUtils.processEndPointStatistics(synCtx);
            StatisticsUtils.processProxyServiceStatistics(synCtx);
            StatisticsUtils.processSequenceStatistics(synCtx);
        }

        Mediator mandatorySeq = synCtx.getConfiguration().getMandatorySequence();
        // the mandatory sequence is optional and hence check for the existance before mediation
        if (mandatorySeq != null) {

            if (log.isDebugEnabled()) {
                log.debug(""Start mediating the message in the "" +
                        ""pre-mediate state using the mandatory sequence"");
            }

            if(!mandatorySeq.mediate(synCtx)) {
                if(log.isDebugEnabled()) {
                    log.debug((synCtx.isResponse() ? ""Response"" : ""Request"") + "" message for the ""
                            + (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null ?
                            ""proxy service "" + synCtx.getProperty(SynapseConstants.PROXY_SERVICE) :
                            ""message mediation"") + "" dropped in the "" +
                            ""pre-mediation state by the mandatory sequence : \n"" + synCtx);
                }
                return false;
            }
        }

        // if this is a response to a proxy service
        if (synCtx.getProperty(SynapseConstants.PROXY_SERVICE) != null) {

            if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    SynapseConstants.PROXY_SERVICE)).getTargetOutSequence() != null) {

                String sequenceName = synCtx.getConfiguration().getProxyService((String) synCtx.
                        getProperty(SynapseConstants.PROXY_SERVICE)).getTargetOutSequence();
                Mediator outSequence = synCtx.getSequence(sequenceName);

                if (outSequence != null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Using the sequence named "" + sequenceName
                                + "" for the outgoing message mediation of the proxy service ""
                                + synCtx.getProperty(SynapseConstants.PROXY_SERVICE));
                    }
                    outSequence.mediate(synCtx);
                } else {
                    log.error(""Unable to find the out-sequence "" +
                            ""specified by the name "" + sequenceName);
                    throw new SynapseException(""Unable to find the "" +
                            ""out-sequence specified by the name "" + sequenceName);
                }

            } else if (synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                    SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence() != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Using the anonymous out-sequence specified in the proxy service ""
                            + synCtx.getProperty(SynapseConstants.PROXY_SERVICE)
                            + "" for outgoing message mediation"");
                }
                synCtx.getConfiguration().getProxyService((String) synCtx.getProperty(
                        SynapseConstants.PROXY_SERVICE)).getTargetInLineOutSequence().mediate(synCtx);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Proxy service "" + synCtx.getProperty(SynapseConstants.PROXY_SERVICE)
                            + "" does not specifies an out-sequence - sending the response back"");
                }
                Axis2Sender.sendBack(synCtx);
            }

        } else {
            if (log.isDebugEnabled()) {
                log.debug(""Using Main Sequence for injected message"");
            }
            return synCtx.getMainSequence().mediate(synCtx);
        }
        return true;
    }

    public void injectAsync(final MessageContext synCtx, SequenceMediator seq) {
        if (log.isDebugEnabled()) {
            log.debug(""Injecting MessageContext for asynchronous mediation using the : ""
                + (seq.getName() == null? ""Anonymous"" : seq.getName()) + "" Sequence"");
        }
        synCtx.setEnvironment(this);
        // todo: do we need to have this in here ? ruwan
        if (synCtx.isResponse()) {
            //Process statistics related to a sequence which has send mediator as a child,end point
            StatisticsUtils.processEndPointStatistics(synCtx);
            StatisticsUtils.processProxyServiceStatistics(synCtx);
            StatisticsUtils.processSequenceStatistics(synCtx);
        }

        executorService.execute(new MediatorWorker(seq, synCtx));

    }

    /**
     * This will be used for sending the message provided, to the endpoint specified by the
     * EndpointDefinition using the axis2 environment.
     *
     * @param endpoint - EndpointDefinition to be used to find the endpoint information
     *                      and the properties of the sending process
     * @param synCtx   - Synapse MessageContext to be sent
     */
    public void send(EndpointDefinition endpoint, MessageContext synCtx) {
        if (synCtx.isResponse()) {

            if (endpoint != null) {
                // not sure whether we need to collect statistics here
                StatisticsUtils.processEndPointStatistics(synCtx);
                StatisticsUtils.processProxyServiceStatistics(synCtx);
                StatisticsUtils.processAllSequenceStatistics(synCtx);

                Axis2Sender.sendOn(endpoint, synCtx);

            } else {
                Axis2Sender.sendBack(synCtx);
            }
        } else {
            Axis2Sender.sendOn(endpoint, synCtx);
        }
    }

    /**
     * This method will be used to create a new MessageContext in the Axis2 environment for
     * Synapse. This will set all the relevant parts to the messagecontext, but for this message
     * context to be useful creator has to fill in the data like envelope and operation context
     * and so on. This will set a default envelope of type soap12 and a new messageID for the
     * created message along with the ConfigurationContext is being set in to the message
     * correctly.
     *
     * @return Synapse MessageContext with the underlying axis2 message context set
     */
    public MessageContext createMessageContext() {

        if (log.isDebugEnabled()) {
            log.debug(""Creating Message Context"");
        }

        org.apache.axis2.context.MessageContext axis2MC
                = new org.apache.axis2.context.MessageContext();
        axis2MC.setConfigurationContext(this.configContext);

        ServiceContext svcCtx = new ServiceContext();
        OperationContext opCtx = new OperationContext(new InOutAxisOperation(), svcCtx);
        axis2MC.setServiceContext(svcCtx);
        axis2MC.setOperationContext(opCtx);
        MessageContext mc = new Axis2MessageContext(axis2MC, synapseConfig, this);
        mc.setMessageID(UUIDGenerator.getUUID());
        try {
			mc.setEnvelope(OMAbstractFactory.getSOAP12Factory().createSOAPEnvelope());
			mc.getEnvelope().addChild(OMAbstractFactory.getSOAP12Factory().createSOAPBody());
		} catch (Exception e) {
            handleException(""Unable to attach the SOAP envelope to "" +
                    ""the created new message context"", e);
        }

        return mc;
    }

    /**
     * Factory method to create the TemporaryData object as per on the parameters specified in the
     * synapse.properties file, so that the TemporaryData parameters like threashold chunk size
     * can be customized by using the properties file. This can be extended to enforce further
     * policies if required in the future.
     *
     * @return created TemporaryData object as per in the synapse.properties file
     */
    public TemporaryData createTemporaryData() {

        String chkSize = synapseConfig.getProperty(SynapseConstants.CHUNK_SIZE);
        String chukNumber = synapseConfig.getProperty(SynapseConstants.THRESHOLD_CHUNKS);
        int numberOfChunks = SynapseConstants.DEFAULT_THRESHOLD_CHUNKS;
        int chunkSize = SynapseConstants.DEFAULT_CHUNK_SIZE;

        if (chkSize != null) {
            chunkSize = Integer.parseInt(chkSize);
        }

        if (chukNumber != null) {
            numberOfChunks = Integer.parseInt(chukNumber);
        }

        String tempPrefix = synapseConfig.getProperty(SynapseConstants.TEMP_FILE_PREFIX,
                SynapseConstants.DEFAULT_TEMPFILE_PREFIX);
        String tempSuffix = synapseConfig.getProperty(SynapseConstants.TEMP_FILE_SUFIX,
                SynapseConstants.DEFAULT_TEMPFILE_SUFIX);

        return new TemporaryData(numberOfChunks, chunkSize, tempPrefix, tempSuffix);
    }

    /**
     * This method returns the StatisticsCollector
     *
     * @return Retruns the StatisticsCollector
     */
    public StatisticsCollector getStatisticsCollector() {
        return statisticsCollector;
    }

    /**
     * To set the StatisticsCollector
     *
     * @param collector - Statistics collector to be set
     */
    public void setStatisticsCollector(StatisticsCollector collector) {
        this.statisticsCollector = collector;
    }

    /**
     * This will give the access to the synapse thread pool for the
     * advanced mediation tasks.
     *
     * @return an ExecutorService to execute the tasks in a new thread from the pool
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Has this environment properly initialized?
     * @return true if ready for processing
     */
    public boolean isInitialized() {
        return initialized;
    }

    /**
     * Mark this environment as ready for processing
     * @param state true means ready for processing
     */
    public void setInitialized(boolean state) {
        this.initialized = state;
    }

    private void handleException(String message, Throwable e) {
        log.error(message, e);
        throw new SynapseException(message, e);
    }

}
"
org/apache/synapse/config/xml/OMElementUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMContainer;
import org.apache.axiom.om.OMDocument;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.jaxen.JaxenException;
import org.jaxen.XPath;

import java.util.Iterator;

/**
 * Holds Axiom utility methods used by Synapse
 */
public class OMElementUtils {

    private static final Log log = LogFactory.getLog(OMElementUtils.class);

    /**
     * Return the namespace with the given prefix, using the given element
     * @param prefix the prefix looked up
     * @param elem the source element to use
     * @return the namespace which maps to the prefix or null
     */
    public static String getNameSpaceWithPrefix(String prefix, OMElement elem) {
        if (prefix == null || elem == null) {
            log.warn(""Searching for null NS prefix and/or using null OMElement"");
            return null;
        }
        
        OMElement currentElem = elem;
        while (true) {
            Iterator iter = currentElem.getAllDeclaredNamespaces();
            while (iter.hasNext()) {
                OMNamespace ns = (OMNamespace) iter.next();
                if (prefix.equals(ns.getPrefix())) {
                    return ns.getNamespaceURI();     
                }
            }
            OMContainer parent = currentElem.getParent();
            if (parent != null && parent instanceof OMElement) {
                currentElem = (OMElement)parent;
            } else {
                return null;
            }
        }
    }

    /**
     * Add the namespace declarations of a given {@link OMElement} to the namespace
     * context of an XPath expression. Typically this method is used with an XPath
     * expression appearing in an attribute of the given element.
     * <p>
     * Note that the default namespace is explicitly excluded and not added to the
     * namespace context. This implies that XPath expressions
     * appearing in Synapse configuration files follow the same rule as in XSL
     * stylesheets. Indeed, the XSLT specification defines the namespace context of
     * an XPath expression as follows:
     * <blockquote>
     * the set of namespace declarations are those in scope on the element which has the
     * attribute in which the expression occurs; [...] the default namespace
     * (as declared by xmlns) is not part of this set
     * </blockquote>
     * 
     * @param xpath
     * @param elem
     * @param log
     */
    public static void addNameSpaces(XPath xpath, OMElement elem, Log log) {

        OMElement currentElem = elem;

        while (currentElem != null) {
            Iterator it = currentElem.getAllDeclaredNamespaces();
            while (it.hasNext()) {

                OMNamespace n = (OMNamespace) it.next();
                // Exclude the default namespace as explained in the Javadoc above
                if (n != null && !"""".equals(n.getPrefix())) {

                    try {
                        xpath.addNamespace(n.getPrefix(), n.getNamespaceURI());
                    } catch (JaxenException je) {
                        String msg = ""Error adding declared name space with prefix : ""
                            + n.getPrefix() + ""and uri : "" + n.getNamespaceURI()
                            + "" to the XPath : "" + xpath;
                        log.error(msg);
                        throw new SynapseException(msg, je);
                    }
                }
            }

            OMContainer parent = currentElem.getParent();
            //if the parent is a document element or parent is null ,then return
            if (parent == null || parent instanceof OMDocument) {
                return;
            }
            if (parent instanceof OMElement) {
                currentElem = (OMElement) parent;
            }
        }
    }
}
"
org/apache/synapse/config/xml/IterateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.eip.splitter.IterateMediator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * The &lt;iterate&gt; element is used to split messages in Synapse to smaller messages with only
 * one part of the elements described in the XPATH expression.
 * <p/>
 * <pre>
 * &lt;iterate [continueParent=(true | false)] [preservePayload=(true | false)]
 *          (attachPath=""xpath"")? expression=""xpath""&gt;
 *   &lt;target [to=""uri""] [soapAction=""qname""] [sequence=""sequence_ref""]
 *          [endpoint=""endpoint_ref""]&gt;
 *     &lt;sequence&gt;
 *       (mediator)+
 *     &lt;/sequence&gt;?
 *     &lt;endpoint&gt;
 *       endpoint
 *     &lt;/endpoint&gt;?
 *   &lt;/target&gt;+
 * &lt;/iterate&gt;
 * </pre>
 */
public class IterateMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(IterateMediatorFactory.class);

    /**
     * Holds the QName for the IterateMeditor xml configuration
     */
    private static final QName ITERATE_Q = new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""iterate"");
    private static final QName ATT_CONTPAR = new QName(""continueParent"");
    private static final QName ATT_PREPLD = new QName(""preservePayload"");
    private static final QName ATT_ATTACHPATH = new QName(""attachPath"");

    /**
     * This method will create the IterateMediator by parsing the given xml configuration
     *
     * @param elem OMElement describing the configuration of the IterateMediaotr
     * @return IterateMediator created from the given configuration
     */
    public Mediator createMediator(OMElement elem) {

        IterateMediator mediator = new IterateMediator();
        processTraceState(mediator, elem);

        OMAttribute continueParent = elem.getAttribute(ATT_CONTPAR);
        if (continueParent != null) {
            mediator.setContinueParent(
                Boolean.valueOf(continueParent.getAttributeValue()).booleanValue());
        }

        OMAttribute preservePayload = elem.getAttribute(ATT_PREPLD);
        if (preservePayload != null) {
            mediator.setPreservePayload(
                Boolean.valueOf(preservePayload.getAttributeValue()).booleanValue());
        }

        OMAttribute expression = elem.getAttribute(ATT_EXPRN);
        if (expression != null) {
            try {
                mediator.setExpression(SynapseXPathFactory.getSynapseXPath(elem, ATT_EXPRN));
            } catch (JaxenException e) {
                handleException(""Unable to build the IterateMediator. "" + ""Invalid XPATH "" +
                    expression.getAttributeValue(), e);
            }
        } else {
            handleException(""XPATH expression is required "" +
                ""for an IterateMediator under the \""expression\"" attribute"");
        }

        OMAttribute attachPath = elem.getAttribute(ATT_ATTACHPATH);
        String attachPathValue = ""."";
        if (attachPath != null && !mediator.isPreservePayload()) {
            handleException(""Wrong configuration for the iterate mediator :: if the iterator "" +
                ""should not preserve payload, then attachPath can not be present"");
        } else if (attachPath != null) {
            attachPathValue = attachPath.getAttributeValue();
        }
        
        try {
            SynapseXPath xp = new SynapseXPath(attachPathValue);
            OMElementUtils.addNameSpaces(xp, elem, log);
            mediator.setAttachPath(xp);
        } catch (JaxenException e) {
            handleException(""Unable to build the IterateMediator. Invalid XPATH "" +
                attachPathValue, e);
        }

        OMElement targetElement = elem.getFirstChildWithName(TARGET_Q);
        if (targetElement != null) {
            mediator.setTarget(TargetFactory.createTarget(targetElement));
        } else {
            handleException(""Target for an iterate mediator is required :: missing target"");
        }

        return mediator;
    }

    /**
     * Get the IterateMediator configuration tag name
     *
     * @return QName specifying the IterateMediator tag name of the xml configuration
     */
    public QName getTagQName() {
        return ITERATE_Q;
    }
}
"
org/apache/synapse/mediators/FilterMediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.MessageContext;

/**
 * The filter mediator is a list mediator, which executes the given (sub) list of mediators
 * if the specified condition is satisfied
 *
 * @see FilterMediator#test(org.apache.synapse.MessageContext)
 */
public interface FilterMediator extends ListMediator {

    /**
     * Should return true if the sub/child mediators should execute. i.e. if the filter
     * condition is satisfied
     * @param synCtx
     * @return true if the configured filter condition evaluates to true
     */
    public boolean test(MessageContext synCtx);
}
"
org/apache/synapse/config/xml/DBReportMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.db.DBReportMediator;

/**
 * Serializer for {@link DBReportMediator} instances.
 * 
 * @see DBReportMediatorFactory
 */
public class DBReportMediatorSerializer extends AbstractDBMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof DBReportMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        DBReportMediator mediator = (DBReportMediator) m;
        OMElement dbReport = fac.createOMElement(""dbreport"", synNS);
        saveTracingState(dbReport,mediator);
        serializeDBInformation(mediator, dbReport);

        if (parent != null) {
            parent.addChild(dbReport);
        }
        return dbReport;
    }

    public String getMediatorClassName() {
        return DBReportMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/ProxyServiceSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.util.PolicyInfo;

import java.net.URI;
import java.util.ArrayList;
import java.util.List;

/**
 * Serializer for {@link ProxyService} instances.
 * 
 * @see ProxyServiceFactory
 */
public class ProxyServiceSerializer {

    private static final Log log = LogFactory.getLog(PropertyMediatorSerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    public static OMElement serializeProxy(OMElement parent, ProxyService service) {

        OMElement proxy = fac.createOMElement(""proxy"", synNS);
        if (service.getName() != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, service.getName()));
        } else {
            handleException(""Invalid proxy service. Service name is required"");
        }
        String descriptionStr = service.getDescription();
        if (descriptionStr != null) {
            OMElement description = fac.createOMElement(""description"", synNS);
            description.addChild(fac.createOMText(descriptionStr));
            proxy.addChild(description);
        }
        ArrayList transports = service.getTransports();
        if (transports != null && !transports.isEmpty()) {
            String transportStr = """" + transports.get(0);
            for (int i = 1; i < transports.size(); i++) {
                transportStr = transportStr + "" "" + transports.get(i);
            }
            proxy.addAttribute(fac.createOMAttribute(""transports"", nullNS, transportStr));
        }

        List pinnedServers = service.getPinnedServers();
        if (pinnedServers != null && !pinnedServers.isEmpty()) {
          String pinnedServersStr = """" + pinnedServers.get(0);
          for (int i = 1; i < pinnedServers.size(); i++) {
            pinnedServersStr = pinnedServersStr + "" "" + pinnedServers.get(i);
          }
          proxy.addAttribute(fac.createOMAttribute(""pinnedServers"", nullNS, pinnedServersStr));
        }
        
        if (service.isStartOnLoad()) {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""true""));
        } else {
            proxy.addAttribute(fac.createOMAttribute(
                    ""startOnLoad"", nullNS, ""false""));
        }
        String endpoint = service.getTargetEndpoint();

        OMElement target = fac.createOMElement(""target"", synNS);
        Endpoint inLineEndpoint = service.getTargetInLineEndpoint();
        if (endpoint != null) {
            target.addAttribute(fac.createOMAttribute(
                    ""endpoint"", nullNS, endpoint));
            proxy.addChild(target);
        } else if (inLineEndpoint != null) {
            OMElement epElement = EndpointSerializer.getElementFromEndpoint(inLineEndpoint);
            target.addChild(epElement);            
            proxy.addChild(target);
        }
            String inSeq = service.getTargetInSequence();
            String outSeq = service.getTargetOutSequence();
            String faultSeq = service.getTargetFaultSequence();
            SequenceMediatorSerializer serializer = new SequenceMediatorSerializer();
            if (inSeq != null) {
                target.addAttribute(fac.createOMAttribute(""inSequence"", nullNS, inSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineInSeq = service.getTargetInLineInSequence();
                if (inLineInSeq != null) {
                    OMElement inSeqElement = serializer.serializeAnonymousSequence(null, inLineInSeq);
                    inSeqElement.setLocalName(""inSequence"");
                    target.addChild(inSeqElement);
                    proxy.addChild(target);
                }
            }
            if (outSeq != null) {
                target.addAttribute(fac.createOMAttribute(""outSequence"", nullNS, outSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineOutSeq = service.getTargetInLineOutSequence();
                if (inLineOutSeq != null) {
                    OMElement outSeqElement = serializer.serializeAnonymousSequence(null, inLineOutSeq);
                    outSeqElement.setLocalName(""outSequence"");
                    target.addChild(outSeqElement);
                    proxy.addChild(target);
                }
            }
            if (faultSeq != null) {
                target.addAttribute(fac.createOMAttribute(""faultSequence"", nullNS, faultSeq));
                proxy.addChild(target);
            } else {
                SequenceMediator inLineFaultSeq = service.getTargetInLineFaultSequence();
                if (inLineFaultSeq != null) {
                    OMElement faultSeqElement = serializer.serializeAnonymousSequence(null, inLineFaultSeq);
                    faultSeqElement.setLocalName(""faultSequence"");
                    target.addChild(faultSeqElement);
                    proxy.addChild(target);
                }
            }

        

        String wsdlKey = service.getWSDLKey();
        URI wsdlUri = service.getWsdlURI();
        Object inLineWSDL = service.getInLineWSDL();
        if (wsdlKey != null || wsdlUri != null || inLineWSDL != null) {
            OMElement wsdl = fac.createOMElement(""publishWSDL"", synNS);
            if (wsdlKey != null) {
                wsdl.addAttribute(fac.createOMAttribute(
                        ""key"", nullNS, wsdlKey));
            } else if (inLineWSDL != null) {
                wsdl.addChild((OMNode) inLineWSDL);
            } else if (wsdlUri != null) {
                wsdl.addAttribute(fac.createOMAttribute(
                        ""uri"", nullNS, wsdlUri.toString()));
            }
            ResourceMapSerializer.serializeResourceMap(wsdl, service.getResourceMap());
            proxy.addChild(wsdl);
        }

        for (PolicyInfo pi : service.getPolicies()) {
            OMElement policy = fac.createOMElement(""policy"", synNS);
            if (pi.getPolicyKey() != null) {
                policy.addAttribute(fac.createOMAttribute(""key"", nullNS, pi.getPolicyKey()));
            } else {
                handleException(""Policy without a key has been found"");
            }

            if (pi.getOperation() != null) {
                policy.addAttribute(fac.createOMAttribute(""operationName"", nullNS, pi.getOperation().getLocalPart()));
                if (pi.getOperation().getNamespaceURI() != null) {
                    policy.addAttribute(fac.createOMAttribute(
                            ""operationNamespace"", nullNS, pi.getOperation().getNamespaceURI()));
                }
            }

            if (pi.getType() != 0) {
                policy.addAttribute(fac.createOMAttribute(""type"", nullNS, pi.getMessageLable().toLowerCase()));
            }

            proxy.addChild(policy);
        }

        for (String propertyName : service.getParameterMap().keySet()) {
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, propertyName));
            Object value = service.getParameterMap().get(propertyName);
            if (value != null) {
                if (value instanceof String) {
                    property.setText(((String) value).trim());
                    proxy.addChild(property);
                } else if (value instanceof OMNode) {
                    property.addChild((OMNode) value);
                    proxy.addChild(property);
                }
            }
        }

        if (service.isWsRMEnabled()) {
            proxy.addChild(fac.createOMElement(""enableRM"", synNS));
        }
        if (service.isWsSecEnabled()) {
            proxy.addChild(fac.createOMElement(""enableSec"", synNS));
        }

        int isEnableStatistics = service.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }

        int traceState = service.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.SynapseConstants.TRACING_ON) {
            traceValue = XMLConfigConstants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.SynapseConstants.TRACING_OFF) {
            traceValue = XMLConfigConstants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            proxy.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }
        if (parent != null) {
            parent.addChild(proxy);
        }
        return proxy;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/FaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Stack;
import java.io.StringWriter;
import java.io.Writer;
import java.io.PrintWriter;

/**
 * This is an abstract class that handles an unexpected error during Synapse mediation, but looking
 * at the stack of registered FaultHanders and invoking on them as appropriate. Sequences and
 * Endpoints would be Synapse entities that handles faults. If such an entity is unable to handle
 * an error condition, then a SynapseException should be thrown, which triggers this fault
 * handling logic.
 */
public abstract class FaultHandler {

    private static final Log log = LogFactory.getLog(FaultHandler.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    public void handleFault(MessageContext synCtx) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""FaultHandler executing impl: "" + this.getClass().getName());
        }

        try {
            synCtx.getServiceLog().info(""FaultHandler executing impl: "" + this.getClass().getName());
            onFault(synCtx);

        } catch (SynapseException e) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    /**
     * Extract and set ERROR_MESSAGE and ERROR_DETAIL to the message context from the Exception
     * @param synCtx the message context
     * @param e the exception encountered
     */
    public void handleFault(MessageContext synCtx, Exception e) {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        synCtx.setProperty(SynapseConstants.ERROR_CODE, ""00000"");
        // use only the first line as the message for multiline exception messages (Axis2 has these)
        synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split(""\n"")[0]);

        synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));
        synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""Fault handler - setting ERROR_MESSAGE : "" +
                synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));
            traceOrDebugWarn(traceOn, ""Fault handler - setting ERROR_DETAIL : "" +
                synCtx.getProperty(SynapseConstants.ERROR_DETAIL));
            traceOrDebugWarn(traceOn, ""Fault handler - setting ERROR_EXCEPTION : "" +
                synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));
        }

        synCtx.getServiceLog().warn(""Fault handler - setting ERROR_MESSAGE : "" +
            synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));

        try {
            onFault(synCtx);

        } catch (SynapseException se) {

            Stack faultStack = synCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx, se);
            }
        }
    }

    /**
     * This will be executed to handle any Exceptions occurred within the Synapse environment.
     * @param synCtx SynapseMessageContext of which the fault occured message comprises
     * @throws SynapseException in case there is a failure in the fault execution
     */
    public abstract void onFault(MessageContext synCtx);

    /**
     * Get the stack trace into a String
     * @param aThrowable
     * @return the stack trace as a string
     */
    public static String getStackTrace(Throwable aThrowable) {
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        aThrowable.printStackTrace(printWriter);
        return result.toString();
    }

    private void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        log.warn(msg);
    }

}
"
org/apache/synapse/mediators/builtin/SendMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.axis2.context.OperationContext;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.clustering.ClusterManager;

import java.util.List;
import java.util.Iterator;

/**
 * SendMediator sends a message using specified semantics. If it contains an endpoint it will
 * send the message to that endpoint. Once a message is sent to the endpoint further sending
 * behaviors are completely governed by that endpoint. If there is no endpoint available,
 * SendMediator will send the message to the implicitly stated destination.
 */
public class SendMediator extends AbstractMediator {

    private Endpoint endpoint = null;

    /**
     * This will call the send method on the messages with implicit message parameters
     * or else if there is an endpoint, with that endpoint parameters
     *
     * @param synCtx the current message to be sent
     * @return false always as this is a leaf mediator
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Send mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (synCtx.isResponse()) {

            Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synCtx;
            OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();

            boolean isClusteringEnable = false;

            // get Axis2 MessageContext and ConfigurationContext
            org.apache.axis2.context.MessageContext axisMC =
                    axis2MsgCtx.getAxis2MessageContext();
            ConfigurationContext cc = axisMC.getConfigurationContext();

            //The heck for clustering environment

            ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
            if (clusterManager != null &&
                    clusterManager.getContextManager() != null) {
                isClusteringEnable = true;
            }

            if (isClusteringEnable) {
                // if this is a clustering env.
                // Only keeps endpoint names , because , it is heavy task to
                // replicate endpoint itself
                Object epNames = opCtx.getPropertyNonReplicable(SALoadbalanceEndpoint.ENDPOINT_NAME_LIST);
                if (epNames != null && epNames instanceof List) {

                    List epNameList = (List) epNames;
                    Object obj = epNameList.remove(0);
                    if (obj != null && obj instanceof String) {
                        Object rootEPObj = opCtx.getPropertyNonReplicable(
                                SALoadbalanceEndpoint.ROOT_ENDPOINT);

                        if (rootEPObj != null && rootEPObj instanceof Endpoint) {
                            String name = ((Endpoint) rootEPObj).getName();

                            if (name != null && name.equals(obj)) {
                                Endpoint rootEP = ((Endpoint) rootEPObj);

                                if (rootEP instanceof SALoadbalanceEndpoint) {
                                    SALoadbalanceEndpoint salEP = (SALoadbalanceEndpoint) rootEP;
                                    salEP.updateSession(synCtx, epNameList,
                                            isClusteringEnable);
                                }
                            }
                        }

                    }
                    opCtx.setProperty(SALoadbalanceEndpoint.ENDPOINT_NAME_LIST, epNames);
                }

            } else {
                Object o = opCtx.getProperty(SALoadbalanceEndpoint.ENDPOINT_LIST);
                if (o != null && o instanceof List) {
                    // we are in the response of the first message of a server initiated session
                    // so update all session maps
                    List epList = (List) o;
                    Object e = epList.remove(0);

                    if (e != null) {
                        if (e instanceof SALoadbalanceEndpoint) {
                            SALoadbalanceEndpoint salEP = (SALoadbalanceEndpoint) e;
                            salEP.updateSession(synCtx, epList, isClusteringEnable);
                        }
                    }
                }
            }

        }

        // if no endpoints are defined, send where implicitly stated
        if (endpoint == null) {

            if (traceOrDebugOn) {
                StringBuffer sb = new StringBuffer();
                sb.append(""Sending "" + (synCtx.isResponse() ? ""response"" : ""request"")
                        + "" message using implicit message properties.."");
                sb.append(""\nSending To: "" + (synCtx.getTo() != null ?
                        synCtx.getTo().getAddress() : ""null""));
                sb.append(""\nSOAPAction: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));
                traceOrDebug(traceOn, sb.toString());
            }

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Envelope : "" + synCtx.getEnvelope());
            }
            synCtx.getEnvironment().send(null, synCtx);

        } else {
            endpoint.send(synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Send mediator"");
        }

        return true;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
}
"
org/apache/synapse/mediators/MediatorFaultHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators;

import org.apache.synapse.*;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This implements the FaultHandler interface as a mediator fault handler. That is the fault handler is
 * specified by a sequence and this handler implements the logic of handling the fault through the set
 * of mediators present in the sequence.
 *
 * @see org.apache.synapse.FaultHandler
 */
public class MediatorFaultHandler extends FaultHandler {

    private static final Log log = LogFactory.getLog(MediatorFaultHandler.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /**
     * This holds the fault sequence for the mediator fault handler
     */
    private Mediator faultMediator = null;

    /**
     * Constructs the FaultHandler object for handling mediator faults
     *
     * @param faultMediator Mediator in which fault sequence is specified
     */
    public MediatorFaultHandler(Mediator faultMediator) {

        this.faultMediator = faultMediator;
    }

    /**
     * Implements the fault handling method for the mediators (basically sequences)
     *
     * @param synCtx Synapse Message Context of which mediation occurs
     * @throws SynapseException in case there is a failure in the fault execution
     * @see org.apache.synapse.FaultHandler#handleFault(org.apache.synapse.MessageContext)
     */
    public void onFault(MessageContext synCtx) throws SynapseException {

        boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
        boolean traceOrDebugOn = traceOn || log.isDebugEnabled();

        String name = null;
        if (faultMediator instanceof SequenceMediator) {
            name = ((SequenceMediator) faultMediator).getName();
        }
        if (name == null) {
            name = faultMediator.getClass().getName();
        }

        if (traceOrDebugOn) {
            traceOrDebugWarn(traceOn, ""Executing fault handler mediator : "" + name);
        }

        synCtx.getServiceLog().warn(""Executing fault sequence mediator : "" + name);
        this.faultMediator.mediate(synCtx);
    }

    /**
     * Getter for the mediator describing the fault sequence
     *
     * @return Mediator specifying the fault sequence for mediator fault handler
     */
    public Mediator getFaultMediator() {
        return faultMediator;
    }

    /**
     * Setter of the mediator describing the fault sequence
     *
     * @param faultMediator Mediator specifying the fault sequence to be used by the handler
     */
    public void setFaultMediator(Mediator faultMediator) {
        this.faultMediator = faultMediator;
    }

    private void traceOrDebugWarn(boolean traceOn, String msg) {
        if (traceOn) {
            trace.warn(msg);
        }
        log.warn(msg);
    }

}
"
org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java,true,"package org.apache.synapse.config.xml;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Collection;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.Startup;

public class SynapseXMLConfigurationSerializer implements ConfigurationSerializer {

    private static final Log log = LogFactory
            .getLog(XMLConfigurationSerializer.class);

    private static final OMFactory fac = OMAbstractFactory.getOMFactory();

    private static final OMNamespace synNS = fac.createOMNamespace(
            XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");

    private static final OMNamespace nullNS = fac.createOMNamespace(
            XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * Order of entries is irrelevant, however its nice to have some order.
     *
     * @param synCfg
     * @throws XMLStreamException
     */

    public OMElement serializeConfiguration(SynapseConfiguration synCfg) {

        OMElement definitions = fac.createOMElement(""definitions"", synNS);

        // first process a remote registry if present
        if (synCfg.getRegistry() != null) {
            RegistrySerializer.serializeRegistry(definitions, synCfg
                    .getRegistry());
        }

        // add proxy services
        Iterator iter = synCfg.getProxyServices().iterator();
        while (iter.hasNext()) {
            ProxyService service = (ProxyService) iter.next();
            ProxyServiceSerializer.serializeProxy(definitions, service);
        }

        Map entries = new HashMap();
        Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
        Map sequences = new HashMap();

        iter = synCfg.getLocalRegistry().keySet().iterator();
        while (iter.hasNext()) {
            Object key = iter.next();
            Object o = synCfg.getLocalRegistry().get(key);
            if (o instanceof Mediator) {
                sequences.put(key, o);
            } else if (o instanceof Endpoint) {
                endpoints.put(key.toString(), (Endpoint) o);
            } else if (o instanceof Entry) {
                entries.put(key, o);
            } else {
                handleException(""Unknown object : "" + o.getClass()
                        + "" for serialization into Synapse configuration"");
            }
        }

        // process entries
        serializeEntries(definitions, entries);

        // process endpoints
        serializeEndpoints(definitions, endpoints);

        // process sequences
        serializeSequences(definitions, sequences);

        // handle startups
        serializeStartups(definitions, synCfg.getStartups());

        return definitions;
    }

    private static void serializeEntries(OMElement definitions, Map entries) {
        Iterator iter = entries.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            EntrySerializer.serializeEntry((Entry) entries.get(key),
                    definitions);
        }
    }

    private static void serializeStartups(OMElement definitions, Collection startups) {
        Iterator it = startups.iterator();
        while (it.hasNext()) {
            Startup s = (Startup) it.next();
            StartupFinder.getInstance().serializeStartup(definitions, s);
        }
    }

    private static void serializeEndpoints(OMElement definitions, Map<String, Endpoint> endpoints) {
        for (Endpoint endpoint: endpoints.values()) {
            definitions.addChild(EndpointSerializer.getElementFromEndpoint(endpoint));
        }
    }

    private static void serializeSequences(OMElement definitions, Map sequences) {
        Iterator iter = sequences.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String) iter.next();
            Mediator mediator = (Mediator) sequences.get(key);
            MediatorSerializerFinder.getInstance().getSerializer(mediator)
                    .serializeMediator(definitions, mediator);
        }
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    public QName getTagQName() {
        return XMLConfigConstants.DEFINITIONS_ELT;
	}

}
"
org/apache/synapse/core/axis2/MediatorDeployer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.deployment.Deployer;
import org.apache.axis2.deployment.DeploymentClassLoader;
import org.apache.axis2.deployment.DeploymentException;
import org.apache.axis2.deployment.repository.util.DeploymentFileData;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.xml.MediatorFactory;
import org.apache.synapse.config.xml.MediatorFactoryFinder;
import org.apache.synapse.config.xml.MediatorSerializer;
import org.apache.synapse.config.xml.MediatorSerializerFinder;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;

/**
 * This will support the hot deployment and hot update of the mediators at runtime using the
 * Axis2 concepts of deployers
 */
public class MediatorDeployer implements Deployer {

    /**
     * Holds the log variable for logging purposes
     */
    private static final Log log = LogFactory.getLog(MediatorDeployer.class);

    /**
     * ConfigurationContext of Axis2
     */
    private ConfigurationContext cfgCtx = null;

    /**
     * Initializes the Deployer
     *
     * @param configurationContext - ConfigurationContext of Axis2 from which
     *  the deployer is initialized
     */
    public void init(ConfigurationContext configurationContext) {
        this.cfgCtx = configurationContext;
    }

    /**
     * This will be called when there is a change in the specified deployment
     * folder (in the axis2.xml) and this will load the relevant classes to the system and
     * register them with the MediatorFactoryFinder
     *
     * @param deploymentFileData - describes the updated file
     * @throws DeploymentException - in case an error on the deployment
     */
    public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {

        log.info(""Loading mediator from: "" + deploymentFileData.getAbsolutePath());

        // get the context class loader for the later restore of the context class loader
        ClassLoader prevCl = Thread.currentThread().getContextClassLoader();

        try {

            DeploymentClassLoader urlCl = new DeploymentClassLoader(
                    new URL[]{deploymentFileData.getFile().toURL()}, null, prevCl);
            Thread.currentThread().setContextClassLoader(urlCl);

            // MediatorFactory registration
            URL facURL = urlCl.findResource(
                    ""META-INF/services/org.apache.synapse.config.xml.MediatorFactory"");
            if (facURL != null) {
                InputStream facStream = facURL.openStream();
                InputStreamReader facreader = new InputStreamReader(facStream);

                StringBuffer facSB = new StringBuffer();
                int c;
                while ((c = facreader.read()) != -1) {
                    facSB.append((char) c);
                }

                String[] facClassNames = facSB.toString().split(""\n"");
                for (String facClassName : facClassNames) {
                    log.info(""Registering the Mediator factory: "" + facClassName);
                    Class facClass = urlCl.loadClass(facClassName);
                    MediatorFactory facInst = (MediatorFactory) facClass.newInstance();
                    MediatorFactoryFinder.getInstance()
                            .getFactoryMap().put(facInst.getTagQName(), facClass);
                    log.info(""Mediator loaded and registered for "" +
                            ""the tag name: "" + facInst.getTagQName());
                }
            } else {
                handleException(""Unable to find the MediatorFactory implementation. "" +
                        ""Unable to register the MediatorFactory with the FactoryFinder"");
            }

            // MediatorSerializer registration
            URL serURL = urlCl.findResource(
                    ""META-INF/services/org.apache.synapse.config.xml.MediatorSerializer"");
            if (serURL != null) {
                InputStream serStream = serURL.openStream();
                InputStreamReader serReader = new InputStreamReader(serStream);

                StringBuffer serSB = new StringBuffer();
                int c;
                while ((c = serReader.read()) != -1) {
                    serSB.append((char) c);
                }

                String[] serClassNames = serSB.toString().split(""\n"");
                for (String serClassName : serClassNames) {
                    log.info(""Registering the Mediator serializer: "" + serClassName);
                    Class serClass = urlCl.loadClass(serClassName);
                    MediatorSerializer serInst = (MediatorSerializer) serClass.newInstance();
                    MediatorSerializerFinder.getInstance()
                            .getSerializerMap().put(serInst.getMediatorClassName(), serInst);
                    log.info(""Mediator loaded and registered for "" +
                            ""the serialization as: "" + serInst.getMediatorClassName());
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Unable to find the MediatorSerializer implementation. "" +
                            ""Unable to register the MediatorSerializer with the SerializerFinder"");
                }
            }

        } catch (IOException e) {
            handleException(""I/O error in reading the mediator jar file"", e);
        } catch (ClassNotFoundException e) {
            handleException(""Unable to find the specified class on the path or in the jar file"", e);
        } catch (IllegalAccessException e) {
            handleException(""Unable to load the class from the jar"", e);
        } catch (InstantiationException e) {
            handleException(""Unable to instantiate the class specified"", e);
        } finally {
            // restore the class loader back
            if (log.isDebugEnabled()) {
                log.debug(""Restoring the context class loader to the original"");
            }
            Thread.currentThread().setContextClassLoader(prevCl);
        }
    }

    /**
     * This will not be implemented because we do not support changing the directory at runtime
     *
     * @param string -
     */
    public void setDirectory(String string) {
        // we do not support changing the directory
    }

    /**
     * This will not be implemented because we do not support changing the extension at runtime
     *
     * @param string -
     */
    public void setExtension(String string) {
        // we do not support changing the extension
    }

    /**
     * This will be called when a particular jar file is deleted from the specified folder.
     *
     * @param string - filename of the deleted file
     * @throws DeploymentException - incase of an error in undeployment
     */
    public void unDeploy(String string) throws DeploymentException {
        // todo: implement the undeployement
    }

    private void handleException(String message, Exception e) throws DeploymentException {
        if (log.isDebugEnabled()) {
            log.debug(message, e);
        }
        throw new DeploymentException(message, e);
    }

    private void handleException(String message) throws DeploymentException {
        if (log.isDebugEnabled()) {
            log.debug(message);
        }
        throw new DeploymentException(message);
    }
}
"
org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.LoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;

import java.util.List;

/**
 * Serializes {@link LoadbalanceEndpoint} to an XML configuration.
 *
 * &lt;endpoint [name=""name""]&gt;
 *    &lt;loadbalance policy=""load balance algorithm""&gt;
 *       &lt;endpoint&gt;+
 *    &lt;/loadbalance&gt;
 * &lt;/endpoint&gt;
 */
public class LoadbalanceEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof LoadbalanceEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement
                = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        LoadbalanceEndpoint loadbalanceEndpoint = (LoadbalanceEndpoint) endpoint;

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement loadbalanceElement
                = fac.createOMElement(""loadbalance"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute(XMLConfigConstants.ALGORITHM_NAME, algorithmName, null);

        // set if failover is turned off in the endpoint
        if (!loadbalanceEndpoint.isFailover()) {
            loadbalanceElement.addAttribute(""failover"", ""false"", null);
        }

        for (Endpoint childEndpoint : loadbalanceEndpoint.getEndpoints()) {
            loadbalanceElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
        }

        return endpointElement;
    }
}
"
org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.aggregator;

import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.mediators.eip.EIPUtils;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * Aggregate a number of messages that are determined to be for a particular group, and combine
 * them to form a single message which is then processed through the 'onComplete' sequence. Thus
 * an aggregator acts like a filter, and may look at a correlation XPath expression to select
 * messages for aggregation - or look at messageSequence number properties for aggregation or
 * let any other (i.e. non aggregatable) messages flow through
 * An instance of this mediator will register with a Timer to be notified after a specified timeout,
 * so that aggregations that never would complete could be timed out and cleared from memory and
 * any fault conditions handled
 */
public class AggregateMediator extends AbstractMediator {

    private static final Log log = LogFactory.getLog(AggregateMediator.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    /** The duration as a number of milliseconds for this aggregation to complete */
    private long completionTimeoutMillis = 0;
    /** The minimum number of messages required to complete aggregation */
    private int minMessagesToComplete = -1;
    /** The maximum number of messages required to complete aggregation */
    private int maxMessagesToComplete = -1;

    /**
     * XPath that specifies a correlation expression that can be used to combine messages. An
     * example maybe //department@id=""11""
     */
    private SynapseXPath correlateExpression = null;
    /**
     * An XPath expression that may specify a selected element to be aggregated from a group of
     * messages to create the aggregated message
     * e.g. //getQuote/return would pick up and aggregate the //getQuote/return elements from a
     * bunch of matching messages into one aggregated message
     */
    private SynapseXPath aggregationExpression = null;

    /** This holds the reference sequence name of the */
    private String onCompleteSequenceRef = null;
    /** Inline sequence definition holder that holds the onComplete sequence */
    private SequenceMediator onCompleteSequence = null;

    /** The active aggregates currently being processd */
    private Map<String, Aggregate> activeAggregates =
        Collections.synchronizedMap(new HashMap<String, Aggregate>());

    /** Lock object to provide the synchronized access to the activeAggregates on checking */
    private final Object lock = new Object();

    public AggregateMediator() {
        try {
            aggregationExpression = new SynapseXPath(""s11:Body/child::*[position()=1] | "" +
                ""s12:Body/child::*[position()=1]"");
            aggregationExpression.addNamespace(""s11"", SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);
            aggregationExpression.addNamespace(""s12"", SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);
        } catch (JaxenException e) {
            if (log.isDebugEnabled()) {
                handleException(""Unable to set the default "" +
                    ""aggregationExpression for the aggregation"", e, null);
            }
        }
    }

    /**
     * Aggregate messages flowing through this mediator according to the correlation criteria
     * and the aggregation algorithm specified to it
     *
     * @param synCtx - MessageContext to be mediated and aggregated
     * @return boolean true if the complete condition for the particular aggregate is validated
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Aggregate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            Aggregate aggregate = null;

            // if a correlateExpression is provided and there is a coresponding
            // element in the current message prepare to correlate the messages on that
            if (correlateExpression != null
                    && correlateExpression.evaluate(synCtx) != null) {

                while (aggregate == null) {

                    synchronized (lock) {

                        if (activeAggregates.containsKey(correlateExpression.toString())) {

                            aggregate = activeAggregates.get(correlateExpression.toString());
                            if (aggregate != null) {
                                if (!aggregate.getLock()) {
                                    aggregate = null;
                                }
                            }

                        } else {

                            if (traceOrDebugOn) {
                                traceOrDebug(traceOn, ""Creating new Aggregator - "" +
                                        (completionTimeoutMillis > 0 ? ""expires in : ""
                                                + (completionTimeoutMillis / 1000) + ""secs"" :
                                                ""without expiry time""));
                            }

                            aggregate = new Aggregate(
                                    correlateExpression.toString(),
                                    completionTimeoutMillis,
                                    minMessagesToComplete,
                                    maxMessagesToComplete, this);

                            if (completionTimeoutMillis > 0) {
                                synCtx.getConfiguration().getSynapseTimer().
                                        schedule(aggregate, completionTimeoutMillis);
                            }
                            aggregate.getLock();
                            activeAggregates.put(correlateExpression.toString(), aggregate);
                        }
                    }
                }

            } else if (synCtx.getProperty(EIPConstants.AGGREGATE_CORRELATION) != null) {
                // if the correlattion cannot be found using the correlateExpression then
                // try the default which is through the AGGREGATE_CORRELATION message property
                // which is the unique original message id of a split or iterate operation and
                // which thus can be used to uniquely group messages into aggregates

                Object o = synCtx.getProperty(EIPConstants.AGGREGATE_CORRELATION);
                String correlation;

                if (o != null && o instanceof String) {
                    correlation = (String) o;
                    while (aggregate == null) {
                        synchronized (lock) {
                            if (activeAggregates.containsKey(correlation)) {
                                aggregate = activeAggregates.get(correlation);
                                if (aggregate != null) {
                                    if (!aggregate.getLock()) {
                                        aggregate = null;
                                    }
                                } else {
                                    break;
                                }
                            } else {
                                if (traceOrDebugOn) {
                                    traceOrDebug(traceOn, ""Creating new Aggregator - "" +
                                            (completionTimeoutMillis > 0 ? ""expires in : ""
                                                    + (completionTimeoutMillis / 1000) + ""secs"" :
                                                    ""without expiry time""));
                                }
                        
                                aggregate = new Aggregate(
                                        correlation,
                                        completionTimeoutMillis,
                                        minMessagesToComplete,
                                        maxMessagesToComplete, this);

                                if (completionTimeoutMillis > 0) {
                                    synCtx.getConfiguration().getSynapseTimer().
                                            schedule(aggregate, completionTimeoutMillis);
                                }
                                aggregate.getLock();
                                activeAggregates.put(correlation, aggregate);
                            }
                        }
                    }
                    
                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Unable to find aggrgation correlation property"");
                    }
                    return true;
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                            ""Unable to find aggrgation correlation XPath or property"");
                }
                return true;
            }

            // if there is an aggregate continue on aggregation
            if (aggregate != null) {
                boolean collected = aggregate.addMessage(synCtx);
                if (traceOrDebugOn) {
                    if (collected) {
                        traceOrDebug(traceOn, ""Collected a message during aggregation"");
                        if (traceOn && trace.isTraceEnabled()) {
                            trace.trace(""Collected message : "" + synCtx);
                        }
                    }
                }
                
                // check the completeness of the aggregate and if completed aggregate the messages
                // if not completed return false and block the message sequence till it completes

                if (aggregate.isComplete(traceOn, traceOrDebugOn, trace, log)) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Aggregation completed - invoking onComplete"");
                    }
                    completeAggregate(aggregate);
                    
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""End : Aggregate mediator"");
                    }
                    return true;
                } else {
                    aggregate.releaseLock();
                }

            } else {
                // if the aggregation correlation cannot be found then continue the message on the
                // normal path by returning true

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Unable to find an aggregate for this message - skip"");
                }
                return true;
            }

        } catch (JaxenException e) {
            handleException(""Unable to execute the XPATH over the message"", e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Aggregate mediator"");
        }

        return false;
    }

    /**
     * Invoked by the Aggregate objects that are timed out, to signal timeout/completion of
     * itself
     * @param aggregate the timed out Aggregate that holds collected messages and properties
     */
    public synchronized void completeAggregate(Aggregate aggregate) {

        if (log.isDebugEnabled()) {
            log.debug(""Aggregation completed or timed out"");
        }

        // cancel the timer
        aggregate.cancel();
        aggregate.setCompleted(true);

        MessageContext newSynCtx = getAggregatedMessage(aggregate);
        if (newSynCtx == null) {
            log.warn(""An aggregation of messages timed out with no aggregated messages"", null);
            return;
        }

        activeAggregates.remove(aggregate.getCorrelation());

        if ((correlateExpression != null &&
            !correlateExpression.toString().equals(aggregate.getCorrelation())) ||
            correlateExpression == null) {

            if (onCompleteSequence != null) {
                onCompleteSequence.mediate(newSynCtx);

            } else if (onCompleteSequenceRef != null
                && newSynCtx.getSequence(onCompleteSequenceRef) != null) {
                newSynCtx.getSequence(onCompleteSequenceRef).mediate(newSynCtx);

            } else {
                handleException(""Unable to find the sequence for the mediation "" +
                    ""of the aggregated message"", newSynCtx);
            }
        }
    }

    /**
     * Get the aggregated message from the specified Aggregate instance
     *
     * @param aggregate the Aggregate object that holds collected messages and properties of the
     * aggregation
     * @return the aggregated message context
     */
    private MessageContext getAggregatedMessage(Aggregate aggregate) {

        MessageContext newCtx = null;

        for (MessageContext synCtx : aggregate.getMessages()) {
            
            if (newCtx == null) {
                newCtx = synCtx;

                if (log.isDebugEnabled()) {
                    log.debug(""Generating Aggregated message from : "" + newCtx.getEnvelope());
                }

            } else {
                try {
                    if (log.isDebugEnabled()) {
                        log.debug(""Merging message : "" + synCtx.getEnvelope() + "" using XPath : "" +
                                aggregationExpression);
                    }

                    EIPUtils.enrichEnvelope(
                            newCtx.getEnvelope(), synCtx.getEnvelope(), aggregationExpression);

                    if (log.isDebugEnabled()) {
                        log.debug(""Merged result : "" + newCtx.getEnvelope());
                    }

                } catch (JaxenException e) {
                    handleException(""Error merging aggregation results using XPath : "" +
                            aggregationExpression.toString(), e, synCtx);
                }
            }
        }
        return newCtx;
    }

    public SynapseXPath getCorrelateExpression() {
        return correlateExpression;
    }

    public void setCorrelateExpression(SynapseXPath correlateExpression) {
        this.correlateExpression = correlateExpression;
    }

    public long getCompletionTimeoutMillis() {
        return completionTimeoutMillis;
    }

    public void setCompletionTimeoutMillis(long completionTimeoutMillis) {
        this.completionTimeoutMillis = completionTimeoutMillis;
    }

    public int getMinMessagesToComplete() {
        return minMessagesToComplete;
    }

    public void setMinMessagesToComplete(int minMessagesToComplete) {
        this.minMessagesToComplete = minMessagesToComplete;
    }

    public int getMaxMessagesToComplete() {
        return maxMessagesToComplete;
    }

    public void setMaxMessagesToComplete(int maxMessagesToComplete) {
        this.maxMessagesToComplete = maxMessagesToComplete;
    }

    public SynapseXPath getAggregationExpression() {
        return aggregationExpression;
    }

    public void setAggregationExpression(SynapseXPath aggregationExpression) {
        this.aggregationExpression = aggregationExpression;
    }

    public String getOnCompleteSequenceRef() {
        return onCompleteSequenceRef;
    }

    public void setOnCompleteSequenceRef(String onCompleteSequenceRef) {
        this.onCompleteSequenceRef = onCompleteSequenceRef;
    }

    public SequenceMediator getOnCompleteSequence() {
        return onCompleteSequence;
    }

    public void setOnCompleteSequence(SequenceMediator onCompleteSequence) {
        this.onCompleteSequence = onCompleteSequence;
    }

    public Map getActiveAggregates() {
        return activeAggregates;
    }
}
"
org/apache/synapse/core/axis2/TimeoutHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.ServerManager;

import java.util.Iterator;
import java.util.Map;
import java.util.Stack;
import java.util.TimerTask;

/**
 * An object of this class is registered to be invoked in some predefined time intervals. This
 * checks the timeouts of callbacks stored in the SynapseCallbackReceiver and removes all expired
 * callbacks. Timeouts of the callbacks are stored as the time, not the duration. So that the
 * time or the interval of invoking this class does not affect the correctness of the timeouts,
 * although longer intervals would introduce larger error between the actual timeout and the
 * specified timeout.
 *
 * For each invocation this gets a time value to be compared against the timeouts of the callback
 * objects. This time is the System.currentTimeMillis() for Java 1.4 and System.nanoTime() for
 * Java 1.5 and later.
 */
public class TimeoutHandler extends TimerTask {

    private static final Log log = LogFactory.getLog(TimeoutHandler.class);

    /** The callback map - already a Collections.synchronized() hash map */
    private Map callbackStore = null;
    /** a lock to prevent concurrent execution while ensuring least overhead */
    private Object lock = new Object();
    private boolean alreadyExecuting = false;
    /**
     * this is the timeout for otherwise non-expiring callbacks
     * to ensure system stability over time
     */
    private long globalTimeout = SynapseConstants.DEFAULT_GLOBAL_TIMEOUT;

    public TimeoutHandler(Map callbacks) {
        this.callbackStore = callbacks;
        globalTimeout = ServerManager.getInstance().getGlobalTimeoutInterval();
        log.info(""This engine will expire all callbacks after : "" + (globalTimeout /1000) +
            "" seconds, irrespective of the timeout action, after the specified or optional timeout"");
    }

    /**
     * Checks if the timeout has expired for each callback in the callback store. If expired, removes
     * the callback. If specified sends a fault message to the client about the timeout.
     */
    public void run() {
        if (alreadyExecuting) return;

        synchronized(lock) {
            alreadyExecuting = true;
            try {
                processCallbacks();
            } catch (Exception ignore) {}
            alreadyExecuting = false;
        }
    }

    private void processCallbacks() {

        // checks if callback store contains at least one entry before proceeding. otherwise getting
        // the time for doing nothing would be a inefficient task.

        // we have to synchronize this on the callbackStore as iterators of thread safe collections
        // are not thread safe. callbackStore can be modified concurrently by the SynapseCallbackReceiver.
        synchronized(callbackStore) {

            if (callbackStore.size() > 0) {

                long currentTime = currentTime();
                Iterator i = callbackStore.keySet().iterator();

                while (i.hasNext()) {

                    Object key = i.next();
                    AsyncCallback callback = (AsyncCallback) callbackStore.get(key);

                    if (callback.getTimeOutAction() != SynapseConstants.NONE) {

                        if (callback.getTimeOutOn() <= currentTime) {
                            callbackStore.remove(key);

                            if (callback.getTimeOutAction() == SynapseConstants.DISCARD_AND_FAULT) {

                                // actiavte the fault sequence of the current sequence mediator
                                MessageContext msgContext = callback.getSynapseOutMsgCtx();

                                // add an error code to the message context, so that error sequences
                                // can identify the cause of error
                                msgContext.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.TIME_OUT);
                                msgContext.setProperty(SynapseConstants.ERROR_MESSAGE, ""Send timeout"");

                                Stack faultStack = msgContext.getFaultStack();

                                for (int j = 0; j < faultStack.size(); j++) {
                                    Object o = faultStack.pop();
                                    if (o instanceof FaultHandler) {
                                        ((FaultHandler) o).handleFault(msgContext);
                                    }
                                }

                            }
                        }

                    } else if (currentTime > globalTimeout + callback.getTimeOutOn()) {
                        log.warn(""Expiring message ID : "" + key + ""; dropping message after "" +
                            ""global timeout of : "" + (globalTimeout/1000) + "" seconds"");
                        callbackStore.remove(key);
                    }
                }
            }
        }
    }

    /**
     * Returns the current time.
     *
     * @return  System.currentTimeMillis() on Java 1.4
     *          System.nanoTime() on Java 1.5 (todo: implement)
     */
    private long currentTime() {
        return System.currentTimeMillis();
    }
}
"
org/apache/synapse/util/FixedByteArrayOutputStream.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.synapse.SynapseException;
import java.io.ByteArrayOutputStream;

public class FixedByteArrayOutputStream extends ByteArrayOutputStream {

    public FixedByteArrayOutputStream(int size) {
        super(size);
    }

    public synchronized void write(int b) {
        if (count+1 > buf.length) {
            throw new SynapseException(""Fixed size of internal byte array exceeded"");
        }
        super.write(b);
    }

    public synchronized void write(byte b[], int off, int len) {
        if (count+len > buf.length) {
            throw new SynapseException(""Fixed size of internal byte array exceeded"");
        }
        super.write(b, off, len);
    }
}
"
org/apache/synapse/endpoints/Endpoint.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.synapse.MessageContext;

/**
 * Endpoint defines the behavior common to all Synapse endpoints. Synapse endpoints should be able
 * to send the given Synapse message context, rather than just providing the information for sending
 * the message. The task a particular endpoint does in its send(...) method is specific to the endpoint.
 * For example a loadbalance endpoint may choose another endpoint using its load balance policy and
 * call its send(...) method while an address endpoint (leaf level) may send the message to an actual
 * endpoint url. Endpoints may contain zero or more endpoints in them and build up a hierarchical
 * structure of endpoints.
 */
public interface Endpoint {

    /**
     * Sends the message context according to an endpoint specific behavior.
     *
     * @param synMessageContext MessageContext to be sent.
     */
    public void send(MessageContext synMessageContext);

    /**
     * Endpoints that contain other endpoints should implement this method. It will be called if a
     * child endpoint causes an exception. Action to be taken on such failure is up to the implementation.
     * But it is good practice to first try addressing the issue. If it can't be addressed propagate the
     * exception to parent endpoint by calling parent endpoint's onChildEndpointFail(...) method.
     *
     * @param endpoint          The child endpoint which caused the exception.
     * @param synMessageContext MessageContext that was used in the failed attempt.
     */
    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext);

    /**
     * Sets the parent endpoint for the current endpoint.
     *
     * @param parentEndpoint parent endpoint containing this endpoint. It should handle the onChildEndpointFail(...)
     *                       callback.
     */
    public void setParentEndpoint(Endpoint parentEndpoint);

    /**
     * Returns the name of the endpoint.
     *
     * @return Endpoint name.
     */
    public String getName();

    /**
     * Sets the name of the endpoint. Local registry use this name as the key for storing the
     * endpoint.
     *
     * @param name Name for the endpoint.
     */
    public void setName(String name);

    /**
     * Returns if the endpoint is currently active or not. Messages should not be sent to inactive
     * endpoints.
     *
     * @param synMessageContext MessageContext for the current message. This is required for
     *                          IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     *                          Endpoint implementations may ignore this parameter.
     * @return true if the endpoint is in active state. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext);

    /**
     * Sets the endpoint as active or inactive. If an endpoint is detected as failed, it should be
     * set as inactive. But endpoints may be eventually set as active by the endpoint refresher to
     * avoid ignoring endpoints forever.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext for the current message. This is required for
     *                          IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
     *                          Endpoint implementations may ignore this parameter.
     */
    public void setActive(boolean active, MessageContext synMessageContext);
}
"
org/apache/synapse/config/xml/ResourceMapSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.util.Map;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.ResourceMap;

/**
 * Creates a sequence of <tt>&lt;resource&gt;</tt> elements from a ResourceMap object:
 * <pre>
 * &lt;resource location=""..."" key=""...""/&gt;*
 * </pre>
 */
public class ResourceMapSerializer {
    private static final OMFactory fac = OMAbstractFactory.getOMFactory();
    
    public static void serializeResourceMap(OMElement parent, ResourceMap resourceMap) {
        if (resourceMap != null) {
        	for (Map.Entry<String,String> entry : resourceMap.getResources().entrySet()) {
                OMElement resource = fac.createOMElement(""resource"",
                    SynapseConstants.SYNAPSE_OMNAMESPACE);
                resource.addAttribute(""location"", (String)entry.getKey(), null);
                resource.addAttribute(""key"", (String)entry.getValue(), null);
                parent.addChild(resource);
            }
        }
    }
}
"
org/apache/synapse/config/xml/StartupFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.xml.namespace.QName;

import org.apache.axiom.om.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Startup;
import org.apache.synapse.startup.quartz.SimpleQuartzFactory;

import sun.misc.Service;

public class StartupFinder {

    private static final Log log = LogFactory
            .getLog(ConfigurationFactoryAndSerializerFinder.class);

    private static StartupFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap(),
            serializerMap = new HashMap();

    public static synchronized StartupFinder getInstance() {
        if (instance == null) {
            instance = new StartupFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private static final Class[] builtins = {SimpleQuartzFactory.class};

    private StartupFinder() {
        // preregister any built in
        for (int i = 0; i < builtins.length; i++) {
            Class b = builtins[i];
            StartupFactory sf;
            try {
                sf = (StartupFactory) b.newInstance();
            } catch (Exception e) {
                throw new SynapseException(""cannot instantiate "" + b.getName(), e);

            }
            factoryMap.put(sf.getTagQName(), b);
            serializerMap.put(sf.getTagQName(), sf.getSerializerClass());

        }

        registerExtensions();
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     * <p/>
     * This looks for JAR files containing a META-INF/services that adheres to
     * the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        // log.debug(""Registering mediator extensions found in the classpath : ""
        // + System.getResource(""java.class.path""));

        // register MediatorFactory extensions
        Iterator it = Service.providers(StartupFactory.class);
        while (it.hasNext()) {
            StartupFactory sf = (StartupFactory) it.next();
            QName tag = sf.getTagQName();
            factoryMap.put(tag, sf.getClass());
            serializerMap.put(tag, sf.getSerializerClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added StartupFactory "" + sf.getClass()
                        + "" to handle "" + tag);
            }
        }
    }

    /**
     * This method returns a Processor given an OMElement. This will be used
     * recursively by the elements which contain processor elements themselves
     * (e.g. rules)
     *
     * @param element
     * @return Processor
     */
    public Startup getStartup(OMElement element) {

        QName qName = element.getQName();
        if (log.isDebugEnabled()) {
            log.debug(""Creating the Startup for : "" + qName);
        }

        Class cls = (Class) factoryMap.get(qName);
        if (cls == null) {
            String msg = ""Unknown Startup type referenced by startup element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            StartupFactory sf = (StartupFactory) cls.newInstance();
            return sf.createStartup(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * This method will serialize the config using the supplied QName (looking
     * up the right class to do it)
     *
     * @param parent  -
     *                Parent OMElement to which the created element will be added if
     *                not null
     * @param startup -
     *                Startup to be serialized
     * @return OMElement startup
     */
    public OMElement serializeStartup(OMElement parent, Startup startup) {

        Class cls = (Class) serializerMap.get(startup.getTagQName());
        if (cls == null) {
            String msg = ""Unknown startup type referenced by startup element : ""
                    + startup.getTagQName();
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            StartupSerializer ss = (StartupSerializer) cls.newInstance();
            return ss.serializeStartup(parent, startup);

        } catch (InstantiationException e) {
            String msg = ""Error initializing startup serializer: "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing startup ser: "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /*
      * This method exposes all the StartupFactories and its Extensions
      */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /*
	 * This method exposes all the StartupSerializers and its Extensions
	 */
    public Map getSerializerMap() {
        return serializerMap;
    }

    /**
     * Allow the startup finder to act as an XMLToObjectMapper for
     * Startup (i.e. Startup) loaded dynamically from a Registry
     *
     * @param om
     * @return
     */
    public Startup getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getStartup((OMElement) om);
        } else {
			handleException(""Invalid configuration XML : "" + om);
		}
		return null;
	}

}
"
org/apache/synapse/config/xml/endpoints/IndirectEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;

/**
 * Serializes an {@link IndirectEndpoint} to an XML configuration.
 *
 * &lt;endpoint key=""key""/&gt;
 */
public class IndirectEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof IndirectEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        IndirectEndpoint indirectEndpoint = (IndirectEndpoint) endpoint;
        String ref = indirectEndpoint.getKey();
        if (ref != null) {
            endpointElement.addAttribute(""key"", ref, null);
        }

        return endpointElement;
    }
}
"
org/apache/synapse/core/axis2/ProxyService.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.AxisFault;
import org.apache.axis2.description.*;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.engine.AxisEvent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.neethi.Policy;
import org.apache.neethi.PolicyEngine;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.ServerManager;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.util.PolicyInfo;
import org.xml.sax.InputSource;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.*;

/**
 * <proxy-service name=""string"" [transports=""(http |https |jms )+|all""] [trace=""enable|disable""]>
 *    <description>..</description>?
 *    <target [inSequence=""name""] [outSequence=""name""] [faultSequence=""name""] [endpoint=""name""]>
 *       <endpoint>...</endpoint>
 *       <inSequence>...</inSequence>
 *       <outSequence>...</outSequence>
 *       <faultSequence>...</faultSequence>
 *    </target>?
 *    <publishWSDL uri="".."" key=""string"">
 *       <wsdl:definition>...</wsdl:definition>?
 *       <wsdl20:description>...</wsdl20:description>?
 *       <resource location=""..."" key=""...""/>*
 *    </publishWSDL>?
 *    <enableSec/>?
 *    <enableRM/>?
 *    <policy key=""string"" [type=(""in"" |""out"")] [operationName=""string""]
 *      [operationNamespace=""string""]>?
 *       // optional service parameters
 *    <parameter name=""string"">
 *       text | xml
 *    </parameter>?
 * </proxy-service>
 */
public class ProxyService {

    private static final Log log = LogFactory.getLog(ProxyService.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
    private final Log serviceLog;
    /**
     * The name of the proxy service
     */
    private String name;
    /**
     * The proxy service description. This could be optional informative text about the service
     */
    private String description;
    /**
     * The transport/s over which this service should be exposed, or defaults to all available
     */
    private ArrayList transports;
    /**
     * Server names for which this service should be exposed
     */
    private List pinnedServers = new ArrayList();
    /**
     * The target endpoint key
     */
    private String targetEndpoint = null;
    /**
     * The target inSequence key
     */
    private String targetInSequence = null;
    /**
     * The target outSequence key
     */
    private String targetOutSequence = null;
    /**
     * The target faultSequence key
     */
    private String targetFaultSequence = null;
    /**
     * The inlined definition of the target endpoint, if defined
     */
    private Endpoint targetInLineEndpoint = null;
    /**
     * The inlined definition of the target in-sequence, if defined
     */
    private SequenceMediator targetInLineInSequence = null;
    /**
     * The inlined definition of the target out-sequence, if defined
     */
    private SequenceMediator targetInLineOutSequence = null;
    /**
     * The inlined definition of the target fault-sequence, if defined
     */
    private SequenceMediator targetInLineFaultSequence = null;
    /**
     * A list of any service parameters (e.g. JMS parameters etc)
     */
    private Map<String, Object> parameters = new HashMap<String, Object>();
    /**
     * The key for the base WSDL
     */
    private String wsdlKey;
    /**
     * The URI for the base WSDL, if defined as a URL
     */
    private URI wsdlURI;
    /**
     * The inlined representation of the service WSDL, if defined inline
     */
    private Object inLineWSDL;
    /**
     * A ResourceMap object allowing to locate artifacts (WSDL and XSD) imported
     * by the service WSDL to be located in the registry.
     */
    private ResourceMap resourceMap;
    /**
     * Policies to be set to the service, this can include service level, operation level,
     * message level or hybrid level policies as well.
     */
    private List<PolicyInfo> policies = new ArrayList<PolicyInfo>();
    /**
     * The keys for any supplied policies that would apply at the service level
     */
    private List<String> serviceLevelPolicies = new ArrayList<String>();
    /**
     * The keys for any supplied policies that would apply at the in message level
     */
    private List<String> inMessagePolicies = new ArrayList<String>();
    /**
     * The keys for any supplied policies that would apply at the out message level
     */
    private List<String> outMessagePolicies = new ArrayList<String>();
    /**
     * Should WS RM be engaged on this service
     */
    private boolean wsRMEnabled = false;
    /**
     * Should WS Sec be engaged on this service
     */
    private boolean wsSecEnabled = false;
    /**
     * Should this service be started by default on initialization?
     */
    private boolean startOnLoad = true;
    /**
     * Is this service running now?
     */
    private boolean running = false;

    public static final String ALL_TRANSPORTS = ""all"";

    /**
     * To decide to whether statistics should have collected or not
     */
    private int statisticsState = SynapseConstants.STATISTICS_UNSET;
    /**
     * The variable that indicate tracing on or off for the current mediator
     */
    protected int traceState = SynapseConstants.TRACING_UNSET;


    /**
     * Constructor
     *
     * @param name the name of the Proxy service
     */
    public ProxyService(String name) {
        this.name = name;
        serviceLog = LogFactory.getLog(SynapseConstants.SERVICE_LOGGER_PREFIX + name);
    }

    /**
     * Build the underlying Axis2 service from the Proxy service definition
     *
     * @param synCfg the Synapse configuration
     * @param axisCfg the Axis2 configuration
     * @return the Axis2 service for the Proxy
     */
    public AxisService buildAxisService(SynapseConfiguration synCfg, AxisConfiguration axisCfg) {

        auditInfo(""Building Axis service for Proxy service : "" + name);
        AxisService proxyService = null;

        // get the wsdlElement as an OMElement
        if (trace()) {
            trace.info(""Loading the WSDL : "" +
                (wsdlKey != null ? "" key = "" + wsdlKey :
                (wsdlURI != null ? "" URI = "" + wsdlURI : "" <Inlined>"")));
        }

        InputStream wsdlInputStream = null;
        OMElement wsdlElement = null;
        boolean wsdlFound = false;

        if (wsdlKey != null) {
            synCfg.getEntryDefinition(wsdlKey);
            Object keyObject = synCfg.getEntry(wsdlKey);
            if (keyObject instanceof OMElement) {
                wsdlElement = (OMElement) keyObject;
            }
            wsdlFound = true;
        } else if (inLineWSDL != null) {
            wsdlElement = (OMElement) inLineWSDL;
            wsdlFound = true;
        } else if (wsdlURI != null) {
            try {
                URL url = wsdlURI.toURL();
                OMNode node = SynapseConfigUtils.getOMElementFromURL(url.toString());
                if (node instanceof OMElement) {
                    wsdlElement = (OMElement) node;
                }
                wsdlFound = true;
            } catch (MalformedURLException e) {
                handleException(""Malformed URI for wsdl"", e);
            } catch (IOException e) {
                handleException(""Error reading from wsdl URI"", e);
            }
        } else {
            // this is for POX... create a dummy service and an operation for which
            // our SynapseDispatcher will properly dispatch to
            if (trace()) trace.info(""Did not find a WSDL. Assuming a POX or Legacy service"");
            proxyService = new AxisService();
            AxisOperation mediateOperation = new InOutAxisOperation(new QName(""mediate""));
            proxyService.addOperation(mediateOperation);
        }

        // if a WSDL was found
        if (wsdlElement != null) {
            OMNamespace wsdlNamespace = wsdlElement.getNamespace();

            // serialize and create an inputstream to read WSDL
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                if (trace()) trace.info(""Serializing wsdlElement found to build an Axis2 service"");
                wsdlElement.serialize(baos);
                wsdlInputStream = new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

            if (wsdlInputStream != null) {

                try {
                    // detect version of the WSDL 1.1 or 2.0
                    if (trace()) trace.info(""WSDL Namespace is : ""
                        + wsdlNamespace.getNamespaceURI());

                    if (wsdlNamespace != null) {
                        boolean isWSDL11 = false;
                        WSDLToAxisServiceBuilder wsdlToAxisServiceBuilder = null;

                        if (WSDL2Constants.WSDL_NAMESPACE.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL20ToAxisServiceBuilder(wsdlInputStream, null, null);

                        } else if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.
                                equals(wsdlNamespace.getNamespaceURI())) {
                            wsdlToAxisServiceBuilder =
                                    new WSDL11ToAxisServiceBuilder(wsdlInputStream);
                            isWSDL11 = true;
                        } else {
                            handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                        }

                        if (wsdlToAxisServiceBuilder == null) {
                            throw new SynapseException(
                                    ""Could not get the WSDL to Axis Service Builder"");
                        }

                        wsdlToAxisServiceBuilder.setBaseUri(
                                wsdlURI != null ? wsdlURI.toString() :
                                        ServerManager.getInstance().getSynapseHome());

                        if (trace()) {
                            trace.info(""Setting up custom resolvers"");
                        }
                        // Set up the URIResolver

                        if (resourceMap != null) {
                            // if the resource map is available use it
                            wsdlToAxisServiceBuilder.setCustomResolver(
                                new CustomURIResolver(resourceMap, synCfg));
                            // Axis 2 also needs a WSDLLocator for WSDL 1.1 documents
                            if (wsdlToAxisServiceBuilder instanceof WSDL11ToAxisServiceBuilder) {
                                ((WSDL11ToAxisServiceBuilder)
                                    wsdlToAxisServiceBuilder).setCustomWSLD4JResolver(
                                    new CustomWSDLLocator(new InputSource(wsdlInputStream),
                                                          wsdlURI != null ? wsdlURI.toString() : """",
                                                          resourceMap, synCfg));
                            }
                        } else {
                            //if the resource map isn't available ,
                            //then each import URIs will be resolved using base URI 
                            wsdlToAxisServiceBuilder.setCustomResolver(
                                new CustomURIResolver());
                            // Axis 2 also needs a WSDLLocator for WSDL 1.1 documents
                            if (wsdlToAxisServiceBuilder instanceof WSDL11ToAxisServiceBuilder) {
                                ((WSDL11ToAxisServiceBuilder)
                                    wsdlToAxisServiceBuilder).setCustomWSLD4JResolver(
                                    new CustomWSDLLocator(new InputSource(wsdlInputStream),
                                            wsdlURI != null ? wsdlURI.toString() : """"));
                            }
                        }

                        if (trace()) {
                            trace.info(""Populating Axis2 service using WSDL"");
                            if (trace.isTraceEnabled()) {
                                trace.trace(""WSDL : "" + wsdlElement.toString());
                            }
                        }
                        proxyService = wsdlToAxisServiceBuilder.populateService();

                        // this is to clear the bindinigs and ports already in the WSDL so that the
                        // service will generate the bindings on calling the printWSDL otherwise
                        // the WSDL which will be shown is same as the original WSDL except for the
                        // service name
                        proxyService.getEndpoints().clear();

                    } else {
                        handleException(""Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0"");
                    }

                } catch (AxisFault af) {
                    handleException(""Error building service from WSDL"", af);
                } catch (IOException ioe) {
                    handleException(""Error reading WSDL"", ioe);
                }
            }
        } else if (wsdlFound) {
            handleException(""Couldn't build the proxy service : "" + name
                    + "". Unable to locate the specified WSDL to build the service"");
        }

        // Set the name and description. Currently Axis2 uses the name as the
        // default Service destination
        if (proxyService == null) {
            throw new SynapseException(""Could not create a proxy service"");
        }
        proxyService.setName(name);
        if (description != null) {
            proxyService.setDocumentation(description);
        }

        // process transports and expose over requested transports. If none
        // is specified, default to all transports using service name as
        // destination
        if (transports == null || transports.size() == 0) {
            // default to all transports using service name as destination
        } else {
            if (trace()) trace.info(""Exposing transports : "" + transports);
            proxyService.setExposedTransports(transports);
        }

        // process parameters
        if (trace() && parameters.size() > 0) {
            trace.info(""Setting service parameters : "" + parameters);
        }
        for (Object o : parameters.keySet()) {
            String name = (String) o;
            Object value = parameters.get(name);

            Parameter p = new Parameter();
            p.setName(name);
            p.setValue(value);

            try {
                proxyService.addParameter(p);
            } catch (AxisFault af) {
                handleException(""Error setting parameter : "" + name + """" +
                    ""to proxy service as a Parameter"", af);
            }
        }

        if (!policies.isEmpty()) {

            for (PolicyInfo pi : policies) {

                if (pi.isServicePolicy()) {

                    proxyService.getPolicyInclude().addPolicyElement(
                            PolicyInclude.AXIS_SERVICE_POLICY,
                            getPolicyFromKey(pi.getPolicyKey(), synCfg));

                } else if (pi.isOperationPolicy()) {

                    AxisOperation op = proxyService.getOperation(pi.getOperation());
                    if (op != null) {
                        op.getPolicyInclude().addPolicyElement(PolicyInclude.AXIS_OPERATION_POLICY,
                                getPolicyFromKey(pi.getPolicyKey(), synCfg));
                    } else {
                        handleException(""Couldn't find the operation specified "" +
                                ""by the QName : "" + pi.getOperation());
                    }
                    
                } else if (pi.isMessagePolicy()) {

                    if (pi.getOperation() != null) {

                        AxisOperation op = proxyService.getOperation(pi.getOperation());
                        if (op != null) {
                            op.getMessage(pi.getMessageLable()).getPolicyInclude().addPolicyElement(
                                    PolicyInclude.MESSAGE_POLICY,
                                    getPolicyFromKey(pi.getPolicyKey(), synCfg));
                        } else {
                            handleException(""Couldn't find the operation "" +
                                    ""specified by the QName : "" + pi.getOperation());
                        }
                        
                    } else {
                        // operation is not specified and hence apply to all the applicable messages
                        for (Iterator itr = proxyService.getOperations(); itr.hasNext();) {
                            Object obj = itr.next();
                            if (obj instanceof AxisOperation) {
                                // check whether the policy is applicable
                                if (!((obj instanceof OutOnlyAxisOperation && pi.getType()
                                        == PolicyInfo.MESSAGE_TYPE_IN) ||
                                        (obj instanceof InOnlyAxisOperation
                                        && pi.getType() == PolicyInfo.MESSAGE_TYPE_OUT))) {

                                    AxisMessage message = ((AxisOperation)
                                            obj).getMessage(pi.getMessageLable());
                                    message.getPolicyInclude().addPolicyElement(
                                            PolicyInclude.AXIS_MESSAGE_POLICY,
                                            getPolicyFromKey(pi.getPolicyKey(), synCfg));
                                }
                            }
                        }
                    }
                } else {
                    handleException(""Undefined Policy type"");
                }
            }
        }

        // create a custom message receiver for this proxy service 
        ProxyServiceMessageReceiver msgRcvr = new ProxyServiceMessageReceiver();
        msgRcvr.setName(name);
        msgRcvr.setProxy(this);

        Iterator iter = proxyService.getOperations();
        while (iter.hasNext()) {
            AxisOperation op = (AxisOperation) iter.next();
            op.setMessageReceiver(msgRcvr);
        }

        try {
            auditInfo(""Adding service "" + name + "" to the Axis2 configuration"");
            axisCfg.addService(proxyService);
            this.setRunning(true);
        } catch (AxisFault axisFault) {
            try {
                if (axisCfg.getService(proxyService.getName()) != null) {
                    if (trace()) trace.info(""Removing service "" + name + "" due to error : ""
                        + axisFault.getMessage());
                    axisCfg.removeService(proxyService.getName());
                }
            } catch (AxisFault ignore) {}
            handleException(""Error adding Proxy service to the Axis2 engine"", axisFault);
        }

        // should RM be engaged on this service?
        if (wsRMEnabled) {
            auditInfo(""WS-Reliable messaging is enabled for service : "" + name);
            try {
                proxyService.engageModule(axisCfg.getModule(
                    SynapseConstants.MERCURY_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS RM module on proxy service : "" + name, axisFault);
            }
        }

        // should Security be engaged on this service?
        if (wsSecEnabled) {
            auditInfo(""WS-Security is enabled for service : "" + name);
            try {
                proxyService.engageModule(axisCfg.getModule(
                    SynapseConstants.RAMPART_MODULE_NAME), axisCfg);
            } catch (AxisFault axisFault) {
                handleException(""Error loading WS Sec module on proxy service : ""
                        + name, axisFault);
            }
        }

        auditInfo(""Successfully created the Axis2 service for Proxy service : "" + name);
        return proxyService;
    }

    private Policy getPolicyFromKey(String key, SynapseConfiguration synCfg) {

        synCfg.getEntryDefinition(key);
        return PolicyEngine.getPolicy(
                SynapseConfigUtils.getStreamSource(synCfg.getEntry(key)).getInputStream());
    }

    /**
     * Start the proxy service
     * @param synCfg the synapse configuration
     */
    public void start(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration();
        if (axisConfig != null) {
            
            Parameter param = axisConfig.getParameter(SynapseConstants.SYNAPSE_ENV);
            if (param != null && param.getValue() instanceof SynapseEnvironment)  {
                SynapseEnvironment env = (SynapseEnvironment) param.getValue();
                if (targetInLineInSequence != null) {
                    targetInLineInSequence.init(env);
                }
                if (targetInLineOutSequence != null) {
                    targetInLineOutSequence.init(env);
                }
                if (targetInLineFaultSequence != null) {
                    targetInLineFaultSequence.init(env);
                }
            } else {
                auditWarn(""Unable to find the SynapseEnvironment. "" +
                    ""Components of the proxy service may not be initialized"");
            }

            AxisService as = axisConfig.getServiceForActivation(this.getName());
            as.setActive(true);
            axisConfig.notifyObservers(AxisEvent.SERVICE_START, as);
            this.setRunning(true);
            auditInfo(""Started the proxy service : "" + name);
        } else {
            auditWarn(""Unable to start proxy service : "" + name + 
                "". Couldn't access Axis configuration"");
        }
    }

    /**
     * Stop the proxy service
     * @param synCfg the synapse configuration
     */
    public void stop(SynapseConfiguration synCfg) {
        AxisConfiguration axisConfig = synCfg.getAxisConfiguration();
        if (axisConfig != null) {

            if (targetInLineInSequence != null) {
                targetInLineInSequence.destroy();
            }
            if (targetInLineOutSequence != null) {
                targetInLineOutSequence.destroy();
            }
            if (targetInLineFaultSequence != null) {
                targetInLineFaultSequence.destroy();
            }

            try {
                AxisService as = axisConfig.getService(this.getName());
                if (as != null) {
                    as.setActive(false);
                    axisConfig.notifyObservers(AxisEvent.SERVICE_STOP, as);
                }
                this.setRunning(false);
                auditInfo(""Stopped the proxy service : "" + name);
            } catch (AxisFault axisFault) {
                handleException(""Error stopping the proxy service : "" + name, axisFault);
            }
        } else {
            auditWarn(""Unable to stop proxy service : "" + name +
                "". Couldn't access Axis configuration"");
        }
    }

    private void handleException(String msg) {
        serviceLog.error(msg);
        log.error(msg);
        if (trace()) trace.error(msg);
        throw new SynapseException(msg);
    }

    private void handleException(String msg, Exception e) {
        serviceLog.error(msg);
        log.error(msg, e);
        if (trace()) trace.error(msg + "" :: "" + e.getMessage());
        throw new SynapseException(msg, e);
    }

    /**
     * Write to the general log, as well as any service specific logs the audit message at INFO
     * @param message the INFO level audit message
     */
    private void auditInfo(String message) {
        log.info(message);
        serviceLog.info(message);
        if (trace()) {
            trace.info(message);
        }
    }

    /**
     * Write to the general log, as well as any service specific logs the audit message at WARN
     * @param message the WARN level audit message
     */
    private void auditWarn(String message) {
        log.warn(message);
        serviceLog.warn(message);
        if (trace()) {
            trace.warn(message);
        }
    }

    /**
     * Return true if tracing should be enabled
     * @return true if tracing is enabled for this service
     */
    private boolean trace() {
        return traceState == SynapseConstants.TRACING_ON;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public ArrayList getTransports() {
        return transports;
    }

    public void addParameter(String name, Object value) {
        parameters.put(name, value);
    }

    public Map<String, Object> getParameterMap() {
        return this.parameters;
    }

    public void setTransports(ArrayList transports) {
        this.transports = transports;
    }

    public String getTargetEndpoint() {
        return targetEndpoint;
    }

    public void setTargetEndpoint(String targetEndpoint) {
        this.targetEndpoint = targetEndpoint;
    }

    public String getTargetInSequence() {
        return targetInSequence;
    }

    public void setTargetInSequence(String targetInSequence) {
        this.targetInSequence = targetInSequence;
    }

    public String getTargetOutSequence() {
        return targetOutSequence;
    }

    public void setTargetOutSequence(String targetOutSequence) {
        this.targetOutSequence = targetOutSequence;
    }

    public String getWSDLKey() {
        return wsdlKey;
    }

    public void setWSDLKey(String wsdlKey) {
        this.wsdlKey = wsdlKey;
    }

    public List<String> getServiceLevelPolicies() {
        return serviceLevelPolicies;
    }

    public void addServiceLevelPolicy(String serviceLevelPolicy) {
        this.serviceLevelPolicies.add(serviceLevelPolicy);
    }

    public boolean isWsRMEnabled() {
        return wsRMEnabled;
    }

    public void setWsRMEnabled(boolean wsRMEnabled) {
        this.wsRMEnabled = wsRMEnabled;
    }

    public boolean isWsSecEnabled() {
        return wsSecEnabled;
    }

    public void setWsSecEnabled(boolean wsSecEnabled) {
        this.wsSecEnabled = wsSecEnabled;
    }

    public boolean isStartOnLoad() {
        return startOnLoad;
    }

    public void setStartOnLoad(boolean startOnLoad) {
        this.startOnLoad = startOnLoad;
    }

    public boolean isRunning() {
        return running;
    }

    public void setRunning(boolean running) {
        this.running = running;
    }

    /**
     * To check whether statistics should have collected or not
     *
     * @return Returns the int value that indicate statistics is enabled or not.
     */
    public int getStatisticsState() {
        return statisticsState;
    }

    /**
     * To set the statistics enable variable value
     *
     * @param statisticsState statistics state
     */
    public void setStatisticsState(int statisticsState) {
        this.statisticsState = statisticsState;
    }

    /**
     * Returns the int value that indicate the tracing state
     *
     * @return Returns the int value that indicate the tracing state
     */
    public int getTraceState() {
        return traceState;
    }

    /**
     * Set the tracing State variable
     *
     * @param traceState tracing state
     */
    public void setTraceState(int traceState) {
        this.traceState = traceState;
    }

    public String getTargetFaultSequence() {
        return targetFaultSequence;
    }

    public void setTargetFaultSequence(String targetFaultSequence) {
        this.targetFaultSequence = targetFaultSequence;
    }

    public Object getInLineWSDL() {
        return inLineWSDL;
    }

    public void setInLineWSDL(Object inLineWSDL) {
        this.inLineWSDL = inLineWSDL;
    }

    public URI getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(URI wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public Endpoint getTargetInLineEndpoint() {
        return targetInLineEndpoint;
    }

    public void setTargetInLineEndpoint(Endpoint targetInLineEndpoint) {
        this.targetInLineEndpoint = targetInLineEndpoint;
    }

    public SequenceMediator getTargetInLineInSequence() {
        return targetInLineInSequence;
    }

    public void setTargetInLineInSequence(SequenceMediator targetInLineInSequence) {
        this.targetInLineInSequence = targetInLineInSequence;
    }

    public SequenceMediator getTargetInLineOutSequence() {
        return targetInLineOutSequence;
    }

    public void setTargetInLineOutSequence(SequenceMediator targetInLineOutSequence) {
        this.targetInLineOutSequence = targetInLineOutSequence;
    }

    public SequenceMediator getTargetInLineFaultSequence() {
        return targetInLineFaultSequence;
    }

    public void setTargetInLineFaultSequence(SequenceMediator targetInLineFaultSequence) {
        this.targetInLineFaultSequence = targetInLineFaultSequence;
    }

    public List getPinnedServers() {
      return pinnedServers;
    }

    public void setPinnedServers(List pinnedServers) {
      this.pinnedServers = pinnedServers;
    }

    public ResourceMap getResourceMap() {
        return resourceMap;
    }

    public void setResourceMap(ResourceMap resourceMap) {
        this.resourceMap = resourceMap;
    }

    public List<String> getInMessagePolicies() {
        return inMessagePolicies;
    }

    public void setInMessagePolicies(List<String> inMessagePolicies) {
        this.inMessagePolicies = inMessagePolicies;
    }

    public void addInMessagePolicy(String messagePolicy) {
        this.inMessagePolicies.add(messagePolicy);
    }

    public List<String> getOutMessagePolicies() {
        return outMessagePolicies;
    }

    public void setOutMessagePolicies(List<String> outMessagePolicies) {
        this.outMessagePolicies = outMessagePolicies;
    }

    public void addOutMessagePolicy(String messagePolicy) {
        this.outMessagePolicies.add(messagePolicy);
    }

    public List<PolicyInfo> getPolicies() {
        return policies;
    }

    public void setPolicies(List<PolicyInfo> policies) {
        this.policies = policies;
    }

    public void addPolicyInfo(PolicyInfo pi) {
        this.policies.add(pi);
    }
}
"
org/apache/synapse/config/xml/FaultMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.FaultMediator;

/**
 * Serializer for {@link FaultMediator} instances.
 * 
 * @see FaultMediatorFactory
 */
public class FaultMediatorSerializer extends AbstractMediatorSerializer {

    private static final String SOAP11 = ""soap11"";

    private static final String SOAP12 = ""soap12"";

    private static final String POX = ""pox"";

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof FaultMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        FaultMediator mediator = (FaultMediator) m;
        OMElement fault = fac.createOMElement(""makefault"", synNS);
        saveTracingState(fault,mediator);

        if(mediator.getSoapVersion()==FaultMediator.SOAP11) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP11));
        } else if(mediator.getSoapVersion()==FaultMediator.SOAP12) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, SOAP12));
        } else if(mediator.getSoapVersion()==FaultMediator.POX) {
           fault.addAttribute(fac.createOMAttribute(
                ""version"", nullNS, POX));
        }

        OMElement code = fac.createOMElement(""code"", synNS, fault);
        if (mediator.getFaultCodeValue() != null) {
            code.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultCodeValue().getPrefix() + "":""
                    + mediator.getFaultCodeValue().getLocalPart()));
            code.declareNamespace(mediator.getFaultCodeValue().getNamespaceURI(),
                    mediator.getFaultCodeValue().getPrefix());

        } else if (mediator.getFaultCodeExpr() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getFaultCodeExpr(), code, ""expression"");

        } else if (mediator.getSoapVersion() != FaultMediator.POX) {
            handleException(""Fault code is required for a fault "" +
                    ""mediator unless it is a pox fault"");
        }

        OMElement reason = fac.createOMElement(""reason"", synNS, fault);
        if (mediator.getFaultReasonValue() != null) {
            reason.addAttribute(fac.createOMAttribute(
                ""value"", nullNS, mediator.getFaultReasonValue()));

        } else if (mediator.getFaultReasonExpr() != null) {

            SynapseXPathSerializer.serializeXPath(
                mediator.getFaultReasonExpr(), reason, ""expression"");

        } else if (mediator.getSoapVersion() != FaultMediator.POX) {
            handleException(""Fault reason is required for a fault "" +
                    ""mediator unless it is a pox fault"");
        }


        if (mediator.getFaultNode() != null) {
            OMElement node = fac.createOMElement(""node"", synNS, fault);
            node.setText(mediator.getFaultNode().toString());
        }

        if (mediator.getFaultRole() != null) {
            OMElement role = fac.createOMElement(""role"", synNS, fault);
            role.setText(mediator.getFaultRole().toString());
        }

        if (mediator.getFaultDetailExpr() != null) {
            OMElement detail = fac.createOMElement(""detail"", synNS, fault);
            SynapseXPathSerializer.serializeXPath(
                    mediator.getFaultDetailExpr(), detail, ""expression"");            
        } else if (mediator.getFaultDetail() != null) {
            OMElement detail = fac.createOMElement(""detail"", synNS, fault);
            detail.setText(mediator.getFaultDetail());
        }

        if (parent != null) {
            parent.addChild(fault);
        }
        return fault;
    }

    public String getMediatorClassName() {
        return FaultMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

public abstract class AbstractMediatorFactory implements MediatorFactory {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected static Log log;
    protected static final QName ATT_NAME    = new QName(""name"");
    protected static final QName ATT_VALUE   = new QName(""value"");
    protected static final QName ATT_XPATH   = new QName(""xpath"");
    protected static final QName ATT_REGEX   = new QName(""regex"");
    protected static final QName ATT_SEQUENCE = new QName(""sequence"");
    protected static final QName ATT_EXPRN   = new QName(""expression"");
    protected static final QName ATT_KEY     = new QName(""key"");
    protected static final QName ATT_SOURCE  = new QName(""source"");
    protected static final QName ATT_TARGET  = new QName(""target"");
    protected static final QName ATT_ONERROR = new QName(""onError"");
    protected static final QName ATT_STATS
        = new QName(XMLConfigConstants.STATISTICS_ATTRIB_NAME);
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"");
    protected static final QName FEATURE_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""feature"");
    protected static final QName TARGET_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediatorFactory() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * This is to Initialize the mediator with the default attributes
     *
     * @param mediator
     * @param mediatorOmElement
     */
    protected void processTraceState(Mediator mediator, OMElement mediatorOmElement) {

        OMAttribute trace = mediatorOmElement.getAttribute(
            new QName(XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.TRACE_ATTRIB_NAME));

        if (trace != null) {
            String traceValue = trace.getAttributeValue();
            if (traceValue != null) {
                if (traceValue.equals(XMLConfigConstants.TRACE_ENABLE)) {
                    mediator.setTraceState(org.apache.synapse.SynapseConstants.TRACING_ON);
                } else if (traceValue.equals(XMLConfigConstants.TRACE_DISABLE)) {
                    mediator.setTraceState(org.apache.synapse.SynapseConstants.TRACING_OFF);
                }
            }
        }
    }

    protected void handleException(String message, Exception e) {
        LogFactory.getLog(this.getClass()).error(message, e);
        throw new SynapseException(message, e);
    }

    protected void handleException(String message) {
        LogFactory.getLog(this.getClass()).error(message);
        throw new SynapseException(message);
    }
}
"
org/apache/synapse/mediators/eip/Target.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.axis2.addressing.EndpointReference;

/**
 * A bean class that holds the target (i.e. sequence or endpoint) information for a message
 * as used by common EIP mediators
 */
public class Target {

    /** An optional To address to be set on the message when handing over to the target */
    private String toAddress = null;

    /** An optional Action to be set on the message when handing over to the target */
    private String soapAction = null;

    /** The inlined target sequence definition */
    private SequenceMediator sequence = null;

    /** The target sequence reference key */
    private String sequenceRef = null;

    /** The inlined target endpoint definition */
    private Endpoint endpoint = null;

    /** The target endpoint reference key */
    private String endpointRef = null;

    /**
     * process the message through this target (may be to mediate
     * using the target sequence, send message to the target endpoint or both)
     *
     * @param synCtx - MessageContext to be mediated
     */
    public void mediate(MessageContext synCtx) {

        if (soapAction != null) {
            synCtx.setSoapAction(soapAction);
        }

        if (toAddress != null) {
            if (synCtx.getTo() != null) {
                synCtx.getTo().setAddress(toAddress);
            } else {
                synCtx.setTo(new EndpointReference(toAddress));
            }
        }

        // since we are injecting the new messages asynchronously, we cannot process a message
        // through a sequence and then again with an endpoint
        if (sequence != null) {
            synCtx.getEnvironment().injectAsync(synCtx, sequence);
        } else if (sequenceRef != null) {
            SequenceMediator refSequence = (SequenceMediator) synCtx.getSequence(sequenceRef);
            if (refSequence != null) {
                synCtx.getEnvironment().injectAsync(synCtx, refSequence);
            }
        } else if (endpoint != null) {
            endpoint.send(synCtx);
        } else if (endpointRef != null) {
            Endpoint epr = synCtx.getConfiguration().getEndpoint(endpointRef);
            if (epr != null) {
                epr.send(synCtx);
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public String getToAddress() {
        return toAddress;
    }

    public void setToAddress(String toAddress) {
        this.toAddress = toAddress;
    }

    public String getSoapAction() {
        return soapAction;
    }

    public void setSoapAction(String soapAction) {
        this.soapAction = soapAction;
    }

    public SequenceMediator getSequence() {
        return sequence;
    }

    public void setSequence(SequenceMediator sequence) {
        this.sequence = sequence;
    }

    public String getSequenceRef() {
        return sequenceRef;
    }

    public void setSequenceRef(String sequenceRef) {
        this.sequenceRef = sequenceRef;
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }

    public String getEndpointRef() {
        return endpointRef;
    }

    public void setEndpointRef(String endpointRef) {
        this.endpointRef = endpointRef;
    }
}"
org/apache/synapse/registry/RegistryEntryImpl.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.synapse.registry.RegistryEntry;

import java.net.URI;
import java.util.Date;

public class RegistryEntryImpl implements RegistryEntry {

    private String key = null;
    private String name = null;
    private long version = Long.MIN_VALUE;
    private URI type = null;
    private String description;
    private long created;
    private long lastModified;
    private long cachableDuration;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getVersion() {
        return version;
    }

    public void setVersion(long version) {
        this.version = version;
    }

    public URI getType() {
        return type;
    }

    public void setType(URI type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getCreated() {
        return created;
    }

    public void setCreated(long created) {
        this.created = created;
    }

    public long getLastModified() {
        return lastModified;
    }

    public void setLastModified(long lastModified) {
        this.lastModified = lastModified;
    }

    public long getCachableDuration() {
        return cachableDuration;
    }

    public void setCachableDuration(long cachableDuration) {
        this.cachableDuration = cachableDuration;
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(""RegistryEntry {"")
            .append("" Key : "" + key)
            .append("" Name : "" + name)
            .append("" Ver : "" + version)
            .append("" Type : "" + type)
            .append("" Desc : "" + description)
            .append("" Created : "" + new Date(created))
            .append("" Modified : "" + new Date(lastModified))
            .append("" Cacheable for : "" + (cachableDuration / 1000) + ""sec"")
            .append(""}"");
        return sb.toString();
    }
}
"
org/apache/synapse/config/xml/DBReportMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.db.DBReportMediator;

import javax.xml.namespace.QName;

/**
 * Factory for {@link DBReportMediator} instances.
 * <pre>
 * &lt;dbreport&gt;
 *   &lt;connection&gt;
 *     &lt;pool&gt;
 *      (
 *       &lt;driver/&gt;
 *       &lt;url/&gt;
 *       &lt;user/&gt;
 *       &lt;password/&gt;
 *     |
 *       &lt;dsName/&gt;
 *       &lt;icClass/&gt;
 *       &lt;url/&gt;
 *       &lt;user/&gt;
 *       &lt;password/&gt;
 *     )
 *       &lt;property name=""name"" value=""value""/&gt;*
 *     &lt;/pool&gt;
 *   &lt;/connection&gt;
 *   &lt;statement&gt;
 *     &lt;sql&gt;insert into something values(?, ?, ?, ?)&lt;/sql&gt;
 *     &lt;parameter [value="""" | expression=""""] type=""int|string""/&gt;*
 *    &lt;/statement&gt;+
 * &lt;/dblreport&gt;
 * </pre>
 */
public class DBReportMediatorFactory extends AbstractDBMediatorFactory {

    private static final QName DBREPORT_Q =
        new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""dbreport"");

    public Mediator createMediator(OMElement elem) {
        DBReportMediator mediator = new DBReportMediator();
        buildDataSource(elem, mediator);
        processStatements(elem, mediator);
        return mediator;
    }

    public QName getTagQName() {
        return DBREPORT_Q;
    }
}
"
org/apache/synapse/config/xml/XMLConfigConstants.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.SynapseConstants;
import javax.xml.namespace.QName;

/**
 * Constants used in the processing of XML configuration language
 */
public class XMLConfigConstants {

    // re-definition of the Synapse NS here to make things easier for the XML config lang code
    public static final String SYNAPSE_NAMESPACE = SynapseConstants.SYNAPSE_NAMESPACE;

    //- Mediators -
    //-- PropertyMediator --
    /** The scope name for synapse message context properties */
    public static final String SCOPE_DEFAULT = ""default"";
    /** The scope name for axis2 message context properties */
    public static final String SCOPE_AXIS2 = ""axis2"";
    /** The scope name for axis2 message context client options properties */
    public static final String SCOPE_CLIENT = ""axis2-client"";
    /** The scope name for transport header properties */
    public static final String SCOPE_TRANSPORT = ""transport"";

    //-- WS-RM sequence mediator --
    /** WS-RM version 1.0*/
    public static final String SEQUENCE_VERSION_1_0 = ""1.0"";
    /** WS-RM version 1.1*/
    public static final String SEQUENCE_VERSION_1_1 = ""1.1"";

    //- configuration language constants -
    public static final QName DEFINITIONS_ELT = new QName(SYNAPSE_NAMESPACE, ""definitions"");
    public static final QName SEQUENCE_ELT    = new QName(SYNAPSE_NAMESPACE, ""sequence"");
    public static final QName ENDPOINT_ELT    = new QName(SYNAPSE_NAMESPACE, ""endpoint"");
    public static final QName ENTRY_ELT       = new QName(SYNAPSE_NAMESPACE, ""localEntry"");
    public static final QName REGISTRY_ELT    = new QName(SYNAPSE_NAMESPACE, ""registry"");
    public static final QName TASK_ELT        = new QName(SYNAPSE_NAMESPACE, ""task"");
    public static final QName PROXY_ELT       = new QName(SYNAPSE_NAMESPACE, ""proxy"");
    public static final String NULL_NAMESPACE = """";
    public static final Object QUARTZ_QNAME   =
        new QName(""http://www.opensymphony.com/quartz/JobSchedulingData"", ""quartz"");

	/** The Trace attribute name, for proxy services, sequences */
	public static final String TRACE_ATTRIB_NAME = ""trace"";
	/** The Trace value 'enable' */
	public static final String TRACE_ENABLE = ""enable"";
	/** The Trace value 'disable' */
	public static final String TRACE_DISABLE = ""disable"";

	/** The statistics attribute name */
	public static final String STATISTICS_ATTRIB_NAME = ""statistics"";
	/** The statistics value 'enable' */
	public static final String STATISTICS_ENABLE = ""enable"";
	/** The statistics value 'disable' */
	public static final String STATISTICS_DISABLE = ""disable"";

	public static final String SUSPEND_DURATION_ON_FAILURE = ""suspendDurationOnFailure"";
	public static final String ALGORITHM_NAME = ""policy"";

    public static final String ONREJECT = ""onReject"";
	public static final String ONACCEPT = ""onAccept"";

    public static final QName ATT_XPATH_RELATIVE = new QName(""relative"");
    public static final String XPATH_BODY_RELATIVE = ""body"";
    public static final String XPATH_ENVELOPE_RELATIVE = ""envelope"";
}
"
org/apache/synapse/config/xml/InMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

/**
 * Factory for {@link InMediator} instances.
 *
 * @see InMediatorFactory
 */
public class InMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof InMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        InMediator mediator = (InMediator) m;
        OMElement in = fac.createOMElement(""in"", synNS);
        saveTracingState(in,mediator);

        serializeChildren(in, mediator.getList());

        if (parent != null) {
            parent.addChild(in);
        }
        return in;
    }

    public String getMediatorClassName() {
        return InMediator.class.getName();
    }
}
"
org/apache/synapse/util/xpath/SynapseXPathVariableContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.xpath;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.jaxen.UnresolvableException;
import org.jaxen.VariableContext;

import java.util.Map;

/**
 * Jaxen variable context for the XPath variables implicitly exposed by Synapse.
 * It exposes the following variables:
 * <dl>
 *   <dt><tt>body</tt></dt>
 *   <dd>The SOAP 1.1 or 1.2 body element.</dd>
 *   <dt><tt>header</tt></dt>
 *   <dd>The SOAP 1.1 or 1.2 header element.</dd>
 * </dl>
 */
public class SynapseXPathVariableContext implements VariableContext {
    /** Parent variable context */
    private final VariableContext parent;

    /** MessageContext to be used for the variable resolution */
    private final MessageContext synCtx;

    /** SOAPEnvelope to be used for the variable resolution */
    private final SOAPEnvelope env;

    /**
     * <p>Initializes the <code>SynapseVariableContext</code> with the specified context</p>
     *
     * @param parent the parent variable context
     * @param synCtx context to be initialized for the variable resolution
     */
    public SynapseXPathVariableContext(VariableContext parent, MessageContext synCtx) {
        this.parent = parent;
        this.synCtx = synCtx;
        this.env = synCtx.getEnvelope();
    }

    /**
     * <p>Initializes the <code>SynapseVariableContext</code> with the specified envelope</p>
     *
     * @param parent the parent variable context
     * @param env envelope to be initialized for the variable resolution
     */
    public SynapseXPathVariableContext(VariableContext parent, SOAPEnvelope env) {
        this.parent = parent;
        this.synCtx = null;
        this.env = env;
    }

    /**
     * Gets the variable values resolved from the context. This includes the
     * <dl>
     *   <dt><tt>body</tt></dt>
     *   <dd>The SOAP 1.1 or 1.2 body element.</dd>
     *   <dt><tt>header</tt></dt>
     *   <dd>The SOAP 1.1 or 1.2 header element.</dd>
     * </dl>
     * and the following variable prefixes
     * <dl>
     *   <dt><tt>ctx</tt></dt>
     *   <dd>Prefix for Synapse MessageContext properties</dd>
     *   <dt><tt>axis2</tt></dt>
     *   <dd>Prefix for Axis2 MessageContext properties</dd>
     *   <dt><tt>trp</tt></dt>
     *   <dd>Prefix for the transport headers</dd>
     * </dl>
     * If the variable is unknown, this method attempts to resolve it using
     * the parent variable context.
     * 
     * @param namespaceURI namespaces for the variable resolution
     * @param prefix string prefix for the variable resolution
     * @param localName string local name for the variable resolution
     * @return Resolved variable value
     * @throws UnresolvableException if the variable specified does not found
     */
    public Object getVariableValue(String namespaceURI, String prefix, String localName)
        throws UnresolvableException {

        if (namespaceURI == null) {
            
            if (env != null) {
                
                if (SynapseXPathConstants.SOAP_BODY_VARIABLE.equals(localName)) {
                    return env.getBody();
                } else if (SynapseXPathConstants.SOAP_HEADER_VARIABLE.equals(localName)) {
                    return env.getHeader();
                }
            }

            if (prefix != null && !"""".equals(prefix) && synCtx != null) {

                if (SynapseXPathConstants.MESSAGE_CONTEXT_VARIABLE_PREFIX.equals(prefix)) {

                    return synCtx.getProperty(localName);

                } else if (SynapseXPathConstants.AXIS2_CONTEXT_VARIABLE_PREFIX.equals(prefix)) {

                    return ((Axis2MessageContext)
                        synCtx).getAxis2MessageContext().getProperty(localName);

                } else if (SynapseXPathConstants.TRANSPORT_VARIABLE_PREFIX.equals(prefix)) {

                    org.apache.axis2.context.MessageContext axis2MessageContext =
                        ((Axis2MessageContext) synCtx).getAxis2MessageContext();
                    Object headers = axis2MessageContext.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

                    if (headers != null && headers instanceof Map) {
                        Map headersMap = (Map) headers;
                        return headersMap.get(localName);
                    }
                }
            }
        }

        return parent.getVariableValue(namespaceURI, prefix, localName);
    }
}
"
org/apache/synapse/config/xml/IterateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.IterateMediator;

/**
 * This class will be acting as the serializer for the IterateMediator which will convert the
 * IterateMediator instance to the following xml configuration
 *
 * <pre>
 * &lt;iterate [continueParent=(true | false)] [preservePayload=(true | false)]
 *          (attachPath=""xpath"")? expression=""xpath""&gt;
 *   &lt;target [to=""uri""] [soapAction=""qname""] [sequence=""sequence_ref""]
 *          [endpoint=""endpoint_ref""]&gt;
 *     &lt;sequence&gt;
 *       (mediator)+
 *     &lt;/sequence&gt;?
 *     &lt;endpoint&gt;
 *       endpoint
 *     &lt;/endpoint&gt;?
 *   &lt;/target&gt;+
 * &lt;/iterate&gt;
 * </pre>
 */
public class IterateMediatorSerializer extends AbstractMediatorSerializer {

    /**
     * This method will implement the serialization logic of the IterateMediator class to the
     * relevant xml configuration
     *
     * @param parent
     *              OMElement specifying the parent element to which the created configurtaion
     *              element will be attached
     *
     * @param m
     *          IterateMediator to be serialized
     *
     * @return OMElement describing the serialized configuration of the IterateMediator
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof IterateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        
        OMElement itrElem = fac.createOMElement(""iterate"", synNS);
        saveTracingState(itrElem, m);

        IterateMediator itrMed = (IterateMediator) m;
        if (itrMed.isContinueParent()) {
            itrElem.addAttribute(""continueParent"", Boolean.toString(true), nullNS);
        }

        if (itrMed.isPreservePayload()) {
            itrElem.addAttribute(""preservePayload"", Boolean.toString(true), nullNS);
        }

        if (itrMed.getAttachPath() != null && !""."".equals(itrMed.getAttachPath().toString())) {
            SynapseXPathSerializer.serializeXPath(itrMed.getAttachPath(), itrElem, ""attachPath"");
        }
        
        if (itrMed.getExpression() != null) {
            SynapseXPathSerializer.serializeXPath(itrMed.getExpression(), itrElem, ""expression"");
        } else {
            handleException(""Missing expression of the IterateMediator which is required."");
        }

        itrElem.addChild(TargetSerializer.serializeTarget(itrMed.getTarget()));

        // attach the serialized element to the parent if specified
        if (parent != null) {
            parent.addChild(itrElem);
        }

        return itrElem;
    }

    /**
     * This method implements the getMediatorClassName of the interface MediatorSerializer and
     * will be used in getting the mediator class name which will be serialized by this serializer
     *
     * @return String representing the full class name of the mediator
     */
    public String getMediatorClassName() {
        return IterateMediator.class.getName();
    }
}
"
org/apache/synapse/registry/AbstractRegistry.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.registry;

import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * Implements the core Registry lookup algorithm
 */
public abstract class AbstractRegistry implements Registry {

    private static final Log log = LogFactory.getLog(AbstractRegistry.class);

    /** The list of configuration properties */
    protected Properties properties = new Properties();

    /**
     * Get the resource for the given key from this registry
     * @param entry
     * @return the matching resultant object
     */
    public Object getResource(Entry entry) {

        OMNode omNode = null;
        RegistryEntry re = null;

        // we are dealing with a dynamic resource. Have we seen this before and processed
        // it at least once and have it cached already?

        // if we have an unexpired cached copy, return the cached object
        if (entry.isCached() && !entry.isExpired()) {
            return entry.getValue();

        // if we have not cached the referenced object, fetch it and its RegistryEntry
        } else if (!entry.isCached()) {
            omNode = lookup(entry.getKey());
            if (omNode == null) {
                return null;
            } else {
                re = getRegistryEntry(entry.getKey());
            }

        // if we have cached it before, and now the cache has expired
        // get its *new* registry entry and compare versions and pick new cache duration
        } else if (entry.isExpired()) {
            if (log.isDebugEnabled()) {
                log.debug(""Cached object has expired for key : "" + entry.getKey());
            }
            re = getRegistryEntry(entry.getKey());

            if (re.getVersion() != Long.MIN_VALUE &&
                re.getVersion() == entry.getVersion()) {
                if (log.isDebugEnabled()) {
                    log.debug(""Expired version number is same as current version in registry"");
                }

                // renew cache lease for another cachable duration (as returned by the
                // new getRegistryEntry() call
                if (re.getCachableDuration() > 0) {
                    entry.setExpiryTime(
                            System.currentTimeMillis() + re.getCachableDuration());
                } else {
                    entry.setExpiryTime(-1);
                }
                if (log.isDebugEnabled()) {
                    log.debug(""Renew cache lease for another "" + re.getCachableDuration() / 1000 + ""s"");
                }

                // return cached object
                return entry.getValue();

            } else {
                omNode = lookup(entry.getKey());
            }
        }

        // if we get here, we have received the raw omNode from the
        // registry and our previous copy (if we had one) has expired or is not valid

        // if we have a XMLToObjectMapper for this entry, use it to convert this
        // resource into the appropriate object - e.g. sequence or endpoint
        if (entry.getMapper() != null) {
            entry.setValue(entry.getMapper().getObjectFromOMNode(omNode));

            if (entry.getValue() instanceof SequenceMediator) {
                SequenceMediator seq = (SequenceMediator) entry.getValue();
                seq.setDynamic(true);
                seq.setRegistryKey(entry.getKey());
            } else if (entry.getValue() instanceof Endpoint) {
                Endpoint ep = (Endpoint) entry.getValue();
            }

        } else {
            // if the type of the object is known to have a mapper, create the
            // resultant Object using the known mapper, and cache this Object
            // else cache the raw OMNode
            if (re != null && re.getType() != null) {

                XMLToObjectMapper mapper = getMapper(re.getType());
                if (mapper != null) {
                    entry.setMapper(mapper);
                    entry.setValue(mapper.getObjectFromOMNode(omNode));

                } else {
                    entry.setValue(omNode);
                }
            }
        }

        // increment cache expiry time as specified by the last getRegistryEntry() call
        if (re != null) {
            if (re.getCachableDuration() > 0) {
                entry.setExpiryTime(System.currentTimeMillis() + re.getCachableDuration());
            } else {
                entry.setExpiryTime(-1);
            }
            entry.setVersion(re.getVersion());
        }

        return entry.getValue();
    }

    private XMLToObjectMapper getMapper(URI type) {
        return null;
    }

    public String getProviderClass() {
        return this.getClass().getName();
    }

    public Properties getConfigurationProperties() {
        return properties;
    }

    public void init(Properties properties) {
        this.properties =properties;
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.PropertyMediator;

/**
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"")/&gt;
 * </pre>
 */
public class PropertyMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof PropertyMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        PropertyMediator mediator = (PropertyMediator) m;
        OMElement property = fac.createOMElement(""property"", synNS);
        saveTracingState(property, mediator);

        if (mediator.getName() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
        } else {
            handleException(""Invalid property mediator. Name is required"");
        }

        if (mediator.getValue() != null) {
            property.addAttribute(fac.createOMAttribute(
                    ""value"", nullNS, mediator.getValue()));

        } else if (mediator.getExpression() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getExpression(), property, ""expression"");

        } else if (mediator.getAction() == PropertyMediator.ACTION_SET) {
            handleException(""Invalid property mediator. Value or expression is required if action is SET"");
        }
        if (mediator.getScope() != null) {
            // if we have already built a mediator with scope, scope should be valid, now save it
            property.addAttribute(fac.createOMAttribute(""scope"", nullNS, mediator.getScope()));
        }
        if (mediator.getAction() == PropertyMediator.ACTION_REMOVE) {
            property.addAttribute(fac.createOMAttribute(
                    ""action"", nullNS, ""remove""));
        }
        if (parent != null) {
            parent.addChild(property);
        }
        return property;
    }

    public String getMediatorClassName() {
        return PropertyMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/XSLTMediatorSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.apache.synapse.mediators.MediatorProperty;
import org.apache.synapse.config.xml.AbstractMediatorSerializer;

import java.util.List;

/**
 * Serializer for {@link XSLTMediator} instances.
 * 
 * @see XSLTMediatorFactory
 */
public class XSLTMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof XSLTMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        XSLTMediator mediator = (XSLTMediator) m;
        OMElement xslt = fac.createOMElement(""xslt"", synNS);

        if (mediator.getXsltKey() != null) {
            xslt.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, mediator.getXsltKey()));
        } else {
            handleException(""Invalid XSLT mediator. XSLT registry key is required"");
        }
        saveTracingState(xslt,mediator);

        if (mediator.getSource() != null &&
            !XSLTMediator.DEFAULT_XPATH.equals(mediator.getSource().toString())) {

            SynapseXPathSerializer.serializeXPath(mediator.getSource(), xslt, ""source"");
        }
        if (mediator.getTargetPropertyName() != null) {
            xslt.addAttribute(fac.createOMAttribute(
                ""target"", nullNS, mediator.getTargetPropertyName()));
        }
        serializeProperties(xslt, mediator.getProperties());
        List<MediatorProperty> features = mediator.getFeatures();
        if (!features.isEmpty()) {
            for (MediatorProperty mp : features) {
                OMElement prop = fac.createOMElement(""feature"", synNS, xslt);
                if (mp.getName() != null) {
                    prop.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
                } else {
                    handleException(""The Feature name is missing"");
                }
                if (mp.getValue() != null) {
                    prop.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));
                }  else {
                    handleException(""The Feature value is missing"");
                }
            }
        }
        if (parent != null) {
            parent.addChild(xslt);
        }
        return xslt;
    }

    public String getMediatorClassName() {
        return XSLTMediator.class.getName();
    }
}
"
org/apache/synapse/metrics/GlobalRequestCountHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.handlers.AbstractHandler;

/*
 * This information is published using WS-Management.
 * Access from any location with XXContext.getParameter(Constants.GLOBAL_REQUEST_COUNTER);
 */

public class GlobalRequestCountHandler extends AbstractHandler {

    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {
        msgContext
                .setProperty(MetricsConstants.REQUEST_RECEIVED_TIME, new Long(System.currentTimeMillis()));
        // global increment
        ((Counter) msgContext.getParameter(MetricsConstants.GLOBAL_REQUEST_COUNTER).getValue())
                .increment();
        return InvocationResponse.CONTINUE;
    }
}
"
org/apache/synapse/mediators/builtin/PropertyMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.xpath.SynapseXPath;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * The property mediator would save(or remove) a named property as a local property of
 * the Synapse Message Context or as a property of the Axis2 Message Context or
 * as a Transport Header.
 * Properties set this way could be extracted through the XPath extension function
 * ""synapse:get-property(scope,prop-name)""
 */

public class PropertyMediator extends AbstractMediator {

    /** The Name of the property  */
    private String name = null;
    /** The Value to be set*/
    private String value = null;
    /** The XPath expr. to get value  */
    private SynapseXPath expression = null;
    /** The scope for which decide properties where to go*/
    private String scope = null;
    /** The Action - set or remove */
    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;
    /** Set the property (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;

    /**
     * Sets a property into the current (local) Synapse Context or into the Axis Message Context
     * or into Transports Header and removes above properties from the corresponding locations.
     *
     * @param synCtx the message context
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Property mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (action == ACTION_SET) {

            String resultValue = (value != null ? value : expression.stringValueOf(synCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting property : "" + name + "" at scope : "" +
                    (scope == null ? ""default"" : scope) + "" to : "" + resultValue + "" (i.e. "" +
                    (value != null ? ""constant : "" + value :
                          ""result of expression : "" + expression) + "")"");
            }

            if (scope == null || XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {
                //Setting property into the  Synapse Context
                synCtx.setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_AXIS2.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting property into the  Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_CLIENT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting property into the  Axis2 Message Context client options
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.getOptions().setProperty(name, resultValue);

            } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                //Setting Transport Headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);

                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.put(name, resultValue);
                }
                if (headers == null) {
                    Map headersMap = new HashMap();
                    headersMap.put(name, resultValue);
                    axis2MessageCtx.setProperty(
                            org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
                            headersMap);
                }
            }

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Removing property : "" + name +
                    "" (scope:"" + (scope == null ? ""default"" : scope) + "")"");
            }

            if (scope == null || XMLConfigConstants.SCOPE_DEFAULT.equals(scope)) {
                //Removing property from the  Synapse Context
                Set pros = synCtx.getPropertyKeySet();
                if (pros != null) {
                    pros.remove(name);
                }

            } else if ((XMLConfigConstants.SCOPE_AXIS2.equals(scope) ||
                XMLConfigConstants.SCOPE_CLIENT.equals(scope))
                && synCtx instanceof Axis2MessageContext) {
                
                //Removing property from the Axis2 Message Context
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                axis2MessageCtx.removeProperty(name);

            } else if (XMLConfigConstants.SCOPE_TRANSPORT.equals(scope)
                    && synCtx instanceof Axis2MessageContext) {
                // Removing transport headers
                Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                org.apache.axis2.context.MessageContext axis2MessageCtx =
                        axis2smc.getAxis2MessageContext();
                Object headers = axis2MessageCtx.getProperty(
                        org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
                if (headers != null && headers instanceof Map) {
                    Map headersMap = (HashMap) headers;
                    headersMap.remove(name);
                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""No transport headers found for the message"");
                    }
                }
            }
        }
        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Property mediator"");
        }
        return true;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public SynapseXPath getExpression() {
        return expression;
    }

    public void setExpression(SynapseXPath expression) {
        this.expression = expression;
    }

    public String getScope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.synapse.SynapseConstants;

import java.util.List;

/**
 * Serializes {@link FailoverEndpoint} to XML configuration.
 *
 * &lt;endpoint [name=""name""]&gt;
 *    &lt;failover&gt;
 *       &lt;endpoint&gt;+
 *    &lt;/failover&gt;
 * &lt;/endpoint&gt;
 */
public class FailoverEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof FailoverEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        FailoverEndpoint failoverEndpoint = (FailoverEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        OMElement failoverElement = fac.createOMElement(""failover"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(failoverElement);

        String name = failoverEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        for (Endpoint childEndpoint : failoverEndpoint.getEndpoints()) {
            failoverElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
        }

        return endpointElement;
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.description.WSDL2Constants;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.ServerManager;
import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.xml.endpoints.utils.WSDL11EndpointBuilder;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

import javax.xml.namespace.QName;
import java.io.File;
import java.net.URL;

/**
 * Creates an {@link WSDLEndpoint} based endpoint from a XML configuration.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;endpoint [name=""<em>name</em>""]&gt;
 *   &lt;wsdl [uri=""<em>WSDL location</em>""]
 *         service=""<em>qualified name</em>"" port=""<em>qualified name</em>""
 *         [format=""soap11|soap12|pox|get""] [optimize=""mtom|swa""]
 *         [encoding=""<em>charset encoding</em>""]
 *         [statistics=""enable|disable""] [trace=""enable|disable""]&gt;
 *     &lt;wsdl:definition&gt;...&lt;/wsdl:definition&gt;?
 *     &lt;wsdl20:description&gt;...&lt;/wsdl20:description&gt;?
 *     
 *     &lt;enableRM [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableSec [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableAddressing [version=""final|submission""] [separateListener=""true|false""]/&gt;?
 *     
 *     &lt;timeout&gt;
 *       &lt;duration&gt;<em>timeout duration in seconds</em>&lt;/duration&gt;
 *       &lt;action&gt;discard|fault&lt;/action&gt;
 *     &lt;/timeout&gt;?
 *     
 *     &lt;suspendDurationOnFailure&gt;
 *       <em>suspend duration in seconds</em>
 *     &lt;/suspendDurationOnFailure&gt;?
 *   &lt;/wsdl&gt;
 * &lt;/endpoint&gt;
 * </pre>
 */
public class WSDLEndpointFactory extends EndpointFactory {

    private static WSDLEndpointFactory instance = new WSDLEndpointFactory();

    private WSDLEndpointFactory() {
    }

    public static WSDLEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        WSDLEndpoint wsdlEndpoint = new WSDLEndpoint();
        OMAttribute name = epConfig.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            wsdlEndpoint.setName(name.getAttributeValue());
        }

        OMElement wsdlElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""wsdl""));
        if (wsdlElement != null) {

            EndpointDefinition endpoint = null;

            // get the service name and port name. at this point we should not worry about
            // the presence of those parameters. they are handled by corresponding WSDL builders.
            String serviceName = wsdlElement.getAttributeValue(new QName(""service""));
            String portName = wsdlElement.getAttributeValue(new QName(""port""));
            // check if wsdl is supplied as a URI
            String wsdlURI = wsdlElement.getAttributeValue(new QName(""uri""));

            // set serviceName and portName in the endpoint. it does not matter if these are
            // null at this point. we are setting them only for serialization purpose.
            wsdlEndpoint.setServiceName(serviceName);
            wsdlEndpoint.setPortName(portName);

            if (wsdlURI != null) {

                wsdlEndpoint.setWsdlURI(wsdlURI.trim());
                try {
                    OMNode wsdlOM = SynapseConfigUtils.getOMElementFromURL(
                            new URL(wsdlURI).toString());
                    if (wsdlOM != null && wsdlOM instanceof OMElement) {
                        OMElement omElement = (OMElement) wsdlOM;
                        OMNamespace ns = omElement.getNamespace();
                        if (ns != null) {
                            String nsUri = omElement.getNamespace().getNamespaceURI();
                            if (org.apache.axis2.namespace.Constants.NS_URI_WSDL11.equals(nsUri)) {

                                endpoint = new WSDL11EndpointBuilder().
                                        createEndpointDefinitionFromWSDL(
                                                wsdlURI.trim(), omElement, serviceName, portName);

                            } else if (WSDL2Constants.WSDL_NAMESPACE.equals(nsUri)) {
                                //endpoint = new WSDL20EndpointBuilder().
                                // createEndpointDefinitionFromWSDL(wsdlURI, serviceName, portName);

                                handleException(""WSDL 2.0 Endpoints are currently not supported"");
                            }
                        }
                    }
                } catch (Exception e) {
                    handleException(""Couldn't create endpoint from the given WSDL URI : ""
                            + e.getMessage(), e);
                }
            }

            // check if the wsdl 1.1 document is suppled inline
            OMElement definitionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""definitions""));
            if (endpoint == null && definitionElement != null) {
                wsdlEndpoint.setWsdlDoc(definitionElement);
                String resolveRoot = ServerManager.getInstance().getResolveRoot();
                String baseUri = ""file:./"";
                if (resolveRoot != null) {
                    baseUri = resolveRoot.trim();
                }
                if (!baseUri.endsWith(File.separator)) {
                    baseUri = baseUri + File.separator;
                }
                endpoint = new WSDL11EndpointBuilder().createEndpointDefinitionFromWSDL(
                        baseUri, definitionElement, serviceName, portName);
            }

            // check if a wsdl 2.0 document is supplied inline
            OMElement descriptionElement = wsdlElement.getFirstChildWithName
                    (new QName(org.apache.axis2.namespace.Constants.NS_URI_WSDL11, ""description""));
            if (endpoint == null && descriptionElement != null) {
                wsdlEndpoint.setWsdlDoc(descriptionElement);
                handleException(""WSDL 2.0 Endpoints are currently not supported."");
            }

            if (endpoint != null) {
                // for now, QOS information has to be provided explicitly.
                extractCommonEndpointProperties(endpoint, wsdlElement);
                extractSpecificEndpointProperties(endpoint, wsdlElement);
                wsdlEndpoint.setEndpoint(endpoint);
            } else {
                handleException(""WSDL is not specified for WSDL endpoint."");
            }
        }

        return wsdlEndpoint;
    }

    protected void extractSpecificEndpointProperties(EndpointDefinition definition, OMElement elem) {

    }

}
"
org/apache/synapse/config/xml/PropertyHelper.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import javax.xml.namespace.QName;
import java.lang.reflect.Method;

/**
 * This class will be used as a Helper class to get the properties loaded while building the
 * Synapse Configuration from the XML
 */
public class PropertyHelper {

    /**
     * Log variable for the logging purposes
     */
    private static final Log log = LogFactory.getLog(PropertyHelper.class);

    /**
     * Find and invoke the setter method with the name of form setXXX passing in the value given
     * on the POJO object
     * @param name name of the setter field
     * @param val value to be set
     * @param obj POJO instance
     */
    public static void setInstanceProperty(String name, Object val, Object obj) {

        String mName = ""set"" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
        Method method = null;

        try {
            Method[] methods = obj.getClass().getMethods();
            boolean invoked = false;

            for (int i=0; i<methods.length; i++) {
                if (mName.equals(methods[i].getName())) {
                    Class[] params = methods[i].getParameterTypes();
                    if (params.length != 1) {
                        handleException(""Did not find a setter method named : "" + mName +
                            ""() that takes a single String, int, long, float, double "" +
                            ""or boolean parameter"");
                    } else if (val instanceof String) {
                        String value = (String) val;
                        if (params[0].equals(String.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{String.class});
                            method.invoke(obj, new String[]{value});
                        } else if (params[0].equals(int.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{int.class});
                            method.invoke(obj, new Integer[]{new Integer(value)});
                        } else if (params[0].equals(long.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{long.class});
                            method.invoke(obj, new Long[]{new Long(value)});
                        } else if (params[0].equals(float.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{float.class});
                            method.invoke(obj, new Float[]{new Float(value)});
                        } else if (params[0].equals(double.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{double.class});
                            method.invoke(obj, new Double[]{new Double(value)});
                        } else if (params[0].equals(boolean.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{boolean.class});
                            method.invoke(obj, new Boolean[]{new Boolean(value)});
                        } else {
                            handleException(""Did not find a setter method named : "" + mName +
                                ""() that takes a single String, int, long, float, double "" +
                                ""or boolean parameter"");
                        }
                    } else {
                        if (params[0].equals(OMElement.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{OMElement.class});
                            method.invoke(obj, new OMElement[]{(OMElement) val});
                        }
                    }
                    invoked = true;
                }
            }

            if (!invoked) {
                handleException(""Did not find a setter method named : "" + mName +
                    ""() that takes a single String, int, long, float, double "" +
                    ""or boolean parameter"");
            }

        } catch (Exception e) {
            handleException(""Error invoking setter method named : "" + mName +
                ""() that takes a single String, int, long, float, double "" +
                ""or boolean parameter"", e);
        }
    }

    /**
     * This method will set the static property discribed in the OMElement to the specified object.
     * This Object should have the setter method for the specified property name
     * 
     * @param property - OMElement specifying the property to be built in to the object
     * @param o - Object to which the specified property will be set.
     */
    public static void setStaticProperty(OMElement property, Object o) {

        if (property.getLocalName().toLowerCase().equals(""property"")) {

            String propertyName = property.getAttributeValue(new QName(""name""));
            String mName = ""set""
                    + Character.toUpperCase(propertyName.charAt(0))
                    + propertyName.substring(1);

            // try to set String value first
            if (property.getAttributeValue(new QName(""value"")) != null) {
                String value = property.getAttributeValue(new QName(""value""));

                try {
                    Method method = o.getClass().getMethod(mName, new Class[]{String.class});
                    if (log.isDebugEnabled()) {
                        log.debug(""Setting property :: invoking method ""
                                + mName + ""("" + value + "")"");
                    }
                    method.invoke(o, new Object[]{value});

                } catch (Exception e) {
                    handleException(""Error setting property : "" + propertyName
                            + "" as a String property into class mediator : "" + o.getClass() + "" : ""
                            + e.getMessage(), e);
                }
                
            } else {
                // now try XML child
                OMElement value = property.getFirstElement();
                if (value != null) {

                    try {
                        Method method = o.getClass().getMethod(mName, new Class[]{OMElement.class});
                        if (log.isDebugEnabled()) {
                            log.debug(""Setting property :: invoking method ""
                                    + mName + ""("" + value + "")"");
                        }
                        method.invoke(o, new Object[]{value});

                    } catch (Exception e) {
                        handleException(""Error setting property : "" + propertyName
                                + "" as an OMElement property into class mediator : ""
                                + o.getClass() + "" : "" + e.getMessage(), e);
                    }

                }

            }
        }
    }

    /**
     * This method will check the given OMElement represent either a static property or not
     * 
     * @param property - OMElement to be checked for the static property
     * @return boolean true if the elemet represents a static property element false otherwise
     */
    public static boolean isStaticProperty(OMElement property) {
        return ""property"".equals(property.getLocalName().toLowerCase())
            && (property.getAttributeValue(new QName(""expression"")) == null);
    }

    private static void handleException(String message, Throwable e) {
        log.error(message + e.getMessage());
        throw new SynapseException(message, e);
    }

    private static void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }    
}
"
org/apache/synapse/mediators/ext/POJOCommandMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.ext;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.synapse.Command;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.eip.EIPUtils;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This mediator will use the specified command object and execute the command after setting
 * the properties specified to it through the configuraiton. The specified command object may or
 * may not implement the Command interface. If the Command object has not implemented the Command
 * interface then this will use reflection to find a method called execute() and execute it.
 *
 * @see org.apache.synapse.Command interface
 */
public class POJOCommandMediator extends AbstractMediator {

    /**
     * This will hold the command object to be executed
     */
    private Class command = null;

    /**
     * 'static' properties whose values are constant and does not depend
     * on the current message (i.e. and XPath over it)
     */
    private Map<String, Object> staticSetterProperties = new HashMap<String, Object>();

    /**
     * 'dynamic' properties whose values are dynamically evaluated before each
     * invocation of the command, by evaluating an XPath against the current message
     */
    private Map<String, SynapseXPath> messageSetterProperties = new HashMap<String, SynapseXPath>();

    /**
     * 'dynamic' properties whose values are dynamically evaluated before each
     * invocation of the command, by getting a property from the message context
     */
    private Map<String, String> contextSetterProperties = new HashMap<String, String>();

    /**
     * 'context' properties whose values are set back to the message context as message
     * context properties
     */
    private Map<String, String> contextGetterProperties = new HashMap<String, String>();

    /**
     * 'messsage' properties whose values are set back to the current message, from the command
     * and as specified by the XPATH
     */
    private Map<String, SynapseXPath> messageGetterProperties = new HashMap<String, SynapseXPath>();

    /**
     * Implements the mediate method of the Mediator interface. This method will instantiate
     * a new instance of the POJO class, set all specified properties from the current runtime
     * state (and message context) and call the execute method of the Command object.
     *
     * @param synCtx - Synapse MessageContext to be mediated
     * @return boolean true since this will not stop exection chain
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : POJOCommand mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Creating a new instance of POJO class : "" + command.getClass());
        }

        Object commandObject = null;
        try {
            // instantiate a new command object each time
            commandObject = command.newInstance();
        } catch (Exception e) {
            handleException(""Error creating an instance of the POJO command class : "" +
                command.getClass(), e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Instance created, setting static and dynamic properties"");
        }

        // then set the static/constant properties first
        for (String name : staticSetterProperties.keySet()) {
            setInstanceProperty(name, staticSetterProperties.get(name), commandObject, synCtx);
        }

        // now set the any dynamic properties from the message context properties
        for (String name : contextSetterProperties.keySet()) {
            setInstanceProperty(name, synCtx.getProperty(contextSetterProperties.get(name)),
                commandObject, synCtx);
        }

        // now set the any dynamic properties evaluating XPath's on the current message
        for (String name : messageSetterProperties.keySet()) {
            SynapseXPath xpath = messageSetterProperties.get(name);
            String value = xpath.stringValueOf(synCtx);

            setInstanceProperty(name, value, commandObject, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""POJO initialized successfully, invoking the execute() method"");
        }

        // then call the execute method if the Command interface is implemented
        if (commandObject instanceof Command) {
            try {
                ((Command) commandObject).execute();
            } catch (Exception e) {
                handleException(""Error invoking POJO command class : ""
                    + command.getClass(), e, synCtx);
            }

        } else {

            Method exeMethod = null;
            try {
                exeMethod = command.getMethod(""execute"", new Class[]{});
                exeMethod.invoke(commandObject, new Object[]{});
            } catch (NoSuchMethodException e) {
                handleException(""Cannot locate an execute() method on POJO class : "" +
                    command.getClass(), e, synCtx);
            } catch (Exception e) {
                handleException(""Error invoking the execute() method on POJO class : "" +
                    command.getClass(), e, synCtx);
            }
        }

        // then set the context properties back to the messageContext from the command
        for (String name : contextGetterProperties.keySet()) {
            synCtx.setProperty(contextGetterProperties.get(name),
                getInstanceProperty(name, commandObject, synCtx));
        }

        // now set the any message properties evaluating XPath's on the current message back
        // to the message from the command
        for (String name : messageGetterProperties.keySet()) {
            SynapseXPath xpath = messageGetterProperties.get(name);

            Object resultValue = getInstanceProperty(name, commandObject, synCtx);

            try {
                List list = EIPUtils.getMatchingElements(synCtx.getEnvelope(), xpath);
                if (list.size() > 0) {
                    Object o = list.get(0);
                    if (resultValue instanceof String) {
                        OMAbstractFactory.getOMFactory().createOMText(
                            ((OMNode) o).getParent(), (String) resultValue);
                        ((OMNode) o).detach();
                    } else if (resultValue instanceof OMNode) {
                        ((OMNode) o).insertSiblingAfter((OMNode) resultValue);
                        ((OMNode) o).detach();
                    }

                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Unable to set the message property "" + resultValue
                            + ""back to the message : Specified element by the xpath ""
                            + xpath + "" can not be found"");
                    }
                }
            } catch (JaxenException e) {
                handleException(""Unable to set the command property ""
                    + name + "" back to the message"", e, synCtx);
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : POJOCommand mediator"");
        }
        return true;
    }

    /**
     * Find and invoke the getter method with the name of form getXXX and returns the value given
     * on the POJO object
     *
     * @param name name of the getter field
     * @param obj POJO instance
     * @param synCtx current message
     * @return object representing the value of the getter method
     */
    private Object getInstanceProperty(String name, Object obj, MessageContext synCtx) {

        String mName = ""get"" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
        try {
            Method[] methods = obj.getClass().getMethods();

            for (Method method : methods) {
                if (mName.equals(method.getName())) {
                    return method.invoke(obj);
                }
            }
        } catch(InvocationTargetException e) {
            handleException(""Unable to get the command property '""
                + name + ""' back to the message"", e, synCtx);
        } catch(IllegalAccessException e){
            handleException(""Unable to get the command property '""
                + name + ""' back to the message"", e, synCtx);
        }

        return null;
    }

    /**
     * Find and invoke the setter method with the name of form setXXX passing in the value given
     * on the POJO object
     *
     * @param name name of the setter field
     * @param value value to be set
     * @param obj POJO instance
     * @param synCtx current message
     */
    protected void setInstanceProperty(
        String name, Object value, Object obj, MessageContext synCtx) {

        String mName = ""set"" + Character.toUpperCase(name.charAt(0)) + name.substring(1);
        Method method = null;

        try {
            Method[] methods = obj.getClass().getMethods();
            boolean invoked = false;

            for (int i=0; i<methods.length; i++) {
                if (mName.equals(methods[i].getName())) {
                    Class[] params = methods[i].getParameterTypes();
                    if (params.length != 1) {
                        handleException(""Did not find a setter method named : "" + mName +
                            ""() that takes a single String, int, long, float, double "" +
                            ""or boolean or OMElement parameter"", synCtx);
                    } else if (value instanceof String) {
                        if (params[0].equals(String.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{String.class});
                            method.invoke(obj, new String[]{(String) value});
                        } else if (params[0].equals(int.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{int.class});
                            method.invoke(obj, new Integer[]{new Integer((String) value)});
                        } else if (params[0].equals(long.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{long.class});
                            method.invoke(obj, new Long[]{new Long((String) value)});
                        } else if (params[0].equals(float.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{float.class});
                            method.invoke(obj, new Float[]{new Float((String) value)});
                        } else if (params[0].equals(double.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{double.class});
                            method.invoke(obj, new Double[]{new Double((String) value)});
                        } else if (params[0].equals(boolean.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{boolean.class});
                            method.invoke(obj, new Boolean[]{new Boolean((String) value)});
                        } else {
                            handleException(""Did not find a setter method named : "" + mName +
                                ""() that takes a single String, int, long, float, double "" +
                                ""or boolean parameter"", synCtx);
                        }
                    } else if (value instanceof OMElement) {
                        if (params[0].equals(OMElement.class)) {
                            method = obj.getClass().getMethod(mName, new Class[]{OMElement.class});
                            method.invoke(obj, new OMElement[]{(OMElement) value});                            
                        } else {
                            handleException(""Did not find a setter method named : "" + mName
                                + ""() that takes an OMElement as the parameter"", synCtx);
                        }
                    } else {
                        handleException(""Can not handle the value type : ""
                            + value.getClass(), synCtx);
                    }
                    invoked = true;
                }
            }

            if (!invoked) {
                handleException(""Did not find a setter method named : "" + mName +
                    ""() that takes a single String, int, long, float, double "" +
                    ""or boolean parameter"", synCtx);
            }

        } catch (Exception e) {
            handleException(""Error invoking setter method named : "" + mName +
                ""() that takes a single String, int, long, float, double "" +
                ""or boolean parameter"", e, synCtx);
        }
    }

    public Class getCommand() {
        return command;
    }

    public void setCommand(Class command) {
        this.command = command;
    }

    public void addStaticSetterProperty(String name, Object value) {
        this.staticSetterProperties.put(name, value);
    }

    public void addMessageSetterProperty(String name, SynapseXPath xpath) {
        this.messageSetterProperties.put(name, xpath);
    }
    
    public void addContextSetterProperty(String name, String ctxName) {
        this.contextSetterProperties.put(name, ctxName);
    }

    public void addContextGetterProperty(String name, String value) {
        this.contextGetterProperties.put(name, value);
    }

    public void addMessageGetterProperty(String name, SynapseXPath xpath) {
        this.messageGetterProperties.put(name, xpath);
    }

    public Map<String, Object> getStaticSetterProperties() {
        return this.staticSetterProperties;
    }

    public Map<String, SynapseXPath> getMessageSetterProperties() {
        return this.messageSetterProperties;
    }

    public Map<String, String> getContextSetterProperties() {
        return this.contextSetterProperties;
    }

    public Map<String, String> getContextGetterProperties() {
        return this.contextGetterProperties;
    }

    public Map<String, SynapseXPath> getMessageGetterProperties() {
        return this.messageGetterProperties;
    }
}
"
org/apache/synapse/util/AXIOMUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.impl.dom.NodeImpl;
import org.springframework.xml.transform.StaxSource;

/**
 * Utility class with AXIOM helper methods.
 */
public class AXIOMUtils {
    private AXIOMUtils() {}
    
    /**
     * Get a {@link Source} backed by a given AXIOM node.
     * 
     * @param node an AXIOM node
     * @return a {@link Source} object that can be used with XSL transformers,
     *         schema validators, etc.
     */
    public static Source asSource(OMNode node) {
        if (node instanceof NodeImpl) {
            return new DOMSource((NodeImpl)node);
        } else {
            // We use Spring's StaxSource for the transformation source. Once we depend
            // on JDK 1.6, we can replace this by StAXSource from JAXP 1.4.
            return new StaxSource(((OMElement)node).getXMLStreamReader());
        }
    }
}
"
org/apache/synapse/statistics/Statistics.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 * The statistics data structure
 */

public class Statistics {

    /**  Maximum processing time for a one way flow  */
    private long maxProcessingTime = 0;
    /** Minimum processing time for a one way flow   */
    private long minProcessingTime = -1;
    /** Average processing time for a one way flow */
    private double avgProcessingTime = 0;
    /** Total processing time for a one way flow  */
    private double totalProcessingTime;
    /** The number of access count for a one way flow  */
    private int count = 0;
    /** The number of fault count for a one way flow  */
    private int faultCount = 0;

    /**
     * Update the statistics
     *
     * @param inTime  - The processing start time
     * @param outTime - The processing end time
     * @param isFault - A boolean value that indicate whether falut has occured or not
     */
    public void update(long inTime, long outTime, boolean isFault) {

        if (outTime < 0 || inTime < 0) {
            return;
        }

        count++;
        if (isFault) {
            faultCount++;
        }

        long responseTime = outTime - inTime;
        if (maxProcessingTime < responseTime) {
            maxProcessingTime = responseTime;
        }
        if (minProcessingTime > responseTime) {
            minProcessingTime = responseTime;
        }
        if (minProcessingTime == -1) {
            minProcessingTime = responseTime;
        }
        totalProcessingTime = totalProcessingTime + responseTime;
        avgProcessingTime = totalProcessingTime / count;
    }

    /**
     * @return Returns the Maximum processing time
     */
    public long getMaxProcessingTime() {
        return maxProcessingTime;
    }

    /**
     * @return Returns the Avarage processing time
     */
    public double getAvgProcessingTime() {
        return avgProcessingTime;
    }

    /**
     * @return Returns the minimum processing time
     */
    public long getMinProcessingTime() {
        return minProcessingTime;
    }

    /**
     * @return Returns the fault count
     */
    public int getFaultCount() {
        return faultCount;
    }

    /**
     * @return Returns the total count that represents number of access in a one way flow
     */
    public int getCount() {
        return count;
    }
}
"
org/apache/synapse/endpoints/algorithms/AlgorithmContext.java,true,"/*
*  Licensed to the Apache Software Foundation (ASF) under one
*  or more contributor license agreements.  See the NOTICE file
*  distributed with this work for additional information
*  regarding copyright ownership.  The ASF licenses this file
*  to you under the Apache License, Version 2.0 (the
*  ""License""); you may not use this file except in compliance
*  with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
package org.apache.synapse.endpoints.algorithms;

import org.apache.axis2.clustering.ClusteringFault;
import org.apache.axis2.clustering.context.Replicator;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

/**
 * Keeps the states of the load balance algorithm.This hides where those states are kept.For a
 * cluster environment ,all states are kept in the axis2 configuration context in order to replicate
 * those states so that other synapse instance in the same cluster can see those changes .
 * This class can be evolved to keep any run time states related to the endpoint .
 * For a non-clustered environment , all data are kept locally.
 * <p/>
 * This class provide the abstraction need to separate the dynamic data from the static data
 * and improve the  high cohesion and provides capability to replicate only required state at
 * a given time. This improves the performance when replicate data.
 */
public class AlgorithmContext {

    private static final Log log = LogFactory.getLog(AlgorithmContext.class);

    /* The  static constant only for construct key prefix for each property in a dispatcher context
     * as it is need when those property state going to replicate in a cluster env. */
    private static final String UNDERSCORE_STRING = ""_"";
    private static final String CURRENT_EPR = ""currentEPR"";

    /* The axis configuration context-  this will hold the all callers states
     * when doing throttling in a clustered environment. */
    private ConfigurationContext configCtx;

    /* Is this env. support clustering*/
    private boolean isClusteringEnable = false;

    /* The key for 'currentEPR' attribute and this is used when this attribute value being
     * replicated */
    private String currentEPRPropertyKey;

    /* The pointer to current epr - The position of the current EPR */
    private int currentEPR = 0;

    /**
     * To get the  position of the current EPR
     * If there is no value and if there will not appear any errors , then '0' will be returned.
     *
     * @return The  position of the current EPR
     */
    public int getCurrentEndpointIndex() {

        if (this.isClusteringEnable) {  // if this is a clustering env.

            if (this.currentEPRPropertyKey == null || """".equals(this.currentEPRPropertyKey)) {
                handleException(""Cannot find the required key to find the "" +
                        ""shared state of the 'currentEPR' attribute"");
            }

            Object value = this.configCtx.getPropertyNonReplicable(this.currentEPRPropertyKey);
            if (value == null) {
                return 0;
            }
            try {
                if (value instanceof Integer) {
                    return ((Integer) value).intValue();
                } else if (value instanceof String) {
                    return Integer.parseInt((String) value);
                }
            } catch (NumberFormatException e) {
                handleException(""The invalid value for the 'currentEPR' attribute"");
            }
        } else {
            return currentEPR;
        }
        return 0;
    }

    /**
     * The  position of the current EPR
     *
     * @param currentEPR The current position
     */
    public void setCurrentEPR(int currentEPR) {

        if (isClusteringEnable) {  // if this is a clustering env.

            if (currentEPRPropertyKey != null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Setting the current EPR "" + currentEPR
                            + "" with the key "" + currentEPRPropertyKey);
                }
                // Sets the property and  replicates the current state  so that all instances
                setAndReplicateState(currentEPRPropertyKey, currentEPR);
            }
        } else {
            if (log.isDebugEnabled()) {
                log.debug(""Setting the current EPR "" + currentEPR);
            }
            this.currentEPR = currentEPR;
        }
    }

    /**
     * Get the configuration context instance . This is only available for cluster env.
     *
     * @return Returns the ConfigurationContext instance
     */
    public ConfigurationContext getConfigurationContext() {
        return configCtx;
    }

    /**
     * Sets the  ConfigurationContext instance . This is only used for cluster env.
     * By setting this , indicates that this is a cluster env.
     *
     * @param configCtx The ConfigurationContext instance
     */
    public void setConfigurationContext(ConfigurationContext configCtx) {

        if (configCtx == null) {
            handleException(""The ConfigurationContext cannot be null when system "" +
                    ""in a cluster environment"");
        }

        this.configCtx = configCtx;
        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
    }

    /**
     * Sets the identifier for this algorithm context , so that , this can be identified
     * uniquely across the cluster. The id will be the name of the endpoint
     *
     * @param contextID The Id for this algorithm context
     */
    public void setContextID(String contextID) {

        if (contextID == null || """".equals(contextID)) {
            handleException(""The Context ID cannot be null when system in a cluster environment"");
        }

        //Making required key for each property in the algorithm context- Those will be used when
        //replicating states
        StringBuffer buffer = new StringBuffer();
        buffer.append(contextID);
        buffer.append(UNDERSCORE_STRING);
        buffer.append(CURRENT_EPR);
        currentEPRPropertyKey = buffer.toString();
    }


    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     */
    protected void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     * @param e   The exception
     */
    protected void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Helper method to replicates states of the property with given key
     * Sets property and  replicates the current state  so that all instances
     * across cluster can see this state
     *
     * @param key   The key of the property
     * @param value The value of the property
     */
    private void setAndReplicateState(String key, Object value) {

        if (configCtx != null && key != null && value != null) {

            try {
                if (log.isDebugEnabled()) {
                    log.debug(""Start replicating the property with key : "" + key
                            + "" value : "" + value);
                }

                configCtx.setProperty(key, value);
                Replicator.replicate(configCtx, new String[]{key});

                if (log.isDebugEnabled()) {
                    log.debug(""Completed replication of the property with key : "" + key);
                }

            } catch (ClusteringFault clusteringFault) {
                handleException(""Error during the replicating states "", clusteringFault);
            }
        }
    }

}"
org/apache/synapse/util/TemporaryData.java,true,"package org.apache.synapse.util;

import org.apache.commons.io.IOUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.*;

/**
 * Class representing some temporary data in the form of a byte stream.
 * <p>
 * Data is stored by writing to the output stream obtained using
 * {@link #getOutputStream()}. It can then be read back using
 * the input stream obtained from {@link #getInputStream()}.
 * The data is first stored into a fixed size buffer. Once this
 * buffer overflows, it is transferred to a temporary file. The buffer
 * is divided into a given number of fixed size chunks that are allocated
 * on demand. Since a temporary file may be created it is mandatory to
 * call {@link #release()} to discard the temporary data.
 */
public class TemporaryData {
    
    private static final Log log = LogFactory.getLog(TemporaryData.class);
    
    class OutputStreamImpl extends OutputStream {
        
        private FileOutputStream fileOutputStream;
        
        public void write(byte[] b, int off, int len) throws IOException {

            if (fileOutputStream != null) {
                fileOutputStream.write(b, off, len);
            } else if (len > (chunks.length-chunkIndex)*chunkSize - chunkOffset) {

                // The buffer will overflow. Switch to a temporary file.
                fileOutputStream = switchToTempFile();
                
                // Write the new data to the temporary file.
                fileOutputStream.write(b, off, len);

            } else {

                // The data will fit into the buffer.
                while (len > 0) {

                    byte[] chunk = getCurrentChunk();

                    // Determine number of bytes that can be copied to the current chunk.
                    int c = Math.min(len, chunkSize-chunkOffset);
                    // Copy data to the chunk.
                    System.arraycopy(b, off, chunk, chunkOffset, c);

                    // Update variables.
                    len -= c;
                    off += c;
                    chunkOffset += c;
                    if (chunkOffset == chunkSize) {
                        chunkIndex++;
                        chunkOffset = 0;
                    }
                }
            }
        }

        public void write(byte[] b) throws IOException {
            write(b, 0, b.length);
        }

        public void write(int b) throws IOException {
            write(new byte[] { (byte)b }, 0, 1);
        }

        public void flush() throws IOException {
            if (fileOutputStream != null) {
                fileOutputStream.flush();
            }
        }

        public void close() throws IOException {
            if (fileOutputStream != null) {
                fileOutputStream.close();
            }
        }
    }
    
    class InputStreamImpl extends InputStream {

        private int currentChunkIndex;
        private int currentChunkOffset;
        private int markChunkIndex;
        private int markChunkOffset;
        
        public int available() throws IOException {
            return (chunkIndex-currentChunkIndex)*chunkSize + chunkOffset - currentChunkOffset;
        }

        public int read(byte[] b, int off, int len) throws IOException {

            if (len == 0) {
                return 0;
            }

            int read = 0;
            while (len > 0 && !(currentChunkIndex == chunkIndex
                    && currentChunkOffset == chunkOffset)) {

                int c;
                if (currentChunkIndex == chunkIndex) {
                    // The current chunk is the last one => take into account the offset
                    c = Math.min(len, chunkOffset-currentChunkOffset);
                } else {
                    c = Math.min(len, chunkSize-currentChunkOffset);
                }

                // Copy the data.
                System.arraycopy(chunks[currentChunkIndex], currentChunkOffset, b, off, c);

                // Update variables
                len -= c;
                off += c;
                currentChunkOffset += c;
                read += c;
                if (currentChunkOffset == chunkSize) {
                    currentChunkIndex++;
                    currentChunkOffset = 0;
                }
            }

            if (read == 0) {
                // We didn't read anything (and the len argument was not 0) => we reached the end of the buffer.
                return -1;
            } else {
                return read;
            }
        }

        public int read(byte[] b) throws IOException {
            return read(b, 0, b.length);
        }

        public int read() throws IOException {
            byte[] b = new byte[1];
            return read(b) == -1 ? -1 : (int)b[0] & 0xFF;
        }

        public boolean markSupported() {
            return true;
        }

        public void mark(int readlimit) {
            markChunkIndex = currentChunkIndex;
            markChunkOffset = currentChunkOffset;
        }

        public void reset() throws IOException {
            currentChunkIndex = markChunkIndex;
            currentChunkOffset = markChunkOffset;
        }

        public long skip(long n) throws IOException {

            int available = available();
            int c = n < available ? (int)n : available;
            int newOffset = currentChunkOffset + c;
            int chunkDelta = newOffset/chunkSize;
            currentChunkIndex += chunkDelta;
            currentChunkOffset = newOffset - (chunkDelta*chunkSize);
            return c;
        }
        
        public void close() throws IOException {
        }
    }
    
    /**
     * Size of the chunks that will be allocated in the buffer.
     */
    final int chunkSize;
    
    /**
     * The prefix to be used in generating the name of the temporary file.
     */
    final String tempPrefix;
    
    /**
     * The suffix to be used in generating the name of the temporary file.
     */
    final String tempSuffix;
    
    /**
     * Array of <code>byte[]</code> representing the chunks of the buffer.
     * A chunk is only allocated when the first byte is written to it.
     * This attribute is set to <code>null</code> when the buffer overflows and
     * is written out to a temporary file.
     */
    byte[][] chunks;
    
    /**
     * Index of the chunk the next byte will be written to.
     */
    int chunkIndex;
    
    /**
     * Offset into the chunk where the next byte will be written.
     */
    int chunkOffset;
    
    /**
     * The handle of the temporary file. This is only set when the memory buffer
     * overflows and is written out to a temporary file.
     */
    File temporaryFile;
    
    public TemporaryData(int numberOfChunks, int chunkSize, String tempPrefix, String tempSuffix) {
        this.chunkSize = chunkSize;
        this.tempPrefix = tempPrefix;
        this.tempSuffix = tempSuffix;
        chunks = new byte[numberOfChunks][];
    }
    
    /**
     * Get the current chunk to write to, allocating it if necessary.
     * 
     * @return the current chunk to write to (never null)
     */
    byte[] getCurrentChunk() {
        if (chunkOffset == 0) {
            // We will write the first byte to the current chunk. Allocate it.
            byte[] chunk = new byte[chunkSize];
            chunks[chunkIndex] = chunk;
            return chunk;
        } else {
            // The chunk has already been allocated.
            return chunks[chunkIndex];
        }
    }
    
    /**
     * Create a temporary file and write the existing in memory data to it.
     * 
     * @return an open FileOutputStream to the temporary file
     * @throws IOException
     */
    FileOutputStream switchToTempFile() throws IOException {
        temporaryFile = File.createTempFile(tempPrefix, tempSuffix);
        if (log.isDebugEnabled()) {
            log.debug(""Using temporary file "" + temporaryFile);
        }
        temporaryFile.deleteOnExit();

        FileOutputStream fileOutputStream = new FileOutputStream(temporaryFile);
        // Write the buffer to the temporary file.
        for (int i=0; i<chunkIndex; i++) {
            fileOutputStream.write(chunks[i]);
        }

        if (chunkOffset > 0) {
            fileOutputStream.write(chunks[chunkIndex], 0, chunkOffset);
        }

        // Release references to the buffer so that it can be garbage collected.
        chunks = null;
        
        return fileOutputStream;
    }
    
    public OutputStream getOutputStream() {
        return new OutputStreamImpl();
    }
    
    /**
     * Fill this object with data read from a given InputStream.
     * <p>
     * A call <code>tmp.readFrom(in)</code> has the same effect as the
     * following code:
     * <pre>
     * OutputStream out = tmp.getOutputStream();
     * IOUtils.copy(in, out);
     * out.close();
     * </pre>
     * However it does so in a more efficient way.
     * 
     * @param in An InputStream to read data from. This method will not
     *           close the stream.
     * @throws IOException
     */
    public void readFrom(InputStream in) throws IOException {
        while (true) {
            int c = in.read(getCurrentChunk(), chunkOffset, chunkSize-chunkOffset);
            if (c == -1) {
                break;
            }
            chunkOffset += c;
            if (chunkOffset == chunkSize) {
                chunkIndex++;
                chunkOffset = 0;
                if (chunkIndex == chunks.length) {
                    FileOutputStream fileOutputStream = switchToTempFile();
                    IOUtils.copy(in, fileOutputStream);
                    fileOutputStream.close();
                    break;
                }
            }
        }
    }
    
    public InputStream getInputStream() throws IOException {
        if (temporaryFile != null) {
            return new FileInputStream(temporaryFile);
        } else {
            return new InputStreamImpl();
        }
    }
    
    public void release() {
        if (temporaryFile != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Deleting temporary file "" + temporaryFile);
            }
            temporaryFile.delete();
        }
    }

    protected void finalize() throws Throwable {
        if (temporaryFile != null) {
            log.warn(""Cleaning up unreleased temporary file "" + temporaryFile);
            temporaryFile.delete();
        }
    }
}
"
org/apache/synapse/mediators/eip/EIPUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Utility methods for the EIP mediators
 */
public class EIPUtils {

    private static final Log log = LogFactory.getLog(EIPUtils.class);

    /**
     * Return the set of elements specified by the XPath over the given envelope
     *
     * @param envelope SOAPEnvelope from which the elements will be extracted
     * @param expression SynapseXPath expression describing the elements to be extracted
     * @return List OMElements in the envelope matching the expression
     * @throws JaxenException if the XPath expression evaluation fails
     */
    public static List getMatchingElements(SOAPEnvelope envelope, SynapseXPath expression)
        throws JaxenException {

        Object o = expression.evaluate(envelope);
        if (o instanceof OMNode) {
            List list = new ArrayList();
            list.add(o);
            return list;
        } else if (o instanceof List) {
            return (List) o;
        } else {
            return new ArrayList();
        }
    }

    /**
     * Return the set of detached elements specified by the XPath over the given envelope
     *
     * @param envelope SOAPEnvelope from which the elements will be extracted
     * @param expression SynapseXPath expression describing the elements to be extracted
     * @return List detached OMElements in the envelope matching the expression
     * @throws JaxenException if the XPath expression evaluation fails
     */
    public static List<OMNode> getDetachedMatchingElements(SOAPEnvelope envelope, SynapseXPath expression)
        throws JaxenException {

        List<OMNode> elementList = new ArrayList<OMNode>();
        Object o = expression.evaluate(envelope);
        if (o instanceof OMNode) {
            elementList.add(((OMNode) o).detach());
        } else if (o instanceof List) {
            for (Object elem : (List) o) {
                if (elem instanceof OMNode) {
                    elementList.add(((OMNode) elem).detach());
                }
            }
        }
        return elementList;
    }

    /**
     * Merge two SOAP envelopes using the given XPath expression that specifies the
     * element that enriches the first envelope from the second
     *
     * @param envelope   SOAPEnvelope to be enriched with the content
     * @param enricher   SOAPEnvelope from which the enriching element will be extracted
     * @param expression SynapseXPath describing the enriching element
     * @throws JaxenException on failing of processing the xpath
     */
    public static void enrichEnvelope(SOAPEnvelope envelope, SOAPEnvelope enricher,
        SynapseXPath expression) throws JaxenException {

        OMElement enrichingElement;
        List elementList = getMatchingElements(envelope, expression);

        if (elementList != null && !elementList.isEmpty()) {

            // attach at parent of the first result from the XPath, or to the SOAPBody
            Object o = elementList.get(0);

            if (o instanceof OMElement &&
                ((OMElement) o).getParent() != null &&
                ((OMElement) o).getParent() instanceof OMElement) {
                enrichingElement = (OMElement) ((OMElement) o).getParent();
            } else {
                enrichingElement = envelope.getBody();
            }

            List list = getMatchingElements(enricher, expression);
            if (list != null) {
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    o = itr.next();
                    if (o != null && o instanceof OMElement) {
                        enrichingElement.addChild((OMElement) o);
                    }
                }
            }
        }
    }    
}
"
org/apache/synapse/ManagedLifecycle.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.synapse.core.SynapseEnvironment;

/**
 * This interface defines all the managed stateful parts of Synapse
 * including the configuration itself.
 */
public interface ManagedLifecycle {

    /**
     * This method should implement the initialization of the
     * implemented parts of the configuration.
     *
     * @param se SynapseEnvironment to be used for initialization
     */
    public void init(SynapseEnvironment se);

    /**
     * This method should implement the destroying of the
     * implemented parts of the configuration.
     */
    public void destroy();
}
"
org/apache/synapse/statistics/StatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 *  This interface need to be implemented by each of the entry that
 *  need to collect statistics
 *
 */

public interface StatisticsStack {

    /**
     * This method is used to put current statistics
     * @param key
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key,long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault);

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault);

    /**
     * Report the particular statistics to the StatisticsCollector
     *
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name);

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault);

}
"
org/apache/synapse/config/SynapseConfigurationBuilder.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.DataSourceRegistrar;
import org.apache.synapse.config.xml.XMLConfigurationBuilder;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.builtin.LogMediator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Builds a Synapse Configuration model with a given input
 * (e.g. XML, programmatic creation, default etc)
 */
public class SynapseConfigurationBuilder {

    private static Log log = LogFactory.getLog(SynapseConfigurationBuilder.class);

    /**
     * Return the default Synapse Configuration
     * @return the default configuration to be used
     */
    public static SynapseConfiguration getDefaultConfiguration() {
        // programatically create an empty configuration which just log and drop the messages 
        SynapseConfiguration config = new SynapseConfiguration();
        SequenceMediator mainmediator = new SequenceMediator();
        mainmediator.addChild(new LogMediator());
        mainmediator.addChild(new DropMediator());
        config.addSequence(SynapseConstants.MAIN_SEQUENCE_KEY, mainmediator);
        SequenceMediator faultmediator = new SequenceMediator();
        LogMediator fault = new LogMediator();
        fault.setLogLevel(LogMediator.FULL);
        faultmediator.addChild(fault);
        config.addSequence(SynapseConstants.FAULT_SEQUENCE_KEY, faultmediator);
        return config;
    }

    /**
     * Build a Synapse configuration from a given XML configuration file
     *
     * @param configFile the XML configuration
     * @return the Synapse configuration model
     */
    public static SynapseConfiguration getConfiguration(String configFile) {

        // build the Synapse configuration parsing the XML config file
        try {
            Properties synapseProperties = loadSynapseProperties();
            DataSourceRegistrar.registerDataSources(synapseProperties);
            SynapseConfiguration synCfg
                    = XMLConfigurationBuilder.getConfiguration(new FileInputStream(configFile));
            log.info(""Loaded Synapse configuration from : "" + configFile);
            synCfg.setPathToConfigFile(new File(configFile).getAbsolutePath());
            synCfg.setProperties(synapseProperties);
            return synCfg;

        } catch (FileNotFoundException fnf) {
            handleException(""Cannot load Synapse configuration from : "" + configFile, fnf);
        } catch (Exception e) {
            handleException(""Could not initialize Synapse : "" + e.getMessage(), e);
        }
        return null;
    }

    private static Properties loadSynapseProperties() {

        try {
            Properties properties = new Properties();
            ClassLoader cl = Thread.currentThread().getContextClassLoader();

            if (log.isDebugEnabled()) {
                log.debug(""synapse.properties file is loading from classpath"");
            }

            InputStream in = cl.getResourceAsStream(SynapseConstants.SYNAPSE_PROPERTIES);
            if (in == null) {
                if (log.isDebugEnabled()) {
                    log.debug(""Unable to load synapse.propeties file"");
                }

                String path = SynapseConstants.CONF_DIRECTORY +
                        File.separatorChar + SynapseConstants.SYNAPSE_PROPERTIES;
                if (log.isDebugEnabled()) {
                    log.debug(""synapse.properties file is loading from classpath"" +
                            "" with resource path '"" + path + "" '"");
                }

                in = cl.getResourceAsStream(path);
                if (in == null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Unable to load the synapse.properties file from classpath"" +
                                "" with resource name '"" + path + "" '"");
                    }
                }
            }

            if (in != null) {
                properties.load(in);
            }
            
            return properties;

        } catch (Exception e) {
            log.info(""Using the default tuning parameters for Synapse"");
        }
        return new Properties();
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.woden.WSDLFactory;
import org.apache.woden.WSDLReader;
import org.apache.woden.WSDLException;
import org.apache.woden.types.NCName;
import org.apache.woden.wsdl20.xml.DescriptionElement;
import org.apache.woden.wsdl20.Description;
import org.apache.woden.wsdl20.Service;
import org.apache.woden.wsdl20.Endpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Currently this class is not used as Woden is dependent on Xerces, which is not included in the
 * current release.
 *  
 * Builder for WSDL 2.0 endpoints. This class extracts endpoint information from the given WSDL 2.0
 * documents.
 */
public class WSDL20EndpointBuilder {

/*  COMMENT DUE TO BUILD FAILURE - TO BE FIXED LATER WHEN WSDL 2.0 SUPPORT IS OFFICIALLY IN 
    private static Log log = LogFactory.getLog(WSDL20EndpointBuilder.class);

    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String serviceName, String portName) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            reader.setFeature(WSDLReader.FEATURE_VALIDATION, false);

            DescriptionElement descriptionElement = reader.readWSDL(wsdlURI);
            return createEndpointDefinitionFromWSDL(descriptionElement, serviceName, portName);

        } catch (WSDLException e) {
            handleException(""Couldn't process the given WSDL document."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (DescriptionElement dElement, String serviceName, String portName) {

        if (dElement == null) {
            throw new SynapseException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            throw new SynapseException(""Service is not specified."");
        }

        if (portName == null) {
            throw new SynapseException(""Port is not specified."");
        }

        Description description = dElement.toComponent();
        String tns = dElement.getTargetNamespace().toString();
        Service service = description.getService(new QName(tns, serviceName));
        if (service != null) {
            Endpoint wsdlEndpoint = service.getEndpoint(new NCName(portName));
            if (wsdlEndpoint != null) {
                String serviceURL = wsdlEndpoint.getAddress().toString();

                EndpointDefinition endpointDefinition = new EndpointDefinition();
                endpointDefinition.setAddress(serviceURL);

                return endpointDefinition;
            } else {
                handleException(""Specified port is not defined in the given WSDL."");
            }
        } else {
            handleException(""Specified service is not defined in the given WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }*/
}
"
org/apache/synapse/mediators/filters/FilterMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;
import org.apache.synapse.mediators.ListMediator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The filter mediator combines the regex and xpath filtering functionality. If an xpath
 * is set, it is evaluated; else the given regex is evaluated against the source xpath.
 */
public class FilterMediator extends AbstractListMediator implements
    org.apache.synapse.mediators.FilterMediator {

    private SynapseXPath source = null;
    private Pattern regex = null;
    private SynapseXPath xpath = null;
    private ListMediator elseMediator = null;
    private boolean thenElementPresent = false;
    private String thenKey = null;
    private String elseKey = null;

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Filter mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = false;
        if (test(synCtx)) {

            if (thenKey != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, (xpath == null ?
                        ""Source : "" + source + "" against : "" + regex.pattern() + "" matches"" :
                        ""XPath expression : ""  + xpath + "" evaluates to true"") +
                        "" - executing then sequence with key : "" + thenKey);
                }

                Mediator seq = synCtx.getSequence(thenKey);
                if (seq != null) {
                    result = seq.mediate(synCtx);
                } else {
                    handleException(""Couldn't find the referred then sequence with key : ""
                        + thenKey, synCtx);
                }
                
            } else {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, (xpath == null ?
                        ""Source : "" + source + "" against : "" + regex.pattern() + "" matches"" :
                        ""XPath expression : ""  + xpath + "" evaluates to true"") +
                        "" - executing child mediators"");
                }

                result = super.mediate(synCtx);
            }

        } else {

            if (elseKey != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, (xpath == null ?
                        ""Source : "" + source + "" against : "" + regex.pattern() + "" does not match"" :
                        ""XPath expression : ""  + xpath + "" evaluates to false"") +
                        "" - executing the else sequence with key : "" + elseKey);
                }

                Mediator elseSeq = synCtx.getSequence(elseKey);

                if (elseSeq != null) {
                    result = elseSeq.mediate(synCtx);
                } else {
                    handleException(""Couldn't find the referred else sequence with key : ""
                        + elseKey, synCtx);
                }
                
            } else if (elseMediator != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, (xpath == null ?
                        ""Source : "" + source + "" against : "" + regex.pattern() + "" does not match"" :
                        ""XPath expression : ""  + xpath + "" evaluates to false"") +
                        "" - executing the else path child mediators"");
                }
                result = elseMediator.mediate(synCtx);

            } else {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, (xpath == null ?
                        ""Source : "" + source + "" against : "" + regex.pattern() + "" does not match"" :
                        ""XPath expression : ""  + xpath + "" evaluates to false and no else path"") +
                        "" - skipping child mediators"");
                }
                result = true;
            }
        }

        if (traceOrDebugOn) {
            trace.trace(""End : Filter mediator "");
        }
        return result;
    }

    /**
     * Tests the supplied condition after evaluation against the given XPath
     * or Regex (against a source XPath). When a regular expression is supplied
     * the source XPath is evaluated into a String value, and matched against
     * the given regex
     *
     * @param synCtx the current message for evaluation of the test condition
     * @return true if evaluation of the XPath/Regex results in true
     */
    public boolean test(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (xpath != null) {
            try {
                return xpath.booleanValueOf(synCtx);
            } catch (JaxenException e) {
                handleException(""Error evaluating XPath expression : "" + xpath, e, synCtx);
            }

        } else if (source != null && regex != null) {
            String sourceString = source.stringValueOf(synCtx);
            if (sourceString == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Source String : "" + source + "" evaluates to null"");
                }
                return false;
            }
            Matcher matcher = regex.matcher(sourceString);
            if (matcher == null) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Regex pattren matcher for : "" + regex.pattern() +
                        ""against source : "" + sourceString + "" is null"");
                }
                return false;
            }
            return matcher.matches();
        }

        return false; // never executes
    }


    public SynapseXPath getSource() {
        return source;
    }

    public void setSource(SynapseXPath source) {
        this.source = source;
    }

    public Pattern getRegex() {
        return regex;
    }

    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    public SynapseXPath getXpath() {
        return xpath;
    }

    public void setXpath(SynapseXPath xpath) {
        this.xpath = xpath;
    }

    public ListMediator getElseMediator() {
        return elseMediator;
    }

    public void setElseMediator(ListMediator elseMediator) {
        this.elseMediator = elseMediator;
    }

    public boolean isThenElementPresent() {
        return thenElementPresent;
    }

    public void setThenElementPresent(boolean thenElementPresent) {
        this.thenElementPresent = thenElementPresent;
    }

    public String getThenKey() {
        return thenKey;
    }

    public void setThenKey(String thenKey) {
        this.thenKey = thenKey;
    }

    public String getElseKey() {
        return elseKey;
    }

    public void setElseKey(String elseKey) {
        this.elseKey = elseKey;
    }
}
"
org/apache/synapse/startup/AbstractStartup.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup;

import org.apache.synapse.Startup;

/**
 * 
 */
public abstract class AbstractStartup implements Startup {

    /**
     * Holds the name of a Startup
     */
    protected String name = null;

    /**
     * This will return the name of the startup
     *
     * @return String representing the name
     */
    public String getName() {
        return this.name;
    }

    /**
     * This will set the name of a Startup
     *
     * @param name
     *          String name to be set to the startup
     */
    public void setName(String name) {
        this.name = name;
    }
}
"
org/apache/synapse/mediators/annotations/ReadFromMessage.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.annotations;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Target({FIELD, METHOD})
@Retention(RUNTIME)
public @interface ReadFromMessage {

    String value();

}
"
org/apache/synapse/config/xml/RegistrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import java.util.Iterator;

/**
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistrySerializer {

    private static final Log log = LogFactory.getLog(RegistrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    public static OMElement serializeRegistry(OMElement parent, Registry registry) {

        OMElement reg = fac.createOMElement(""registry"", synNS);

        if (registry.getProviderClass() != null) {
            reg.addAttribute(fac.createOMAttribute(
                ""provider"", nullNS, registry.getProviderClass()));
        } else {
            handleException(""Invalid registry. Provider is required"");
        }

        Iterator iter = registry.getConfigurationProperties().keySet().iterator();
        while (iter.hasNext()) {
            String name = (String) iter.next();
            String value = (String) registry.getConfigurationProperties().get(name);
            OMElement property = fac.createOMElement(""parameter"", synNS);
            property.addAttribute(fac.createOMAttribute(
                ""name"", nullNS, name));
            property.setText(value.trim());
            reg.addChild(property);
        }

        if (parent != null) {
            parent.addChild(reg);
        }
        return reg;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/core/axis2/CustomWSDLLocator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.synapse.config.SynapseConfigUtils;
import org.apache.synapse.config.SynapseConfiguration;
import org.xml.sax.InputSource;

import javax.wsdl.xml.WSDLLocator;

/**
 * Class that adapts a {@link ResourceMap} object to {@link WSDLLocator}.
 */
public class CustomWSDLLocator implements WSDLLocator {
    private final InputSource baseInputSource;
    private final String baseURI;
    private ResourceMap resourceMap;
    private SynapseConfiguration synCfg;

    private String latestImportURI;

    public CustomWSDLLocator(InputSource baseInputSource,
                                  String baseURI) {
        this.baseInputSource = baseInputSource;
        this.baseURI = baseURI;
    }

    public CustomWSDLLocator(InputSource baseInputSource,
                                  String baseURI,
                                  ResourceMap resourceMap,
                                  SynapseConfiguration synCfg) {
        this(baseInputSource, baseURI);
        this.resourceMap = resourceMap;
        this.synCfg = synCfg;
    }

    public InputSource getBaseInputSource() {
        return baseInputSource;
    }

    public String getBaseURI() {
        return baseURI;
    }

    /**
     * Resolve a schema or WSDL import.
     * This method will first attempt to resolve the location using the configured
     * {@link ResourceMap} object. If this fails (because no {@link ResourceMap} is
     * configured or because {@link ResourceMap#resolve(SynapseConfiguration, String)}
     * returns null, it will resolve the location using
     * {@link SynapseConfigUtils#resolveRelativeURI(String, String)}.
     */
    public InputSource getImportInputSource(String parentLocation, String relativeLocation) {
        InputSource result = null;
        if (resourceMap != null) {
            result = resourceMap.resolve(synCfg, relativeLocation);
        }
        if (result == null) {
            result = new InputSource(SynapseConfigUtils.resolveRelativeURI(parentLocation, relativeLocation));
        }
        this.latestImportURI = relativeLocation;
        return result;
    }

    public String getLatestImportURI() {
        return latestImportURI;
    }

    public void close() {
    }
}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;

public class SALoadbalanceEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof SALoadbalanceEndpoint)) {
            handleException(""Invalid endpoint type for serializing. "" +
                    ""Expected: SALoadbalanceEndpoint Found: "" + endpoint.getClass().getName());
        }

        SALoadbalanceEndpoint loadbalanceEndpoint = (SALoadbalanceEndpoint) endpoint;

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        String name = loadbalanceEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        Dispatcher dispatcher = loadbalanceEndpoint.getDispatcher();

        if (dispatcher instanceof SoapSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""soap"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof HttpSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""http"", null);
            endpointElement.addChild(sessionElement);

        } else if (dispatcher instanceof SimpleClientSessionDispatcher) {
            OMElement sessionElement = fac.createOMElement(""session"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            sessionElement.addAttribute(""type"", ""simpleClientSession"", null);
            endpointElement.addChild(sessionElement);
        }

        OMElement loadbalanceElement = fac.createOMElement(""loadbalance"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        endpointElement.addChild(loadbalanceElement);

        LoadbalanceAlgorithm algorithm = loadbalanceEndpoint.getAlgorithm();
        String algorithmName = ""roundRobin"";
        if (algorithm instanceof RoundRobin) {
             algorithmName = ""roundRobin"";
        }
        loadbalanceElement.addAttribute(""algorithm"", algorithmName, null);

        for (Endpoint childEndpoint : loadbalanceEndpoint.getEndpoints()) {
            loadbalanceElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
        }

        return endpointElement;
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointSerializer.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.*;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

/**
 * All endpoint serializers should implement this interface. Use EndpointSerializer to
 * obtain the correct EndpointSerializer implementation for a particular endpoint.
 * EndpointSerializer implementation may call other EndpointSerializer implementations to serialize
 * nested endpoints.
 */
public abstract class EndpointSerializer {

    private static Log log = LogFactory.getLog(EndpointSerializer.class);

    protected OMFactory fac;

    /**
     * Core method which is exposed to the external use, and serializes the {@link Endpoint} to the
     * XML format
     *
     * @param endpoint to be serialized
     * @return XML format of the serialized endpoint
     */
    public static OMElement getElementFromEndpoint(Endpoint endpoint) {
        return getEndpointSerializer(endpoint).serializeEndpoint(endpoint);
    }

    /**
     * Serializes the given endpoint implementation to an XML object.
     *
     * @param endpoint Endpoint implementation to be serialized.
     * @return OMElement containing XML configuration.
     */
    protected abstract OMElement serializeEndpoint(Endpoint endpoint);

    /**
     * Serializes the QoS infomation of the endpoint to the XML element
     *
     * @param endpointDefinition specifies the QoS information of the endpoint
     * @param element            to which the QoS information will be serialized
     */
    protected void serializeCommonEndpointProperties(
            EndpointDefinition endpointDefinition, OMElement element) {

        if (endpointDefinition.getStatisticsState() == SynapseConstants.STATISTICS_ON) {
            element.addAttribute(fac.createOMAttribute(XMLConfigConstants.STATISTICS_ATTRIB_NAME,
                    null, XMLConfigConstants.STATISTICS_ENABLE));
        } else if (endpointDefinition.getStatisticsState() == SynapseConstants.STATISTICS_OFF) {
            element.addAttribute(fac.createOMAttribute(XMLConfigConstants.STATISTICS_ATTRIB_NAME,
                    null, XMLConfigConstants.STATISTICS_DISABLE));
        }

        if (endpointDefinition.getTraceState() == SynapseConstants.TRACING_ON) {
            element.addAttribute(fac.createOMAttribute(XMLConfigConstants.TRACE_ATTRIB_NAME,
                    null, XMLConfigConstants.TRACE_ENABLE));
        } else if (endpointDefinition.getStatisticsState() == SynapseConstants.TRACING_OFF) {
            element.addAttribute(fac.createOMAttribute(XMLConfigConstants.TRACE_ATTRIB_NAME,
                    null, XMLConfigConstants.TRACE_DISABLE));
        }

        if (endpointDefinition.isUseSwa()) {
            element.addAttribute(fac.createOMAttribute(""optimize"", null, ""swa""));
        } else if (endpointDefinition.isUseMTOM()) {
            element.addAttribute(fac.createOMAttribute(""optimize"", null, ""mtom""));
        }

        if (endpointDefinition.getCharSetEncoding() != null) {
            element.addAttribute(fac.createOMAttribute(
                    ""encoding"", null, endpointDefinition.getCharSetEncoding()));
        }

        if (endpointDefinition.isAddressingOn()) {
            OMElement addressing = fac.createOMElement(
                    ""enableAddressing"", SynapseConstants.SYNAPSE_OMNAMESPACE);

            if (endpointDefinition.getAddressingVersion() != null) {
                addressing.addAttribute(fac.createOMAttribute(
                        ""version"", null, endpointDefinition.getAddressingVersion()));
            }

            if (endpointDefinition.isUseSeparateListener()) {
                addressing.addAttribute(fac.createOMAttribute(""separateListener"", null, ""true""));
            }
            element.addChild(addressing);
        }

        if (endpointDefinition.isReliableMessagingOn()) {
            OMElement rm = fac.createOMElement(""enableRM"", SynapseConstants.SYNAPSE_OMNAMESPACE);

            if (endpointDefinition.getWsRMPolicyKey() != null) {
                rm.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsRMPolicyKey()));
            }
            element.addChild(rm);
        }

        if (endpointDefinition.isSecurityOn()) {
            OMElement sec = fac.createOMElement(""enableSec"", SynapseConstants.SYNAPSE_OMNAMESPACE);

            if (endpointDefinition.getWsSecPolicyKey() != null) {
                sec.addAttribute(fac.createOMAttribute(
                        ""policy"", null, endpointDefinition.getWsSecPolicyKey()));
            }
            element.addChild(sec);
        }

        if (endpointDefinition.getTimeoutAction() != SynapseConstants.NONE) {

            OMElement timeout = fac.createOMElement(
                    ""timeout"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            element.addChild(timeout);

            OMElement duration = fac.createOMElement(
                    ""duration"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            duration.setText(Long.toString(endpointDefinition.getTimeoutDuration() / 1000));
            timeout.addChild(duration);

            OMElement action = fac.createOMElement(""action"", SynapseConstants.SYNAPSE_OMNAMESPACE);
            if (endpointDefinition.getTimeoutAction() == SynapseConstants.DISCARD) {
                action.setText(""discard"");
            } else if (endpointDefinition.getTimeoutAction()
                    == SynapseConstants.DISCARD_AND_FAULT) {
                action.setText(""fault"");
            }
            timeout.addChild(action);
        }

        long suspendDuration = endpointDefinition.getSuspendOnFailDuration();
        if (suspendDuration != -1) {
            // user has set some value for this. let's serialize it.
            OMElement suspendElement = fac.createOMElement(
                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE,
                    SynapseConstants.SYNAPSE_OMNAMESPACE);

            suspendElement.setText(Long.toString(suspendDuration / 1000));
            element.addChild(suspendElement);
        }
    }

    protected void serializeSpecificEndpointProperties(EndpointDefinition endpointDefinition, OMElement element){

    }


    protected void handleException(String message) {
        log.error(message);
        throw new SynapseException(message);
    }

    /**
     * Returns the EndpointSerializer implementation for the given endpoint. Throws a SynapseException,
     * if there is no serializer for the given endpoint type.
     *
     * @param endpoint Endpoint implementaion.
     * @return EndpointSerializer implementation.
     */
    public static EndpointSerializer getEndpointSerializer(Endpoint endpoint) {

        if (endpoint instanceof AddressEndpoint) {
            return new AddressEndpointSerializer();
        } else if (endpoint instanceof WSDLEndpoint) {
            return new WSDLEndpointSerializer();
        } else if (endpoint instanceof IndirectEndpoint) {
            return new IndirectEndpointSerializer();
        } else if (endpoint instanceof LoadbalanceEndpoint) {
            return new LoadbalanceEndpointSerializer();
        } else if (endpoint instanceof SALoadbalanceEndpoint) {
            return new SALoadbalanceEndpointSerializer();
        } else if (endpoint instanceof FailoverEndpoint) {
            return new FailoverEndpointSerializer();
        }

        throw new SynapseException(""Serializer for endpoint "" +
                endpoint.getClass().toString() + "" is not defined."");
    }
}
"
org/apache/synapse/core/axis2/Axis2Sender.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.AddressingHelper;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.AxisEngine;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.rampart.handler.WSSHandlerConstants;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.transport.nhttp.NhttpConstants;
import org.apache.synapse.util.POXUtils;
import org.apache.synapse.util.UUIDGenerator;

/**
 * This class helps the Axis2SynapseEnvironment implement the send method
 */
public class Axis2Sender {

    private static final Log log = LogFactory.getLog(Axis2Sender.class);

    /**
     * Send a message out from the Synapse engine to an external service
     * @param endpoint the endpoint definition where the message should be sent
     * @param synapseInMessageContext the Synapse message context
     */
    public static void sendOn(EndpointDefinition endpoint,
        org.apache.synapse.MessageContext synapseInMessageContext) {

        try {
            Axis2FlexibleMEPClient.send(
                // The endpoint where we are sending to
                endpoint,
                // The Axis2 Message context of the Synapse MC
                synapseInMessageContext);

        } catch (Exception e) {
            handleException(""Unexpected error during sending message out"", e);
        }
    }

    /**
     * Send a response back to a client of Synapse
     * @param smc the Synapse message context sent as the response
     */
    public static void sendBack(org.apache.synapse.MessageContext smc) {

        MessageContext messageContext = ((Axis2MessageContext) smc).getAxis2MessageContext();

        // if this is a dummy 202 Accepted message meant only for the http/s transports
        // prevent it from going into any other transport sender
        if (messageContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED) &&
            messageContext.getTransportOut() != null &&
            !messageContext.getTransportOut().getName().startsWith(Constants.TRANSPORT_HTTP)) {
                return;
        }

        // fault processing code
        if (messageContext.isDoingREST() && messageContext.isFault()) {
            POXUtils.convertSOAPFaultToPOX(messageContext);
        }

        try {
            messageContext.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            // check if addressing is already engaged for this message.
            // if engaged we should use the addressing enabled Configuraion context.
            if (smc.isResponse()) {
                //Process statistics
                StatisticsUtils.processEndPointStatistics(smc);
                StatisticsUtils.processProxyServiceStatistics(smc);
                StatisticsUtils.processAllSequenceStatistics(smc);
            }

            if (AddressingHelper.isReplyRedirected(messageContext) &&
                    !messageContext.getReplyTo().hasNoneAddress()) {

                messageContext.setTo(messageContext.getReplyTo());
                messageContext.setReplyTo(null);
                messageContext.setWSAAction("""");
                messageContext.setSoapAction("""");
                messageContext.setProperty(
                        NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);                
                messageContext.setProperty(
                        AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.FALSE);
            }
            
            if (messageContext.getEnvelope().hasFault()
                    && AddressingHelper.isFaultRedirected(messageContext)
                    && !messageContext.getFaultTo().hasNoneAddress()) {

                messageContext.setTo(messageContext.getFaultTo());
                messageContext.setFaultTo(null);
                messageContext.setWSAAction("""");
                messageContext.setSoapAction("""");
                messageContext.setProperty(
                        NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
                messageContext.setProperty(
                        AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.FALSE);
            }
            
            Axis2FlexibleMEPClient.removeAddressingHeaders(messageContext);
            messageContext.setMessageID(UUIDGenerator.getUUID());

            // temporary workaround for https://issues.apache.org/jira/browse/WSCOMMONS-197
            if (messageContext.isEngaged(WSSHandlerConstants.SECURITY_MODULE_NAME) &&
                messageContext.getEnvelope().getHeader() == null) {
                SOAPFactory fac = messageContext.isSOAP11() ?
                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory();
                fac.createSOAPHeader(messageContext.getEnvelope());
            }
            
            AxisEngine.send(messageContext);

        } catch (AxisFault e) {
            handleException(""Unexpected error sending message back"", e);
        }
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/mediators/eip/splitter/IterateMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip.splitter;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.context.OperationContext;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.mediators.eip.EIPUtils;
import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.util.MessageHelper;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.util.Iterator;
import java.util.List;

/**
 * Splits a message using an XPath expression and creates a new message to hold
 * each resulting element. This is very much similar to the clone mediator, and
 * hands over the newly created messages to a target for processing
 */
public class IterateMediator extends AbstractMediator implements ManagedLifecycle {

    /** Continue mediation on the parent message or not? */
    private boolean continueParent = false;

    /**
     * Preserve the payload as a template to create new messages with the selected
     * elements with the rest of the parent, or create new message that contain only
     * the selected element as its payload?
     */
    private boolean preservePayload = false;

    /** The XPath that will list the elements to be splitted */
    private SynapseXPath expression = null;

    /**
     * An XPath expression that specifies where the splitted elements should be attached when
     * the payload is being preserved
     */
    private SynapseXPath attachPath = null;

    /** The target for the newly splitted messages */
    private Target target = null;

    /**
     * Splits the message by iterating over the results of the given XPath expression
     *
     * @param synCtx - MessageContext to be mediated
     * @return boolean false if need to stop processing of the parent message
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Iterate mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            // get a copy of the message for the processing, if the continueParent is set to true
            // this original message can go in further mediations and hence we should not change
            // the original message context
            SOAPEnvelope envelope = MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope());

            // get the iteration elements and iterate through the list,
            // this call will also detach all the iteration elements 
            List splitElements = EIPUtils.getDetachedMatchingElements(envelope, expression);

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Splitting with XPath : "" + expression + "" resulted in "" +
                    splitElements.size() + "" elements"");
            }

            // if not preservePayload remove all the child elements
            if (!preservePayload && envelope.getBody() != null) {
                for (Iterator itr = envelope.getBody().getChildren(); itr.hasNext();) {
                    ((OMNode) itr.next()).detach();
                }
            }

            int msgCount = splitElements.size();
            int msgNumber = 0;

            // iterate through the list
            for (Object o : splitElements) {

                // for the moment iterator will look for an OMNode as the iteration element
                if (!(o instanceof OMNode)) {
                    handleException(""Error splitting message with XPath : ""
                        + expression + "" - result not an OMNode"", synCtx);
                }

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Submitting "" + (msgNumber+1) + "" of "" + msgNumber +
                        "" messages for processing in parallel"");
                }

                target.mediate(
                    getIteratedMessage(synCtx, msgNumber++, msgCount, envelope, (OMNode) o));
            }

        } catch (JaxenException e) {
            handleException(""Error evaluating split XPath expression : "" + expression, e, synCtx);
        } catch (AxisFault af) {
            handleException(""Error creating an iterated copy of the message"", af, synCtx);
        }

        // if the continuation of the parent message is stopped from here set the RESPONSE_WRITTEN
        // property to SKIP to skip the blank http response 
        OperationContext opCtx
            = ((Axis2MessageContext) synCtx).getAxis2MessageContext().getOperationContext();
        if (!continueParent && opCtx != null) {
            opCtx.setProperty(Constants.RESPONSE_WRITTEN,""SKIP"");
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Iterate mediator"");
        }

        // whether to continue mediation on the original message
        return continueParent;
    }

    /**
     * Create a new message context using the given original message context, the envelope
     * and the split result element.
     *
     * @param synCtx    - original message context
     * @param msgNumber - message number in the iteration
     * @param msgCount  - total number of messages in the split
     * @param envelope  - envelope to be used in the iteration
     * @param o         - element which participates in the iteration replacement
     * @return newCtx created by the iteration
     * @throws AxisFault if there is a message creation failure
     * @throws JaxenException if the expression evauation failure
     */
    private MessageContext getIteratedMessage(MessageContext synCtx, int msgNumber, int msgCount,
        SOAPEnvelope envelope, OMNode o) throws AxisFault, JaxenException {
        
        // clone the message for the mediation in iteration
        MessageContext newCtx = MessageHelper.cloneMessageContext(synCtx);

        // set the messageSequence property for possibal aggreagtions
        newCtx.setProperty(
            EIPConstants.MESSAGE_SEQUENCE,
            msgNumber + EIPConstants.MESSAGE_SEQUENCE_DELEMITER + msgCount);

        // get a clone of the envelope to be attached
        SOAPEnvelope newEnvelope = MessageHelper.cloneSOAPEnvelope(envelope);

        // if payload should be preserved then attach the iteration element to the
        // node specified by the attachPath
        if (preservePayload) {

            Object attachElem = attachPath.evaluate(newEnvelope);
            if (attachElem != null &&
                attachElem instanceof List && !((List) attachElem).isEmpty()) {
                attachElem = ((List) attachElem).get(0);
            }

            // for the moment attaching element should be an OMElement
            if (attachElem != null && attachElem instanceof OMElement) {
                ((OMElement) attachElem).addChild(o);
            } else {
                handleException(""Error in attaching the splitted elements :: "" +
                    ""Unable to get the attach path specified by the expression "" +
                    attachPath, synCtx);
            }

        } else if (newEnvelope.getBody() != null) {
            // if not preserve payload then attach the iteration element to the body
            newEnvelope.getBody().addChild(o);
        }

        // set the envelope and mediate as specified in the target
        newCtx.setEnvelope(newEnvelope);

        return newCtx;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    //                        Getters and Setters                                        //
    ///////////////////////////////////////////////////////////////////////////////////////

    public boolean isContinueParent() {
        return continueParent;
    }

    public void setContinueParent(boolean continueParent) {
        this.continueParent = continueParent;
    }

    public boolean isPreservePayload() {
        return preservePayload;
    }

    public void setPreservePayload(boolean preservePayload) {
        this.preservePayload = preservePayload;
    }

    public SynapseXPath getExpression() {
        return expression;
    }

    public void setExpression(SynapseXPath expression) {
        this.expression = expression;
    }

    public SynapseXPath getAttachPath() {
        return attachPath;
    }

    public void setAttachPath(SynapseXPath attachPath) {
        this.attachPath = attachPath;
    }

    public Target getTarget() {
        return target;
    }

    public void setTarget(Target target) {
        this.target = target;
    }

    public void init(SynapseEnvironment se) {
        if (target.getSequence() != null) {
            target.getSequence().init(se);
        }
    }

    public void destroy() {
        if (target.getSequence() != null) {
            target.getSequence().destroy();
        }
    }
}
"
org/apache/synapse/config/xml/AbstractDBMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.dbcp.BasicDataSource;
import org.apache.synapse.mediators.db.AbstractDBMediator;
import org.apache.synapse.mediators.db.Statement;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import javax.xml.namespace.QName;
import java.sql.Connection;
import java.util.Hashtable;
import java.util.Iterator;

/**
 * Base class for factories for database related mediators.
 * 
 * <pre>
 * &lt;dbreport | dblookup | .. etc>
 *   &lt;connection>
 *     &lt;pool>
 *     (
 *       &lt;driver/>
 *       &lt;url/>
 *       &lt;user/>
 *       &lt;password/>
 *     | 
 *       &lt;dsName/>
 *       &lt;icClass/>
 *       &lt;url/>
 *       &lt;user/>
 *       &lt;password/>
 *     )
 *       &lt;property name=""name"" value=""value""/>*
 *     &lt;/pool>
 *   &lt;/connection>
 *   &lt;statement>
 *     &lt;sql>insert into table values (?, ?, ..) OR select target from destinations where src = ?&lt;/sql>
 *     &lt;parameter (value=""const"" | expression=""xpath"") type=""INTEGER|VARCHAR|...""/>*
 *     &lt;result name=""propName"" column=""target | number""/>*
 *   &lt;/statement>+
 * &lt;/dbreport | dblookup | .. etc>
 * </pre>
 * 
 * Supported properties for custom DataSources
 * autocommit = true | false
 * isolation = Connection.TRANSACTION_NONE
 *           | Connection.TRANSACTION_READ_COMMITTED
 *           | Connection.TRANSACTION_READ_UNCOMMITTED 
 *           | Connection.TRANSACTION_REPEATABLE_READ 
 *           | Connection.TRANSACTION_SERIALIZABLE
 * initialsize = int
 * maxactive = int
 * maxidle = int
 * maxopenstatements = int
 * maxwait = long
 * minidle = int
 * poolstatements = true | false
 * testonborrow = true | false
 * testonreturn = true | false
 * testwhileidle = true | false
 * validationquery = String
 */
public abstract class AbstractDBMediatorFactory extends AbstractMediatorFactory {

    public static final QName URL_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""url"");
    static final QName DRIVER_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""driver"");
    static final QName USER_Q     = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""user"");
    static final QName PASS_Q     = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""password"");

    static final QName DSNAME_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""dsName"");
    static final QName ICCLASS_Q  = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""icClass"");

    static final QName STMNT_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""statement"");
    static final QName SQL_Q      = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sql"");
    static final QName PARAM_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter"");
    static final QName RESULT_Q   = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""result"");

    static final QName ATT_COLUMN = new QName(""column"");
    static final QName ATT_TYPE   = new QName(""type"");

    protected void buildDataSource(OMElement elem, AbstractDBMediator mediator) {

        OMElement pool = null;
        // get the 'pool' element and determine if we need to create a DataSource or
        // look up using JNDI
        try {
            SynapseXPath xpath = new SynapseXPath(""self::node()/syn:connection/syn:pool"");
            xpath.addNamespace(""syn"", XMLConfigConstants.SYNAPSE_NAMESPACE);
            pool = (OMElement) xpath.selectSingleNode(elem);

            if (pool.getFirstChildWithName(DRIVER_Q) != null) {
                mediator.setDataSource(createCustomDataSource(pool, mediator));

            } else if (
                pool.getFirstChildWithName(ICCLASS_Q) != null &&
                pool.getFirstChildWithName(DSNAME_Q) != null) {
                mediator.setDataSource(lookupDataSource(pool, mediator));
            } else {
                handleException(""The DataSource connection information must be specified for "" +
                    ""using a custom DataSource connection pool or for a JNDI lookup"");
            }

        } catch (JaxenException e) {
            handleException(""Error looking up DataSource connection information"", e);
        }
    }

    /**
     * Lookup the DataSource on JNDI using the specified properties
     * @param pool the toplevel 'pool' element that holds DataSource information
     * @param mediator the mediator to store properties for serialization
     * @return a DataSource looked up using specified properties
     */
    private DataSource lookupDataSource(OMElement pool, AbstractDBMediator mediator) {

        Hashtable props = new Hashtable();
        // load the minimum required properties
        props.put(Context.INITIAL_CONTEXT_FACTORY, (getValue(pool, ICCLASS_Q)));
        props.put(Context.SECURITY_PRINCIPAL, getValue(pool, USER_Q));
        props.put(Context.SECURITY_CREDENTIALS, getValue(pool, PASS_Q));
        props.put(Context.PROVIDER_URL, getValue(pool, URL_Q));
        String dsName = getValue(pool, DSNAME_Q);

        //save loaded properties for later
        mediator.addDataSourceProperty(ICCLASS_Q, getValue(pool, ICCLASS_Q));
        mediator.addDataSourceProperty(DSNAME_Q,  getValue(pool, DSNAME_Q));
        mediator.addDataSourceProperty(URL_Q,  getValue(pool, URL_Q));
        mediator.addDataSourceProperty(USER_Q, getValue(pool, USER_Q));
        mediator.addDataSourceProperty(PASS_Q, getValue(pool, PASS_Q));

        try {
            Context ctx = new InitialContext(props);
            Object ds = ctx.lookup(dsName);
            if (ds != null && ds instanceof DataSource) {
                return (DataSource) ds;
            } else {
                handleException(""DataSource : "" + dsName + "" not found when looking up"" +
                        "" using JNDI properties : "" + props);
            }

        } catch (NamingException e) {
            handleException(""Error looking up DataSource : "" + dsName +
                    "" using JNDI properties : "" + props, e);
        }
        return null;
    }

    /**
     * Create a custom DataSource using the specified properties and Apache DBCP
     * @param pool the toplevel 'pool' element that holds DataSource information
     * @param mediator the mediator to store properties for serialization
     * @return a DataSource created using specified properties
     */
    private DataSource createCustomDataSource(OMElement pool, AbstractDBMediator mediator) {

        BasicDataSource ds = new BasicDataSource();

        // load the minimum required properties
        ds.setDriverClassName(getValue(pool, DRIVER_Q));
        ds.setUsername(getValue(pool, USER_Q));
        ds.setPassword(getValue(pool, PASS_Q));
        ds.setUrl(getValue(pool, URL_Q));

        //save loaded properties for later
        mediator.addDataSourceProperty(DRIVER_Q, getValue(pool, DRIVER_Q));
        mediator.addDataSourceProperty(URL_Q,  getValue(pool, URL_Q));
        mediator.addDataSourceProperty(USER_Q, getValue(pool, USER_Q));
        mediator.addDataSourceProperty(PASS_Q, getValue(pool, PASS_Q));

        Iterator props = pool.getChildrenWithName(PROP_Q);
        while (props.hasNext()) {

            OMElement prop = (OMElement) props.next();
            String name  = prop.getAttribute(ATT_NAME).getAttributeValue();
            String value = prop.getAttribute(ATT_VALUE).getAttributeValue();
            // save property for later
            mediator.addDataSourceProperty(name, value);

            if (""autocommit"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setDefaultAutoCommit(true);
                } else if (""false"".equals(value)) {
                    ds.setDefaultAutoCommit(false);
                }
            } else if (""isolation"".equals(name)) {
                try {
                    if (""Connection.TRANSACTION_NONE"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_NONE);
                    } else if (""Connection.TRANSACTION_READ_COMMITTED"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
                    } else if (""Connection.TRANSACTION_READ_UNCOMMITTED"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
                    } else if (""Connection.TRANSACTION_REPEATABLE_READ"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
                    } else if (""Connection.TRANSACTION_SERIALIZABLE"".equals(value)) {
                        ds.setDefaultTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
                    }
                } catch (NumberFormatException ignore) {}
            } else if (""initialsize"".equals(name)) {
                try {
                    ds.setInitialSize(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxactive"".equals(name)) {
                try {
                    ds.setMaxActive(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxidle"".equals(name)) {
                try {
                    ds.setMaxIdle(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxopenstatements"".equals(name)) {
                try {
                    ds.setMaxOpenPreparedStatements(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""maxwait"".equals(name)) {
                try {
                    ds.setMaxWait(Long.parseLong(value));
                } catch (NumberFormatException ignore) {}
            } else if (""minidle"".equals(name)) {
                try {
                    ds.setMinIdle(Integer.parseInt(value));
                } catch (NumberFormatException ignore) {}
            } else if (""poolstatements"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setPoolPreparedStatements(true);
                } else if (""false"".equals(value)) {
                    ds.setPoolPreparedStatements(false);
                }
            } else if (""testonborrow"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestOnBorrow(true);
                } else if (""false"".equals(value)) {
                    ds.setTestOnBorrow(false);
                }
            } else if (""testonreturn"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestOnReturn(true);
                } else if (""false"".equals(value)) {
                    ds.setTestOnReturn(false);
                }
            } else if (""testwhileidle"".equals(name)) {
                if (""true"".equals(value)) {
                    ds.setTestWhileIdle(true);
                } else if (""false"".equals(value)) {
                    ds.setTestWhileIdle(false);
                }
            } else if (""validationquery"".equals(name)) {
                ds.setValidationQuery(value);
            }
        }
        return ds;
    }

    protected void processStatements(OMElement elem, AbstractDBMediator mediator) {

        Iterator iter = elem.getChildrenWithName(STMNT_Q);
        while (iter.hasNext()) {

            OMElement stmntElt = (OMElement) iter.next();
            Statement statement = new Statement(getValue(stmntElt, SQL_Q));

            Iterator paramIter = stmntElt.getChildrenWithName(PARAM_Q);
            while (paramIter.hasNext()) {

                OMElement paramElt = (OMElement) paramIter.next();
                String xpath = getAttribute(paramElt, ATT_EXPRN);
                String value = getAttribute(paramElt, ATT_VALUE);

                if (xpath != null || value != null) {
                    
                    SynapseXPath xp = null;
                    if (xpath != null) {
                        try {
                            xp = SynapseXPathFactory.getSynapseXPath(paramElt, ATT_EXPRN);

                        } catch (JaxenException e) {
                            handleException(""Invalid XPath specified for the source attribute : "" +
                                    xpath);
                        }
                    }
                    statement.addParameter(
                            value,
                            xp,
                            getAttribute(paramElt, ATT_TYPE));
                }
            }

            Iterator resultIter = stmntElt.getChildrenWithName(RESULT_Q);
            while (resultIter.hasNext()) {

                OMElement resultElt = (OMElement) resultIter.next();
                statement.addResult(
                    getAttribute(resultElt, ATT_NAME),
                    getAttribute(resultElt, ATT_COLUMN));
            }

            mediator.addStatement(statement);
        }
    }

    protected String getValue(OMElement elt, QName qName) {
        OMElement e = elt.getFirstChildWithName(qName);
        if (e != null) {
            return e.getText();
        } else {
            handleException(""Unable to read configuration value for : "" + qName);
        }
        return null;
    }

    protected String getAttribute(OMElement elt, QName qName) {
        OMAttribute a = elt.getAttribute(qName);
        if (a != null) {
            return a.getAttributeValue();
        }
        return null;
    }
}

"
org/apache/synapse/config/xml/endpoints/XMLToEndpointMapper.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMNode;
import org.apache.axiom.om.OMElement;

/**
 * This is a generic XMLToObjectMapper implementation for all endpoint types. Use this if the endpoint
 * type is not known at the time mapper is created. If the endpoint type is known use the EndpointFactory
 * implementation for that specific endpoint.
 */
public class XMLToEndpointMapper implements XMLToObjectMapper {

    private static XMLToEndpointMapper instance = new XMLToEndpointMapper();

    private XMLToEndpointMapper() {}

    public static XMLToEndpointMapper getInstance() {
        return instance;
    }

    /**
     * Constructs the Endpoint implementation for the given OMNode.
     *
     * @param om OMNode containig endpoint configuration. This should be an OMElement.
     * @return Endpoint implementaiotn for the given OMNode.
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            OMElement epElement = (OMElement) om;
            return EndpointFactory.getEndpointFromElement(epElement, false);
        } else {
            throw new SynapseException(""Configuration is not in proper format."");
        }
    }
}
"
org/apache/synapse/config/xml/AbstractMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.xpath.AXIOMXPath;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;

import javax.xml.namespace.QName;
import java.util.Collection;
import java.util.Iterator;

public abstract class AbstractMediatorSerializer implements MediatorSerializer {

    /** the standard log for mediators, will assign the logger for the actual subclass */
    protected static Log log;

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS
            = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS
            = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");
    protected static final QName PROP_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property"", ""syn"");

    /**
     * A constructor that makes subclasses pick up the correct logger
     */
    protected AbstractMediatorSerializer() {
        log = LogFactory.getLog(this.getClass());
    }

    /**
     * Perform common functions and finalize the mediator serialization.
     * i.e. process any common attributes
     *
     * @param mediatorOmElement the OMElement being created
     * @param mediator          the Mediator instance being serialized
     */
    protected static void saveTracingState(OMElement mediatorOmElement, Mediator mediator) {
        int traceState = mediator.getTraceState();
        String traceValue = null;
        if (traceState == org.apache.synapse.SynapseConstants.TRACING_ON) {
            traceValue = XMLConfigConstants.TRACE_ENABLE;
        } else if (traceState == org.apache.synapse.SynapseConstants.TRACING_OFF) {
            traceValue = XMLConfigConstants.TRACE_DISABLE;
        }
        if (traceValue != null) {
            mediatorOmElement.addAttribute(fac.createOMAttribute(
                XMLConfigConstants.TRACE_ATTRIB_NAME, nullNS, traceValue));
        }

    }

    protected void serializeMediatorProperties(OMElement parent, Collection props) {

        Iterator iter = props.iterator();
        while (iter.hasNext()) {
            MediatorProperty mp = (MediatorProperty) iter.next();
            OMElement prop = fac.createOMElement(""property"", synNS, parent);
            if (mp.getName() != null) {
                prop.addAttribute(fac.createOMAttribute(""name"", nullNS, mp.getName()));
            } else {
                handleException(""Mediator property name missing"");
            }

            if (mp.getValue() != null) {
                prop.addAttribute(fac.createOMAttribute(""value"", nullNS, mp.getValue()));

            } else if (mp.getExpression() != null) {
                SynapseXPathSerializer.serializeXPath(mp.getExpression(), prop, ""expression"");

            } else {
                handleException(""Mediator property must have a literal value or be an expression"");
            }
        }
    }

    protected void serializeProperties(OMElement parent, Collection props) {
        serializeMediatorProperties(parent, props);
    }

    protected void serializeNamespaces(OMElement elem, AXIOMXPath xpath) {
        Iterator iter = xpath.getNamespaces().keySet().iterator();
        while (iter.hasNext()) {
            String prefix = (String) iter.next();
            String uri = xpath.getNamespaceContext().translateNamespacePrefixToUri(prefix);
            if (!XMLConfigConstants.SYNAPSE_NAMESPACE.equals(uri)) {
                elem.declareNamespace(uri, prefix);
            }
        }
    }

    protected void handleException(String msg) {
        LogFactory.getLog(this.getClass()).error(msg);
        throw new SynapseException(msg);
    }

    protected void handleException(String msg, Exception e) {
        LogFactory.getLog(this.getClass()).error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/SwitchMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.SwitchMediator;

import java.util.Iterator;

/**
 * Factory for {@link SwitchMediator} instances.
 * 
 * @see SwitchMediatorFactory
 */
public class SwitchMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SwitchMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SwitchMediator mediator = (SwitchMediator) m;
        OMElement switchMed = fac.createOMElement(""switch"", synNS);
        saveTracingState(switchMed, mediator);

        if (mediator.getSource() != null) {
            SynapseXPathSerializer.serializeXPath(mediator.getSource(), switchMed, ""source"");

        } else {
            handleException(""Invalid switch mediator. Source required"");
        }

        Iterator iter = mediator.getCases().iterator();
        while (iter.hasNext()) {
            OMElement caseElem = fac.createOMElement(""case"", synNS);
            SwitchCase aCase = ((SwitchCase) iter.next());
            if (aCase.getRegex() != null) {
                caseElem.addAttribute(fac.createOMAttribute(
                        ""regex"", nullNS, aCase.getRegex().pattern()));
            } else {
                handleException(""Invalid switch case. Regex required"");
            }
            AnonymousListMediator caseMediator = aCase.getCaseMediator();
            if (caseMediator != null) {
                new AnonymousListMediatorSerializer().serializeMediator(
                        caseElem, caseMediator);
                switchMed.addChild(caseElem);
            }
        }
        SwitchCase defaultCase = mediator.getDefaultCase();
        if (defaultCase != null) {
            OMElement caseDefaultElem = fac.createOMElement(""default"", synNS);
            AnonymousListMediator caseDefaultMediator = defaultCase.getCaseMediator();
            if (caseDefaultMediator != null) {
                new AnonymousListMediatorSerializer().serializeMediator(
                        caseDefaultElem, caseDefaultMediator);
                switchMed.addChild(caseDefaultElem);
            }
        }
        if (parent != null) {
            parent.addChild(switchMed);
        }
        return switchMed;
    }

    public String getMediatorClassName() {
        return SwitchMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/builtin/CalloutMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.transport.http.HTTPConstants;
import org.apache.axis2.description.Parameter;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.ServiceClient;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.ConfigurationContextFactory;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.MessageHelper;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import java.util.List;

/**
 * <callout serviceURL=""string"" [action=""string""]>
 *      <configuration [axis2xml=""string""] [repository=""string""]/>?
 *      <source xpath=""expression"" | key=""string""> <!-- key can be a MC property or entry key -->
 *      <target xpath=""expression"" | key=""string""/>
 * </callout>
 */
public class CalloutMediator extends AbstractMediator implements ManagedLifecycle {

    private ServiceClient sc = null;
    private String serviceURL = null;
    private String action = null;
    private String requestKey = null;
    private SynapseXPath requestXPath = null;
    private SynapseXPath targetXPath = null;
    private String targetKey = null;
    private String clientRepository = null;
    private String axis2xml = null;
    public static String DEFAULT_CLIENT_REPO = ""./samples/axis2Client/client_repo"";
    public static String DEFAULT_AXIS2_XML = ""./samples/axis2Client/client_repo/conf/axis2.xml"";

    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Callout mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        try {
            Options options = new Options();
            options.setTo(new EndpointReference(serviceURL));

            if (action != null) {
                options.setAction(action);
            } else {
                if (synCtx.isSOAP11()) {
                    options.setProperty(Constants.Configuration.DISABLE_SOAP_ACTION, true);
                } else {
                    Axis2MessageContext axis2smc = (Axis2MessageContext) synCtx;
                    org.apache.axis2.context.MessageContext axis2MessageCtx =
                            axis2smc.getAxis2MessageContext();
                    axis2MessageCtx.getTransportOut().addParameter(
                            new Parameter(HTTPConstants.OMIT_SOAP_12_ACTION, true));
                }
            }

            options.setProperty(
                    AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);
            sc.setOptions(options);

            OMElement request = getRequestPayload(synCtx);
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""About to invoke service : "" + serviceURL + (action != null ?
                    "" with action : "" + action : """"));
                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Request message payload : "" + request);
                }
            }

            OMElement result = sc.sendReceive(request);

            if (traceOrDebugOn) {
                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Response payload received : "" + result);
                }
            }

            if (result != null) {
                if (targetXPath != null) {
                    Object o = targetXPath.evaluate(synCtx);

                    if (o != null && o instanceof OMElement) {
                        OMNode tgtNode = (OMElement) o;
                        tgtNode.insertSiblingAfter(result);
                        tgtNode.detach();
                    } else if (o != null && o instanceof List && !((List) o).isEmpty()) {
                        // Always fetches *only* the first
                        OMNode tgtNode = (OMElement) ((List) o).get(0);
                        tgtNode.insertSiblingAfter(result);
                        tgtNode.detach();
                    } else {
                        handleException(""Evaluation of target XPath expression : "" +
                            targetXPath.toString() + "" did not yeild an OMNode"", synCtx);
                    }
                } if (targetKey != null) {
                    synCtx.setProperty(targetKey, result);
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Service returned a null response"");
                }
            }

        } catch (Exception e) {
            handleException(""Error invoking service : "" + serviceURL +
                (action != null ? "" with action : "" + action : """"), e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Callout mediator"");
        }
        return true;
    }

    private OMElement getRequestPayload(MessageContext synCtx) throws AxisFault {

        if (requestKey != null) {
            Object request = synCtx.getProperty(requestKey);
            if (request == null) {
                request = synCtx.getEntry(requestKey);
            }
            if (request != null && request instanceof OMElement) {
                return (OMElement) request;
            } else {
                handleException(""The property : "" + requestKey + "" is not an OMElement"", synCtx);
            }
        } else if (requestXPath != null) {
            try {
                Object o = null;
                o = requestXPath.evaluate(MessageHelper.cloneMessageContext(synCtx));

                if (o instanceof OMElement) {
                    return (OMElement) o;
                } else if (o instanceof List && !((List) o).isEmpty()) {
                    return (OMElement) ((List) o).get(0);  // Always fetches *only* the first
                } else {
                    handleException(""The evaluation of the XPath expression : ""
                        + requestXPath.toString() + "" did not result in an OMElement"", synCtx);
                }
            } catch (JaxenException e) {
                handleException(""Error evaluating XPath expression : ""
                        + requestXPath.toString(), e, synCtx);
            }
        }
        return null;
    }

    public void init(SynapseEnvironment synEnv) {
        try {
            ConfigurationContext cfgCtx
                    = ConfigurationContextFactory.createConfigurationContextFromFileSystem(
                    clientRepository != null ? clientRepository : DEFAULT_CLIENT_REPO,
                    axis2xml != null ? axis2xml : DEFAULT_AXIS2_XML);
            sc = new ServiceClient(cfgCtx, null);
        } catch (AxisFault e) {
            String msg = ""Error initializing callout mediator : "" + e.getMessage();
            log.error(msg, e);
            throw new SynapseException(msg, e);
        }
    }

    public void destroy() {
        try {
            sc.cleanup();
        } catch (AxisFault ignore) {}
    }

    public String getServiceURL() {
        return serviceURL;
    }

    public void setServiceURL(String serviceURL) {
        this.serviceURL = serviceURL;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getRequestKey() {
        return requestKey;
    }

    public void setRequestKey(String requestKey) {
        this.requestKey = requestKey;
    }

    public void setRequestXPath(SynapseXPath requestXPath) throws JaxenException {
        this.requestXPath = requestXPath;
    }

    public void setTargetXPath(SynapseXPath targetXPath) throws JaxenException {
        this.targetXPath = targetXPath;
    }

    public String getTargetKey() {
        return targetKey;
    }

    public void setTargetKey(String targetKey) {
        this.targetKey = targetKey;
    }

    public SynapseXPath getRequestXPath() {
        return requestXPath;
    }

    public SynapseXPath getTargetXPath() {
        return targetXPath;
    }

    public String getClientRepository() {
        return clientRepository;
    }

    public void setClientRepository(String clientRepository) {
        this.clientRepository = clientRepository;
    }

    public String getAxis2xml() {
        return axis2xml;
    }

    public void setAxis2xml(String axis2xml) {
        this.axis2xml = axis2xml;
    }
}
"
org/apache/synapse/Startup.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import javax.xml.namespace.QName;

/**
 * This startup interface will be instantiated to create startup tasks.
 */
public interface Startup extends ManagedLifecycle {

    /**
     * This will return the configuration tag QName of the implemented startup
     *
     * @return QName representing the configuraiton element for the startup
     */
    public abstract QName getTagQName();

    /**
     * This will return the name of the startup
     *
     * @return String representing the name
     */
    public String getName();

    /**
     * This will set the name of a Startup
     *
     * @param id String name to be set to the startup
     */
    public void setName(String id);
}
"
org/apache/synapse/config/xml/MediatorFactoryFinder.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.XMLToObjectMapper;
import sun.misc.Service;

import javax.xml.namespace.QName;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 *
 * 
 * This class is based on J2SE Service Provider model
 * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
 */

public  class MediatorFactoryFinder implements XMLToObjectMapper {

	private static final Log log = LogFactory.getLog(MediatorFactoryFinder.class);

	private static final Class[] mediatorFactories = {
        SequenceMediatorFactory.class,
        LogMediatorFactory.class,
        SendMediatorFactory.class,         
        FilterMediatorFactory.class,
        SynapseMediatorFactory.class,
        DropMediatorFactory.class,
        HeaderMediatorFactory.class,
        FaultMediatorFactory.class,
        PropertyMediatorFactory.class,
        SwitchMediatorFactory.class,
        InMediatorFactory.class,
        OutMediatorFactory.class,
        RMSequenceMediatorFactory.class,          
        ClassMediatorFactory.class,
        ValidateMediatorFactory.class,
        XSLTMediatorFactory.class,
        AnnotatedCommandMediatorFactory.class,
        POJOCommandMediatorFactory.class,
        CloneMediatorFactory.class,
        IterateMediatorFactory.class,
        AggregateMediatorFactory.class,
        DBReportMediatorFactory.class,
        DBLookupMediatorFactory.class,
        CacheMediatorFactory.class,
        CalloutMediatorFactory.class
    };

    private static MediatorFactoryFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map<QName, Class> factoryMap = new HashMap<QName, Class>();

    public static synchronized MediatorFactoryFinder getInstance() {
        if (instance == null) {
            instance = new MediatorFactoryFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private MediatorFactoryFinder() {

        factoryMap = new HashMap<QName, Class>();

        for (Class c : mediatorFactories) {
            try {
                MediatorFactory fac = (MediatorFactory) c.newInstance();
                factoryMap.put(fac.getTagQName(), c);
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    /**
     * Register pluggable mediator factories from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        // register MediatorFactory extensions
        Iterator it = Service.providers(MediatorFactory.class);
        while (it.hasNext()) {
            MediatorFactory mf = (MediatorFactory) it.next();
            QName tag = mf.getTagQName();
            factoryMap.put(tag, mf.getClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorFactory "" + mf.getClass() + "" to handle "" + tag);
            }
        }
    }

    /**
	 * This method returns a Processor given an OMElement. This will be used
	 * recursively by the elements which contain processor elements themselves
	 * (e.g. rules)
	 * 
	 * @param element XML representation of a mediator
     * @return Processor
	 */
	public Mediator getMediator(OMElement element) {

        String localName = element.getLocalName();
        QName qName;
        if (element.getNamespace() != null) {
            qName = new QName(element.getNamespace().getNamespaceURI(), localName);
        } else {
            qName = new QName(localName);
        }
        if (log.isDebugEnabled()) {
            log.debug(""getMediator("" + qName + "")"");
        }
        Class cls = factoryMap.get(qName);

        if (cls == null && localName.indexOf('.') > -1) {
            String newLocalName = localName.substring(0, localName.indexOf('.'));
            qName = new QName(element.getNamespace().getNamespaceURI(), newLocalName);
            if (log.isDebugEnabled()) {
                log.debug(""getMediator.2("" + qName + "")"");
            }
            cls = factoryMap.get(qName);
        }

        if (cls == null) {
            String msg = ""Unknown mediator referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
			MediatorFactory mf = (MediatorFactory) cls.newInstance();
			return mf.createMediator(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing mediator factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
		}
	}
    
    /**
     * This method exposes all the MediatorFactories and its Extensions
     * @return factoryMap
     */
    public Map<QName, Class> getFactoryMap() {
        return factoryMap;
    }

    /**
     * Allow the mediator factory finder to act as an XMLToObjectMapper for Mediators
     * (i.e. Sequence Mediator) loaded dynamically from a Registry 
     * @param om node from which the object is expected
     * @return Object buit from the om node
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getMediator((OMElement) om);
        } else {
            handleException(""Invalid mediator configuration XML : "" + om);
        }
        return null;
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

}
"
org/apache/synapse/config/xml/AbstractListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;

import java.util.Iterator;
import java.util.List;

public abstract class AbstractListMediatorSerializer extends AbstractMediatorSerializer {

    protected void serializeChildren(OMElement parent, List list) {
        Iterator iter = list.iterator();
        while (iter.hasNext()) {
            Mediator child = (Mediator) iter.next();
            MediatorSerializer medSer = MediatorSerializerFinder.getInstance().getSerializer(child);
            if (medSer != null) {
                medSer.serializeMediator(parent, child);
            } else {
                handleException(""Unable to find a serializer for mediator : "" + child.getType());
            }
        }
    }
}
"
org/apache/synapse/config/xml/TargetSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.mediators.eip.Target;

/**
 * Serializer for {@link Target} instances.
 * 
 * @see TargetFactory
 */
public class TargetSerializer {

    /**
     * This holds the OMFactory to be used for the OMElement creations
     */
    private static final OMFactory fac = OMAbstractFactory.getOMFactory();

    /**
     * This holds the Synapse namesapce for all the elements (qualified from default)
     */
    private static final OMNamespace synNS
            = fac.createOMNamespace(XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");

    /**
     * This holds the null namespace for all the attributes (unqualified from default)
     */
    private static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * This static method will serialize the Target object to the target elements
     *
     * @param target - Target which is subjected to the serialization
     * @return OMElement representing the serialized Target
     */
    public static OMElement serializeTarget(Target target) {

        OMElement targetElem = fac.createOMElement(""target"", synNS);
        if (target.getToAddress() != null) {
            targetElem.addAttribute(""to"", target.getToAddress(), nullNS);
        }

        if (target.getSoapAction() != null) {
            targetElem.addAttribute(""soapAction"", target.getSoapAction(), nullNS);
        }

        if (target.getSequenceRef() != null) {
            targetElem.addAttribute(""sequence"", target.getSequenceRef(), nullNS);
        }

        if (target.getEndpointRef() != null) {
            targetElem.addAttribute(""endpoint"", target.getEndpointRef(), nullNS);
        }

        if (target.getSequence() != null) {
            SequenceMediatorSerializer serializer = new SequenceMediatorSerializer();
            serializer.serializeAnonymousSequence(targetElem, target.getSequence());
        }

        if (target.getEndpoint() != null) {
            targetElem.addChild(EndpointSerializer.getElementFromEndpoint(target.getEndpoint()));
        }

        return targetElem;
    }
}
"
org/apache/synapse/config/xml/TargetFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.synapse.mediators.eip.Target;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Factory for {@link Target} instances.
 * <p>
 * This will build the Target util object for EIP mediators using
 * &lt;target&gt; element specified as follows
 *
 * &lt;target (sequence=""string reference"")? (endpoint=""string reference"")?&gt;
 *  (&lt;sequence&gt; | &lt;endpoinit&gt;)?
 * &lt;/target&gt;
 */
public class TargetFactory {

    /**
     * This will hold the logger for the logging purposes
     */
    private static final Log log = LogFactory.getLog(TargetFactory.class);

    /**
     * Holds the QName of the target element in the xml configuration
     */
    private static final QName TARGET_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * This static method will be used to build the Target from the specified element
     * 
     * @param elem - OMElement describing the xml configuration of the target
     * @return Target built by parsing the given element
     */
    public static Target createTarget(OMElement elem) {

        if (!TARGET_Q.equals(elem.getQName())) {
            handleException(""Element does not match with the target QName"");
        }

        Target target = new Target();
        OMAttribute toAttr = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""to""));
        if (toAttr != null && toAttr.getAttributeValue() != null) {
            target.setToAddress(toAttr.getAttributeValue());
        }

        OMAttribute soapAction = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""soapAction""));
        if (soapAction != null && soapAction.getAttributeValue() != null) {
            target.setSoapAction(soapAction.getAttributeValue());
        }

        OMAttribute sequenceAttr = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""sequence""));
        if (sequenceAttr != null && sequenceAttr.getAttributeValue() != null) {
            target.setSequenceRef(sequenceAttr.getAttributeValue());
        }

        OMAttribute endpointAttr = elem.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""endpoint""));
        if (endpointAttr != null && endpointAttr.getAttributeValue() != null) {
            target.setEndpointRef(endpointAttr.getAttributeValue());
        }

        OMElement sequence = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""sequence""));
        if (sequence != null) {
            SequenceMediatorFactory fac = new SequenceMediatorFactory();
            target.setSequence(fac.createAnonymousSequence(sequence));
        }

        OMElement endpoint = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint""));
        if (endpoint != null) {
            target.setEndpoint(EndpointFactory.getEndpointFromElement(endpoint, true));
        }

        return target;
    }

    /**
     * This private method is used for exception handling and logging purposes.
     *
     * @param message - String message to be logged and the message of the exception
     */
    private static void handleException (String message) {
        if (log.isDebugEnabled()) {
            log.debug(message);
        }
        throw new SynapseException(message);
    }
}
"
org/apache/synapse/mediators/annotations/Namespaces.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.annotations;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 * Annotation used to declare namespaces available to be used in XPATH expressions
 * 
 * To support setting multiple namespaces with arbitrary prefixes the namespace and 
 * namespace prefix are held in as a single string value seperated by a colon. For
 * example, ""ns:http://tempuri.org"" represents the namespace uri http://tempuri.org
 * and the namespace prefix ""ns"", and the complete Namespaces annotation for that
 * example would be @Namespaces({""ns:http://tempuri.org""})
 */
@Target({TYPE, FIELD, METHOD})
@Retention(RUNTIME)
public @interface Namespaces {

    String[] value();

}
"
org/apache/synapse/statistics/StatisticsHolder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

/**
 * To hold statistics that will collected during both of in and out message mediation
 */

public class StatisticsHolder {

    private int statisticsCategory ;

    private String key ;

    /**  The statistics that will collect during in coming message mediation  */
    private Statistics inFlowStatistics;

    /**  The statistics that will collect during out going message mediation  */
    private Statistics outFlowStatistics;

    /**
     * To update the statistics
     *
     * @param isResponse - A boolean value that indicate whether message flow is in or out
     * @param inTime     - The processing start time
     * @param outTime    - The processing end time
     * @param isFault    - A boolean value that indicate whether falut has occured or not
     */
    public synchronized void update(boolean isResponse, long inTime, long outTime,
                                    boolean isFault) {
        if (isResponse) {
            if (outFlowStatistics == null) {
                outFlowStatistics = new Statistics();
            }
            outFlowStatistics.update(inTime, outTime, isFault);
        } else {
            if (inFlowStatistics == null) {
                inFlowStatistics = new Statistics();
            }
            inFlowStatistics.update(inTime, outTime, isFault);
        }

    }

    /**
     * To get Statistics related to the In Flow
     * @return  Statistics related to the In Flow
     */
    public synchronized Statistics getInFlowStatistics() {
        return inFlowStatistics;
    }

    /**
     * To get Statistics related to the Out Flow
     * @return  Statistics related to the Out Flow
     */
    public synchronized Statistics getOutFlowStatistics() {
        return outFlowStatistics;
    }

    /**
     * To get statistics category
     * @return  Statistics Category
     */
    public int getStatisticsCategory() {
        return statisticsCategory;
    }

    /**
     * To set statistics category
     * @param statisticsCategory
     */
    public void setStatisticsCategory(int statisticsCategory) {
        this.statisticsCategory = statisticsCategory;
    }

    /**
     * To get key of statistics
     * @return   key of statistics
     */
    public String getKey() {
        return key;
    }

    /**
     * To set key of statistics
     * @param key
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * To clear stored statistics
     */
    public synchronized void clearStatistics(){
        this.inFlowStatistics =null;
        this.outFlowStatistics=null;
    }
}
"
org/apache/synapse/util/PolicyInfo.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.axis2.wsdl.WSDLConstants;

import javax.xml.namespace.QName;

/**
 * Keeps the information on the Proxy service Policies
 */
public class PolicyInfo {

    private String policyKey;
    private int type;
    private QName operation;

    public static final int MESSAGE_TYPE_IN = 1;
    public static final int MESSAGE_TYPE_OUT = 2;

    public PolicyInfo(String policyKey) {
        this.policyKey = policyKey;
    }

    public PolicyInfo(String policyKey, int type) {
        this.policyKey = policyKey;
        this.type = type;
    }

    public PolicyInfo(String policyKey, QName operation) {
        this.policyKey = policyKey;
        this.operation = operation;
    }

    public PolicyInfo(String policyKey, int type, QName operation) {
        this.policyKey = policyKey;
        this.type = type;
        this.operation = operation;
    }

    public boolean isServicePolicy() {
        return policyKey != null && type == 0 && operation == null;
    }

    public boolean isOperationPolicy() {
        return policyKey != null && type == 0 && operation != null;
    }

    public boolean isMessagePolicy() {
        return policyKey != null && type != 0;
    }

    public String getMessageLable() {
        if (type == MESSAGE_TYPE_IN) {
            return WSDLConstants.MESSAGE_LABEL_IN_VALUE;
        } else if (type == MESSAGE_TYPE_OUT) {
            return WSDLConstants.MESSAGE_LABEL_OUT_VALUE;
        } else {
            return null;
        }
    }

    public String getPolicyKey() {
        return policyKey;
    }

    public void setPolicyKey(String policyKey) {
        this.policyKey = policyKey;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public QName getOperation() {
        return operation;
    }

    public void setOperation(QName operation) {
        this.operation = operation;
    }
}
"
org/apache/synapse/config/xml/ConfigurationSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.io.OutputStream;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import org.apache.synapse.config.SynapseConfiguration;
import org.apache.axiom.om.OMElement;

/**
 * This interface defines the configuration serializers of Synapse.
 */
public interface ConfigurationSerializer {

    /**
     * Serializes the given configuration to an OMElement.
     *
     * @param synCfg Configuration to be serialized
     * @return OMElement describing the configuraiton
     */
    OMElement serializeConfiguration(SynapseConfiguration synCfg);

    /**
     * Get the tag QName of the element
     *
     * @return QName describing the element name
     */
    QName getTagQName();

}
"
org/apache/synapse/mediators/db/AbstractDBMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.commons.dbcp.BasicDataSource;
import org.apache.commons.dbcp.datasources.PerUserPoolDataSource;
import org.apache.commons.logging.Log;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.config.xml.AbstractDBMediatorFactory;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.mediators.AbstractMediator;

import javax.sql.DataSource;
import javax.xml.namespace.QName;
import java.math.BigDecimal;
import java.sql.*;
import java.sql.Date;
import java.util.*;

/**
 * This abstract DB mediator will perform common DB connection pooling etc. for all DB mediators
 */
public abstract class AbstractDBMediator extends AbstractMediator implements ManagedLifecycle {

    /** Hold JDBC properties */
    protected Map dataSourceProps = new HashMap();
    /** The DataSource to get DB connections */
    private DataSource dataSource = null;
    /** Statements */
    List statementList = new ArrayList();

    /**
     * Initializes the mediator. Does nothing right now. If DataSource lookup is supported, could
     * do the IC lookup here
     * @param se the Synapse environment reference
     */
    public void init(SynapseEnvironment se) {
        // do nothing
    }

    /**
     * Destroys the mediator. If we are using our custom DataSource, then shut down the connections
     */
    public void destroy() {
        if (this.dataSource instanceof BasicDataSource) {
            try {
                ((BasicDataSource) this.dataSource).close();
                log.info(""Successfully shut down DB connection pool for URL : "" + getDSName());
            } catch (SQLException e) {
                log.warn(""Error shutting down DB connection pool for URL : "" + getDSName());
            }
        } else if (this.dataSource instanceof PerUserPoolDataSource) {
            ((PerUserPoolDataSource) this.dataSource).close();
            log.info(""Successfully shut down DB connection pool for URL : "" + getDSName());
        }
    }

    /**
     * Process each SQL statement against the current message
     * @param synCtx the current message
     * @return true, always
     */
    public boolean mediate(MessageContext synCtx) {

        String name = (this instanceof DBLookupMediator ? ""DBLookup"" : ""DBReport"");
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : "" + name + "" mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        for (Iterator iter = statementList.iterator(); iter.hasNext(); ) {
            processStatement((Statement) iter.next(), synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : "" + name + "" mediator"");
        }
        return true;
    }

    /**
     * Subclasses must specify how each SQL statement is processed
     * @param query the SQL statement
     * @param msgCtx current message
     */
    abstract protected void processStatement(Statement query, MessageContext msgCtx);

    /**
     * Return the name or (hopefully) unique connection URL specific to the DataSource being used
     * This is used for logging purposes only
     * @return a unique name or URL to refer to the DataSource being used
     */
    protected String getDSName() {
        return (String) dataSourceProps.get(AbstractDBMediatorFactory.URL_Q);
    }

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void addDataSourceProperty(QName name, String value) {
        dataSourceProps.put(name, value);
    }

    public void addDataSourceProperty(String name, String value) {
        dataSourceProps.put(name, value);
    }

    public Map getDataSourceProps() {
        return dataSourceProps;
    }

    public void addStatement(Statement stmnt) {
        statementList.add(stmnt);
    }

    public List getStatementList() {
        return statementList;
    }

    /**
     * Return a Prepared statement for the given Statement object, which is ready to be executed
     * @param stmnt
     * @param msgCtx
     * @return
     * @throws SQLException
     */
    protected PreparedStatement getPreparedStatement(Statement stmnt, MessageContext msgCtx) throws SQLException {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        Log serviceLog = msgCtx.getServiceLog();

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Getting a connection from DataSource "" + getDSName() +
                "" and preparing statement : "" + stmnt.getRawStatement());
        }
        Connection con = getDataSource().getConnection();
        PreparedStatement ps = con.prepareStatement(stmnt.getRawStatement());

        // set parameters if any
        List params = stmnt.getParameters();
        int column = 1;

        for (Iterator pi = params.iterator(); pi.hasNext(); ) {

            Statement.Parameter param = (Statement.Parameter) pi.next();
            String value = (param.getPropertyName() != null ?
                param.getPropertyName() : param.getXpath().stringValueOf(msgCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Setting as parameter : "" + column + "" value : "" + value +
                    "" as JDBC Type : "" + param.getType() + ""(see java.sql.Types for valid types)"");
            }

            switch (param.getType()) {
                // according to J2SE 1.5 /docs/guide/jdbc/getstart/mapping.html
                case Types.CHAR:
                case Types.VARCHAR:
                case Types.LONGVARCHAR: {
                    ps.setString(column++, value);
                    break;
                }
                case Types.NUMERIC:
                case Types.DECIMAL: {
                    ps.setBigDecimal(column++, new BigDecimal(value));
                    break;
                }
                case Types.BIT: {
                    ps.setBoolean(column++, Boolean.parseBoolean(value));
                    break;
                }
                case Types.TINYINT: {
                    ps.setByte(column++, Byte.parseByte(value));
                    break;
                }
                case Types.SMALLINT: {
                    ps.setShort(column++, Short.parseShort(value));
                    break;
                }
                case Types.INTEGER: {
                    ps.setInt(column++, Integer.parseInt(value));
                    break;
                }
                case Types.BIGINT: {
                    ps.setLong(column++, Long.parseLong(value));
                    break;
                }
                case Types.REAL: {
                    ps.setFloat(column++, Float.parseFloat(value));
                    break;
                }
                case Types.FLOAT: {
                    ps.setDouble(column++, Double.parseDouble(value));
                    break;
                }
                case Types.DOUBLE: {
                    ps.setDouble(column++, Double.parseDouble(value));
                    break;
                }
                // skip BINARY, VARBINARY and LONGVARBINARY
                case Types.DATE: {
                    ps.setDate(column++, Date.valueOf(value));
                    break;
                }
                case Types.TIME: {
                    ps.setTime(column++, Time.valueOf(value));
                    break;
                }
                case Types.TIMESTAMP: {
                    ps.setTimestamp(column++, Timestamp.valueOf(value));
                    break;
                }
                // skip CLOB, BLOB, ARRAY, DISTINCT, STRUCT, REF, JAVA_OBJECT
                default: {
                    String msg = ""Trying to set an un-supported JDBC Type : "" + param.getType() +
                        "" against column : "" + column + "" and statement : "" + stmnt.getRawStatement() +
                        "" used by a DB mediator against DataSource : "" + getDSName() +
                        "" (see java.sql.Types for valid type values)"";
                    handleException(msg, msgCtx);
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Successfully prepared statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName());
        }
        return ps;
    }
}
"
org/apache/synapse/config/xml/PropertyMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.PropertyMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Creates a property mediator through the supplied XML configuration
 * <p/>
 * <pre>
 * &lt;property name=""string"" [action=set/remove] (value=""literal"" | expression=""xpath"") [scope=(axis2 | axis2-client | transport)]/&gt;
 * </pre>
 */
public class PropertyMediatorFactory extends AbstractMediatorFactory {
    private static final QName ATT_SCOPE = new QName(""scope"");
    private static final QName ATT_ACTION = new QName(""action"");

    public Mediator createMediator(OMElement elem) {

        PropertyMediator propMediator = new PropertyMediator();
        OMAttribute name = elem.getAttribute(ATT_NAME);
        OMAttribute value = elem.getAttribute(ATT_VALUE);
        OMAttribute expression = elem.getAttribute(ATT_EXPRN);
        OMAttribute scope = elem.getAttribute(ATT_SCOPE);
        OMAttribute action = elem.getAttribute(ATT_ACTION);

        if (name == null) {
            String msg = ""The 'name' attribute is required for the configuration of a property mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else if ((value == null && expression == null) && !(action != null && ""remove"".equals(action.getAttributeValue()))) {
            String msg = ""Either an 'value' or 'expression' attribute is required for a property mediator when action is SET"";
            log.error(msg);
            throw new SynapseException(msg);
        }
        propMediator.setName(name.getAttributeValue());
        if (value != null) {
            propMediator.setValue(value.getAttributeValue());
        } else if (expression != null) {
            try {
                propMediator.setExpression(SynapseXPathFactory.getSynapseXPath(elem, ATT_EXPRN));

            } catch (JaxenException e) {
                String msg = ""Invalid XPath expression for attribute 'expression' : "" + expression.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        if (scope != null) {
            String valueStr = scope.getAttributeValue();
            if (!XMLConfigConstants.SCOPE_AXIS2.equals(valueStr) && !XMLConfigConstants.SCOPE_TRANSPORT.equals(valueStr)
                    && !XMLConfigConstants.SCOPE_DEFAULT.equals(valueStr) && !XMLConfigConstants.SCOPE_CLIENT.equals(valueStr)) {
                String msg = ""Only '"" + XMLConfigConstants.SCOPE_AXIS2 + ""' or '"" + XMLConfigConstants.SCOPE_TRANSPORT + ""' or '"" + XMLConfigConstants.SCOPE_CLIENT
                        + ""' values are allowed for attribute scope for a property mediator""
                        + "", Unsupported scope "" + valueStr;
                log.error(msg);
                throw new SynapseException(msg);
            }
            propMediator.setScope(valueStr);
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(propMediator, elem);
        // The action attribute is optional, if provided and equals to 'remove' the
        // property mediator will act as a property remove mediator
        if (action != null && ""remove"".equals(action.getAttributeValue())) {
            propMediator.setAction(PropertyMediator.ACTION_REMOVE);
        }
        return propMediator;
    }

    public QName getTagQName() {
        return PROP_Q;
    }
}
"
org/apache/synapse/config/xml/StartupSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Startup;

/**
 * Defines the serialization of Startups
 */
public interface StartupSerializer {

    /**
     * Serializes the Startup to an OMElement and
     * attaches as a child to the provided parent OMElement
     *
     * @param parent  - OMElement to which, serialized startup will be attached
     * @param startup - Startup to be serialized
     * @return Serialized OMElement
     */
    public OMElement serializeStartup(OMElement parent, Startup startup);
}"
org/apache/synapse/config/xml/OutMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.OutMediator;

import javax.xml.namespace.QName;

/**
 * Creates an Out mediator instance
 *
 * <pre>
 * &lt;out&gt;
 *    mediator+
 * &lt;/out&gt;
 * </pre>
 */
public class OutMediatorFactory extends AbstractListMediatorFactory {

    private static final QName OUT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""out"");

    public Mediator createMediator(OMElement elem) {
        OutMediator filter = new OutMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);

        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return OUT_Q;
    }
}
"
org/apache/synapse/mediators/filters/InMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The In Mediator acts only on ""incoming"" messages into synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class InMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : In mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = true;
        if (test(synCtx)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is incoming - executing child mediators"");
            }
            result = super.mediate(synCtx);

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is a response - skipping child mediators"");
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : In mediator"");
        }

        return result;
    }

    /**
     * Apply mediation only on request messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return !synCtx.isResponse();
    }
}
"
org/apache/synapse/MessageContext.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;


import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.commons.logging.Log;

import java.util.Set;
import java.util.Stack;
import java.util.Map;


/**
 * The Synapse Message Context is available to all mediators through which it flows. It
 * allows one to call to the underlying SynapseEnvironment (i.e. the SOAP engine
 * - such as Axis2) where required. It also allows one to access the current
 * SynapseConfiguration. Additionally it holds per message properties (i.e. local
 * properties valid for the lifetime of the message), and the current SOAPEnvelope
 */
public interface MessageContext {

    /**
     * Get a reference to the current SynapseConfiguration
     *
     * @return the current synapse configuration
     */
    public SynapseConfiguration getConfiguration();

    /**
     * Set or replace the Synapse Configuration instance to be used. May be used to
     * programatically change the configuration at runtime etc.
     *
     * @param cfg The new synapse configuration instance
     */
    public void setConfiguration(SynapseConfiguration cfg);

    /**
     * Returns a reference to the host Synapse Environment
     * @return the Synapse Environment
     */
    public SynapseEnvironment getEnvironment();

    /**
     * Sets the SynapseEnvironment reference to this context
     * @param se the reference to the Synapse Environment
     */
    public void setEnvironment(SynapseEnvironment se);

    /**
     * Return all the entries which are in the MessageContext. This does not represent
     * all the declared entries in the configuration, rather only the entries that the
     * context has already used. This will not lookup for the entries in the Configuration.
     * @return the set of local entries in the context
     */
    public Map getContextEntries();

    /**
     * Sets the entries to the current context and not to the configuration. This can be
     * used to forcibly override an existing set of resources in the configuration, because
     * the resource lookup will look for the context first. But this only sets the entries
     * to the current context
     * @param entries the set of local entries to be set
     */
    public void setContextEntries(Map<String, Object> entries);

    /**
     * Return the main sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.MAIN_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the main sequence if the main
     * sequence was dynamic and changed in between at the registry
     * @return the main sequence to be used for mediation
     */
    public Mediator getMainSequence();

    /**
     * Return the fault sequence from the configuration, or the local message context
     * This method looks up for the sequence named Constants.FAULT_SEQUENCE_KEY from
     * the local message context to make this look up transactional - i.e. a request and
     * response message pair will not see a difference in the fault sequence if the fault
     * sequence was dynamic and changed in between at the registry
     * @return the fault sequence to be used for mediation
     */
    public Mediator getFaultSequence();

    /**
     * Return the sequence with the given key from the configuration, or the local message
     * context. This method looks up for the sequence with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said sequence if it was dynamic and
     * changed in between at the registry
     * @param key the sequence key to be looked up
     * @return the sequence mediator mapped to the key
     */
    public Mediator getSequence(String key);

    /**
     * Return the endpoint with the given key from the configuration, or the local message
     * context. This method looks up for the endpoint with the given key from the local
     * message context to make this look up transactional - i.e. a request and response
     * message pair will not see a difference in the said endpoint if it was dynamic and
     * changed in between at the registry
     * @param key the endpoint key to be looked up
     * @return the endpoint mapped to the key
     */
    public Endpoint getEndpoint(String key);

    /**
     * Get the value of a custom (local) property set on the message instance
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getProperty(String key);

    /**
     * Get the value of a property set on the message instance, from the local registry
     * or the remote registry - by cascading through
     * @param key key to look up property
     * @return value for the given key
     */
    public Object getEntry(String key);

    /**
     * Set a custom (local) property with the given name on the message instance
     * @param key key to be used
     * @param value value to be saved
     */
    public void setProperty(String key, Object value);

    /**
     * Returns the Set of keys over the properties on this message context
     * @return a Set of keys over message properties
     */
    public Set getPropertyKeySet();

    /**
     * Get the SOAP envelope of this message
     * @return the SOAP envelope of the message
     */
    public SOAPEnvelope getEnvelope();

    /**
     * Sets the given envelope as the current SOAPEnvelope for this message
     * @param envelope the envelope to be set
     * @throws org.apache.axis2.AxisFault on exception
     */
    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault;

    // --- SOAP Message related methods ------
    /**
     * Get the faultTo EPR if available
     * @return FaultTo epr if available
     */
    public EndpointReference getFaultTo();

    /**
     * Set the faultTo EPR
     * @param reference epr representing the FaultTo address
     */
    public void setFaultTo(EndpointReference reference);

    /**
     * Get the from EPR if available
     * @return From epr if available
     */
    public EndpointReference getFrom();

    /**
     * Set the from EPR
     * @param reference epr representing the From address
     */
    public void setFrom(EndpointReference reference);

    /**
     * Get the message id if available
     * @return message id if available
     */
    public String getMessageID();

    /**
     * Set the message id
     * @param string message id to be set
     */
    public void setMessageID(String string);

    /**
     * Get the relatesTo of this message
     * @return RelatesTo of the message if available
     */
    public RelatesTo getRelatesTo();

    /**
     * Sets the relatesTo references for this message
     * @param reference the relatesTo references array
     */
    public void setRelatesTo(RelatesTo[] reference);

    /**
     * Get the replyTo EPR if available
     * @return ReplyTo epr of the message if available
     */
    public EndpointReference getReplyTo();

    /**
     * Set the replyTo EPR
     * @param reference epr representing the ReplyTo address
     */
    public void setReplyTo(EndpointReference reference);

    /**
     * Get the To EPR
     * @return To epr of the message if available
     */
    public EndpointReference getTo();

     /**
     * Set the To EPR
     * @param reference the To EPR
     */
    public void setTo(EndpointReference reference);

    /**
     * Sets the WSAAction
     * @param actionURI the WSAAction
     */
    public void setWSAAction(String actionURI);

    /**
     * Returns the WSAAction
     * @return the WSAAction
     */
    public String getWSAAction();

    /**
     * Returns the SOAPAction of the message
     * @return the SOAPAction
     */
    public String getSoapAction();

    /**
     * Set the SOAPAction
     * @param string the SOAP Action
     */
    public void setSoapAction(String string);

    /**
     * Set the message
     * @param messageID message id to be set
     */
    public void setWSAMessageID(String messageID);

    /**
     * Gets the message name
     * @return the WSA MessageID
     */
    public String getWSAMessageID();

    /**
     * If this message using MTOM?
     * @return true if using MTOM
     */
    public boolean isDoingMTOM();

    /**
     * If this message using SWA?
     * @return true if using SWA
     */
    public boolean isDoingSWA();

    /**
     * Marks as using MTOM
     * @param b true to mark as using MTOM
     */
    public void setDoingMTOM(boolean b);

    /**
     * Marks as using SWA
     * @param b true to mark as using SWA
     */
    public void setDoingSWA(boolean b);

    /**
     * Is this message over POX?
     * @return true if over POX
     */
    public boolean isDoingPOX();

    /**
     * Marks this message as over POX
     * @param b true to mark as POX
     */
    public void setDoingPOX(boolean b);

    /**
     * Is this message over GET?
     * @return true if over GET
     */
    public boolean isDoingGET();

    /**
     * Marks this message as over REST/GET
     * @param b true to mark as REST/GET
     */
    public void setDoingGET(boolean b);

    /**
     * Is this message a SOAP 1.1 message?
     * @return true if this is a SOAP 1.1 message
     */
    public boolean isSOAP11();

    /**
     * Mark this message as a response or not.
     * @see org.apache.synapse.MessageContext#isResponse()
     * @param b true to set this as a response
     */
    public void setResponse(boolean b);

    /**
     * Is this message a response to a synchronous message sent out through Synapse?
     * @return true if this message is a response message
     */
    public boolean isResponse();

    /**
     * Marks this message as a fault response
     * @see org.apache.synapse.MessageContext#isFaultResponse()
     * @param b true to mark this as a fault response
     */
    public void setFaultResponse(boolean b);

    /**
     * Is this message a response to a fault message?
     * @return true if this is a response to a fault message
     */
    public boolean isFaultResponse();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return indicate whether tracing is on, off or unset
     */
    public int getTracingState();

    /**
     * This is used to set the value of tracing enable variable
     * @param tracingState Set whether the tracing is enabled or not
     */
    public void setTracingState(int tracingState);

    public Stack getFaultStack();

    public void pushFaultHandler(FaultHandler fault);

    /**
     * Return the service level Log for this message context or null
     * @return the service level Log for the message
     */
    public Log getServiceLog();
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

import javax.xml.namespace.QName;

/**
 * Creates {@link AddressEndpoint} using a XML configuration.
 * <p/>
 * Configuration syntax:
 * <pre>
 * &lt;endpoint [name=""<em>name</em>""]&gt;
 *   &lt;address uri=""<em>endpoint address</em>"" [format=""soap11|soap12|pox|get""] [optimize=""mtom|swa""]
 *            [encoding=""<em>charset encoding</em>""]
 *            [statistics=""enable|disable""] [trace=""enable|disable""]&gt;
 *     .. extensibility ..
 *
 *     &lt;enableRM [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableSec [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableAddressing [version=""final|submission""] [separateListener=""true|false""]/&gt;?
 *
 *     &lt;timeout&gt;
 *       &lt;duration&gt;<em>timeout duration in seconds</em>&lt;/duration&gt;
 *       &lt;action&gt;discard|fault&lt;/action&gt;
 *     &lt;/timeout&gt;?
 *
 *     &lt;suspendDurationOnFailure&gt;
 *       <em>suspend duration in seconds</em>
 *     &lt;/suspendDurationOnFailure&gt;?
 *   &lt;/address&gt;
 * &lt;/endpoint&gt;
 * </pre>
 */
public class AddressEndpointFactory extends DefaultEndpointFactory {

    private static AddressEndpointFactory instance = new AddressEndpointFactory();

    private AddressEndpointFactory() {
    }

    public static AddressEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        AddressEndpoint addressEndpoint = new AddressEndpoint();
        OMAttribute name = epConfig.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            addressEndpoint.setName(name.getAttributeValue());
        }

        OMElement addressElement = epConfig.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""address""));
        if (addressElement != null) {
            EndpointDefinition endpoint = createEndpointDefinition(addressElement);
            addressEndpoint.setEndpoint(endpoint);
        }

        return addressEndpoint;
    }

    /**
     * Creates an EndpointDefinition instance using the XML fragment specification. Configuration
     * for EndpointDefinition always resides inside a configuration of an AddressEndpoint. This
     * factory extracts the details related to the EPR provided for address endpoint.
     *
     * @param elem XML configuration element
     * @return EndpointDefinition object containing the endpoint details.
     */
    public EndpointDefinition createEndpointDefinition(OMElement elem) {

        OMAttribute address = elem.getAttribute(new QName(""uri""));
        EndpointDefinition endpointDefinition = new EndpointDefinition();

        if (address != null) {
            endpointDefinition.setAddress(address.getAttributeValue());
        }

        extractCommonEndpointProperties(endpointDefinition, elem);
        extractSpecificEndpointProperties(endpointDefinition,elem);
        return endpointDefinition;
    }
}
"
org/apache/synapse/core/axis2/SynapseAxisServlet.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.core.axis2;

import org.apache.axis2.transport.http.AxisServlet;
import org.apache.axis2.transport.http.ListingAgent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.ServerManager;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;

/**
 * Extends axis2 servlet functionality so that  avoid  starting listeners again
 */

public class SynapseAxisServlet extends AxisServlet {
    private final static Log log = LogFactory.getLog(SynapseAxisServlet.class);
    
    /**
     * Overrides init method so that avoid  starting listeners again
     *
     * @param config
     * @throws ServletException
     */
    public void init(ServletConfig config) throws ServletException {
        ServletContext servletContext = config.getServletContext();
        this.configContext = ServerManager.getInstance().getConfigurationContext();
        this.axisConfiguration = this.configContext.getAxisConfiguration();
        servletContext.setAttribute(this.getClass().getName(), this);
        this.servletConfig = config;
        agent = new ListingAgent(configContext);
        initParams();
    }

    public void initContextRoot(HttpServletRequest req) {
        this.configContext.setContextRoot(""/"");
    }
}
"
org/apache/synapse/config/xml/AnonymousListMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This is Serializer  for serialization of an anonymous list mediator(an unnamed list of mediators )
 */

public class AnonymousListMediatorSerializer extends AbstractListMediatorSerializer {

    /**
     * To serialize an  anonymous list mediator
     *
     * @param parent
     * @param m
     * @return OMElement
     */
    public OMElement serializeMediator(OMElement parent, Mediator m) {
        if (!(m instanceof AnonymousListMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        AnonymousListMediator mediator = (AnonymousListMediator) m;
        serializeChildren(parent, mediator.getList());
        return parent;
    }

    public String getMediatorClassName() {
        return AnonymousListMediator.class.getName();
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.axiom.om.OMElement;
import org.apache.axis2.util.XMLUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.CustomWSDLLocator;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.wsdl.Definition;
import javax.wsdl.Port;
import javax.wsdl.Service;
import javax.wsdl.WSDLException;
import javax.wsdl.extensions.soap.SOAPAddress;
import javax.wsdl.extensions.soap12.SOAP12Address;
import javax.wsdl.factory.WSDLFactory;
import javax.wsdl.xml.WSDLLocator;
import javax.wsdl.xml.WSDLReader;
import javax.xml.namespace.QName;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * Builds the EndpointDefinition containing the details for an epr using a WSDL 1.1 document.
 */
public class WSDL11EndpointBuilder {

    private static Log log = LogFactory.getLog(WSDL11EndpointBuilder.class);

    /**
     * Creates an EndpointDefinition for WSDL endpoint from an inline WSDL supplied in the WSDL
     * endpoint configuration.
     *
     * @param baseUri base uri of the wsdl
     * @param wsdl OMElement representing the inline WSDL
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    public EndpointDefinition createEndpointDefinitionFromWSDL
            (String baseUri, OMElement wsdl, String service, String port) {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            wsdl.serialize(baos);
            InputStream in = new ByteArrayInputStream(baos.toByteArray());
            InputSource inputSource = new InputSource(in);
            WSDLLocator wsdlLocator = new CustomWSDLLocator(inputSource,baseUri);
            Document doc = null;
            try {
                doc = XMLUtils.newDocument(inputSource);
            } catch (ParserConfigurationException e) {
                handleException(""Parser Configuration Error"", e);
            } catch (SAXException e) {
                handleException(""Parser SAX Error"", e);
            } catch (IOException e) {
                handleException(WSDLException.INVALID_WSDL+ ""IO Error"",e);
            }
            if (doc != null) {
                WSDLFactory fac = WSDLFactory.newInstance();
                WSDLReader reader = fac.newWSDLReader();
                Definition definition = reader.readWSDL(wsdlLocator, doc.getDocumentElement());
                return createEndpointDefinitionFromWSDL(definition, service, port);
            }
        } catch (XMLStreamException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the inline WSDL."");
        }

        return null;
    }

    /**
     * Creates an EndpointDefinition for WSDL endpoint from a WSDL document residing in the given URI.
     *
     * @param wsdlURI URI of the WSDL document
     * @param service Service of the endpoint
     * @param port Port of the endpoint
     *
     * @return EndpointDefinition containing the information retrieved from the WSDL
     */
    private EndpointDefinition createEndpointDefinitionFromWSDL
            (String wsdlURI, String service, String port) {

        try {
            WSDLFactory fac = WSDLFactory.newInstance();
            WSDLReader reader = fac.newWSDLReader();
            Definition definition = reader.readWSDL(wsdlURI);

            return createEndpointDefinitionFromWSDL(definition, service, port);

        } catch (WSDLException e) {
            handleException(""Error retrieving the WSDL definition from the WSDL URI."");
        }

        return null;
    }

    private EndpointDefinition createEndpointDefinitionFromWSDL
            (Definition definition, String serviceName, String portName) {

        if (definition == null) {
            handleException(""WSDL is not specified."");
        }

        if (serviceName == null) {
            handleException(""Service of the WSDL document is not specified."");
        }

        if (portName == null) {
            handleException(""Port of the WSDL document is not specified."");
        }


        String serviceURL = null;
        // get soap version from wsdl port and update endpoint definition below
        // so that correct soap version is used when endpoint is called
        String format = null; 
        String tns = definition.getTargetNamespace();
        Service service = definition.getService(new QName(tns, serviceName));
        if (service != null) {
            Port port = service.getPort(portName);
            if (port != null) {
                List ext = port.getExtensibilityElements();
                for (int i = 0; i < ext.size(); i++) {
                    Object o = ext.get(i);
                    if (o instanceof SOAPAddress) {
                        SOAPAddress address = (SOAPAddress) o;
                        serviceURL = address.getLocationURI();
                        format = SynapseConstants.FORMAT_SOAP11;
                        break;
                    } else if (o instanceof SOAP12Address) {
                        SOAP12Address address = (SOAP12Address) o;
                        serviceURL = address.getLocationURI();
                        format = SynapseConstants.FORMAT_SOAP12;
                        break;
                    }
                }
            }
        }

        if (serviceURL != null) {
            EndpointDefinition endpointDefinition = new EndpointDefinition();
            endpointDefinition.setAddress(serviceURL);
            if (SynapseConstants.FORMAT_SOAP11.equals(format)) {
                endpointDefinition.setForceSOAP11(true);
            } else if (SynapseConstants.FORMAT_SOAP12.equals(format)) {
                endpointDefinition.setForceSOAP12(true);
            } else {
                handleException(""format value -\"""" + format + ""\"" not yet implemented"");
            }
            endpointDefinition.setFormat(format);

            // todo: determine this using wsdl and policy                                    

            return endpointDefinition;

        } else {
            handleException(""Couldn't retrieve endpoint information from the WSDL."");
        }

        return null;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/startup/quartz/SimpleQuartzJob.java,false,"package org.apache.synapse.startup.quartz;

import java.util.Iterator;
import java.util.Set;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.startup.Task;
import org.apache.synapse.config.xml.PropertyHelper;
import org.apache.synapse.core.SynapseEnvironment;
import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

public class SimpleQuartzJob implements Job {
    public static final String
        SYNAPSE_ENVIRONMENT = ""SynapseEnvironment"",
        CLASSNAME = ""ClassName"",
        PROPERTIES = ""Properties"";
    private static final Log log = LogFactory.getLog(SimpleQuartzJob.class);

    public void execute(JobExecutionContext ctx) throws JobExecutionException {

        log.debug(""Executing task : "" + ctx.getJobDetail().getFullName());
        JobDataMap jdm = ctx.getMergedJobDataMap();
        String jobClassName = (String) jdm.get(CLASSNAME);
        if (jobClassName == null) {
            handleException(""No "" + CLASSNAME + "" in JobDetails"");
        }

        Task task = null;
        try {
            task = (Task) getClass().getClassLoader().loadClass(jobClassName).newInstance();
        } catch (Exception e) {
            handleException(""Cannot instantiate task : "" + jobClassName, e);
        }

        Set properties = (Set) jdm.get(PROPERTIES);
        Iterator it = properties.iterator();
        while (it.hasNext()) {
            OMElement prop = (OMElement) it.next();
            log.debug(""Found Property : "" + prop.toString());
            PropertyHelper.setStaticProperty(prop, task);
        }

        SynapseEnvironment se = (SynapseEnvironment) jdm.get(""SynapseEnvironment"");
        if (task instanceof ManagedLifecycle) {
            if (se != null) {
                ((ManagedLifecycle) task).init(se);
            }
        }

        if (se.isInitialized()) {
            task.execute();
        }
    }

    private void handleException(String msg) throws JobExecutionException {
        log.error(msg);
        throw new JobExecutionException(msg);
    }

    private void handleException(String msg, Exception e) throws JobExecutionException {
        log.error(msg, e);
        throw new JobExecutionException(msg, e);
    }

}
"
org/apache/synapse/config/xml/SequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;

/**
 * Serializer for {@link SequenceMediator} instances.
 * 
 * @see SequenceMediatorFactory
 */
public class SequenceMediatorSerializer extends AbstractListMediatorSerializer {

    public OMElement serializeAnonymousSequence(OMElement parent, SequenceMediator mediator) {
        OMElement sequence = fac.createOMElement(""sequence"", synNS);
        int isEnableStatistics = mediator.getStatisticsState();
        String statisticsValue = null;
        if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
            statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
        } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
            statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
        }
        if (statisticsValue != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
        }
        if (mediator.getErrorHandler() != null) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""onError"", nullNS, mediator.getErrorHandler()));
        }
        saveTracingState(sequence, mediator);
        serializeChildren(sequence, mediator.getList());
        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SequenceMediator mediator = (SequenceMediator) m;
        OMElement sequence = fac.createOMElement(""sequence"", synNS);

        // is this a dynamic sequence we loaded from a registry? if so we have no work to here
        // except make sure that we refer back to the registry key used when we loaded ourself
        if (mediator.isDynamic()) {
            sequence.addAttribute(fac.createOMAttribute(
                    ""name"", nullNS, mediator.getName()));
            sequence.addAttribute(fac.createOMAttribute(
                    ""key"", nullNS, mediator.getRegistryKey()));

        } else {

            int isEnableStatistics = mediator.getStatisticsState();
            String statisticsValue = null;
            if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_ON) {
                statisticsValue = XMLConfigConstants.STATISTICS_ENABLE;
            } else if (isEnableStatistics == org.apache.synapse.SynapseConstants.STATISTICS_OFF) {
                statisticsValue = XMLConfigConstants.STATISTICS_DISABLE;
            }
            if (statisticsValue != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        XMLConfigConstants.STATISTICS_ATTRIB_NAME, nullNS, statisticsValue));
            }

            if (mediator.getKey() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""key"", nullNS, mediator.getKey()));
            } else if (mediator.getName() != null) {
                sequence.addAttribute(fac.createOMAttribute(
                        ""name"", nullNS, mediator.getName()));

                if (mediator.getErrorHandler() != null) {
                    sequence.addAttribute(fac.createOMAttribute(
                            ""onError"", nullNS, mediator.getErrorHandler()));
                }
                saveTracingState(sequence, mediator);
                serializeChildren(sequence, mediator.getList());
            }
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return SequenceMediator.class.getName();
    }
}
"
org/apache/synapse/util/SimpleMap.java,false,"package org.apache.synapse.util;

import java.util.Map;
/*
 * This interface is a helper for dealing with a restriction on Map messages 
 * The key MUST be a String
 * and the value MUST be one of
 * boolean, char, String, int, double, float, long, short, byte, byte[] (Consider adding DataHandler in future)
 * or the equivalent Object
 * The simple type putters are equivalent to using an Object
 * so 
 * put(""paul"", new Integer(38));
 * getInt(""paul""); returns 38
 */

public interface SimpleMap extends Map {
	
	public Object get(String name);
	public void put(String name, Object value);
	public boolean getBoolean(String name);
	public void putBoolean(String name, boolean b);
	public String getString(String value);
	public void putString(String name, String value);
	public char getChar(String name);
	public void putChar(String name, char c);
	public int getInt(String name);
	public void putInt(String name, int i);
	public short getShort(String name);
	public void putShort(String name, short s);
	public float getFloat(String name);
	public void putFloat(String name, float fl);
	public double getDouble(String name);
	public void putDouble(String name, double d);
	public long getLong(String name);
	public void putLong(String name, long l);
	public byte getByte(String name);
	public void putByte(String name, byte b);
	public byte[] getBytes(String name);
	public void putBytes(String name, byte[] bytes);
	

}
"
org/apache/synapse/config/xml/MediatorPropertyFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.MediatorProperty;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * A utility class capable of creating instances of MediatorProperty objects by reading
 * through a given XML configuration
 *
 * <pre>
 * &lt;element&gt;
 *    &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 * &lt;/element&gt;
 * </pre>
 */
public class MediatorPropertyFactory {

    private static final Log log = LogFactory.getLog(MediatorPropertyFactory.class);

    public static List<MediatorProperty> getMediatorProperties(OMElement elem) {

        List<MediatorProperty> propertyList = new ArrayList<MediatorProperty>();

        Iterator iter = elem.getChildrenWithName(
            new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""property""));

        while (iter.hasNext()) {

            OMElement propEle = (OMElement) iter.next();
            OMAttribute attName  = propEle.getAttribute(MediatorProperty.ATT_NAME_Q);
            OMAttribute attValue = propEle.getAttribute(MediatorProperty.ATT_VALUE_Q);
            OMAttribute attExpr  = propEle.getAttribute(MediatorProperty.ATT_EXPR_Q);

            MediatorProperty prop = new MediatorProperty();

            if (attName == null || attName.getAttributeValue() == null ||
                attName.getAttributeValue().trim().length() == 0) {
                String msg = ""Entry name is a required attribute for a Log property"";
                log.error(msg);
                throw new SynapseException(msg);
            } else {
                prop.setName(attName.getAttributeValue());
            }

            // if a value is specified, use it, else look for an expression
            if (attValue != null) {

                if (attValue.getAttributeValue() == null ||
                    attValue.getAttributeValue().trim().length() == 0) {
                    
                    String msg = ""Entry attribute value (if specified) "" +
                        ""is required for a Log property"";
                    log.error(msg);
                    throw new SynapseException(msg);

                } else {
                    prop.setValue(attValue.getAttributeValue());
                }

            } else if (attExpr != null) {

                if (attExpr.getAttributeValue() == null ||
                    attExpr.getAttributeValue().trim().length() == 0) {

                    String msg = ""Entry attribute expression (if specified) "" +
                        ""is required for a mediator property"";
                    log.error(msg);
                    throw new SynapseException(msg);

                } else {
                    try {
                        prop.setExpression(SynapseXPathFactory.getSynapseXPath(
                            propEle, MediatorProperty.ATT_EXPR_Q));

                    } catch (JaxenException e) {
                        String msg = ""Invalid XPapth expression : "" + attExpr.getAttributeValue();
                        log.error(msg);
                        throw new SynapseException(msg, e);
                    }
                }

            } else {
                String msg = ""Entry attribute value OR expression must "" +
                    ""be specified for a mediator property"";
                log.error(msg);
                throw new SynapseException(msg);
            }

            propertyList.add(prop);
        }

        return propertyList;
    }
}
"
org/apache/synapse/util/RMIRegistryController.java,false,"/**
 *
 */
package org.apache.synapse.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;

import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
import java.rmi.RemoteException;
import java.rmi.NoSuchObjectException;
import java.rmi.server.UnicastRemoteObject;

public class RMIRegistryController {

    public static final Log log = LogFactory.getLog(RMIRegistryController.class);

    private static RMIRegistryController ourInstance = new RMIRegistryController();
    private Registry localRegistry;
    private boolean weCreatedRMIReg = false;

    public static RMIRegistryController getInstance() {
        return ourInstance;
    }

    private RMIRegistryController() {}

    /**
     * Creates a RMI local registry with given port
     *
     * @param port The port
     */
    public void createLocalRegistry(int port) {
        try {
            localRegistry = LocateRegistry.createRegistry(port);
        } catch (RemoteException e) {
            String msg = ""Couldn't create a local registry(RMI) : port "" + port +
                    "" already in use."";
            handleException(msg, e);
        }
    }

    /**
     * removes if there is a RMI local registry instance
     */
    public void removeLocalRegistry() {
        if (localRegistry != null) {
            try {
                log.info(""Removing the RMI registy instance from the RMI runtime "");
                UnicastRemoteObject.unexportObject(localRegistry, true);
            } catch (NoSuchObjectException e) {
                String msg = ""Error when stoping localregistry(RMI)"";
                handleException(msg, e);
            }
        }
    }


    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     * @param e   The exception
     */
    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

}
"
org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import javax.xml.namespace.QName;

/**
 * This dispatcher is implemented to demonstrate a sample client session. It will detect sessions
 * based on the <syn:ClientID xmlns:syn=""http://ws.apache.org/ns/synapse""> soap header of the
 * request message. Therefore, above header has to be included in the request soap messages by the
 * client who wants to initiate and maintain a session.
 */
public class SimpleClientSessionDispatcher implements Dispatcher {

    private static final Log log = LogFactory.getLog(SimpleClientSessionDispatcher.class);

    private static final QName CSID_QNAME
            = new QName(""http://ws.apache.org/ns/synapse"", ""ClientID"", ""syn"");

    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if (header != null) {
            OMElement sgcIDElm = header.getFirstChildWithName(CSID_QNAME);

            if (sgcIDElm != null) {
                String sgcID = sgcIDElm.getText();

                if (sgcID != null) {
                    log.debug(""Using the client session id : '""
                            + sgcID + ""' extracted from current message to retrieve endpoint"");
                    Object o = dispatcherContext.getEndpoint(sgcID);

                    if (o != null && o instanceof Endpoint) {
                        return (Endpoint) o;
                    }
                } else if (log.isDebugEnabled()) {
                    log.debug(""Couldn't find the client session id for the current message "" +
                            ""to retrieve endpoint"");
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find a SOAP header with the QName "" + CSID_QNAME +
                        "" for the current message to retrieve the endpoint"");
            }
        }

        return null;
    }

    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
        Endpoint endpoint) {

        if (endpoint == null || dispatcherContext == null) {
            return;
        }

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if (header != null) {
            OMElement csIDElm = header.getFirstChildWithName(CSID_QNAME);

            if (csIDElm != null) {
                String csID = csIDElm.getText();

                if (csID != null) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Using the client session id : '""
                                + csID + ""' extracted from current message to update the session"");
                    }
                    dispatcherContext.setEndpoint(csID, endpoint);
                } else if (log.isDebugEnabled()) {
                    log.debug(""Couldn't find the client session id for the current message "" +
                            ""to update the session"");
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find a SOAP header with the QName "" + CSID_QNAME +
                        "" for the current message to update the session"");
            }
        }
    }


    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {

        if (dispatcherContext == null) {
            return;
        }

        SOAPHeader header = synCtx.getEnvelope().getHeader();

        if (header != null) {
            OMElement csIDElm = header.getFirstChildWithName(CSID_QNAME);

            if (csIDElm != null) {
                String csID = csIDElm.getText();

                if (csID != null) {
                    dispatcherContext.removeSession(csID);
                } else if (log.isDebugEnabled()) {
                    log.debug(""Couldn't find the client session id for the current message "" +
                            ""to unbind the session"");
                }
            } else if (log.isDebugEnabled()) {
                log.debug(""Couldn't find a SOAP header with the QName "" + CSID_QNAME +
                        "" for the current message to unbind the session"");
            }
        }
    }

    public boolean isServerInitiatedSession() {
        return false;
    }
}
"
org/apache/synapse/mediators/annotations/UpdateMessage.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.annotations;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Target({FIELD, METHOD})
@Retention(RUNTIME)
public @interface UpdateMessage {

    String value();

}
"
org/apache/synapse/config/xml/RegistryFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.registry.Registry;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.Properties;

/**
 * Create an instance of the given registry, and sets properties on it.
 *
 * &lt;registry [name=""string""] provider=""provider.class""&gt;
 *   &lt;property name=""string"" value=""string""&gt;
 * &lt;/registry&gt;
 */
public class RegistryFactory {

    private static final Log log = LogFactory.getLog(RegistryFactory.class);

    public static final QName PROVIDER_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""provider"");
    public static final QName PARAMETER_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""parameter"");
    public static final QName NAME_Q     = new QName(XMLConfigConstants.NULL_NAMESPACE, ""name"");

    public static Registry createRegistry(OMElement elem) {

        OMAttribute prov = elem.getAttribute(PROVIDER_Q);
        if (prov != null) {
            try {
                Class provider = Class.forName(prov.getAttributeValue());
                Registry registry = (Registry) provider.newInstance();
                registry.init(getProperties(elem));
                return registry;

            } catch (ClassNotFoundException e) {
                handleException(""Cannot locate registry provider class : "" +
                    prov.getAttributeValue(), e);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            } catch (InstantiationException e) {
                handleException(""Error instantiating registry provider : "" +
                    prov.getAttributeValue(), e);
            }
        } else {
            handleException(""The registry 'provider' attribute is required for a registry definition"");
        }

        return null;
    }

    private static Properties getProperties(OMElement elem) {
        Iterator params = elem.getChildrenWithName(PARAMETER_Q);
        Properties props =new Properties();
        while (params.hasNext()) {
            Object o = params.next();
            if (o instanceof OMElement) {
                OMElement prop = (OMElement) o;
                OMAttribute pname = prop.getAttribute(NAME_Q);
                String propertyValue = prop.getText();
                if (pname != null) {
                    if (propertyValue != null) {
                        props.setProperty(pname.getAttributeValue(), propertyValue.trim());
                    }
                } else {
                    handleException(""Invalid registry property - property should have a name "");
                }
            } else {
                handleException(""Invalid registry property"");
            }
        }
        return props;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/config/xml/endpoints/DefaultEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.DefaultEndpoint;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

import javax.xml.namespace.QName;

/**
 * Creates {@link DefaultEndpoint} using a XML configuration.
 * <p/>
 * Configuration syntax:
 * <pre>
 * &lt;endpoint [name=""<em>name</em>""]&gt;
 *   &lt;default [format=""soap11|soap12|pox|get""] [optimize=""mtom|swa""]
 *      [encoding=""<em>charset encoding</em>""]
 *          [statistics=""enable|disable""] [trace=""enable|disable""]&gt;
 *     .. extensibility ..
 *
 *     &lt;enableRM [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableSec [policy=""<em>key</em>""]/&gt;?
 *     &lt;enableAddressing [version=""final|submission""] [separateListener=""true|false""]/&gt;?
 *
 *     &lt;timeout&gt;
 *       &lt;duration&gt;<em>timeout duration in seconds</em>&lt;/duration&gt;
 *       &lt;action&gt;discard|fault&lt;/action&gt;
 *     &lt;/timeout&gt;?
 *
 *     &lt;suspendDurationOnFailure&gt;
 *       <em>suspend duration in seconds</em>
 *     &lt;/suspendDurationOnFailure&gt;?
 *   &lt;/address&gt;
 * &lt;/endpoint&gt;
 * </pre>
 */
public class DefaultEndpointFactory extends EndpointFactory {

    private static DefaultEndpointFactory instance = new DefaultEndpointFactory();

    protected DefaultEndpointFactory() {
    }

    public static DefaultEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        DefaultEndpoint defaultEndpoint = new DefaultEndpoint();
        OMAttribute name = epConfig.getAttribute(
                new QName(XMLConfigConstants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            defaultEndpoint.setName(name.getAttributeValue());
        }

        OMElement defaultElement = epConfig.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""default""));
        if (defaultElement != null) {
            EndpointDefinition endpoint = createEndpointDefinition(defaultElement);
            defaultEndpoint.setEndpoint(endpoint);
        }

        return defaultEndpoint;
    }

    protected void extractSpecificEndpointProperties(EndpointDefinition definition, OMElement elem) {

        OMAttribute format
                = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""format""));
        if (format != null) {
            String forceValue = format.getAttributeValue().trim().toLowerCase();
            if (SynapseConstants.FORMAT_POX.equals(forceValue)) {
                definition.setForcePOX(true);
                definition.setFormat(SynapseConstants.FORMAT_POX);

            } else if (SynapseConstants.FORMAT_GET.equals(forceValue)) {
                definition.setForceGET(true);
                definition.setFormat(SynapseConstants.FORMAT_GET);

            } else if (SynapseConstants.FORMAT_SOAP11.equals(forceValue)) {
                definition.setForceSOAP11(true);
                definition.setFormat(SynapseConstants.FORMAT_SOAP11);

            } else if (SynapseConstants.FORMAT_SOAP12.equals(forceValue)) {
                definition.setForceSOAP12(true);
                definition.setFormat(SynapseConstants.FORMAT_SOAP12);

            } else {
                handleException(""force value -\"""" + forceValue + ""\"" not yet implemented"");
            }
        }

    }

    /**
     * Creates an EndpointDefinition instance using the XML fragment specification. Configuration
     * for EndpointDefinition always resides inside a configuration of an AddressEndpoint. This
     * factory extracts the details related to the EPR provided for address endpoint.
     *
     * @param elem XML configuration element
     * @return EndpointDefinition object containing the endpoint details.
     */
    public EndpointDefinition createEndpointDefinition(OMElement elem) {
        EndpointDefinition endpointDefinition = new EndpointDefinition();
        extractCommonEndpointProperties(endpointDefinition, elem);
        extractSpecificEndpointProperties(endpointDefinition, elem);
        return endpointDefinition;
    }
}
"
org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.FailoverEndpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates {@link FailoverEndpoint} using a XML configuration.
 *
 * &lt;endpoint [name=""name""]&gt;
 *    &lt;failover&gt;
 *       &lt;endpoint&gt;+
 *    &lt;/failover&gt;
 * &lt;/endpoint&gt;
 */
public class FailoverEndpointFactory extends EndpointFactory {

    private static FailoverEndpointFactory instance = new FailoverEndpointFactory();

    private FailoverEndpointFactory() {}

    public static FailoverEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        OMElement failoverElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""failover""));
        if (failoverElement != null) {

            FailoverEndpoint failoverEndpoint = new FailoverEndpoint();
            // set endpoint name
            String name = epConfig.getAttributeValue(new QName(""name""));
            if (name != null) {
                failoverEndpoint.setName(name);
            }
            // set endpoints and return
            failoverEndpoint.setEndpoints(getEndpoints(failoverElement, failoverEndpoint));
            return failoverEndpoint;
        }
        return null;
    }

}
"
org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.config.xml.endpoints.utils.LoadbalanceAlgorithmFactory;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.dispatch.Dispatcher;
import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SimpleClientSessionDispatcher;
import org.apache.synapse.endpoints.dispatch.SoapSessionDispatcher;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Creates {@link SALoadbalanceEndpoint} from a XML configuration.
 *
 * &lt;endpoint [name=""name""]&gt;
 *    &lt;session type=""soap | ..other session types.."" /&gt;
 *    &lt;loadbalance policy=""policy""&gt;
 *       &lt;endpoint&gt;+
 *    &lt;/loadbalance&gt;
 * &lt;/endpoint&gt;
 */
public class SALoadbalanceEndpointFactory extends EndpointFactory {

    private static SALoadbalanceEndpointFactory instance = new SALoadbalanceEndpointFactory();

    private SALoadbalanceEndpointFactory() {}

    public static SALoadbalanceEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        // create the endpoint, manager and the algorithms
        SALoadbalanceEndpoint loadbalanceEndpoint = new SALoadbalanceEndpoint();

        // get the session for this endpoint
        OMElement sessionElement = epConfig.
                getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""session""));
        if (sessionElement != null) {

            String type = sessionElement.getAttributeValue(new QName(""type""));

            if (type.equalsIgnoreCase(""soap"")) {
                Dispatcher soapDispatcher = new SoapSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(soapDispatcher);

            } else if (type.equalsIgnoreCase(""http"")) {
                Dispatcher httpDispatcher = new HttpSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(httpDispatcher);

            } else if (type.equalsIgnoreCase(""simpleClientSession"")) {
                Dispatcher csDispatcher = new SimpleClientSessionDispatcher();
                loadbalanceEndpoint.setDispatcher(csDispatcher);
            }
        } else {
            handleException(""Session affinity endpoints should "" +
                    ""have a session element in the configuration."");
        }

        // set endpoint name
        OMAttribute name = epConfig.getAttribute(new QName(
                org.apache.synapse.config.xml.XMLConfigConstants.NULL_NAMESPACE, ""name""));

        if (name != null) {
            loadbalanceEndpoint.setName(name.getAttributeValue());
        }

        OMElement loadbalanceElement;
        loadbalanceElement = epConfig.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));

        if(loadbalanceElement != null) {

            // set endpoints
            ArrayList<Endpoint> endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
            loadbalanceEndpoint.setEndpoints(endpoints);

            // set load balance algorithm
            LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
                    createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
            loadbalanceEndpoint.setAlgorithm(algorithm);

            // set abandon time
            //long abandonTime = 0;
            //OMAttribute atAttribute = loadbalanceElement.getAttribute(new QName(
            //      null, org.apache.synapse.config.xml.Constants.RETRY_AFTER_FAILURE_TIME));
            //if(atAttribute != null) {
            //    String at = atAttribute.getAttributeValue();
            //    abandonTime = Long.parseLong(at);
            //    loadbalanceEndpoint.setAbandonTime(abandonTime);
            //}

            //long retryInterval = 30000;
            //OMAttribute riAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.RETRY_INTERVAL));
            //
            //if(riAttribute != null) {
            //    String ri = riAttribute.getAttributeValue();
            //    retryInterval = Long.parseLong(ri);
            //}

            //int maximumRetries = 0;
            //OMAttribute mrAttribute = loadbalanceElement.getAttribute
            //        (new QName(null, Constants.MAXIMUM_RETRIES));
            //
            //if(mrAttribute != null) {
            //    String mr = mrAttribute.getAttributeValue();
            //    maximumRetries = Integer.parseInt(mr);
            //}

            return loadbalanceEndpoint;
        }

        return null;
    }
}
"
org/apache/synapse/config/xml/POJOCommandMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ext.POJOCommandMediator;
import org.apache.synapse.util.xpath.SynapseXPath;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Factory for {@link POJOCommandMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;pojoCommand name=&quot;class-name&quot;&gt;
 *   &lt;property name=&quot;string&quot; value=&quot;literal&quot; expression=&quot;xpath&quot;?
 *          context-name=&quot;string&quot;? &gt;
 *      either literal or XML child
 *   &lt;/property&gt;
 *   &lt;property name=&quot;string&quot; expression=&quot;XPATH expression&quot;
 *                action=(&quot;ReadMessage&quot; | &quot;UpdateMessage&quot; |
 *                  &quot;ReadAndUpdateMessage&quot;) context-name=&quot;string&quot;? /&gt;
 *   &lt;property name=&quot;string&quot; context-name=&quot;string&quot;
 *                action=(&quot;ReadContext&quot; | &quot;UpdateContext&quot; |
 *                  &quot;ReadAndUpdateContext&quot;) expression=&quot;XPATH expression&quot;? /&gt;
 * &lt;/pojoCommand&gt;
 * </pre>
 */
public class POJOCommandMediatorFactory extends AbstractMediatorFactory {

    private static final QName POJO_COMMAND_Q
        = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""pojoCommand"");
    protected static final QName ATT_ACTION = new QName(""action"");
    protected static final QName ATT_CTXNAME = new QName(""context-name"");

    protected static final String RM_ACTION = ""ReadMessage"";
    protected static final String UM_ACTION = ""UpdateMessage"";
    protected static final String RC_ACTION = ""ReadContext"";
    protected static final String UC_ACTION = ""UpdateContext"";
    protected static final String RAUM_ACTION = ""ReadAndUpdateMessage"";
    protected static final String RAUC_ACTION = ""ReadAndUpdateContext"";

    public Mediator createMediator(OMElement elem) {

        POJOCommandMediator pojoMediator = new POJOCommandMediator();

        // Class name of the Command object should be present
        OMAttribute name = elem.getAttribute(ATT_NAME);
        if (name == null) {
            String msg = ""The name of the actual POJO command implementation class"" +
                    "" is a required attribute"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        // load the class for the command object
        try {
            pojoMediator.setCommand(
                    getClass().getClassLoader().loadClass(name.getAttributeValue()));
        } catch (ClassNotFoundException e) {
            handleException(""Unable to load the class specified as the command ""
                    + name.getAttributeValue(), e);
        }

        // setting the properties to the command. these properties will be instantiated
        // at the mediation time
        for (Iterator it = elem.getChildElements(); it.hasNext();) {
            OMElement child = (OMElement) it.next();
            if(""property"".equals(child.getLocalName())) {

                OMAttribute nameAttr = child.getAttribute(ATT_NAME);
                if (nameAttr != null && nameAttr.getAttributeValue() != null
                    && !"""".equals(nameAttr.getAttributeValue())) {

                    handlePropertyAction(nameAttr.getAttributeValue(), child, pojoMediator);
                } else {
                    handleException(""A POJO command mediator "" +
                        ""property must specify the name attribute"");
                }
            }
        }

        return pojoMediator;
    }

    private void handlePropertyAction(String name, OMElement propElem, POJOCommandMediator m) {

        OMAttribute valueAttr   = propElem.getAttribute(ATT_VALUE);
        OMAttribute exprAttr    = propElem.getAttribute(ATT_EXPRN);
        OMAttribute ctxNameAttr = propElem.getAttribute(ATT_CTXNAME);
        OMAttribute actionAttr  = propElem.getAttribute(ATT_ACTION);

        SynapseXPath xpath = null;
        try {
            if (exprAttr != null) {
                xpath = SynapseXPathFactory.getSynapseXPath(propElem, ATT_EXPRN);
            }
        } catch (JaxenException e) {
            handleException(""Error in building the expression as an SynapseXPath"" + e);
        }

        // if there is a value attribute there is no action (action is implied as read value)
        if (valueAttr != null) {
            String value = valueAttr.getAttributeValue();
            // all other three attributes can not co-exists
            if (exprAttr != null && ctxNameAttr != null) {
                handleException(""Command properties can not contain all three 'value', "" +
                    ""'expression' and 'context-name' attributes. Only one or "" +
                    ""combination of two can be there."");
            } else {
                m.addStaticSetterProperty(name, value);
                if (exprAttr != null) {
                    // action ==> ReadValueAndUpdateMesssage
                    m.addMessageGetterProperty(name, xpath);
                } else if (ctxNameAttr != null) {
                    // action ==> ReadValueAndUpdateContext
                    m.addContextGetterProperty(name, ctxNameAttr.getAttributeValue());
                } // else the action ==> ReadValue
            }
        } else if (propElem.getFirstElement() != null) {
            // all other two attributes can not co-exists
            if (exprAttr != null && ctxNameAttr != null) {
                handleException(""Command properties can not contain all the "" +
                    ""'expression' and 'context-name' attributes with a child. Only one "" +
                    ""attribute of those can co-exists with a child"");
            } else {
                m.addStaticSetterProperty(name, propElem.getFirstElement());
                if (exprAttr != null) {
                    // action ==> ReadValueAndUpdateMesssage
                    m.addMessageGetterProperty(name, xpath);
                } else if (ctxNameAttr != null) {
                    // action ==> ReadValueAndUpdateContext
                    m.addContextGetterProperty(name, ctxNameAttr.getAttributeValue());
                } // else the action ==> ReadValue
            }
        } else {
            // if both context-name and expression is there
            if (exprAttr != null && ctxNameAttr != null) {
                if (actionAttr != null && actionAttr.getAttributeValue() != null) {
                    String action = actionAttr.getAttributeValue();
                    if (RM_ACTION.equals(action) || UC_ACTION.equals(action)) {
                        // action ==> ReadMessageAndUpdateContext
                        m.addMessageSetterProperty(name, xpath);
                        m.addContextGetterProperty(name, ctxNameAttr.getAttributeValue());
                    } else if (RC_ACTION.equals(action) || UM_ACTION.equals(action)) {
                        // action ==> ReadContextAndUpdateMessage
                        m.addContextSetterProperty(name, ctxNameAttr.getAttributeValue());
                        m.addMessageGetterProperty(name, xpath);
                    } else {
                        handleException(""Invalid action for "" +
                            ""the command property with the name "" + name);
                    }
                } else {
                    handleException(""Action attribute "" +
                        ""is required for the command property with name "" + name);
                }
            } else {
                // only one of expression or context-name is present
                if (actionAttr != null && actionAttr.getAttributeValue() != null) {
                    String action = actionAttr.getAttributeValue();
                    if (exprAttr != null) {
                        if (RM_ACTION.equals(action)) {
                            // action ==> ReadMessage
                            m.addMessageSetterProperty(name, xpath);
                        } else if (UM_ACTION.equals(action)) {
                            // action ==> UpdateMessage
                            m.addMessageGetterProperty(name, xpath);
                        } else if (RAUM_ACTION.equals(action)) {
                            // action ==> ReadAndUpdateMessage
                            m.addMessageSetterProperty(name, xpath);
                            m.addMessageGetterProperty(name, xpath);
                        } else {
                            handleException(""Invalid action for "" +
                                ""the command property with the name "" + name);
                        }
                    } else if (ctxNameAttr != null) {
                        String ctxName = ctxNameAttr.getAttributeValue();
                        if (RC_ACTION.equals(action)) {
                            // action ==> ReadContext
                            m.addContextSetterProperty(name, ctxName);
                        } else if (UC_ACTION.equals(action)) {
                            // action ==> UpdateContext
                            m.addContextGetterProperty(name, ctxName);
                        } else if (RAUC_ACTION.equals(action)) {
                            // action ==> ReadAndUpdateContext
                            m.addContextSetterProperty(name, ctxName);
                            m.addContextGetterProperty(name, ctxName);
                        } else {
                            handleException(""Invalid action for "" +
                                ""the command property with the name "" + name);
                        }
                    } else {
                        handleException(""Unrecognized command property with the name "" + name);
                    }
                } else {
                    // action ==> ReadAndUpdateMessage/Context
                    if (exprAttr != null) {
                        m.addMessageSetterProperty(name, xpath);
                        m.addMessageGetterProperty(name, xpath);
                    } else if (ctxNameAttr != null) {
                        String ctxName = ctxNameAttr.getAttributeValue();
                        m.addContextSetterProperty(name, ctxName);
                        m.addContextGetterProperty(name, ctxName);
                    } else {
                        handleException(""Unrecognized command property with the name "" + name);
                    }
                }
            }
        }
    }

    public QName getTagQName() {
        return POJO_COMMAND_Q;
    }

}

"
org/apache/synapse/config/xml/RMSequenceMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Factory for {@link RMSequenceMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;RMSequence (correlation=""xpath"" [last-message=""xpath""]) | single=""true"" [version=""1.0|1.1""]/&gt;
 * </pre>
 */
public class RMSequenceMediatorFactory extends AbstractMediatorFactory {

    private static final QName SEQUENCE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""RMSequence"");
    private static final QName ATT_CORR = new QName(""correlation"");
    private static final QName ATT_LASTMSG = new QName(""last-message"");
    private static final QName ATT_VERSION = new QName(""version"");
    private static final QName ATT_SINGLE = new QName(""single"");

    public Mediator createMediator(OMElement elem) {

        RMSequenceMediator sequenceMediator = new RMSequenceMediator();
        OMAttribute correlation = elem.getAttribute(ATT_CORR);
        OMAttribute lastMessage = elem.getAttribute(ATT_LASTMSG);
        OMAttribute single = elem.getAttribute(ATT_SINGLE);
        OMAttribute version = elem.getAttribute(ATT_VERSION);

        if (single == null && correlation == null) {
            String msg = ""The 'single' attribute value of true or a 'correlation' attribute is "" +
                ""required for the configuration of a RMSequence mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (correlation != null) {
            if (correlation.getAttributeValue() != null &&
                correlation.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for correlation"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setCorrelation(
                        SynapseXPathFactory.getSynapseXPath(elem, ATT_CORR));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute correlation : ""
                        + correlation.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
        }

        if (single != null) {
            sequenceMediator.setSingle(Boolean.valueOf(single.getAttributeValue()));
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getCorrelation() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);

        } else if (!sequenceMediator.isSingle() && sequenceMediator.getCorrelation() == null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence must have a ""
                + ""single attribute value of true or a correlation attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (lastMessage != null) {
            if (lastMessage.getAttributeValue() != null &&
                lastMessage.getAttributeValue().trim().length() == 0) {
                String msg = ""Invalid attribute value specified for last-message"";
                log.error(msg);
                throw new SynapseException(msg);

            } else {
                try {
                    sequenceMediator.setLastMessage(
                        SynapseXPathFactory.getSynapseXPath(elem, ATT_LASTMSG));
                } catch (JaxenException e) {
                    String msg = ""Invalid XPath expression for attribute last-message : ""
                        + lastMessage.getAttributeValue();
                    log.error(msg);
                    throw new SynapseException(msg);
                }
            }
        }

        if (sequenceMediator.isSingle() && sequenceMediator.getLastMessage() != null) {
            String msg = ""Invalid RMSequence mediator. A RMSequence can't have both a ""
                + ""single attribute value of true and a last-message attribute specified."";
            log.error(msg);
            throw new SynapseException(msg);
        }

        if (version != null) {
            if (!XMLConfigConstants.SEQUENCE_VERSION_1_0.equals(version.getAttributeValue()) &&
                !XMLConfigConstants.SEQUENCE_VERSION_1_1.equals(version.getAttributeValue())) {
                String msg = ""Only '"" + XMLConfigConstants.SEQUENCE_VERSION_1_0 + ""' or '"" +
                    XMLConfigConstants.SEQUENCE_VERSION_1_1
                    + ""' values are allowed for attribute version for a RMSequence mediator""
                    + "", Unsupported version "" + version.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            sequenceMediator.setVersion(version.getAttributeValue());
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sequenceMediator, elem);

        return sequenceMediator;
    }

    public QName getTagQName() {
        return SEQUENCE_Q;
    }
}
"
org/apache/synapse/config/xml/CloneMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.splitter.CloneMediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * The &lt;clone&gt; element is used to copy messages in Synapse to simillar messages but with
 * different message contexts and mediated using the specified targets
 *
 * <pre>
 * &lt;clone [continueParent=(true | false)]&gt;
 *   &lt;target [to=""uri""] [soapAction=""qname""] [sequence=""sequence_ref""]
 *          [endpoint=""endpoint_ref""]&gt;
 *     &lt;sequence&gt;
 *       (mediator)+
 *     &lt;/sequence&gt;?
 *     &lt;endpoint&gt;
 *       endpoint
 *     &lt;/endpoint&gt;?
 *   &lt;/target&gt;+
 * &lt;/clone&gt;
 * </pre>
 */
public class CloneMediatorFactory extends AbstractMediatorFactory {

    /**
     * This will hold the QName of the clone mediator element in the xml configuration
     */
    private static final QName CLONE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""clone"");
    private static final QName ATT_CONTPAR = new QName(""continueParent"");
    private static final QName TARGET_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""target"");

    /**
     * This method implements the createMediator method of the MediatorFactory interface
     * 
     * @param elem - OMElement describing the element which will be parsed
     *  to build the CloneMediator
     * @return Mediator of the type CloneMediator built from the config element
     */
    public Mediator createMediator(OMElement elem) {

        CloneMediator mediator = new CloneMediator();
        processTraceState(mediator, elem);
        
        OMAttribute continueParent = elem.getAttribute(ATT_CONTPAR);
        if (continueParent != null) {
            mediator.setContinueParent(
                    Boolean.valueOf(continueParent.getAttributeValue()).booleanValue());
        }

        Iterator targetElements = elem.getChildrenWithName(TARGET_Q);
        while (targetElements.hasNext()) {
            mediator.addTarget(TargetFactory.createTarget((OMElement) targetElements.next()));
        }

        return mediator;
    }

    /**
     * This method will implement the getTagQName method of the MediatorFactory interface
     *
     * @return QName of the clone element in xml configuraiton
     */
    public QName getTagQName() {
        return CLONE_Q;
    }
}
"
org/apache/synapse/endpoints/algorithms/RoundRobin.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.algorithms;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

import java.util.ArrayList;

/**
 * This is the implementation of the round robin load balancing algorithm. It simply iterates
 * through the endpoint list one by one for until an active endpoint is found.
 */
public class RoundRobin implements LoadbalanceAlgorithm {

    private static final Log log = LogFactory.getLog(RoundRobin.class);

    /**
     * Endpoints list for the round robin algorithm
     */
    private ArrayList endpoints = null;

    public RoundRobin(ArrayList endpoints) {
        this.endpoints = endpoints;
    }

    /**
     * Choose an active endpoint using the round robin algorithm. If there are no active endpoints
     * available, returns null.
     *
     * @param synapseMessageContext MessageContext instance which holds all per-message properties
     * @param  algorithmContext The context in which holds run time states related to the algorithm
     * @return endpoint to send the next message
     */
    public Endpoint getNextEndpoint(MessageContext synapseMessageContext,
        AlgorithmContext algorithmContext) {

        if (log.isDebugEnabled()) {
            log.debug(""Using the Round Robin loadbalancing algorithm to select the next endpoint"");
        }

        Endpoint nextEndpoint;
        int attempts = 0;
        int currentEPR = algorithmContext.getCurrentEndpointIndex();
        do {
            // two successive clients could get the same endpoint if not synchronized.
            synchronized (this) {
                nextEndpoint = (Endpoint) endpoints.get(currentEPR);

                if (currentEPR == endpoints.size() - 1) {
                    currentEPR = 0;
                } else {
                    currentEPR++;
                }
                algorithmContext.setCurrentEPR(currentEPR);
            }

            attempts++;
            if (attempts > endpoints.size()) {
                log.warn(""Couldn't find an endpoint from the Round Robin loadbalancing algorithm"");
                return null;
            }

        } while (!nextEndpoint.isActive(synapseMessageContext));

        return nextEndpoint;
    }

    public void reset(AlgorithmContext algorithmContext) {
        if (log.isDebugEnabled()) {
            log.debug(""Resetting the Round Robin loadbalancing algorithm ..."");
        }
        algorithmContext.setCurrentEPR(0);
    }
}
"
org/apache/synapse/config/xml/endpoints/EndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.XMLToObjectMapper;
import org.apache.synapse.config.xml.XMLConfigConstants;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

import javax.xml.namespace.QName;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * All endpoint factories should implement this interface. Use EndpointFactory to obtain the
 * correct endpoint for particular endpoint configuration. As endpoints can be nested inside
 * each other, EndpointFactory implementations may call other EndpointFactory implementations
 * recursively to obtain the required endpoint hierarchy.
 * <p/>
 * This also serves as the XMLToObjactMapper implementation for specific endpoint implementations.
 * If the endpoint type is not known use XMLToEndpointMapper as the generic XMLToObjectMapper for
 * all endpoints.
 */
public abstract class EndpointFactory implements XMLToObjectMapper {

    private static Log log = LogFactory.getLog(EndpointFactory.class);

    /**
     * Core method which is exposed for the external use, and this will find the proper
     * {@link EndpointFactory} and create the endpoint which is of the format {@link Endpoint}.
     *
     * @param elem        XML from which the endpoint will be built
     * @param isAnonymous whether this is an anonymous endpoint or not
     * @return created endpoint
     */
    public static Endpoint getEndpointFromElement(OMElement elem, boolean isAnonymous) {
        return getEndpointFactory(elem).createEndpoint(elem, isAnonymous);
    }

    /**
     * Creates the {@link Endpoint} object from the provided {@link OMNode}
     *
     * @param om XML node from which the endpoint will be built
     * @return created endpoint as an {@link Object}
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return createEndpoint((OMElement) om, false);
        } else {
            handleException(""Invalid XML configuration for an Endpoint. OMElement expected"");
        }
        return null;
    }

    /**
     * Creates the Endpoint implementation for the given XML endpoint configuration. If the endpoint
     * configuration is an inline one, it should be an anonymous endpoint. If it is defined as an
     * immediate child element of the definitions tag it should have a name, which is used as the
     * key in local registry.
     *
     * @param epConfig          OMElement conatining the endpoint configuration.
     * @param anonymousEndpoint false if the endpoint has a name. true otherwise.
     * @return Endpoint implementation for the given configuration.
     */
    protected abstract Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint);

    /**
     * Extracts the QoS information from the XML which represents a WSDL/Address/Default endpoints
     *
     * @param definition to be filled with the extracted information
     * @param elem       XML which represents the endpoint with QoS information
     */
    protected void extractCommonEndpointProperties(EndpointDefinition definition, OMElement elem) {

        OMAttribute optimize
                = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""optimize""));
        OMAttribute encoding
                = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""encoding""));

        OMAttribute statistics = elem.getAttribute(new QName(
                XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.STATISTICS_ATTRIB_NAME));
        if (statistics != null && statistics.getAttributeValue() != null) {
            String statisticsValue = statistics.getAttributeValue();
            if (XMLConfigConstants.STATISTICS_ENABLE.equals(statisticsValue)) {
                definition.setStatisticsState(SynapseConstants.STATISTICS_ON);
            } else if (XMLConfigConstants.STATISTICS_DISABLE.equals(statisticsValue)) {
                definition.setStatisticsState(SynapseConstants.STATISTICS_OFF);
            }
        } else {
            definition.setStatisticsState(SynapseConstants.STATISTICS_UNSET);
        }

        OMAttribute trace = elem.getAttribute(new QName(
                XMLConfigConstants.NULL_NAMESPACE, XMLConfigConstants.TRACE_ATTRIB_NAME));
        if (trace != null && trace.getAttributeValue() != null) {
            String traceValue = trace.getAttributeValue();
            if (XMLConfigConstants.TRACE_ENABLE.equals(traceValue)) {
                definition.setTraceState(SynapseConstants.TRACING_ON);
            } else if (XMLConfigConstants.TRACE_DISABLE.equals(traceValue)) {
                definition.setTraceState(SynapseConstants.TRACING_OFF);
            }
        } else {
            definition.setTraceState(SynapseConstants.TRACING_UNSET);
        }


        if (optimize != null && optimize.getAttributeValue().length() > 0) {
            String method = optimize.getAttributeValue().trim();
            if (""mtom"".equalsIgnoreCase(method)) {
                definition.setUseMTOM(true);
            } else if (""swa"".equalsIgnoreCase(method)) {
                definition.setUseSwa(true);
            }
        }

        if (encoding != null && encoding.getAttributeValue() != null) {
            definition.setCharSetEncoding(encoding.getAttributeValue());
        }

        OMElement wsAddr = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableAddressing""));
        if (wsAddr != null) {

            definition.setAddressingOn(true);

            OMAttribute version = wsAddr.getAttribute(new QName(""version""));
            if (version != null && version.getAttributeValue() != null) {
                String versionValue = version.getAttributeValue().trim().toLowerCase();
                if (SynapseConstants.ADDRESSING_VERSION_FINAL.equals(versionValue) ||
                        SynapseConstants.ADDRESSING_VERSION_SUBMISSION.equals(versionValue)) {
                    definition.setAddressingVersion(version.getAttributeValue());
                } else {
                    handleException(""Unknown value for the addressing version. Possible values "" +
                            ""for the addressing version are 'final' and 'submission' only."");
                }
            }

            String useSepList = wsAddr.getAttributeValue(new QName(""separateListener""));
            if (useSepList != null) {
                if (""true"".equals(useSepList.trim().toLowerCase())) {
                    definition.setUseSeparateListener(true);
                }
            }
        }

        OMElement wsSec = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableSec""));
        if (wsSec != null) {

            definition.setSecurityOn(true);

            OMAttribute policy
                    = wsSec.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                definition.setWsSecPolicyKey(policy.getAttributeValue());
            }
        }

        OMElement wsRm = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""enableRM""));
        if (wsRm != null) {

            definition.setReliableMessagingOn(true);

            OMAttribute policy
                    = wsRm.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, ""policy""));
            if (policy != null) {
                definition.setWsRMPolicyKey(policy.getAttributeValue());
            }
        }

        // set the timeout configuration
        OMElement timeout = elem.getFirstChildWithName(
                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""timeout""));
        if (timeout != null) {
            OMElement duration = timeout.getFirstChildWithName(
                    new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""duration""));

            if (duration != null) {
                String d = duration.getText();
                if (d != null) {
                    try {
                        long timeoutSeconds = Long.parseLong(d.trim());
                        definition.setTimeoutDuration(timeoutSeconds * 1000);
                    } catch (NumberFormatException e) {
                        handleException(""Endpoint timeout duration expected as a "" +
                                ""number but was not a number"");
                    }
                }
            }

            OMElement action = timeout.getFirstChildWithName(
                    new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""action""));
            if (action != null && action.getText() != null) {
                String actionString = action.getText();
                if (""discard"".equalsIgnoreCase(actionString.trim())) {

                    definition.setTimeoutAction(SynapseConstants.DISCARD);

                    // set timeout duration to 30 seconds, if it is not set explicitly
                    if (definition.getTimeoutDuration() == 0) {
                        definition.setTimeoutDuration(30000);
                    }
                } else if (""fault"".equalsIgnoreCase(actionString.trim())) {

                    definition.setTimeoutAction(SynapseConstants.DISCARD_AND_FAULT);

                    // set timeout duration to 30 seconds, if it is not set explicitly
                    if (definition.getTimeoutDuration() == 0) {
                        definition.setTimeoutDuration(30000);
                    }
                } else {
                    handleException(""Invalid timeout action, action : ""
                            + actionString + "" is not supported"");
                }
            }
        }

        // set the suspend on fail duration.
        OMElement suspendElement = elem.getFirstChildWithName(new QName(
                SynapseConstants.SYNAPSE_NAMESPACE,
                XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE));
        if (suspendElement != null && suspendElement.getText() != null) {
            try {
                long suspendDuration = Long.parseLong(suspendElement.getText().trim());
                definition.setSuspendOnFailDuration(suspendDuration * 1000);
            } catch (NumberFormatException e) {
                handleException(""The suspend duration should be specified as a valid number :: ""
                        + e.getMessage(), e);
            }
        }
    }

    protected void extractSpecificEndpointProperties(EndpointDefinition definition, OMElement elem){

    }

    /**
     * Returns the EndpointFactory implementation for given endpoint configuration. Throws a
     * SynapseException, if there is no EndpointFactory for given configuration.
     *
     * @param configElement Endpoint configuration.
     * @return EndpointFactory implementation.
     */
    private static EndpointFactory getEndpointFactory(OMElement configElement) {

        if (configElement.getAttribute(new QName(""key"")) != null) {
            return IndirectEndpointFactory.getInstance();
        }

        OMElement addressElement = configElement.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""address""));
        if (addressElement != null) {
            return AddressEndpointFactory.getInstance();
        }

        OMElement wsdlElement = configElement.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""wsdl""));
        if (wsdlElement != null) {
            return WSDLEndpointFactory.getInstance();
        }

        OMElement defaultElement = configElement.getFirstChildWithName(
                new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""default""));
        if (defaultElement != null) {
            return DefaultEndpointFactory.getInstance();
        }

        OMElement lbElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""loadbalance""));
        if (lbElement != null) {
            OMElement sessionElement = configElement.
                    getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""session""));
            if (sessionElement != null) {
                return SALoadbalanceEndpointFactory.getInstance();
            } else {
                return LoadbalanceEndpointFactory.getInstance();
            }
        }

        OMElement foElement = configElement.getFirstChildWithName
                (new QName(SynapseConstants.SYNAPSE_NAMESPACE, ""failover""));
        if (foElement != null) {
            return FailoverEndpointFactory.getInstance();
        }

        handleException(""Invalid endpoint configuration."");
        // just to make the compiler happy : never executes
        return null;
    }

    /**
     * Helper method to construct children endpoints
     *
     * @param listEndpointElement OMElement representing  the children endpoints
     * @param parent              Parent endpoint
     * @return List of children endpoints
     */
    protected ArrayList<Endpoint> getEndpoints(OMElement listEndpointElement, Endpoint parent) {

        ArrayList<Endpoint> endpoints = new ArrayList<Endpoint>();
        ArrayList<String> keys = new ArrayList<String>();
        Iterator iter = listEndpointElement.getChildrenWithName(XMLConfigConstants.ENDPOINT_ELT);
        while (iter.hasNext()) {
            OMElement endptElem = (OMElement) iter.next();
            Endpoint endpoint = EndpointFactory.getEndpointFromElement(endptElem, true);
            if (endpoint instanceof IndirectEndpoint) {
                String key = ((IndirectEndpoint) endpoint).getKey();
                if (!keys.contains(key)) {
                    keys.add(key);
                } else {
                    handleException(""Same endpoint definition cannot be used with in the siblings"");
                }
            }
            endpoint.setParentEndpoint(parent);
            endpoints.add(endpoint);
        }

        return endpoints;
    }

    protected static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    protected static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }
}
"
org/apache/synapse/endpoints/WSDLEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.axiom.om.OMElement;
import org.apache.axis2.clustering.ClusterManager;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.endpoints.utils.EndpointDefinition;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;

import java.util.Stack;

/**
 * WSDLEndpoint represents the endpoints built using a wsdl document. It stores the details about
 * the endpoint in a EndpointDefinition object. Once the WSDLEndpoint object is constructed, it
 * should not access the wsdl document at runtime to obtain endpoint information. If it is necessary
 * to create an endpoint using a dynamic wsdl, store the endpoint configuration in the registry and
 * create a dynamic wsdl endpoint using that registry key.
 * <p/>
 * TODO: This should allow various policies to be applied on fine grained level (e.g. operations).
 */
public class WSDLEndpoint extends FaultHandler implements Endpoint {

    private static final Log log = LogFactory.getLog(WSDLEndpoint.class);
    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);

    private String name = null;
    private String wsdlURI;
    private OMElement wsdlDoc;
    private String serviceName;
    private String portName;

    private Endpoint parentEndpoint = null;
    private EndpointDefinition endpoint = null;

    /**
     * The endpoint context , place holder for keep any runtime states related to the endpoint
     */
    private final EndpointContext endpointContext = new EndpointContext();

    /**
     * Sends the message through this endpoint. This method just handles statistics related
     * functions and gives the message to the Synapse environment to send. It does not add any
     * endpoint specific details to the message context. These details are added only to the cloned
     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
     * context for resending through different endpoints.
     *
     * @param synCtx MessageContext sent by client to Synapse
     */
    public void send(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : WSDL Endpoint"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (endpoint.getAddress() != null) {

            String eprAddress = endpoint.getAddress();
            boolean isClusteringEnable = false;
            // get Axis2 MessageContext and ConfigurationContext
            org.apache.axis2.context.MessageContext axisMC =
                    ((Axis2MessageContext) synCtx).getAxis2MessageContext();
            ConfigurationContext cc = axisMC.getConfigurationContext();

            //The check for clustering environment
            ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
            if (clusterManager != null &&
                    clusterManager.getContextManager() != null) {
                isClusteringEnable = true;
            }

            String endPointName = this.getName();
            if (endPointName == null) {

                if (traceOrDebugOn && isClusteringEnable) {
                    log.warn(""In a clustering environment , the endpoint  name should be "" +
                            ""specified even for anonymous endpoints. Otherwise, the clustering "" +
                            ""would not be functioned correctly if there are more than one "" +
                            ""anonymous endpoints. "");
                }
                endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
            }

            if (isClusteringEnable) {
                // if this is a cluster environment , then set configuration context
                // to endpoint context
                if (endpointContext.getConfigurationContext() == null) {
                    endpointContext.setConfigurationContext(cc);
                    endpointContext.setContextID(endPointName);
                }
            }

            // Setting Required property to collect the End Point statistics
            boolean statisticsEnable =
                    (SynapseConstants.STATISTICS_ON == endpoint.getStatisticsState());

            if (statisticsEnable) {
                EndPointStatisticsStack endPointStatisticsStack = null;
                Object statisticsStackObj =
                        synCtx.getProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS);
                if (statisticsStackObj == null) {
                    endPointStatisticsStack = new EndPointStatisticsStack();
                    synCtx.setProperty(org.apache.synapse.SynapseConstants.ENDPOINT_STATS,
                            endPointStatisticsStack);
                } else if (statisticsStackObj instanceof EndPointStatisticsStack) {
                    endPointStatisticsStack = (EndPointStatisticsStack) statisticsStackObj;
                }
                if (endPointStatisticsStack != null) {
                    boolean isFault = synCtx.getEnvelope().getBody().hasFault();
                    endPointStatisticsStack.put(endPointName, System.currentTimeMillis(),
                            !synCtx.isResponse(), statisticsEnable, isFault);
                }
            }
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Sending message to WSDL endpoint : "" +
                        endPointName + "" resolves to address = "" + eprAddress);
                traceOrDebug(traceOn, ""SOAPAction: "" + (synCtx.getSoapAction() != null ?
                        synCtx.getSoapAction() : ""null""));
                traceOrDebug(traceOn, ""WSA-Action: "" + (synCtx.getWSAAction() != null ?
                        synCtx.getWSAAction() : ""null""));

                if (traceOn && trace.isTraceEnabled()) {
                    trace.trace(""Envelope : \n"" + synCtx.getEnvelope());
                }
            }

            // register this as the immediate fault handler for this message.
            synCtx.pushFaultHandler(this);

            // add this as the last endpoint to process this message. it is used by statistics code.
            synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);

            synCtx.getEnvironment().send(endpoint, synCtx);
        }
    }

    public void onFault(MessageContext synCtx) {
        // perform retries here

        // if this endpoint has actually failed, inform the parent.
        setActive(false, synCtx);

        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synCtx);
        } else {
            Stack faultStack = synCtx.getFaultStack();
            if (!faultStack.isEmpty()) {
                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
            }
        }
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
        // WSDLEndpoint does not contain any child endpoints. So this method will never be called.
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public String getWsdlURI() {
        return wsdlURI;
    }

    public void setWsdlURI(String wsdlURI) {
        this.wsdlURI = wsdlURI;
    }

    public OMElement getWsdlDoc() {
        return wsdlDoc;
    }

    public void setWsdlDoc(OMElement wsdlDoc) {
        this.wsdlDoc = wsdlDoc;
    }

    public String getServiceName() {
        return serviceName;
    }

    public void setServiceName(String serviceName) {
        this.serviceName = serviceName;
    }

    public String getPortName() {
        return portName;
    }

    public void setPortName(String portName) {
        this.portName = portName;
    }

    /**
     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
     * suspendOnFailDuration has elapsed, it will be set to active.
     *
     * @param synMessageContext MessageContext of the current message. This is not used here.
     * @return true if endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        boolean active = endpointContext.isActive();
        if (!active) {
            long recoverOn = endpointContext.getRecoverOn();
            if (System.currentTimeMillis() > recoverOn) {
                active = true;
                endpointContext.setActive(true);
            }
        }

        if (log.isDebugEnabled()) {
            log.debug(""WSDLEndpoint with name '"" + name + ""' is in ""
                    + (active ? ""active"" : ""inactive"") + "" state"");
        }

        return active;
    }

    /**
     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
     * time is calculated so that it will be activated after the recover on time.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext of the current message. This is not used here.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {

        if (!active) {
            if (endpoint.getSuspendOnFailDuration() != -1) {
                // Calculating a new value by adding suspendOnFailDuration to current time.
                // as the endpoint is set as failed
                endpointContext.setRecoverOn(
                        System.currentTimeMillis() + endpoint.getSuspendOnFailDuration());
            } else {
                endpointContext.setRecoverOn(Long.MAX_VALUE);
            }
        }

        endpointContext.setActive(true);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public EndpointDefinition getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(EndpointDefinition endpoint) {
        this.endpoint = endpoint;
    }

    /**
     * Should this mediator perform tracing? True if its explicitly asked to
     * trace, or its parent has been asked to trace and it does not reject it
     *
     * @param msgCtx the current message
     * @return true if tracing should be performed
     */
    protected boolean isTraceOn(MessageContext msgCtx) {
        return
                (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
                        (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
                                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
    }

    /**
     * Is tracing or debug logging on?
     *
     * @param isTraceOn is tracing known to be on?
     * @return true, if either tracing or debug logging is on
     */
    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
        return isTraceOn || log.isDebugEnabled();
    }

    /**
     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
     *
     * @param traceOn is runtime trace on for this message?
     * @param msg     the message to log/trace
     */
    protected void traceOrDebug(boolean traceOn, String msg) {
        if (traceOn) {
            trace.info(msg);
        }
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
    }
}
"
org/apache/synapse/config/xml/EntrySerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.config.Entry;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.impl.llom.OMTextImpl;
import javax.xml.stream.XMLStreamConstants;
import java.net.URL;

/**
 * Serializer for {@link Entry} instances.
 */
public class EntrySerializer {

    private static Log log = LogFactory.getLog(EntrySerializer.class);

    protected static final OMFactory fac = OMAbstractFactory.getOMFactory();
    protected static final OMNamespace synNS = fac.createOMNamespace(
            XMLConfigConstants.SYNAPSE_NAMESPACE, ""syn"");
    protected static final OMNamespace nullNS = fac.createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

    /**
     * Serialize the Entry object to an OMElement representing the entry
     * @param entry
     * @param parent
     * @return OMElement representing the entry
     */
    public static OMElement serializeEntry(Entry entry, OMElement parent) {
        OMElement propertyElement = fac.createOMElement(""localEntry"", synNS);
        propertyElement.addAttribute(fac.createOMAttribute(
                ""key"", nullNS, entry.getKey().trim()));
        int type = entry.getType();
        if (type == Entry.URL_SRC) {
            URL srcUrl = entry.getSrc();
            if (srcUrl != null) {
                propertyElement.addAttribute(fac.createOMAttribute(
                        ""src"", nullNS, srcUrl.toString().trim()));
            }
        } else if (type == Entry.INLINE_XML) {
            Object value = entry.getValue();
            if (value != null && value instanceof OMElement) {
                propertyElement.addChild((OMElement) value);
            }
        } else if (type == Entry.INLINE_TEXT) {
            Object value = entry.getValue();
            if (value != null && value instanceof String) {
                OMTextImpl textData = (OMTextImpl) fac.createOMText(((String) value).trim());
                textData.setType(XMLStreamConstants.CDATA);
                propertyElement.addChild(textData);
            }
        } else if (type == Entry.REMOTE_ENTRY) {
            // nothing to serialize
            return null;
        } else {
            handleException(""Entry type undefined"");
        }
        if (parent != null) {
            parent.addChild(propertyElement);
        }
        return propertyElement;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.AddressEndpoint;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

/**
 * Serializes {@link AddressEndpoint} to XML.
 *
 * @see AddressEndpointFactory
 */
public class AddressEndpointSerializer extends DefaultEndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof AddressEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement
                = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        AddressEndpoint addressEndpoint = (AddressEndpoint) endpoint;
        String name = addressEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        EndpointDefinition epAddress = addressEndpoint.getEndpoint();
        OMElement addressElement = serializeEndpointDefinition(epAddress);
        endpointElement.addChild(addressElement);

        return endpointElement;
    }

    public OMElement serializeEndpointDefinition(EndpointDefinition endpointDefinition) {

        OMElement element = fac.createOMElement(""address"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        if (endpointDefinition.getAddress() != null) {
            element.addAttribute(
                    fac.createOMAttribute(""uri"", null, endpointDefinition.getAddress()));
        } else {
            handleException(""Invalid Endpoint. Address is required"");
        }

        serializeCommonEndpointProperties(endpointDefinition, element);
        serializeSpecificEndpointProperties(endpointDefinition, element);

        return element;
    }
}
"
org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.WSDLEndpoint;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

/**
 * Serializes an WSDL based endpoint to an XML configuration.
 * 
 * @see WSDLEndpointFactory
 */
public class WSDLEndpointSerializer extends EndpointSerializer {

    protected OMElement serializeEndpoint(Endpoint endpoint) {

        if (!(endpoint instanceof WSDLEndpoint)) {
            throw new SynapseException(""Invalid endpoint type."");
        }

        fac = OMAbstractFactory.getOMFactory();
        OMElement endpointElement
                = fac.createOMElement(""endpoint"", SynapseConstants.SYNAPSE_OMNAMESPACE);

        WSDLEndpoint wsdlEndpoint = (WSDLEndpoint) endpoint;
        String name = wsdlEndpoint.getName();
        if (name != null) {
            endpointElement.addAttribute(""name"", name, null);
        }

        OMElement wsdlElement = fac.createOMElement(""wsdl"", SynapseConstants.SYNAPSE_OMNAMESPACE);
        String serviceName = wsdlEndpoint.getServiceName();
        if (serviceName != null) {
            wsdlElement.addAttribute(""service"", serviceName, null);
        }

        String portName = wsdlEndpoint.getPortName();
        if (portName != null) {
            wsdlElement.addAttribute(""port"", portName, null);
        }

        String uri = wsdlEndpoint.getWsdlURI();
        if (uri != null) {
            wsdlElement.addAttribute(""uri"", uri, null);
        }

        OMElement wsdlDoc = wsdlEndpoint.getWsdlDoc();
        if (wsdlDoc != null) {
            wsdlElement.addChild(wsdlDoc);
        }

        // currently, we have to get QOS information from the endpoint definition and set them as
        // special elements under the wsdl element. in future, these information should be
        // extracted from the wsdl.
        EndpointDefinition epDefinition = wsdlEndpoint.getEndpoint();
        serializeCommonEndpointProperties(epDefinition, wsdlElement);
        serializeSpecificEndpointProperties(epDefinition, wsdlElement);
        endpointElement.addChild(wsdlElement);

        return endpointElement;
    }

    protected void serializeSpecificEndpointProperties(EndpointDefinition endpointDefinition, OMElement element) {
    }

}
"
org/apache/synapse/config/SynapseConfiguration.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axis2.AxisFault;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.*;
import org.apache.synapse.config.xml.MediatorFactoryFinder;
import org.apache.synapse.config.xml.endpoints.XMLToEndpointMapper;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.core.axis2.ProxyService;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.registry.Registry;

import javax.xml.namespace.QName;
import java.io.IOException;
import java.util.*;

/**
 * The SynapseConfiguration holds the global configuration for a Synapse
 * instance.
 */
public class SynapseConfiguration implements ManagedLifecycle {

	private static final Log log = LogFactory.getLog(SynapseConfiguration.class);

	/**
	 * The remote registry made available to the Synapse configuration. Only one
	 * is supported
	 */
	Registry registry = null;

    /**
     * This holds the default QName of the configuration.
     */
    private QName defaultQName = null;

    /**
     * Mandatory sequence is treated specially since it is required for each and every message.
     * Keeps the reference to the mandatory sequence while it is available as a sequence in the
     * localRegistry map
     */
    private Mediator mandatorySequence = null;

    /**
     * Holds Proxy services defined through Synapse
     */
	private Map<String, ProxyService> proxyServices = new HashMap<String, ProxyService>();

    /**
     * This holds a Map of ManagedLifecycle objects
     */
    private Map<String, Startup> startups = new HashMap<String, Startup>();

    /**
	 * The local registry is a simple HashMap and provides the ability to
	 * override definitions of a remote registry for entries defined locally
	 * with the same key
	 */
	private Map<String, Object> localRegistry = new HashMap<String, Object>();

    /** Holds the synapse properties */
    private Properties properties = new Properties();

    /**
     * This will provide the timer daemon object for the scheduled tasks.
     */
    private Timer synapseTimer = new Timer(true);

    /** Hold reference to the Axis2 ConfigurationContext */
	private AxisConfiguration axisConfiguration = null;

	/**
	 * Save the path to the configuration file loaded, to save it later if
	 * required
	 */
	private String pathToConfigFile = null;

    /**
	 * Add a named sequence into the local registry
	 *
	 * @param key
	 *            the name for the sequence
	 * @param mediator
	 *            a Sequence mediator
	 */
	public void addSequence(String key, Mediator mediator) {
		localRegistry.put(key, mediator);
	}

	/**
	 * Allow a dynamic sequence to be cached and made available through the
	 * local registry
	 *
	 * @param key
	 *            the key to lookup the sequence from the remote registry
	 * @param entry
	 *            the Entry object which holds meta information and the cached
	 *            resource
	 */
	public void addSequence(String key, Entry entry) {
		localRegistry.put(key, entry);
	}

	/**
	 * Returns the map of defined sequences in the configuration excluding the
	 * fetched sequences from remote registry.
	 *
	 * @return Map of SequenceMediators defined in the local configuration
	 */
	public Map<String, SequenceMediator> getDefinedSequences() {

        Map<String, SequenceMediator> definedSequences = new HashMap<String, SequenceMediator>();

        for (Object o : localRegistry.values()) {

            if (o instanceof SequenceMediator) {
                SequenceMediator seq = (SequenceMediator) o;
                definedSequences.put(seq.getName(), seq);
            }
        }
		return definedSequences;
	}

    /**
     * Gets the mandatory sequence, from the direct reference. This is also available in the
     * {@link SynapseConfiguration#getSequence} but this method improves the performance hence this
     * will be required for all messages
     *
     * @return mandatory sequence direct reference in the local configuration
     */
    public Mediator getMandatorySequence() {
        return mandatorySequence;
    }

    /**
     * Sets the mandatory sequence direct reference
     * 
     * @param mandatorySequence to be set as the direct reference
     */
    public void setMandatorySequence(Mediator mandatorySequence) {
        this.mandatorySequence = mandatorySequence;
    }

    /**
	 * Return the sequence specified with the given key
	 *
	 * @param key
	 *            the key being referenced
	 * @return the sequence referenced by the key
	 */
	public Mediator getSequence(String key) {
		Object o = localRegistry.get(key);
		if (o != null && o instanceof Mediator) {
			return (Mediator) o;
		}

		Entry entry;
		if (o != null && o instanceof Entry) {
			entry = (Entry) o;
		} else {
			entry = new Entry(key);
			entry.setType(Entry.REMOTE_ENTRY);
			entry.setMapper(MediatorFactoryFinder.getInstance());
		}

		if (registry != null) {
			o = registry.getResource(entry);
			if (o != null && o instanceof Mediator) {
				localRegistry.put(key, entry);
				return (Mediator) o;
			}
		}

		return null;
	}

	/**
	 * Removes a sequence from the local registry
	 *
	 * @param key
	 *            of the sequence to be removed
	 */
	public void removeSequence(String key) {
		localRegistry.remove(key);
	}

	/**
	 * Return the main/default sequence to be executed. This is the sequence
	 * which will execute for all messages when message mediation takes place
	 *
	 * @return the main mediator sequence
	 */
	public Mediator getMainSequence() {
		return getSequence(SynapseConstants.MAIN_SEQUENCE_KEY);
	}

	/**
	 * Return the fault sequence to be executed when Synapse encounters a fault
	 * scenario during processing
	 *
	 * @return the fault sequence
	 */
	public Mediator getFaultSequence() {
		return getSequence(SynapseConstants.FAULT_SEQUENCE_KEY);
	}

	/**
	 * Define a resource to the local registry. All static resources (e.g. URL
	 * source) are loaded during this definition phase, and the inability to
	 * load such a resource will not allow the definition of the resource to the
	 * local registry
	 *
	 * @param key
	 *            the key associated with the resource
	 * @param entry
	 *            the Entry that holds meta information about the resource and
	 *            its contents (or cached contents if the Entry refers to a
	 *            dynamic resource off a remote registry)
	 */
	public void addEntry(String key, Entry entry) {

		if (entry.getType() == Entry.URL_SRC && entry.getValue() == null) {
			try {
				entry.setValue(SynapseConfigUtils.getOMElementFromURL(entry.getSrc()
						.toString()));
				localRegistry.put(key, entry);
			} catch (IOException e) {
				handleException(""Can not read from source URL : ""
						+ entry.getSrc());
			}
		} else {
			localRegistry.put(key, entry);
		}
	}

    /**
     * Gives the set of remote entries that are cached in localRegistry as mapping of entry key
     * to the Entry definition
     * 
     * @return Map of locally cached entries
     */
    public Map<String, Entry> getCachedEntries() {

        Map<String, Entry> cachedEntries = new HashMap<String, Entry>();
        for (Object o : localRegistry.values()) {

            if (o != null && o instanceof Entry) {
                Entry entry = (Entry) o;
                if (entry.isDynamic() && entry.isCached()) {
                    cachedEntries.put(entry.getKey(), entry);
                }
            }
        }

        return cachedEntries;
    }

    /**
	 * Returns the map of defined entries in the configuration excluding the
	 * fetched entries from remote registry.
	 *
	 * @return Map of Entries defined in the local configuraion
	 */
	public Map<String, Entry> getDefinedEntries() {

        Map<String, Entry> definedEntries = new HashMap<String, Entry>();
        for (Object o : localRegistry.values()) {

            if (o instanceof Entry
                && ((Entry) o).getType() != Entry.REMOTE_ENTRY) {

                Entry entry = (Entry) o;
                definedEntries.put(entry.getKey(), entry);
            }
        }
		return definedEntries;
	}

	/**
	 * Get the resource with the given key
	 *
	 * @param key
	 *            the key of the resource required
	 * @return its value
	 */
	public Object getEntry(String key) {
		Object o = localRegistry.get(key);
		if (o != null && o instanceof Entry) {
			Entry entry = (Entry) o;
			if (entry.isDynamic()) {
                if (entry.isCached() && !entry.isExpired()) {
                    return entry.getValue();
                } else if (registry != null) {
                    o = registry.getResource(entry);
                } else {
                    if (log.isDebugEnabled()) {
                        log.debug(""Will not  evaluate the value of the remote entry with a key ""
                            + key + "",  because the registry is not available"");
                    }
                    return null; // otherwise will return an entry with a value null
                    // (method expects return  a value not an entry )
                }
			} else {
				return entry.getValue();
			}
		}
		return o;
	}

	/**
	 * Get the Entry object mapped to the given key
	 *
	 * @param key
	 *            the key for which the Entry is required
	 * @return its value
	 */
	public Entry getEntryDefinition(String key) {
		Object o = localRegistry.get(key);
		if (o == null || o instanceof Entry) {
			if (o == null) {
				// this is not a local definition
				Entry entry = new Entry(key);
				entry.setType(Entry.REMOTE_ENTRY);
				addEntry(key, entry);
				return entry;
			}
			return (Entry) o;
		} else {
			handleException(""Invalid local registry entry : "" + key);
			return null;
		}
	}

	/**
	 * Deletes any reference mapped to the given key from the local registry
	 *
	 * @param key
	 *            the key of the reference to be removed
	 */
	public void removeEntry(String key) {
		localRegistry.remove(key);
	}

    /**
     * Clears the cache of the remote entry with the key specified
     * 
     * @param key - String key of the entry
     */
    public void clearCachedEntry(String key) {
        Entry entry = getEntryDefinition(key);
        if (entry.isDynamic() && entry.isCached()) {
            entry.clearCache();
        }
    }

    /**
     * Clears the cache of all the remote entries which has been
     * cached in the configuration
     */
    public void clearCache() {

        for (Object o : localRegistry.values()) {
            
            if (o != null && o instanceof Entry) {
                Entry entry = (Entry) o;
                if (entry.isDynamic() && entry.isCached()) {
                    entry.clearCache();
                }
            }
        }
    }

    /**
	 * Define a named endpoint with the given key
	 *
	 * @param key
	 *            the key for the endpoint
	 * @param endpoint
	 *            the endpoint definition
	 */
	public void addEndpoint(String key, Endpoint endpoint) {
		localRegistry.put(key, endpoint);
	}

	/**
	 * Add a dynamic endpoint definition to the local registry
	 *
	 * @param key
	 *            the key for the endpoint definition
	 * @param entry
	 *            the actual endpoint definition to be added
	 */
	public void addEndpoint(String key, Entry entry) {
		localRegistry.put(key, entry);
	}

	/**
	 * Returns the map of defined endpoints in the configuration excluding the
	 * fetched endpoints from remote registry
	 *
	 * @return Map of Endpoints defined in the local configuration
	 */
	public Map<String, Endpoint> getDefinedEndpoints() {

        Map<String, Endpoint> definedEndpoints = new HashMap<String, Endpoint>();
        for (Object o : localRegistry.values()) {

            if (o instanceof Endpoint) {
                Endpoint ep = (Endpoint) o;
                definedEndpoints.put(ep.getName(), ep);
            }
        }

        return definedEndpoints;
	}

	/**
	 * Get the definition of the endpoint with the given key
	 *
	 * @param key
	 *            the key of the endpoint
	 * @return the endpoint definition
	 */
	public Endpoint getEndpoint(String key) {
        
        Object o = localRegistry.get(key);
		if (o != null && o instanceof Endpoint) {
			return (Endpoint) o;
		}

		Entry entry;
		if (o != null && o instanceof Entry) {
			entry = (Entry) o;
		} else {
			entry = new Entry(key);
			entry.setType(Entry.REMOTE_ENTRY);
			entry.setMapper(XMLToEndpointMapper.getInstance());
		}

		if (registry != null) {
			o = registry.getResource(entry);
			if (o != null && o instanceof Endpoint) {
				localRegistry.put(key, entry);
				return (Endpoint) o;
			}
		}

		return null;
	}

	/**
	 * Deletes the endpoint with the given key
	 *
	 * @param key
	 *            of the endpoint to be deleted
	 */
	public void removeEndpoint(String key) {
		localRegistry.remove(key);
	}

	/**
	 * Add a Proxy service to the configuration
	 *
	 * @param name
	 *            the name of the Proxy service
	 * @param proxy
	 *            the Proxy service instance
	 */
	public void addProxyService(String name, ProxyService proxy) {
		proxyServices.put(name, proxy);
	}

	/**
	 * Get the Proxy service with the given name
	 *
	 * @param name
	 *            the name being looked up
	 * @return the Proxy service
	 */
	public ProxyService getProxyService(String name) {
		return proxyServices.get(name);
	}

	/**
	 * Deletes the Proxy Service named with the given name
	 *
	 * @param name
	 *            of the Proxy Service to be deleted
	 */
	public void removeProxyService(String name) {
		Object o = proxyServices.get(name);
		if (o == null) {
			handleException(""Unknown proxy service for name : "" + name);
		} else {
			try {
				if (getAxisConfiguration().getServiceForActivation(name) != null) {
					if (getAxisConfiguration().getServiceForActivation(name)
							.isActive()) {
						getAxisConfiguration().getService(name)
								.setActive(false);
					}
					getAxisConfiguration().removeService(name);
				}
				proxyServices.remove(name);
			} catch (AxisFault axisFault) {
				handleException(axisFault.getMessage());
			}
		}
	}

	/**
	 * Return the list of defined proxy services
	 *
	 * @return the proxy services defined
	 */
	public Collection<ProxyService> getProxyServices() {
		return proxyServices.values();
	}

	/**
	 * Return an unmodifiable copy of the local registry
	 *
	 * @return an unmodifiable copy of the local registry
	 */
	public Map getLocalRegistry() {
		return Collections.unmodifiableMap(localRegistry);
	}

	/**
	 * Get the remote registry defined (if any)
	 *
	 * @return the currently defined remote registry
	 */
	public Registry getRegistry() {
		return registry;
	}

	/**
	 * Set the remote registry for the configuration
	 *
	 * @param registry
	 *            the remote registry for the configuration
	 */
	public void setRegistry(Registry registry) {
		this.registry = registry;
	}

	/**
	 * Set the Axis2 AxisConfiguration to the SynapseConfiguration
	 *
	 * @param axisConfig AxisConfiguration to be set
	 */
	public void setAxisConfiguration(AxisConfiguration axisConfig) {
		this.axisConfiguration = axisConfig;
	}

	/**
	 * Get the Axis2 AxisConfiguration for the SynapseConfiguration
	 *
	 * @return AxisConfiguration of the Axis2
	 */
	public AxisConfiguration getAxisConfiguration() {
		return axisConfiguration;
	}

	/**
	 * The path to the currently loaded configuration file
	 *
	 * @return file path to synapse.xml
	 */
	public String getPathToConfigFile() {
		return pathToConfigFile;
	}

	/**
	 * Set the path to the loaded synapse.xml
	 *
	 * @param pathToConfigFile
	 *            path to the synapse.xml loaded
	 */
	public void setPathToConfigFile(String pathToConfigFile) {
		this.pathToConfigFile = pathToConfigFile;
	}

    /**
     * Set the default QName of the Synapse Configuration
     * 
     * @param defaultQName
     *          QName specifying the default QName of the configuration
     */
    public void setDefaultQName(QName defaultQName) {
		this.defaultQName = defaultQName;
	}

    /**
     * Get the default QName of the configuration.
     * 
     * @return default QName of the configuration
     */
    public QName getDefaultQName() {
		return defaultQName;
	}

    /**
     * Get the timer object for the Synapse Configuration
     *
     * @return synapseTimer timer object of the configuration
     */
    public Timer getSynapseTimer() {
        return synapseTimer;
    }

    /**
     * Get the startup collection in the configuration
     *
     * @return collection of startup objects registered
     */
    public Collection<Startup> getStartups() {
        return startups.values();
    }

    /**
     * Get the Startup with the specified name
     * 
     * @param id - String name of the startup to be retrieved
     * @return Startup object with the specified name or null
     */
    public Startup getStartup(String id) {
        return startups.get(id);
    }

    /**
     * Add a startup to the startups map in the configuration
     *
     * @param startup - Startup object to be added 
     */
    public void addStartup(Startup startup) {
        startups.put(startup.getName(), startup);
    }

    /**
     * Removes the startup specified by the name
     * 
     * @param name - name of the startup that needs to be removed
     */
    public void removeStartup(String name) {
        startups.remove(name);
    }

    /**
     * Gets the properties to configure the Synapse environment.
     * 
     * @return set of properties as Properties
     */
    public Properties getProperties() {
        return properties;
    }

    /**
     * Sets the properties to configure the Synapse enviornment.
     *
     * @param properties - Properties which needs to be set
     */
    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    /**
     * Gets the String representation of the property value if there is a property for the
     * given propKey or returns the default value passed
     * 
     * @param propKey - key for the property lookup
     * @param def     - default value
     * @return String representation of the property value with the given key or the def value
     */
    public String getProperty(String propKey, String def) {
        String val = System.getProperty(propKey);
        if (val == null) {
            val = properties.getProperty(propKey);
        }

        if (val != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Using synapse tuning parameter : "" + propKey + "" = "" + val);
            }
            return val;
        }
        return def;
    }

    /**
     * Gets the String representation of the property value if there is a property for the
     * given propKey or returns the default value passed
     *
     * @param propKey - key for the property lookup
     * @param def     - default value
     * @return String representation of the property value with the given key or the def value
     */
    public long getProperty(String propKey, long def) {
        String val = System.getProperty(propKey);
        if (val == null) {
            val = properties.getProperty(propKey);
        }

        if (val != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Using synapse tuning parameter : "" + propKey + "" = "" + val);
            }
            return Long.valueOf(val);
        }
        return def;
    }

    /**
     * Gets the propety value if the property specified by the propKey is there or null else
     *
     * @param propKey - key for the property lookup
     * @return String representation of the property value if found or null else
     */
    public String getProperty(String propKey) {
        String val = System.getProperty(propKey);
        if (val == null) {
            val = properties.getProperty(propKey);
        }

        if (val != null) {
            if (log.isDebugEnabled()) {
                log.debug(""Using synapse tuning parameter : "" + propKey + "" = "" + val);
            }
            return val;
        }
        return null;
    }

    /**
     * This method will be called on the soft shutdown or destroying the configuration
     * and will destroy all the stateful managed parts of the configuration.
     */
    public void destroy() {
        
        if (log.isDebugEnabled()) {
            log.debug(""Destroying the Synapse Configuration"");
        }

        // clear the timer tasks of Synapse
        synapseTimer.cancel();
        synapseTimer = null;

        // stop and shutdown all the proxy services
        for (ProxyService p : getProxyServices()) {

            if (p.getTargetInLineInSequence() != null) {
                p.getTargetInLineInSequence().destroy();
            }

            if (p.getTargetInLineOutSequence() != null) {
                p.getTargetInLineOutSequence().destroy();
            }
        }

        // destroy the managed mediators
        for (SequenceMediator seq : getDefinedSequences().values()) {
            if (seq != null) {
                seq.destroy();
            }
        }

        // destroy the startups
        if (startups != null) {
            
            for (Startup stp : startups.values()) {
                if (stp != null) {
                    stp.destroy();
                }
            }
        }
    }

    /**
     * This method will be called in the startup of Synapse or in an initiation
     * and will initialize all the managed parts of the Synapse Configuration
     *
     * @param se
     *          SynapseEnvironment specifying the env to be initialized
     */
    public void init(SynapseEnvironment se) {
        
        if (log.isDebugEnabled()) {
            log.debug(""Initializing the Synapse Configuration"");
        }

        // initialize registry
        if (registry != null && registry instanceof ManagedLifecycle) {
            ((ManagedLifecycle) registry).init(se);
        }
        
        // initialize all the proxy services
        for (ProxyService p : getProxyServices()) {
            
                if (p.getTargetInLineInSequence() != null) {
                    p.getTargetInLineInSequence().init(se);
                }
            
                if (p.getTargetInLineOutSequence() != null) {
                    p.getTargetInLineOutSequence().init(se);
                }
        }

        // initialize managed mediators
        for (SequenceMediator seq : getDefinedSequences().values()) {
            if (seq != null) {
                seq.init(se);
            }
        }
    }

    private void handleException(String msg) {
		log.error(msg);
		throw new SynapseException(msg);
	}
}
"
org/apache/synapse/config/xml/InMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.filters.InMediator;

import javax.xml.namespace.QName;

/**
 * Factory for {@link InMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;in&gt;
 *    mediator+
 * &lt;/in&gt;
 * </pre>
 */
public class InMediatorFactory extends AbstractListMediatorFactory {

    private static final QName IN_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""in"");

    public Mediator createMediator(OMElement elem) {
        InMediator filter = new InMediator();
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(filter,elem);
        addChildren(elem, filter);
        return filter;
    }

    public QName getTagQName() {
        return IN_Q;
    }
}
"
org/apache/synapse/config/xml/AbstractListMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.ListMediator;
import org.apache.synapse.Mediator;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * This implements the basic logic to build a list mediator from a given XML
 * configuration. It recursively builds the child mediators of the list.
 */
public abstract class AbstractListMediatorFactory extends AbstractMediatorFactory {

    protected static void addChildren(OMElement el, ListMediator m) {
        Iterator it = el.getChildElements();
        while (it.hasNext()) {
            OMElement child = (OMElement) it.next();
            Mediator med = MediatorFactoryFinder.getInstance().getMediator(child);
            if (med != null) {
                m.addChild(med);
            } else {
                String msg = ""Unknown mediator : "" + child.getLocalName();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
    }
}
"
org/apache/synapse/mediators/db/DBReportMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.db;

import org.apache.synapse.MessageContext;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Connection;

/**
 * A mediator that writes (i.e. inserts one row) to a table using message information
 */
public class DBReportMediator extends AbstractDBMediator {

    protected void processStatement(Statement stmnt, MessageContext msgCtx) {

        boolean traceOn = isTraceOn(msgCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        Connection con = null;
        try {
            PreparedStatement ps = getPreparedStatement(stmnt, msgCtx);
            con = ps.getConnection();
            int count = ps.executeUpdate();

            if (count > 0) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Inserted "" + count + "" row/s using statement : "" + stmnt.getRawStatement());
                }
            } else {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""No rows were inserted for statement : "" + stmnt.getRawStatement());
                }
            }
            con.commit();

        } catch (SQLException e) {
            handleException(""Error execuring insert statement : "" + stmnt.getRawStatement() +
                "" against DataSource : "" + getDSName(), e, msgCtx);
        } finally {
            if (con != null) {
                try {
                    con.close();
                } catch (SQLException ignore) {}
            }
        }
    }
}
"
org/apache/synapse/util/xpath/SynapseXPathConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.xpath;

/**
 * All the constants that has been used for the SynapseXPath
 */
public final class SynapseXPathConstants {

    /** Get-Property XPath extension function name */
    public static final String GET_PROPERTY_FUNCTION = ""get-property"";

    /** Body relative XPath variale name for the SOAPBody */
    public static final String SOAP_BODY_VARIABLE = ""body"";

    /** Header relative XPath variable name for the SOAPHeader */
    public static final String SOAP_HEADER_VARIABLE = ""header"";

    /** Variable prefix for accessing the MessageContext properties through XPath variables */
    public static final String MESSAGE_CONTEXT_VARIABLE_PREFIX = ""ctx"";

    /** Variable prefix for accessing the axis2 MessageContext properties through XPath variables */
    public static final String AXIS2_CONTEXT_VARIABLE_PREFIX = ""axis2"";

    /** Variable prefix for accessing transport headers of the message through XPath variables */
    public static final String TRANSPORT_VARIABLE_PREFIX = ""trp"";
}
"
org/apache/synapse/config/xml/XSLTMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.transform.XSLTMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;

/**
 * Factory for {@link XSLTMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;xslt key=""property-key"" [source=""xpath""] [target=""string""]&gt;
 *   &lt;property name=""string"" (value=""literal"" | expression=""xpath"")/&gt;*
 *   &lt;feature name=""string"" value=""true| false"" /&gt;*
 * &lt;/transform&gt;
 * </pre>
 */
public class XSLTMediatorFactory extends AbstractMediatorFactory {

    private static final QName TAG_NAME    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""xslt"");

    public QName getTagQName() {
        return TAG_NAME;
    }

    public Mediator createMediator(OMElement elem) {

        XSLTMediator transformMediator = new XSLTMediator();

        OMAttribute attXslt   = elem.getAttribute(ATT_KEY);
        OMAttribute attSource = elem.getAttribute(ATT_SOURCE);
        OMAttribute attTarget = elem.getAttribute(ATT_TARGET);

        if (attXslt != null) {
            transformMediator.setXsltKey(attXslt.getAttributeValue());
        } else {
            handleException(""The 'key' attribute is required for the XSLT mediator"");
        }

        if (attSource != null) {
            try {
                transformMediator.setSourceXPathString(attSource.getAttributeValue());
                transformMediator.setSource(SynapseXPathFactory.getSynapseXPath(elem, ATT_SOURCE));

            } catch (JaxenException e) {
                handleException(""Invalid XPath specified for the source attribute : "" +
                    attSource.getAttributeValue());
            }
        }

        if (attTarget != null) {
            transformMediator.setTargetPropertyName(attTarget.getAttributeValue());    
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(transformMediator, elem);
        // set the features 
        Iterator iter = elem.getChildrenWithName(FEATURE_Q);
        while (iter.hasNext()) {
            OMElement featureElem = (OMElement) iter.next();
            OMAttribute attName = featureElem.getAttribute(ATT_NAME);
            OMAttribute attValue = featureElem.getAttribute(ATT_VALUE);
            if (attName != null && attValue != null) {
                String name = attName.getAttributeValue();
                String value = attValue.getAttributeValue();
                if (name != null && value != null) {
                    if (""true"".equals(value.trim())) {
                        transformMediator.addFeature(name.trim(),
                                true);
                    } else if (""false"".equals(value.trim())) {
                        transformMediator.addFeature(name.trim(),
                                false);
                    } else {
                        handleException(""The feature must have value true or false"");
                    }
                } else {
                    handleException(""The valid values for both of the name and value are need"");
                }
            } else {
                handleException(""Both of the name and value attribute are required for a feature"");
            }
        }
        transformMediator.addAllProperties(
            MediatorPropertyFactory.getMediatorProperties(elem));

        return transformMediator;
    }
}
"
org/apache/synapse/mediators/transform/HeaderMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.transform;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.util.xpath.SynapseXPath;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.List;

/**
 * The header mediator is able to set a given value as a SOAP header, or remove a given
 * header from the current message instance. This supports the headers currently
 * supported by the HeaderType class. If an expression is supplied, its runtime value
 * is evaluated using the current message. Unless the action is set to remove, the
 * default behavior of this mediator is to set a header value.
 */
public class HeaderMediator extends AbstractMediator {

    public static final int ACTION_SET = 0;
    public static final int ACTION_REMOVE = 1;

    /** The qName of the header @see HeaderType */
    private QName qName = null;
    /** The literal value to be set as the header (if one was specified) */
    private String value = null;
    /** Set the header (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */
    private int action = ACTION_SET;
    /** An expression which should be evaluated, and the result set as the header value */
    private SynapseXPath expression = null;

    /**
     * Sets/Removes a SOAP header on the current message
     *
     * @param synCtx the current message which is altered as necessary
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Header mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        if (action == ACTION_SET) {

            String value = (getExpression() == null ? getValue() :
                    expression.stringValueOf(synCtx));

            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Set SOAP header : "" + qName + "" to : "" + value);
            }

            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {

                // is this a ""well known"" Synapse header?
                if (SynapseConstants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_FROM.equals(qName.getLocalPart())) {
                    synCtx.setFrom(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(value);
                } else if (SynapseConstants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(new EndpointReference(value));
                } else if (SynapseConstants.HEADER_RELATES_TO.equals(qName.getLocalPart())) {
                    synCtx.setRelatesTo(new RelatesTo[] { new RelatesTo(value) });
                } else {
                    addCustomHeader(synCtx, value);
                }
            } else {
                addCustomHeader(synCtx, value);
            }

        } else {

             if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Removing SOAP Header : "" + qName);
            }

            if (qName.getNamespaceURI() == null || """".equals(qName.getNamespaceURI())) {

                // is this a ""well known"" Synapse header?
                if (SynapseConstants.HEADER_TO.equals(qName.getLocalPart())) {
                    synCtx.setTo(null);
                } else if (SynapseConstants.HEADER_FROM.equals(qName.getLocalPart())) {
                    synCtx.setFrom(null);
                } else if (SynapseConstants.HEADER_ACTION.equals(qName.getLocalPart())) {
                    synCtx.setWSAAction(null);
                } else if (SynapseConstants.HEADER_FAULT.equals(qName.getLocalPart())) {
                    synCtx.setFaultTo(null);
                } else if (SynapseConstants.HEADER_REPLY_TO.equals(qName.getLocalPart())) {
                    synCtx.setReplyTo(null);
                } else if (SynapseConstants.HEADER_RELATES_TO.equals(qName.getLocalPart())) {
                    synCtx.setRelatesTo(null);
                } else {
                    SOAPEnvelope envelope = synCtx.getEnvelope();
                    if (envelope != null) {
                        SOAPHeader header = envelope.getHeader();
                        if (header != null) {
                            removeFromHeaderList(header.
                                getHeaderBlocksWithNSURI(""""));
                        }
                    }
                }

            } else {
                SOAPEnvelope envelope = synCtx.getEnvelope();
                if (envelope != null) {
                    SOAPHeader header = envelope.getHeader();
                    if (header != null) {
                        removeFromHeaderList(header.
                            getHeaderBlocksWithNSURI(qName.getNamespaceURI()));
                    }
                }
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Header mediator"");
        }
        return true;
    }

    private void addCustomHeader(MessageContext synCtx, String value) {
        SOAPEnvelope env = synCtx.getEnvelope();
        if (env == null) {
            return;
        }
        SOAPFactory fac = (SOAPFactory) env.getOMFactory();
        SOAPHeader header = env.getHeader();
        if (header == null) {
            header = fac.createSOAPHeader(env);
        }
        SOAPHeaderBlock hb = header.addHeaderBlock(qName.getLocalPart(),
                fac.createOMNamespace(qName.getNamespaceURI(), qName.getPrefix()));
        hb.setText(value);
    }

    private void removeFromHeaderList(List headersList) {
        if (headersList == null || headersList.isEmpty()) {
            return;
        }
        for ( Iterator iter = headersList.iterator();iter.hasNext();) {
            Object o = iter.next();
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock header = (SOAPHeaderBlock) o;
                if (header.getLocalName().equals(qName.getLocalPart())) {
                    header.detach();
                }
            } else if (o instanceof OMElement) {
                OMElement omElem = (OMElement) o;
                if (omElem.getLocalName().equals(qName.getLocalPart())) {
                    omElem.detach();
                }
            }
        }
    }

    public int getAction() {
        return action;
    }

    public void setAction(int action) {
        this.action = action;
    }

    public QName getQName() {
        return qName;
    }

    public void setQName(QName qName) {
        this.qName = qName;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public SynapseXPath getExpression() {
        return expression;
    }

    public void setExpression(SynapseXPath expression) {
        this.expression = expression;
    }
}
"
org/apache/synapse/core/axis2/SynapseMustUnderstandHandler.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.handlers.AbstractHandler;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * This is a handler for axis2 which will clear the mustUnderstand ness of the headers
 * if there are any after the Dispatch, which will allow Synapse to get the message
 * even with unprocessed mustUnderstand headers
 */
public class SynapseMustUnderstandHandler extends AbstractHandler {
    
    public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {

        SOAPEnvelope envelope = messageContext.getEnvelope();

        if (envelope.getHeader() != null) {
            Iterator headerBlocks = envelope.getHeader().getHeadersToProcess(null);
            ArrayList markedHeaderBlocks = new ArrayList();

            while (headerBlocks.hasNext()) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) headerBlocks.next();

                // if this header block mustUnderstand but has not been processed
                // then mark it as processed to get the message in to Synapse
                if (!headerBlock.isProcessed() && headerBlock.getMustUnderstand()) {
                    markedHeaderBlocks.add(headerBlock);
                    headerBlock.setProcessed();
                }
            }

            // incase we need to get them inside synapse
            messageContext.setProperty(""headersMarkedAsProcessedBySynapse"", markedHeaderBlocks);
        }

        return InvocationResponse.CONTINUE;
    }
}
"
org/apache/synapse/config/xml/MediatorSerializerFinder.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.Mediator;
import sun.misc.Service;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class MediatorSerializerFinder {

    private static final Log log = LogFactory.getLog(MediatorSerializerFinder.class);

    private static final Class[] mediatorSerializers = {
        SequenceMediatorSerializer.class,
        LogMediatorSerializer.class,
        SendMediatorSerializer.class,
        FilterMediatorSerializer.class,
        SynapseMediatorSerializer.class,
        DropMediatorSerializer.class,
        HeaderMediatorSerializer.class,
        FaultMediatorSerializer.class,
        PropertyMediatorSerializer.class,
        SwitchMediatorSerializer.class,
        InMediatorSerializer.class,
        OutMediatorSerializer.class,
        RMSequenceMediatorSerializer.class,     
        ClassMediatorSerializer.class,
        ValidateMediatorSerializer.class,
        XSLTMediatorSerializer.class,
        POJOCommandMediatorSerializer.class,
        CloneMediatorSerializer.class,
        IterateMediatorSerializer.class,
        AggregateMediatorSerializer.class,
        DBLookupMediatorSerializer.class,
        DBReportMediatorSerializer.class,
        CacheMediatorSerializer.class,
        CalloutMediatorSerializer.class
    };

    private static MediatorSerializerFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map<String, MediatorSerializer> serializerMap
            = new HashMap<String, MediatorSerializer>();

    public static synchronized MediatorSerializerFinder getInstance() {
        if (instance == null) {
            instance = new MediatorSerializerFinder();
        }
        return instance;
    }

    public MediatorSerializer getSerializer(Mediator mediator) {
        return serializerMap.get(mediator.getClass().getName());
    }

    private MediatorSerializerFinder() {

        serializerMap = new HashMap<String, MediatorSerializer>();

        for (Class c : mediatorSerializers) {
            try {
                MediatorSerializer ser = (MediatorSerializer) c.newInstance();
                serializerMap.put(ser.getMediatorClassName(), ser);
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    /**
     * Register pluggable mediator serializers from the classpath
     *
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {
        if (log.isDebugEnabled()) {
            log.debug(""Registering mediator extensions found in the classpath.. "");
        }
        // register MediatorSerializer extensions
        Iterator it = Service.providers(MediatorSerializer.class);
        while (it.hasNext()) {
            MediatorSerializer ms = (MediatorSerializer) it.next();
            String name = ms.getMediatorClassName();
            try {
                serializerMap.put(name, ms.getClass().newInstance());
            } catch (InstantiationException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            } catch (IllegalAccessException e) {
                handleException(""Error instantiating mediator serializer : "" + ms);
            }
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorSerializer "" + ms.getClass().getName() + "" to handle "" + name);
            }
        }
    }

    /**
     * This method will return the serializer Map registered with the Finder
     * 
     * @return Map of serilaizers already registered with the Finder
     */
    public Map<String, MediatorSerializer> getSerializerMap() {
        return serializerMap;
    }

    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }
}
"
org/apache/synapse/mediators/builtin/DropMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.mediators.AbstractMediator;

/**
 * Halts further processing/mediation of the current message. i.e. returns false
 */
public class DropMediator extends AbstractMediator {

    /**
     * Halts further mediation of the current message by returning false.
     *
     * @param synCtx the current message
     * @return false always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Drop mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        //If drop mediator is a child of a sequence
        // and if this sequence is a IN or OUT sequence of a proxy service
        StatisticsUtils.processProxyServiceStatistics(synCtx);
        //If this a sequence is not  a IN or OUT sequence of a proxy service
        StatisticsUtils.processAllSequenceStatistics(synCtx);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Drop mediator"");
        }
        synCtx.setTo(null);
        return false;
    }
}
"
org/apache/synapse/config/xml/SendMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.config.xml.endpoints.EndpointSerializer;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

/**
 * Serializer for {@link SendMediator} instances.
 * 
 * @see SendMediatorFactory
 */
public class SendMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof SendMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        SendMediator mediator = (SendMediator) m;
        OMElement send = fac.createOMElement(""send"", synNS);
        saveTracingState(send, mediator);

        Endpoint activeEndpoint = mediator.getEndpoint();
        if (activeEndpoint != null) {
            send.addChild(EndpointSerializer.getElementFromEndpoint(activeEndpoint));
        }

        if (parent != null) {
            parent.addChild(send);
        }
        return send;
    }

    public String getMediatorClassName() {
        return SendMediator.class.getName();
    }
}
"
org/apache/synapse/mediators/base/SynapseMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.base;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsUtils;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The SynapseMediator is the ""mainmediator"" of the synapse engine. It is
 * given each message on arrival at the Synapse engine. The Synapse configuration
 * holds a reference to this special mediator instance. The SynapseMediator
 * holds the list of mediators supplied within the <rules> element of an XML
 * based Synapse configuration
 *
 * @see org.apache.synapse.config.SynapseConfiguration#getMainSequence()
 */
public class SynapseMediator extends AbstractListMediator {

    /**
     * Perform the mediation specified by the rule set
     *
     * @param synCtx the message context
     * @return as per standard mediate() semantics
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Mediation using '"" + SynapseConstants.MAIN_SEQUENCE_KEY +
                ""' sequence Message is a : "" + (synCtx.isResponse() ? ""response"" : ""request""));

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // If the message flow path is OUT, then process the satatistics
        if (synCtx.isResponse()) {
            StatisticsUtils.processAllSequenceStatistics(synCtx);
        }

        //put the required property for the collecttng statistics for the message mediation
        StatisticsStack sequenceStack = (StatisticsStack) synCtx.getProperty(
                SynapseConstants.SEQUENCE_STATS);
        if (sequenceStack == null) {
            sequenceStack = new SequenceStatisticsStack();
            synCtx.setProperty(SynapseConstants.SEQUENCE_STATS,sequenceStack);
        }
        String seqName = ""MainSequence"";
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        sequenceStack.put(seqName,System.currentTimeMillis(),!synCtx.isResponse(),true,isFault);

        boolean result = super.mediate(synCtx);

        if (traceOrDebugOn) {
            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
            traceOrDebug(traceOn, ""End : Mediation using '"" +
                SynapseConstants.MAIN_SEQUENCE_KEY + ""' sequence"");
        }
        return result;        
    }
}
"
org/apache/synapse/config/xml/LogMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.LogMediator;

/**
 * <pre>
 * &lt;log [level=""simple|headers|full|custom""] [separator=""string""]&gt;
 *      &lt;property&gt; *
 * &lt;/log&gt;
 * </pre>
 */
public class LogMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof LogMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        LogMediator mediator = (LogMediator) m;
        OMElement log = fac.createOMElement(""log"", synNS);
        saveTracingState(log,mediator);

        if (mediator.getLogLevel() != LogMediator.SIMPLE) {
            log.addAttribute(fac.createOMAttribute(
                ""level"", nullNS,
                    mediator.getLogLevel() == LogMediator.HEADERS ? ""headers"" :
                    mediator.getLogLevel() == LogMediator.FULL ? ""full"" :
                    mediator.getLogLevel() == LogMediator.CUSTOM ? ""custom"" : ""simple""
                ));
        }

        if (mediator.getSeparator() != LogMediator.DEFAULT_SEP) {
            log.addAttribute(fac.createOMAttribute(
                ""separator"", nullNS, mediator.getSeparator()));
        }

        super.serializeProperties(log, mediator.getProperties());

        if (parent != null) {
            parent.addChild(log);
        }
        return log;
    }

    public String getMediatorClassName() {
        return LogMediator.class.getName();
    }
}
"
org/apache/synapse/metrics/MetricsConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.metrics;

/**
 * 
 */
public final class MetricsConstants {
    public static final String GLOBAL_REQUEST_COUNTER = ""__GLOBAL_REQUEST_COUNTER__"";
    public static final String REQUEST_RECEIVED_TIME = ""__REQUEST_RECEIVED_TIME__"";
}

"
org/apache/synapse/config/xml/XMLConfigurationBuilder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import java.io.InputStream;

import org.apache.axiom.om.*;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.config.SynapseConfiguration;

import javax.xml.stream.XMLStreamException;

/**
 * Builds a Synapse Configuration from an XML input stream
 */
public class XMLConfigurationBuilder {

    private static Log log = LogFactory.getLog(XMLConfigurationBuilder.class);

    public static SynapseConfiguration getConfiguration(InputStream is) throws XMLStreamException {

        log.info(""Generating the Synapse configuration model by parsing the XML configuration"");
        
        OMElement definitions = new StAXOMBuilder(is).getDocumentElement();
        definitions.build();

        return ConfigurationFactoryAndSerializerFinder.getInstance().getConfiguration(definitions);
        
    }
}"
org/apache/synapse/config/xml/ConfigurationFactoryAndSerializerFinder.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.config.XMLToObjectMapper;
import sun.misc.Service;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import java.io.OutputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * This class is based on J2SE Service Provider model
 * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
 * <p/>
 * It deals with both the problem of turning an XML into a Synapse config and vice-versa
 */
public class ConfigurationFactoryAndSerializerFinder implements XMLToObjectMapper {

    private static final Log log = LogFactory
            .getLog(ConfigurationFactoryAndSerializerFinder.class);

    private static final Class[] configurationFactories = {
            SynapseXMLConfigurationFactory.class,
    };


    private static ConfigurationFactoryAndSerializerFinder instance = null;

    /**
     * A map of mediator QNames to implementation class
     */
    private static Map factoryMap = new HashMap();

    private static Map serializerMap = new HashMap();

    public static synchronized ConfigurationFactoryAndSerializerFinder getInstance() {
        if (instance == null) {
            instance = new ConfigurationFactoryAndSerializerFinder();
        }
        return instance;
    }

    /**
     * Force re initialization next time
     */
    public synchronized void reset() {
        factoryMap.clear();
        instance = null;
    }

    private ConfigurationFactoryAndSerializerFinder() {

        factoryMap = new HashMap();

        for (int i = 0; i < configurationFactories.length; i++) {
            Class c = configurationFactories[i];
            try {
                ConfigurationFactory fac = (ConfigurationFactory) c.newInstance();
                factoryMap.put(fac.getTagQName(), c);
                serializerMap.put(fac.getTagQName(), fac.getSerializerClass());
            } catch (Exception e) {
                throw new SynapseException(""Error instantiating "" + c.getName(), e);
            }
        }
        // now iterate through the available pluggable mediator factories
        registerExtensions();
    }

    private void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Register pluggable mediator factories from the classpath
     * <p/>
     * This looks for JAR files containing a META-INF/services that adheres to the following
     * http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider
     */
    private void registerExtensions() {

        // register MediatorFactory extensions
        Iterator it = Service.providers(ConfigurationFactory.class);
        while (it.hasNext()) {
            ConfigurationFactory cf = (ConfigurationFactory) it.next();
            QName tag = cf.getTagQName();
            factoryMap.put(tag, cf.getClass());
            serializerMap.put(tag, cf.getSerializerClass());
            if (log.isDebugEnabled()) {
                log.debug(""Added MediatorFactory "" + cf.getClass() + "" to handle "" + tag);
            }
        }
    }

    /**
     * This method returns a Processor given an OMElement. This will be used
     * recursively by the elements which contain processor elements themselves
     * (e.g. rules)
     *
     * @param element
     * @return Processor
     */
    public SynapseConfiguration getConfiguration(OMElement element) {

        String localName = element.getLocalName();
        QName qName = null;
        if (element.getNamespace() != null) {
            qName = new QName(element.getNamespace().getNamespaceURI(), localName);
        } else {
            qName = new QName(localName);
        }
        if (log.isDebugEnabled()) {
            log.debug(""getConfiguration("" + qName + "")"");
        }
        Class cls = (Class) factoryMap.get(qName);


        if (cls == null) {
            String msg = ""Unknown Configuration type "" +
                    ""referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            ConfigurationFactory cf = (ConfigurationFactory) cls.newInstance();
            return cf.getConfiguration(element);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * @param synCfg
     * @return
     */
    public static OMElement serializeConfiguration(SynapseConfiguration synCfg) {
        if (synCfg.getDefaultQName() == null) {
            return serializeConfiguration(synCfg, XMLConfigConstants.DEFINITIONS_ELT);
        } else {
            return serializeConfiguration(synCfg, synCfg.getDefaultQName());
        }
    }

    /**
     * This method will serialize the config using the supplied QName
     * (looking up the right class to do it)
     *
     * @param synCfg
     * @param qName
     * @throws XMLStreamException
     */
    public static OMElement serializeConfiguration(SynapseConfiguration synCfg, QName qName) {

        Class cls = (Class) serializerMap.get(qName);
        if (cls == null) {
            String msg = ""Unknown Configuration type "" +
                    ""referenced by configuration element : "" + qName;
            log.error(msg);
            throw new SynapseException(msg);
        }

        try {
            ConfigurationSerializer cs = (ConfigurationSerializer) cls.newInstance();
            return cs.serializeConfiguration(synCfg);

        } catch (InstantiationException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);

        } catch (IllegalAccessException e) {
            String msg = ""Error initializing configuration factory : "" + cls;
            log.error(msg);
            throw new SynapseException(msg, e);
        }
    }

    /**
     * This method exposes all the ConfigurationFactories and its Extensions
     *
     * @return Map of factories
     */
    public Map getFactoryMap() {
        return factoryMap;
    }

    /**
     * This method exposes all the ConfigurationSerializer and its Extensions
     *
     * @return Map of serializers
     */
    public static Map getSerializerMap() {
        return serializerMap;
    }

    /**
     * Allow the mediator factory finder to act as an XMLToObjectMapper for Mediators
     * (i.e. Sequence Mediator) loaded dynamically from a Registry
     *
     * @param om
     * @return
     */
    public Object getObjectFromOMNode(OMNode om) {
        if (om instanceof OMElement) {
            return getConfiguration((OMElement) om);
        } else {
            handleException(""Invalid configuration XML : "" + om);
        }
        return null;
    }
}
"
org/apache/synapse/mediators/builtin/CacheMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axis2.AxisFault;
import org.apache.axis2.clustering.ClusteringFault;
import org.apache.axis2.clustering.context.Replicator;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.saaj.util.SAAJUtil;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseException;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.synapse.core.axis2.Axis2Sender;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.util.FixedByteArrayOutputStream;
import org.apache.synapse.util.MessageHelper;
import org.wso2.caching.CacheManager;
import org.wso2.caching.CachedObject;
import org.wso2.caching.CachingConstants;
import org.wso2.caching.CachingException;
import org.wso2.caching.digest.DigestGenerator;

import javax.xml.soap.MessageFactory;
import javax.xml.soap.MimeHeaders;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPMessage;
import javax.xml.stream.XMLStreamException;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

/**
 * CacheMediator will cache the response messages indexed using the hash value of the
 * request message, and subsequent messages with the same request (request hash will be
 * generated and checked for the equality) within the cache expiration period will be served
 * from the stored responses in the cache
 *
 * @see org.apache.synapse.Mediator
 */
public class CacheMediator extends AbstractMediator {

    private String id = null;
    private String scope = CachingConstants.SCOPE_PER_HOST;// global
    private boolean collector = false;
    private DigestGenerator digestGenerator = CachingConstants.DEFAULT_XML_IDENTIFIER;
    private int inMemoryCacheSize = CachingConstants.DEFAULT_CACHE_SIZE;
    // if this is 0 then no disk cache, and if there is no size specified in the config
    // factory will asign a default value to enable disk based caching
    private int diskCacheSize = 0;
    private long timeout = 0L;
    private SequenceMediator onCacheHitSequence = null;
    private String onCacheHitRef = null;
    private int maxMessageSize = 0;
    private String cacheManagerKey = CachingConstants.CACHE_MANAGER; // default per-host
    private static final String CACHE_MANAGER_PREFIX = ""synapse.cache_manager_"";

    public boolean mediate(MessageContext synCtx) {

        // tracing and debuggin related mediation initiation
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Cache mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        // if maxMessageSize is specified check for the message size before processing
        FixedByteArrayOutputStream fbaos = null;
        if (maxMessageSize > 0) {
            fbaos = new FixedByteArrayOutputStream(maxMessageSize);
            try {
                MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()).serialize(fbaos);
            } catch (XMLStreamException e) {
                handleException(""Error in checking the message size"", e, synCtx);
            } catch (SynapseException syne) {
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Message size exceeds the upper bound for caching, "" +
                            ""request will not be cached"");
                    return true;
                }
            }
        }

        ConfigurationContext cfgCtx =
            ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();
        if (cfgCtx == null) {
            handleException(""Unable to perform caching, ""
                + "" ConfigurationContext cannot be found"", synCtx);
            return false; // never executes.. but keeps IDE happy
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn,
                ""Looking up cache at scope : "" + scope + "" with ID : "" + cacheManagerKey);
        }

        // look up cache
        Object prop = cfgCtx.getPropertyNonReplicable(cacheManagerKey);
        CacheManager cacheManager;
        if (prop != null && prop instanceof CacheManager) {
            cacheManager = (CacheManager) prop;
        } else {
            synchronized (cfgCtx) {
                // check again after taking the lock to make sure no one else did it before us
                prop = cfgCtx.getPropertyNonReplicable(cacheManagerKey);
                if (prop != null && prop instanceof CacheManager) {
                    cacheManager = (CacheManager) prop;

                } else {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Creating/recreating the cache object"");
                    }
                    cacheManager = new CacheManager();
                    cfgCtx.setProperty(cacheManagerKey, cacheManager);
                }
            }
        }

        boolean result = true;
        try {
            
            if (synCtx.isResponse()) {
                processResponseMessage(synCtx, cfgCtx, traceOrDebugOn, traceOn, cacheManager);

            } else {
                result = processRequestMessage(
                    synCtx, cfgCtx, traceOrDebugOn, traceOn, cacheManager);
            }
            
        } catch (ClusteringFault clusteringFault) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Unable to replicate Cache mediator state among the cluster"");
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Cache mediator"");
        }
        
        return result;
    }

    /**
     * Process a response message through this cache mediator. This finds the Cache used, and
     * updates it for the corresponding request hash
     *
     * @param traceOrDebugOn is trace or debug logging on?
     * @param traceOn        is tracing on?
     * @param synCtx         the current message (response)
     * @param cfgCtx         the abstract context in which the cache will be kept
     * @param cacheManager   the cache manager
     * @throws ClusteringFault is there is an error in replicating the cfgCtx
     */
    private void processResponseMessage(MessageContext synCtx, ConfigurationContext cfgCtx,
        boolean traceOrDebugOn, boolean traceOn, CacheManager cacheManager) throws ClusteringFault {

        if (!collector) {
            handleException(""Response messages cannot be handled in a non collector cache"", synCtx);
        }

        String requestHash = (String) synCtx.getProperty(CachingConstants.REQUEST_HASH);

        if (requestHash != null) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Storing the response message into the cache at scope : "" +
                    scope + "" with ID : "" + cacheManagerKey + "" for request hash : "" + requestHash);
            }

            CachedObject cachedObj = cacheManager.getResponseForKey(requestHash, cfgCtx);
            if (cachedObj != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Storing the response for the message with ID : "" +
                        synCtx.getMessageID() + "" with request hash ID : "" +
                        cachedObj.getRequestHash() + "" in the cache : "" + cacheManagerKey);
                }

                ByteArrayOutputStream outStream = new ByteArrayOutputStream();
                try {
                    MessageHelper.cloneSOAPEnvelope(synCtx.getEnvelope()).serialize(outStream);
                    cachedObj.setResponseEnvelope(outStream.toByteArray());
                } catch (XMLStreamException e) {
                    handleException(""Unable to set the response to the Cache"", e, synCtx);
                }

                /* this is not required yet, can commented this for perf improvements
                   in the future there can be a situation where user sends the request
                   with the response hash (if client side caching is on) in which case
                   we can compare that response hash with the given response hash and
                   respond with not-modified http header */
                // cachedObj.setResponseHash(cache.getGenerator().getDigest(
                //     ((Axis2MessageContext) synCtx).getAxis2MessageContext()));

                if (cachedObj.getTimeout() > 0) {
                    cachedObj.setExpireTimeMillis(System.currentTimeMillis() + cachedObj.getTimeout());
                }

                cfgCtx.setProperty(cacheManagerKey, cacheManager);
                Replicator.replicate(cfgCtx);

            } else {
                auditWarn(""A response message without a valid mapping to the "" +
                    ""request hash found. Unable to store the response in cache"", synCtx);
            }

        } else {
            auditWarn(""A response message without a mapping to the "" +
                ""request hash found. Unable to store the response in cache"", synCtx);
        }
    }

    /**
     * Processes a request message through the cache mediator. Generates the request hash and looks
     * up for a hit, if found; then the specified named or anonymous sequence is executed or marks
     * this message as a response and sends back directly to client.
     *
     * @param synCtx         incoming request message
     * @param cfgCtx         the AbstractContext in which the cache will be kept
     * @param traceOrDebugOn is tracing or debug logging on?
     * @param traceOn        is tracing on?
     * @param cacheManager   the cache manager
     * @return should this mediator terminate further processing?
     * @throws ClusteringFault if there is an error in replicating the cfgCtx
     */
    private boolean processRequestMessage(MessageContext synCtx, ConfigurationContext cfgCtx,
        boolean traceOrDebugOn, boolean traceOn, CacheManager cacheManager) throws ClusteringFault {

        if (collector) {
            handleException(""Request messages cannot be handled in a collector cache"", synCtx);
        }

        String requestHash = null;
        try {  
            requestHash = digestGenerator.getDigest(
                ((Axis2MessageContext) synCtx).getAxis2MessageContext());
            synCtx.setProperty(CachingConstants.REQUEST_HASH, requestHash);
        } catch (CachingException e) {
            handleException(""Error in calculating the hash value of the request"", e, synCtx);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Generated request hash : "" + requestHash);
        }

        if (cacheManager.containsKey(requestHash) &&
            cacheManager.getResponseForKey(requestHash, cfgCtx) != null) {

            // get the response from the cache and attach to the context and change the
            // direction of the message
            CachedObject cachedObj = cacheManager.getResponseForKey(requestHash, cfgCtx);

            if (!cachedObj.isExpired() && cachedObj.getResponseEnvelope() != null) {

                if (traceOrDebugOn) {
                    traceOrDebug(traceOn, ""Cache-hit for message ID : "" + synCtx.getMessageID());
                }

                // mark as a response and replace envelope from cache
                synCtx.setResponse(true);
                try {
                    MessageFactory mf = MessageFactory.newInstance();
                    SOAPMessage smsg = mf.createMessage(new MimeHeaders(),
                        new ByteArrayInputStream(cachedObj.getResponseEnvelope()));

                    org.apache.axiom.soap.SOAPEnvelope omSOAPEnv =
                        SAAJUtil.toOMSOAPEnvelope(smsg.getSOAPPart().getDocumentElement());

                    // todo: if there is a WSA messageID in the response, is that need to be unique on each and every resp

                    synCtx.setEnvelope(omSOAPEnv);
                } catch (AxisFault axisFault) {
                    handleException(""Error setting response envelope from cache : ""
                        + cacheManagerKey, synCtx);
                } catch (IOException ioe) {
                    handleException(""Error setting response envelope from cache : ""
                        + cacheManagerKey, ioe, synCtx);
                } catch (SOAPException soape) {
                    handleException(""Error setting response envelope from cache : ""
                        + cacheManagerKey, soape, synCtx);
                }

                // take specified action on cache hit
                if (onCacheHitSequence != null) {
                    // if there is an onCacheHit use that for the mediation
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn,
                            ""Delegating message to the onCachingHit "" + ""Anonymous sequence"");
                    }
                    onCacheHitSequence.mediate(synCtx);

                } else if (onCacheHitRef != null) {

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Delegating message to the onCachingHit "" +
                            ""sequence : "" + onCacheHitRef);
                    }
                    synCtx.getSequence(onCacheHitRef).mediate(synCtx);

                } else {

                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""Request message "" + synCtx.getMessageID() +
                            "" was served from the cache : "" + cacheManagerKey);
                    }
                    // send the response back if there is not onCacheHit is specified
                    synCtx.setTo(null);
                    Axis2Sender.sendBack(synCtx);
                }
                // stop any following mediators from executing
                return false;

            } else {
                // cache exists, but has expired...
                cachedObj.expire();
                cachedObj.setTimeout(timeout);
                if (traceOrDebugOn) {
                    traceOrDebug(traceOn,
                        ""Existing cached response has expired. Reset cache element"");
                }

                cfgCtx.setProperty(cacheManagerKey, cacheManager);
                Replicator.replicate(cfgCtx);
            }

        } else {

            // if not found in cache, check if we can cache this request
            if (cacheManager.getCacheKeys().size() == inMemoryCacheSize) {
                cacheManager.removeExpiredResponses(cfgCtx);
                if (cacheManager.getCacheKeys().size() == inMemoryCacheSize) {
                    if (traceOrDebugOn) {
                        traceOrDebug(traceOn, ""In-memory cache is full. Unable to cache"");
                    }
                } else {
                    storeRequestToCache(cfgCtx, requestHash, cacheManager);
                }
            } else {
                storeRequestToCache(cfgCtx, requestHash, cacheManager);
            }
        }
        return true;
    }

    /**
     * Store request message to the cache
     *
     * @param cfgCtx        - the Abstract context in which the cache will be kept
     * @param requestHash   - the request hash that has already been computed
     * @param cacheManager  - the cache
     * @throws ClusteringFault if there is an error in replicating the cfgCtx
     */
    private void storeRequestToCache(ConfigurationContext cfgCtx,
        String requestHash, CacheManager cacheManager) throws ClusteringFault {
        
        CachedObject cachedObj = new CachedObject();
        cachedObj.setRequestHash(requestHash);
        // this does not set the expiretime but just sets the timeout and the espiretime will
        // be set when the response is availabel
        cachedObj.setTimeout(timeout);
        cacheManager.addResponseWithKey(requestHash, cachedObj, cfgCtx);

        cfgCtx.setProperty(cacheManagerKey, cacheManager);
        Replicator.replicate(cfgCtx);
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getScope() {
        return scope;
    }

    public void setScope(String scope) {
        this.scope = scope;
        if (CachingConstants.SCOPE_PER_MEDIATOR.equals(scope)) {
            cacheManagerKey = CACHE_MANAGER_PREFIX + id;
        }
    }

    public boolean isCollector() {
        return collector;
    }

    public void setCollector(boolean collector) {
        this.collector = collector;
    }

    public DigestGenerator getDigestGenerator() {
        return digestGenerator;
    }

    public void setDigestGenerator(DigestGenerator digestGenerator) {
        this.digestGenerator = digestGenerator;
    }

    public int getInMemoryCacheSize() {
        return inMemoryCacheSize;
    }

    public void setInMemoryCacheSize(int inMemoryCacheSize) {
        this.inMemoryCacheSize = inMemoryCacheSize;
    }

    public int getDiskCacheSize() {
        return diskCacheSize;
    }

    public void setDiskCacheSize(int diskCacheSize) {
        this.diskCacheSize = diskCacheSize;
    }

    // change the variable to Timeout milis seconds
    public long getTimeout() {
        return timeout / 1000;
    }

    public void setTimeout(long timeout) {
        this.timeout = timeout * 1000;
    }

    public SequenceMediator getOnCacheHitSequence() {
        return onCacheHitSequence;
    }

    public void setOnCacheHitSequence(SequenceMediator onCacheHitSequence) {
        this.onCacheHitSequence = onCacheHitSequence;
    }

    public String getOnCacheHitRef() {
        return onCacheHitRef;
    }

    public void setOnCacheHitRef(String onCacheHitRef) {
        this.onCacheHitRef = onCacheHitRef;
    }

    public int getMaxMessageSize() {
        return maxMessageSize;
    }

    public void setMaxMessageSize(int maxMessageSize) {
        this.maxMessageSize = maxMessageSize;
    }
}
"
org/apache/synapse/core/axis2/SynapseCallbackReceiver.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFault;
import org.apache.axiom.soap.SOAPFaultReason;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.axis2.client.Options;
import org.apache.axis2.client.async.AxisCallback;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.MessageReceiver;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.ServerManager;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.transport.nhttp.NhttpConstants;
import org.apache.synapse.transport.nhttp.util.ResponseAcceptEncodingProcessor;

import java.util.*;

/**
 * This is the message receiver that receives the responses for outgoing messages sent out
 * by Synapse. It holds a callbackStore that maps the [unique] messageID of each message to
 * a callback object that gets executed on timeout or when a response is received (before timeout)
 *
 * The AnonymousServiceFactory uses this MessageReceiver for all Anonymous services created by it.
 * This however - effectively - is a singleton class
 */
public class SynapseCallbackReceiver implements MessageReceiver {

    private static final Log log = LogFactory.getLog(SynapseCallbackReceiver.class);

    /** This is the synchronized callbackStore that maps outgoing messageID's to callback objects */
    private Map<String, AxisCallback> callbackStore;  // will made thread safe in the constructor

    /**
     * Create the *single* instance of this class that would be used by all anonymous services
     * used for outgoing messaging.
     * @param synCfg the Synapse configuration
     */
    public SynapseCallbackReceiver(SynapseConfiguration synCfg) {

        callbackStore = Collections.synchronizedMap(new HashMap<String, AxisCallback>());
        ServerManager.getInstance().setCallbackStore(callbackStore);

        // create the Timer object and a TimeoutHandler task
        TimeoutHandler timeoutHandler = new TimeoutHandler(callbackStore);
        
        Timer timeOutTimer = synCfg.getSynapseTimer();
        long timeoutHandlerInterval = ServerManager.getInstance().getTimeoutHandlerInterval();

        // schedule timeout handler to run every n seconds (n : specified or defaults to 15s)
        timeOutTimer.schedule(timeoutHandler, 0, timeoutHandlerInterval);
    }


    public void addCallback(String MsgID, AxisCallback callback) {
        callbackStore.put(MsgID, callback);
        if (log.isDebugEnabled()) {
            log.debug(""Callback added. Total callbacks waiting for : "" + callbackStore.size());
        }
    }

    /**
     * Everytime a response message is received this method gets invoked. It will then select
     * the outgoing *Synapse* message context for the reply we received, and determine what action
     * to take at the Synapse level
     *
     * @param messageCtx the Axis2 message context of the reply received
     * @throws AxisFault
     */
    public void receive(MessageContext messageCtx) throws AxisFault {

        String messageID = null;

        if (messageCtx.getOptions() != null && messageCtx.getOptions().getRelatesTo() != null) {
            // never take a chance with a NPE at this stage.. so check at each level :-)
            Options options = messageCtx.getOptions();
            if (options != null) {
                RelatesTo relatesTo = options.getRelatesTo();
                if (relatesTo != null) {
                    messageID = relatesTo.getValue();
                }
            }
        } else if (messageCtx.getProperty(SynapseConstants.MERCURY_SEQUENCE_KEY) == null) {
            messageID = (String) messageCtx.getProperty(SynapseConstants.RELATES_TO_FOR_POX);
        }

        if (messageID != null) {
            AxisCallback callback = callbackStore.remove(messageID);
            if (log.isDebugEnabled()) {
                log.debug(""Callback removed. Pending callbacks count : "" + callbackStore.size());
            }

            RelatesTo[] relates = messageCtx.getRelationships();
            if (relates != null && relates.length > 1) {
                // we set a relates to to the response message so that if WSA is not used, we
                // could still link back to the original message. But if WSA was used, this
                // gets duplicated, and we should remove it
                removeDuplicateRelatesTo(messageCtx, relates);
            }
            
            if (callback != null) {
                handleMessage(messageCtx, ((AsyncCallback) callback).getSynapseOutMsgCtx());
                
            } else {
                // TODO invoke a generic synapse error handler for this message
                log.warn(""Synapse received a response for the request with message Id : "" +
                    messageID + "" But a callback is not registered (anymore) to process this response"");
            }

        } else if (!messageCtx.isPropertyTrue(NhttpConstants.SC_ACCEPTED)){
            // TODO invoke a generic synapse error handler for this message
            log.warn(""Synapse received a response message without a message Id"");
        }
    }

    /**
     * Handle the response or error (during a failed send) message received for an outgoing request
     *
     * @param response         the Axis2 MessageContext that has been received and has to be handled
     * @param synapseOutMsgCtx the corresponding (outgoing) Synapse MessageContext for the above
     *                         Axis2 MC, that holds Synapse specific information such as the error
     *                         handler stack and local properties etc.
     * @throws AxisFault       if the message cannot be processed
     */
    private void handleMessage(MessageContext response,
        org.apache.synapse.MessageContext synapseOutMsgCtx) throws AxisFault {

        Object o = response.getProperty(NhttpConstants.SENDING_FAULT);
        if (o != null && Boolean.TRUE.equals(o)) {

            // there is a sending fault. propagate the fault to fault handlers.

            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (faultStack != null && !faultStack.isEmpty()) {
                SOAPEnvelope envelope = response.getEnvelope();
                if (envelope != null) {
                    SOAPFault fault = envelope.getBody().getFault();
                    if (fault != null) {
                        Exception e = fault.getException();
                        if (e == null) {
                            SOAPFaultReason reason = fault.getReason();
                            if (reason != null) {
                                e = new Exception(reason.getText());
                            }
                        }
                        // set an error code to the message context, so that error sequences can
                        // filter using that property to determine the cause of error
                        synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE,
                            SynapseConstants.SENDING_FAULT);
                        SOAPFaultReason faultReason = fault.getReason();
                        if (faultReason != null) {
                            synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
                                    faultReason.getText());
                        }
                        if (fault.getException() != null) {
                            synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION,
                                    fault.getException());
                        }
                        ((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);
                    }
                }
            }

        } else {

            // there can always be only one instance of an Endpoint in the faultStack of a message
            // if the send was successful, so remove it before we proceed any further
            Stack faultStack = synapseOutMsgCtx.getFaultStack();
            if (faultStack !=null && !faultStack.isEmpty()
                && faultStack.peek() instanceof Endpoint) {
                faultStack.pop();
            }
            if (log.isDebugEnabled()) {
                log.debug(""Synapse received an asynchronous response message"");
                log.debug(""Received To: "" +
                        (response.getTo() != null ? response.getTo().getAddress() : ""null""));
                log.debug(""SOAPAction: "" +
                        (response.getSoapAction() != null ? response.getSoapAction() : ""null""));
                log.debug(""WSA-Action: "" +
                        (response.getWSAAction() != null ? response.getWSAAction() : ""null""));
                String[] cids = response.getAttachmentMap().getAllContentIDs();
                if (cids != null && cids.length > 0) {
                    for (String cid : cids) {
                        log.debug(""Attachment : "" + cid);
                    }
                }
                log.debug(""Body : \n"" + response.getEnvelope());
            }
            MessageContext axisOutMsgCtx =
                    ((Axis2MessageContext) synapseOutMsgCtx).getAxis2MessageContext();

            //Processes 'Accept-Encoding'
            ResponseAcceptEncodingProcessor.process(response, axisOutMsgCtx);

            response.setServiceContext(null);
            response.setOperationContext(axisOutMsgCtx.getOperationContext());
            response.setAxisMessage(axisOutMsgCtx.getAxisOperation().getMessage(
                    WSDLConstants.MESSAGE_LABEL_OUT_VALUE));

            // set properties on response
            response.setServerSide(true);
            response.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, Boolean.TRUE);
            response.setProperty(MessageContext.TRANSPORT_OUT,
                    axisOutMsgCtx.getProperty(MessageContext.TRANSPORT_OUT));
            response.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
                    axisOutMsgCtx.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));
            response.setTransportIn(axisOutMsgCtx.getTransportIn());
            response.setTransportOut(axisOutMsgCtx.getTransportOut());

            // If request is REST assume that the response is REST too
            response.setDoingREST(axisOutMsgCtx.isDoingREST());
            if (axisOutMsgCtx.isDoingMTOM()) {
                response.setDoingMTOM(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }
            if (axisOutMsgCtx.isDoingSwA()) {
                response.setDoingSwA(true);
                response.setProperty(
                        org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                        org.apache.axis2.Constants.VALUE_TRUE);
            }

             // copy the message type property thats used by the out message to the response message
            response.setProperty(org.apache.axis2.Constants.Configuration.MESSAGE_TYPE,
                axisOutMsgCtx.getProperty(org.apache.axis2.Constants.Configuration.MESSAGE_TYPE));
            
            // compare original received message (axisOutMsgCtx) soap version with the response
            // if they are different change to original version 
            if(axisOutMsgCtx.isSOAP11() != response.isSOAP11()) {
            	if(axisOutMsgCtx.isSOAP11()) {
            		SOAPUtils.convertSOAP12toSOAP11(response);
            	} else {
            		SOAPUtils.convertSOAP11toSOAP12(response);
            	}
            }

            if (axisOutMsgCtx.getMessageID() != null) {
                response.setRelationships(
                        new RelatesTo[]{new RelatesTo(axisOutMsgCtx.getMessageID())});
            }

            response.setReplyTo(axisOutMsgCtx.getReplyTo());
            response.setFaultTo(axisOutMsgCtx.getFaultTo());

            if (axisOutMsgCtx.isPropertyTrue(NhttpConstants.IGNORE_SC_ACCEPTED)) {
                response.setProperty(NhttpConstants.FORCE_SC_ACCEPTED, Constants.VALUE_TRUE);
            }

            // create the synapse message context for the response
            Axis2MessageContext synapseInMessageContext =
                    new Axis2MessageContext(
                            response,
                            synapseOutMsgCtx.getConfiguration(),
                            synapseOutMsgCtx.getEnvironment());

            synapseInMessageContext.setResponse(true);
            synapseInMessageContext.setTo(
                new EndpointReference(AddressingConstants.Final.WSA_ANONYMOUS_URL));
            synapseInMessageContext.setTracingState(synapseOutMsgCtx.getTracingState());

            // set the properties of the original MC to the new MC

            for (Object key : synapseOutMsgCtx.getPropertyKeySet()) {
                synapseInMessageContext.setProperty(
                        (String) key, synapseOutMsgCtx.getProperty((String) key));
            }

            // send the response message through the synapse mediation flow
            try {
                synapseOutMsgCtx.getEnvironment().injectMessage(synapseInMessageContext);
            } catch (SynapseException syne) {
                Stack stack = synapseInMessageContext.getFaultStack();
                if (stack != null &&
                        !stack.isEmpty()) {
                    ((FaultHandler) stack.pop()).handleFault(synapseInMessageContext, syne);
                } else {
                    log.error(""Synapse encountered an exception, "" +
                            ""No error handlers found - [Message Dropped]\n"" + syne.getMessage());
                }
            }
        }
    }

    /**
     * It is possible for us (Synapse) to cause the creation of a duplicate relatesTo as we
     * try to hold onto the outgoing message ID even for POX messages using the relates to
     * Now once we get a response, make sure we remove any trace of this before we proceed any
     * further
     * @param mc the message context from which a possibly duplicated relatesTo should be removed
     * @param relates the existing relatedTo array of the message
     */
    private void removeDuplicateRelatesTo(MessageContext mc, RelatesTo[] relates) {

        int insertPos = 0;
        RelatesTo[] newRelates = new RelatesTo[relates.length];

        for (RelatesTo current : relates) {
            boolean found = false;
            for (int j = 0; j < newRelates.length && j < insertPos; j++) {
                if (newRelates[j].equals(current) ||
                        newRelates[j].getValue().equals(current.getValue())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                newRelates[insertPos++] = current;
            }
        }

        RelatesTo[] trimmedRelates = new RelatesTo[insertPos];
        System.arraycopy(newRelates, 0, trimmedRelates, 0, insertPos);
        mc.setRelationships(trimmedRelates);
    }
}
"
org/apache/synapse/config/xml/SwitchMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.filters.SwitchMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.util.Iterator;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * Factory for {@link SwitchMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;switch source=""xpath""&gt;
 *   &lt;case regex=""string""&gt;
 *     mediator+
 *   &lt;/case&gt;+
 *   &lt;default&gt;
 *     mediator+
 *   &lt;/default&gt;?
 * &lt;/switch&gt;
 * </pre>
 */
public class SwitchMediatorFactory extends AbstractMediatorFactory {

    private static final QName SWITCH_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""switch"");
    private static final QName CASE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""case"");
    private static final QName DEFAULT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""default"");

    public Mediator createMediator(OMElement elem) {

        SwitchMediator switchMediator = new SwitchMediator();
        OMAttribute source = elem.getAttribute(ATT_SOURCE);
        if (source == null) {
            String msg = ""A 'source' XPath attribute is required for a switch mediator"";
            log.error(msg);
            throw new SynapseException(msg);
        } else {
            try {

                switchMediator.setSource(SynapseXPathFactory.getSynapseXPath(elem, ATT_SOURCE));

            } catch (JaxenException e) {
                String msg = ""Invalid XPath for attribute 'source' : "" + source.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
        }
        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(switchMediator, elem);
        Iterator iter = elem.getChildrenWithName(CASE_Q);
        while (iter.hasNext()) {
            OMElement caseElem = (OMElement) iter.next();
            SwitchCase aCase = new SwitchCase();
            OMAttribute regex = caseElem.getAttribute(ATT_REGEX);
            if (regex == null) {
                String msg = ""The 'regex' attribute is required for a switch case definition"";
                log.error(msg);
                throw new SynapseException(msg);
            }
            try {
                aCase.setRegex(Pattern.compile(regex.getAttributeValue()));
            } catch (PatternSyntaxException pse) {
                String msg = ""Invalid Regular Expression for attribute 'regex' : "" + regex.getAttributeValue();
                log.error(msg);
                throw new SynapseException(msg);
            }
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator(caseElem));
            switchMediator.addCase(aCase);
        }
        iter = elem.getChildrenWithName(DEFAULT_Q);
        while (iter.hasNext()) {
            SwitchCase aCase = new SwitchCase();
            aCase.setCaseMediator(AnonymousListMediatorFactory.createAnonymousListMediator((OMElement) iter.next()));
            switchMediator.setDefaultCase(aCase);
            break; // add only the *first* default if multiple are specified, ignore rest if any
        }
        return switchMediator;
    }

    public QName getTagQName() {
        return SWITCH_Q;
    }
}
"
org/apache/synapse/util/MessageHelper.java,true,"package org.apache.synapse.util;

import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.eip.EIPConstants;
import org.apache.synapse.core.axis2.Axis2MessageContext;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.attachments.Attachments;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNode;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 *
 */
public class MessageHelper {

    /**
     * This method will simulate cloning the message context and creating an exact copy of the
     * passed message. One should use this method with care; that is because, inside the new MC,
     * most of the attributes of the MC like opCtx and so on are still kept as references inside
     * the axis2 MessageContext for performance improvements. (Note: U dont have to worrie
     * about the SOAPEnvelope, it is a cloned copy and not a reference from any other MC)
     *
     * @param synCtx - this will be cloned 
     * @return cloned Synapse MessageContext
     * @throws AxisFault if there is a failure in creating the new Synapse MC or in a failure in
     *          clonning the underlying axis2 MessageContext
     * 
     * @see MessageHelper#cloneAxis2MessageContext 
     */
    public static MessageContext cloneMessageContext(MessageContext synCtx) throws AxisFault {

        // creates the new MessageContext and clone the internal axis2 MessageContext
        // inside the synapse message context and place that in the new one
        MessageContext newCtx = synCtx.getEnvironment().createMessageContext();
        Axis2MessageContext axis2MC = (Axis2MessageContext) newCtx;
        axis2MC.setAxis2MessageContext(
            cloneAxis2MessageContext(((Axis2MessageContext) synCtx).getAxis2MessageContext()));

        newCtx.setConfiguration(synCtx.getConfiguration());
        newCtx.setEnvironment(synCtx.getEnvironment());
        newCtx.setContextEntries(synCtx.getContextEntries());

        // set the parent corelation details to the cloned MC -
        //                              for the use of aggregation like tasks
        newCtx.setProperty(EIPConstants.AGGREGATE_CORRELATION, synCtx.getMessageID());

        // copying the core parameters of the synapse MC
        newCtx.setTo(synCtx.getTo());
        newCtx.setReplyTo(synCtx.getReplyTo());
        newCtx.setSoapAction(synCtx.getSoapAction());
        newCtx.setWSAAction(synCtx.getWSAAction());
        newCtx.setResponse(synCtx.isResponse());

        // copy all the synapse level properties to the newCtx
        for (Object o : synCtx.getPropertyKeySet()) {
            // If there are non String keyed properties neglect them rathern than trow exception
            if (o instanceof String) {
                newCtx.setProperty((String) o, synCtx.getProperty((String) o));
            }
        }

        return newCtx;
    }

    /**
     * This method will simulate cloning the message context and creating an exact copy of the
     * passed message. One should use this method with care; that is because, inside the new MC,
     * most of the attributes of the MC like opCtx and so on are still kept as references. Otherwise
     * there will be perf issues. But ..... this may reveal in some conflicts in the cloned message
     * if you try to do advanced mediations with the cloned message, in which case you should
     * mannually get a clone of the changing part of the MC and set that cloned part to your MC.
     * Changing the MC after doing that will solve most of the issues. (Note: U dont have to worrie
     * about the SOAPEnvelope, it is a cloned copy and not a reference from any other MC)
     *
     * @param mc - this will be cloned for getting an exact copy
     * @return cloned MessageContext from the given mc
     * @throws AxisFault if there is a failure in copying the certain attributes of the
     *          provided message context
     */
    public static org.apache.axis2.context.MessageContext cloneAxis2MessageContext(
        org.apache.axis2.context.MessageContext mc) throws AxisFault {

        org.apache.axis2.context.MessageContext newMC = clonePartially(mc);
        newMC.setEnvelope(cloneSOAPEnvelope(mc.getEnvelope()));
        
        newMC.setServiceContext(mc.getServiceContext());
        newMC.setOperationContext(mc.getOperationContext());
        newMC.setAxisMessage(mc.getAxisMessage());
        if (newMC.getAxisMessage() != null) {
            newMC.getAxisMessage().setParent(mc.getAxisOperation());
        }
        newMC.setAxisService(mc.getAxisService());

        // copying transport related parts from the original
        newMC.setTransportIn(mc.getTransportIn());
        newMC.setTransportOut(mc.getTransportOut());
        newMC.setProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO,
            mc.getProperty(org.apache.axis2.Constants.OUT_TRANSPORT_INFO));

        newMC.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS,
            getClonedTransportHeaders(mc));

        return newMC;
    }

    public static Map getClonedTransportHeaders(org.apache.axis2.context.MessageContext msgCtx) {
        
        Map headers = (Map) msgCtx.
            getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
        Map clonedHeaders = new HashMap();

        if (headers != null && headers.isEmpty()) {
            for (Object o : headers.keySet()) {
                String headerName = (String) o;
                clonedHeaders.put(headerName, headers.get(headerName));
            }
        }

        return clonedHeaders;
    }

    public static org.apache.axis2.context.MessageContext clonePartially(
        org.apache.axis2.context.MessageContext ori) throws AxisFault {

        org.apache.axis2.context.MessageContext newMC
            = new org.apache.axis2.context.MessageContext();
        
        // do not copy options from the original
        newMC.setConfigurationContext(ori.getConfigurationContext());
        newMC.setMessageID(UUIDGenerator.getUUID());
        newMC.setTo(ori.getTo());
        newMC.setSoapAction(ori.getSoapAction());

        newMC.setProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING,
                ori.getProperty(org.apache.axis2.Constants.Configuration.CHARACTER_SET_ENCODING));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_MTOM));
        newMC.setProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA,
                ori.getProperty(org.apache.axis2.Constants.Configuration.ENABLE_SWA));
        newMC.setProperty(Constants.Configuration.HTTP_METHOD,
            ori.getProperty(Constants.Configuration.HTTP_METHOD));
        //coping the Message type from req to res to get the message formatters working correctly.
        newMC.setProperty(Constants.Configuration.MESSAGE_TYPE,
                ori.getProperty(Constants.Configuration.MESSAGE_TYPE));

        newMC.setDoingREST(ori.isDoingREST());
        newMC.setDoingMTOM(ori.isDoingMTOM());
        newMC.setDoingSwA(ori.isDoingSwA());

        // if the original request carries any attachments, copy them to the clone
        // as well, except for the soap part if any
        Attachments attachments = ori.getAttachmentMap();
        if (attachments != null && attachments.getAllContentIDs().length > 0) {
            String[] cIDs = attachments.getAllContentIDs();
            String soapPart = attachments.getSOAPPartContentID();
            for (String cID : cIDs) {
                if (!cID.equals(soapPart)) {
                    newMC.addAttachment(cID, attachments.getDataHandler(cID));
                }
            }
        }

        for (Object o : ori.getOptions().getProperties().keySet()) {
            String key = (String) o;
            newMC.getOptions().setProperty(key, ori.getOptions().getProperty(key));
        }

        Iterator itr = ori.getPropertyNames();
        while (itr.hasNext()) {
            String key = (String) itr.next();
            if (key != null) {
                // In a clustered environment, all the properties that need to be relpicated,
                // are replicated explicitly  by the corresponding Mediators (Ex: throttle,
                // cache), and therefore we should avoid any implicit replication
                newMC.setNonReplicableProperty(key, ori.getPropertyNonReplicable(key));
            }
        }

        newMC.setServerSide(false);

        return newMC;
    }

    /**
     * This method will clone the provided SOAPEnvelope and returns the cloned envelope
     * as an exact copy of the provided envelope
     *
     * @param envelope - this will be cloned to get the new envelope
     * @return cloned SOAPEnvelope from the provided one
     */
    public static SOAPEnvelope cloneSOAPEnvelope(SOAPEnvelope envelope) {
        SOAPEnvelope newEnvelope;
        if (SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI
            .equals(envelope.getBody().getNamespace().getNamespaceURI())) {
            newEnvelope = OMAbstractFactory.getSOAP11Factory().getDefaultEnvelope();
        } else {
            newEnvelope = OMAbstractFactory.getSOAP12Factory().getDefaultEnvelope();
        }

        if (envelope.getHeader() != null) {
            Iterator itr = envelope.getHeader().cloneOMElement().getChildren();
            while (itr.hasNext()) {
                newEnvelope.getHeader().addChild((OMNode) itr.next());
            }
        }

        if (envelope.getBody() != null) {
            Iterator itr = envelope.getBody().cloneOMElement().getChildren();
            while (itr.hasNext()) {
                newEnvelope.getBody().addChild((OMNode) itr.next());
            }
        }

        return newEnvelope;
    }

    /**
     * Removes Submission and Final WS-Addressing headers and return the SOAPEnvelope from the given
     * message context
     *
     * @param axisMsgCtx the Axis2 Message context
     * @return the resulting SOAPEnvelope
     */
    public static SOAPEnvelope removeAddressingHeaders(
        org.apache.axis2.context.MessageContext axisMsgCtx) {

        SOAPEnvelope env = axisMsgCtx.getEnvelope();
        SOAPHeader soapHeader = env.getHeader();
        ArrayList addressingHeaders;

        if (soapHeader != null) {
            addressingHeaders =
                soapHeader.getHeaderBlocksWithNSURI(AddressingConstants.Submission.WSA_NAMESPACE);

            if (addressingHeaders != null && addressingHeaders.size() != 0) {
                detachAddressingInformation(addressingHeaders);

            } else {
                addressingHeaders =
                    soapHeader.getHeaderBlocksWithNSURI(AddressingConstants.Final.WSA_NAMESPACE);
                if (addressingHeaders != null && addressingHeaders.size() != 0) {
                    detachAddressingInformation(addressingHeaders);
                }
            }
        }
        return env;
    }

    /**
     * Remove WS-A headers
     *
     * @param headerInformation headers to be removed
     */
    private static void detachAddressingInformation(ArrayList headerInformation) {
        for (Object o : headerInformation) {
            if (o instanceof SOAPHeaderBlock) {
                SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                headerBlock.detach();
            } else if (o instanceof OMElement) {
                // work around for a known addressing bug which sends non SOAPHeaderBlock objects
                OMElement om = (OMElement) o;
                OMNamespace ns = om.getNamespace();
                if (ns != null && (
                    AddressingConstants.Submission.WSA_NAMESPACE.equals(ns.getNamespaceURI()) ||
                        AddressingConstants.Final.WSA_NAMESPACE.equals(ns.getNamespaceURI()))) {
                    om.detach();
                }
            }
        }
    }

}
"
org/apache/synapse/config/xml/AggregateMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.base.SequenceMediator;
import org.apache.synapse.mediators.builtin.DropMediator;
import org.apache.synapse.mediators.eip.aggregator.AggregateMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;

/**
 * Factory for {@link AggregateMediator} instances.
 * 
 * <pre>
 * &lt;aggregate&gt;
 *   &lt;correlateOn expression=""xpath""/&gt;?
 *   &lt;completeCondition [timeout=""time-in-seconds""]&gt;
 *     &lt;messageCount min=""int-min"" max=""int-max""/&gt;?
 *   &lt;/completeCondition&gt;?
 *   &lt;onComplete expression=""xpath"" [sequence=""sequence-ref""]&gt;
 *     (mediator +)?
 *   &lt;/onComplete&gt;
 * &lt;/aggregate&gt;
 * </pre>
 */
public class AggregateMediatorFactory extends AbstractMediatorFactory {

    private static final Log log = LogFactory.getLog(AggregateMediatorFactory.class);

    private static final QName AGGREGATE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""aggregate"");
    private static final QName CORELATE_ON_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""correlateOn"");
    private static final QName COMPLETE_CONDITION_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""completeCondition"");
    private static final QName MESSAGE_COUNT_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""messageCount"");
    private static final QName ON_COMPLETE_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""onComplete"");
    private static final QName EXPRESSION_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""expression"");
    private static final QName TIMEOUT_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""timeout"");
    private static final QName MIN_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""min"");
    private static final QName MAX_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""max"");
    private static final QName SEQUENCE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, ""sequence"");

    public Mediator createMediator(OMElement elem) {

        AggregateMediator mediator = new AggregateMediator();
        processTraceState(mediator, elem);

        OMElement corelateOn = elem.getFirstChildWithName(CORELATE_ON_Q);
        if (corelateOn != null) {
            OMAttribute corelateExpr = corelateOn.getAttribute(EXPRESSION_Q);
            if (corelateExpr != null) {
                try {
                    mediator.setCorrelateExpression(
                        SynapseXPathFactory.getSynapseXPath(corelateOn, EXPRESSION_Q));
                } catch (JaxenException e) {
                    handleException(""Unable to load the corelate XPATH expression"", e);
                }
            }
        }

        OMElement completeCond = elem.getFirstChildWithName(COMPLETE_CONDITION_Q);
        if (completeCond != null) {
            OMAttribute completeTimeout = completeCond.getAttribute(TIMEOUT_Q);
            if (completeTimeout != null) {
                mediator.setCompletionTimeoutMillis(
                        Long.parseLong(completeTimeout.getAttributeValue()) * 1000);
            }

            OMElement messageCount = completeCond.getFirstChildWithName(MESSAGE_COUNT_Q);
            if (messageCount != null) {
                OMAttribute min = messageCount.getAttribute(MIN_Q);
                if (min != null) {
                    mediator.setMinMessagesToComplete(Integer.parseInt(min.getAttributeValue()));
                }

                OMAttribute max = messageCount.getAttribute(MAX_Q);
                if (max != null) {
                    mediator.setMaxMessagesToComplete(Integer.parseInt(max.getAttributeValue()));
                }
            }
        }

        OMElement onComplete = elem.getFirstChildWithName(ON_COMPLETE_Q);
        if (onComplete != null) {

            OMAttribute aggregateExpr = onComplete.getAttribute(EXPRESSION_Q);
            if (aggregateExpr != null) {
                try {
                    mediator.setAggregationExpression(
                        SynapseXPathFactory.getSynapseXPath(onComplete, EXPRESSION_Q));
                } catch (JaxenException e) {
                    handleException(""Unable to load the aggregating XPATH"", e);
                }
            }

            OMAttribute onCompleteSequence = onComplete.getAttribute(SEQUENCE_Q);
            if (onCompleteSequence != null) {
                mediator.setOnCompleteSequenceRef(onCompleteSequence.getAttributeValue());
            } else if (onComplete.getFirstElement() != null) {
                mediator.setOnCompleteSequence(
                        (new SequenceMediatorFactory()).createAnonymousSequence(onComplete));
            } else {
                SequenceMediator sequence = new SequenceMediator();
                sequence.addChild(new DropMediator());
                mediator.setOnCompleteSequence(sequence);
            }
        }
        return mediator;
    }

    public QName getTagQName() {
        return AGGREGATE_Q;
    }
}
"
org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints.utils;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMAttribute;
import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
import org.apache.synapse.endpoints.algorithms.RoundRobin;
import org.apache.synapse.config.xml.XMLConfigConstants;

import javax.xml.namespace.QName;
import java.util.ArrayList;

/**
 * Factory of all load balance algorithms. ESBSendMediatorFactroy will use this to create the
 * appropriate algorithm implementation.
 */
public class LoadbalanceAlgorithmFactory {

    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement, ArrayList endpoints) {

        LoadbalanceAlgorithm algorithm = null;

        String algorithmName = ""roundRobin"";
        OMAttribute algoAttribute = loadbalanceElement.getAttribute(new QName(null, XMLConfigConstants.ALGORITHM_NAME));
        if(algoAttribute != null) {
            algorithmName = algoAttribute.getAttributeValue();
        }

        if(algorithmName.equalsIgnoreCase(""roundRobin"")) {
                algorithm = new RoundRobin(endpoints);
        }

        return algorithm;
    }
}
"
org/apache/synapse/util/concurrent/SynapseThreadFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util.concurrent;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.ThreadFactory;

/**
 * This is the thread factory for Synapse threads which are accessible through the
 * SynapseEnvironment as pooled threads.
 */
public class SynapseThreadFactory implements ThreadFactory {

    /** Holds the ThreadGroup under which this factory creates threads */
    final ThreadGroup group;

    /** Holds the AtomicInteger class instance for the factory */
    final AtomicInteger count;

    /** prefix for the thread id, thread number will be followed to construct the id */
    final String namePrefix;

    /**
     * Constructor for the ThreadFactory to create new threads
     *
     * @param group      - all the threads are created under this group by this factory
     * @param namePrefix - name prefix of the threads created by this factory
     */
    public SynapseThreadFactory(final ThreadGroup group, final String namePrefix) {
        super();
        this.count = new AtomicInteger(1);
        this.group = group;
        this.namePrefix = namePrefix;
    }

    /**
     * This method is the implementation of the the newThread method and will
     * create new threads under the group and with the nameprefix followed by the
     * thread number as the id
     * 
     * @param runnable - Runnable class to run by the created thread
     * @return a Thread executing the given runnable
     */
    public Thread newThread(final Runnable runnable) {
        StringBuffer buffer = new StringBuffer();
        buffer.append(this.namePrefix);
        buffer.append('-');
        buffer.append(this.count.getAndIncrement());
        Thread t = new Thread(group, runnable, buffer.toString(), 0);
        t.setDaemon(false);
        t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }

}
"
org/apache/synapse/config/xml/AggregateMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.eip.aggregator.AggregateMediator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Serializer for {@link AggregateMediator} instances.
 * 
 * <pre>
 * &lt;aggregate&gt;
 *   &lt;correlateOn expression=""xpath""/&gt;?
 *   &lt;completeCondition [timeout=""time-in-seconds""]&gt;
 *     &lt;messageCount min=""int-min"" max=""int-max""/&gt;?
 *   &lt;/completeCondition&gt;?
 *   &lt;onComplete expression=""xpath"" [sequence=""sequence-ref""]&gt;
 *     (mediator +)?
 *   &lt;/onComplete&gt;
 * &lt;/aggregate&gt;
 * </pre>
 */
public class AggregateMediatorSerializer extends AbstractMediatorSerializer {

    private static final Log log = LogFactory.getLog(AggregateMediatorSerializer.class);

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof AggregateMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }
        AggregateMediator mediator = (AggregateMediator) m;
        OMElement aggregator = fac.createOMElement(""aggregate"", synNS);
        saveTracingState(aggregator, mediator);

        if (mediator.getCorrelateExpression() != null) {
            OMElement corelateOn = fac.createOMElement(""correlateOn"", synNS);
            SynapseXPathSerializer.serializeXPath(
                mediator.getCorrelateExpression(), corelateOn, ""expression"");
            aggregator.addChild(corelateOn);
        }

        OMElement completeCond = fac.createOMElement(""completeCondition"", synNS);
        if (mediator.getCompletionTimeoutMillis() != 0) {
            completeCond.addAttribute(""timeout"", Long.toString(mediator.getCompletionTimeoutMillis() / 1000), nullNS);
        }
        OMElement messageCount = fac.createOMElement(""messageCount"", synNS);
        if (mediator.getMinMessagesToComplete() != 0) {
            messageCount.addAttribute(""min"", Integer.toString(mediator.getMinMessagesToComplete()), nullNS);
        }
        if (mediator.getMaxMessagesToComplete() != 0) {
            messageCount.addAttribute(""max"", Integer.toString(mediator.getMaxMessagesToComplete()), nullNS);
        }
        completeCond.addChild(messageCount);
        aggregator.addChild(completeCond);

        OMElement onCompleteElem = fac.createOMElement(""onComplete"", synNS);
        if (mediator.getAggregationExpression() != null) {
            SynapseXPathSerializer.serializeXPath(
                mediator.getAggregationExpression(), onCompleteElem, ""expression"");
        }
        if (mediator.getOnCompleteSequenceRef() != null) {
            onCompleteElem.addAttribute(""sequence"", mediator.getOnCompleteSequenceRef(), nullNS);
        } else if (mediator.getOnCompleteSequence() != null) {
            new SequenceMediatorSerializer().serializeChildren(
                    onCompleteElem, mediator.getOnCompleteSequence().getList());
        }
        aggregator.addChild(onCompleteElem);

        if (parent != null) {
            parent.addChild(aggregator);
        }

        return aggregator;
    }

    public String getMediatorClassName() {
        return AggregateMediator.class.getName();
    }
}
"
org/apache/synapse/util/POXUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.soap.SOAPBody;
import org.apache.axiom.soap.SOAPFault;
import org.apache.axis2.context.MessageContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 *
 */
public class POXUtils {

    private static final Log log = LogFactory.getLog(POXUtils.class);

    public static void convertSOAPFaultToPOX(MessageContext msgCtx) {

        SOAPBody body = msgCtx.getEnvelope().getBody();
        SOAPFault fault = body.getFault();
        if (fault != null) {

            OMFactory fac = msgCtx.getEnvelope().getOMFactory();
            OMElement faultPayload = fac.createOMElement(new QName(""Exception""));

            if (fault.getDetail() != null && !fault.getDetail().getText().equals("""")) {

                String faultDetail = fault.getDetail().getText();

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the fault detail : "" + faultDetail + "" as athe POX Fault"");
                }
                faultPayload.setText(faultDetail);

            } else if (fault.getReason() != null && !fault.getReason().getText().equals("""")) {

                String faultReasonValue = fault.getReason().getText();

                if (log.isDebugEnabled()) {
                    log.debug(""Setting the fault reason : ""
                        + faultReasonValue + "" as athe POX Fault"");
                }
                faultPayload.setText(faultReasonValue);

            } else if (log.isDebugEnabled()) {
                
                log.debug(""Couldn't find the fault detail or reason to compose POX Fault"");
            }

            if (body.getFirstElement() != null) {
                body.getFirstElement().detach();
            }

            msgCtx.setProcessingFault(true);

            if (log.isDebugEnabled()) {

                String msg = ""Original SOAP Message : "" + msgCtx.getEnvelope().toString() +
                    ""POXFault Message created : "" + faultPayload.toString();
                log.debug(msg);
                
                if (log.isTraceEnabled()) {
                    log.trace(msg);
                }
            }

            body.addChild(faultPayload);
        }
    }
}
"
org/apache/synapse/config/xml/SwitchCase.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.config.xml;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.MessageContext;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A SwitchCase define a case element of Switch Mediator and It has a list mediator and
 * a regex that is matched by its owning SwitchMediator for selection.
 * If any SwitchCase has selected ,Then the list mediator of it, will responsible
 * for message mediation
 */

public class SwitchCase {

    private static final Log log = LogFactory.getLog(SwitchCase.class);

    /**
     * The regular expression pattern to be checked
     */
    private Pattern regex = null;
    
    /**
     * The list mediator which is responsible on message mediation of the case
     */
    private AnonymousListMediator caseMediator;

    /**
     * To delegate message mediation to list mediator
     *
     * @param synCtx message context to be mediated
     * @return boolean value
     */
    public boolean mediate(MessageContext synCtx) {
        return caseMediator != null ? caseMediator.mediate(synCtx) : true;
    }

    /**
     * To get list mediator of this case element
     *
     * @return List mediator of  switch case
     */
    public AnonymousListMediator getCaseMediator() {
        return caseMediator;
    }

    /**
     * To set the set of case mediators
     *
     * @param caseMediator anonymous sequence to be used for the case mediation
     */
    public void setCaseMediator(AnonymousListMediator caseMediator) {
        this.caseMediator = caseMediator;
    }

    /**
     * To get the regular expression pattern
     *
     * @return Pattern
     */
    public Pattern getRegex() {
        return regex;
    }

    /**
     * To set the regular expression pattern
     *
     * @param regex Regular Expression to be matched
     */
    public void setRegex(Pattern regex) {
        this.regex = regex;
    }

    /**
     * To evaluate regular expression pattern to a get switch case
     *
     * @param value value to be tested over the regular expression of match
     * @return boolean value
     */
    public boolean matches(String value) {

        if (value == null) {

            log.warn(""Provided character sequence for switch case condition is 'null'."" +
                    "" Switch case will not be executed."");

            return false;
        }

        Matcher matcher = regex.matcher(value);
        if (matcher == null) {

            log.warn(""Matcher for the provided character sequence and the pattern ' ""
                    + regex + "" '"" + "" cannot be found. Switch case will not be executed."");

            return false;
        }

        return matcher.matches();
    }
}
"
org/apache/synapse/config/xml/SynapseXPathSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseException;
import org.apache.synapse.util.xpath.SynapseXPath;

/**
 * 
 */
public class SynapseXPathSerializer {

    private static final Log log = LogFactory.getLog(SynapseXPathSerializer.class);

    public static OMElement serializeXPath(SynapseXPath xpath, OMElement elem, String attribName) {

        OMNamespace nullNS = elem.getOMFactory()
            .createOMNamespace(XMLConfigConstants.NULL_NAMESPACE, """");

        if (xpath != null) {
            
            elem.addAttribute(elem.getOMFactory().createOMAttribute(
                attribName, nullNS, xpath.toString()));

            serializeNamespaces(elem, xpath);

        } else {
            handleException(""Couldn't find the xpath in the SynapseXPath"");
        }

        return elem;
    }

    private static void serializeNamespaces(OMElement elem, SynapseXPath xpath) {

        for (Object o : xpath.getNamespaces().keySet()) {
            String prefix = (String) o;
            String uri = xpath.getNamespaceContext().translateNamespacePrefixToUri(prefix);
            if (!XMLConfigConstants.SYNAPSE_NAMESPACE.equals(uri)) {
                elem.declareNamespace(uri, prefix);
            }
        }
    }

    private static void handleException(String message) {
        log.error(message);
        throw new SynapseException(message); 
    }
}
"
org/apache/synapse/core/axis2/Axis2MessageContext.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.core.axis2;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.soap.SOAPBody;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axis2.AxisFault;
import org.apache.axis2.Constants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.addressing.RelatesTo;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.Mediator;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.config.Entry;
import org.apache.synapse.config.SynapseConfiguration;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.mediators.MediatorFaultHandler;

import java.util.*;

/**
 * This is the MessageContext implementation that synapse uses almost all the time because Synapse
 * is implemented on top of the Axis2
 */
public class Axis2MessageContext implements MessageContext {

    /** Holds the reference to the Synapse Message Context */
    private SynapseConfiguration synCfg = null;

    /** Holds the environment on which synapse operates */
    private SynapseEnvironment synEnv = null;

    /** Synapse Message Context properties */
    private Map<String, Object> properties = new HashMap<String, Object>();

    /**
     * Local entries fetched from the configuration or from the registry for the transactional
     * resource access
     */
    private Map<String, Object> localEntries = new HashMap<String, Object>();

    /** Fault Handler stack which will be popped and called the handleFault in error states */
    private Stack<FaultHandler> faultStack = new Stack<FaultHandler>();

    /** The Axis2 MessageContext reference */
    private org.apache.axis2.context.MessageContext axis2MessageContext = null;

    /** Attribute of the MC specifying whether this is a response or not */
    private boolean response = false;

    /** Attribute specifying whether this MC corresponds to fault response or not */
    private boolean faultResponse = false;

    /** Attribute of MC stating the tracing state of the message */
    private int tracingState = SynapseConstants.TRACING_UNSET;

    /** The service log for this message */
    private Log serviceLog = null;

    public SynapseConfiguration getConfiguration() {
        return synCfg;
    }

    public void setConfiguration(SynapseConfiguration synCfg) {
        this.synCfg = synCfg;
    }

    public SynapseEnvironment getEnvironment() {
        return synEnv;
    }

    public void setEnvironment(SynapseEnvironment synEnv) {
        this.synEnv = synEnv;
    }

    public Map getContextEntries() {
        return localEntries;
    }

    public void setContextEntries(Map<String, Object> entries) {
        this.localEntries = entries;
    }

    public Mediator getMainSequence() {
        Object o = localEntries.get(SynapseConstants.MAIN_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator main = getConfiguration().getMainSequence();
            localEntries.put(SynapseConstants.MAIN_SEQUENCE_KEY, main);
            return main;
        }
    }

    public Mediator getFaultSequence() {
        Object o = localEntries.get(SynapseConstants.FAULT_SEQUENCE_KEY);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator fault = getConfiguration().getFaultSequence();
            localEntries.put(SynapseConstants.FAULT_SEQUENCE_KEY, fault);
            return fault;
        }
    }

    public Mediator getSequence(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Mediator) {
            return (Mediator) o;
        } else {
            Mediator m = getConfiguration().getSequence(key);
            localEntries.put(key, m);
            return m;
        }
    }

    public Endpoint getEndpoint(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Endpoint) {
            return (Endpoint) o;
        } else {
            Endpoint e = getConfiguration().getEndpoint(key);
            localEntries.put(key, e);
            return e;
        }
    }

    public Object getEntry(String key) {
        Object o = localEntries.get(key);
        if (o != null && o instanceof Entry) {
            return ((Entry) o).getValue();
        } else {
            Object e = getConfiguration().getEntry(key);
            if (e != null) {
                localEntries.put(key, e);
                return e;
            } else {
                getConfiguration().getEntryDefinition(key);
                return getConfiguration().getEntry(key);
            }
        }
    }

    public Object getProperty(String key) {
        return properties.get(key);
    }

    public void setProperty(String key, Object value) {
        properties.put(key, value);

        // do not commit response by default in the server process
        if (SynapseConstants.RESPONSE.equals(key) &&
                getAxis2MessageContext().getOperationContext() != null) {
            getAxis2MessageContext().getOperationContext().setProperty(
                org.apache.axis2.Constants.RESPONSE_WRITTEN, ""SKIP"");
        }
    }

    public Set getPropertyKeySet() {
        return properties.keySet();
    }

    /**
     * Constructor for the Axis2MessageContext inside Synapse
     *
     * @param axisMsgCtx MessageContext representing the relevant Axis MC
     * @param synCfg SynapseConfiguraion describing Synapse
     * @param synEnv SynapseEnvironment describing the environment of Synapse
     */
    public Axis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx,
                               SynapseConfiguration synCfg, SynapseEnvironment synEnv) {
        setAxis2MessageContext(axisMsgCtx);
        this.synCfg = synCfg;
        this.synEnv = synEnv;
        this.pushFaultHandler(new MediatorFaultHandler(synCfg.getFaultSequence()));
    }

    public EndpointReference getFaultTo() {
        return axis2MessageContext.getFaultTo();
    }

    public void setFaultTo(EndpointReference reference) {
        axis2MessageContext.setFaultTo(reference);
    }

    public EndpointReference getFrom() {
        return axis2MessageContext.getFrom();
    }

    public void setFrom(EndpointReference reference) {
        axis2MessageContext.setFrom(reference);
    }

    public SOAPEnvelope getEnvelope() {
        return axis2MessageContext.getEnvelope();
    }

    public void setEnvelope(SOAPEnvelope envelope) throws AxisFault {
        axis2MessageContext.setEnvelope(envelope);
    }

    public String getMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public void setMessageID(String string) {
        axis2MessageContext.setMessageID(string);
    }

    public RelatesTo getRelatesTo() {
        return axis2MessageContext.getRelatesTo();
    }

    public void setRelatesTo(RelatesTo[] reference) {
        axis2MessageContext.setRelationships(reference);
    }

    public EndpointReference getReplyTo() {
        return axis2MessageContext.getReplyTo();
    }

    public void setReplyTo(EndpointReference reference) {
        axis2MessageContext.setReplyTo(reference);
    }

    public EndpointReference getTo() {
        return axis2MessageContext.getTo();
    }

    public void setTo(EndpointReference reference) {
        axis2MessageContext.setTo(reference);
    }

    public void setWSAAction(String actionURI) {
        axis2MessageContext.setWSAAction(actionURI);
    }

    public String getWSAAction() {
        return axis2MessageContext.getWSAAction();
    }

    public void setWSAMessageID(String messageID) {
        axis2MessageContext.setWSAMessageId(messageID);
    }

    public String getWSAMessageID() {
        return axis2MessageContext.getMessageID();
    }

    public String getSoapAction() {
        return axis2MessageContext.getSoapAction();
    }

    public void setSoapAction(String string) {
        axis2MessageContext.setSoapAction(string);
    }

    public boolean isDoingMTOM() {
        return axis2MessageContext.isDoingMTOM();
    }

    public boolean isDoingSWA() {
        return axis2MessageContext.isDoingSwA();
    }

    public void setDoingMTOM(boolean b) {
        axis2MessageContext.setDoingMTOM(b);
    }

    public void setDoingSWA(boolean b) {
        axis2MessageContext.setDoingSwA(b);
    }

    public boolean isDoingPOX() {
        return axis2MessageContext.isDoingREST();
    }

    public void setDoingPOX(boolean b) {
        axis2MessageContext.setDoingREST(b);
    }

    public boolean isDoingGET() {
        return Constants.Configuration.HTTP_METHOD_GET.equals(
            axis2MessageContext.getProperty(Constants.Configuration.HTTP_METHOD))
            && axis2MessageContext.isDoingREST();
    }

    public void setDoingGET(boolean b) {
        if(b) {
            axis2MessageContext.setDoingREST(b);
            axis2MessageContext.setProperty(Constants.Configuration.HTTP_METHOD,
                Constants.Configuration.HTTP_METHOD_GET);
        } else {
            axis2MessageContext.removeProperty(Constants.Configuration.HTTP_METHOD);
        }
    }

    public boolean isSOAP11() {
        return axis2MessageContext.isSOAP11();
    }

    public void setResponse(boolean b) {
        response = b;
        axis2MessageContext.setProperty(SynapseConstants.ISRESPONSE_PROPERTY, b);
    }

    public boolean isResponse() {
        Object o = properties.get(SynapseConstants.RESPONSE);
        return o != null && o instanceof String &&
                ((String) o).equalsIgnoreCase(""true"") || response;
    }

    public void setFaultResponse(boolean b) {
        this.faultResponse = b;
    }

    public boolean isFaultResponse() {
        return this.faultResponse;
    }

    public int getTracingState() {
        return tracingState;
    }

    public void setTracingState(int tracingState) {
        this.tracingState= tracingState;
    }

    public Stack getFaultStack() {
        return this.faultStack;
    }

    public void pushFaultHandler(FaultHandler fault) {
        this.faultStack.push(fault);
    }

    /**
     * Return the service level Log for this message context or null
     * @return the service level Log for the message
     */
    public Log getServiceLog() {

        if (serviceLog != null) {
            return serviceLog;
        } else {
            String serviceName = (String) getProperty(SynapseConstants.PROXY_SERVICE);
            if (serviceName != null && synCfg.getProxyService(serviceName) != null) {
                serviceLog = LogFactory.getLog(
                    SynapseConstants.SERVICE_LOGGER_PREFIX + serviceName);
                return serviceLog;
            } else {
                serviceLog = LogFactory.getLog(
                    SynapseConstants.SERVICE_LOGGER_PREFIX.substring(0,
                    SynapseConstants.SERVICE_LOGGER_PREFIX.length()-1));
                return serviceLog;
            }
        }
    }

    /**
     * Set the service log
     * @param serviceLog log to be used on a per-service basis
     */
    public void setServiceLog(Log serviceLog) {
        this.serviceLog = serviceLog;
    }

    public org.apache.axis2.context.MessageContext getAxis2MessageContext() {
        return axis2MessageContext;
    }

    public void setAxis2MessageContext(org.apache.axis2.context.MessageContext axisMsgCtx) {
        this.axis2MessageContext = axisMsgCtx;
        Boolean resp = (Boolean) axisMsgCtx.getProperty(SynapseConstants.ISRESPONSE_PROPERTY);
        if (resp != null) {
            response = resp;
        }
    }

    public void setPaused(boolean value) {
        axis2MessageContext.setPaused(value);
    }

    public boolean isPaused() {
        return axis2MessageContext.isPaused();
    }

    public boolean isServerSide() {
        return axis2MessageContext.isServerSide();
    }

    public void setServerSide(boolean value) {
        axis2MessageContext.setServerSide(value);
    }

    public String toString() {
        
        StringBuffer sb = new StringBuffer();
        String separator = ""\n"";

        if (getTo() != null) {
            sb.append(""To : "").append(getTo().getAddress());
        } else {
            sb.append(""To : "");
        }

        if (getFrom() != null) {
            sb.append(separator).append(""From : "").append(getFrom().getAddress());
        }

        if (getWSAAction() != null) {
            sb.append(separator).append(""WSAction : "").append(getWSAAction());
        }

        if (getSoapAction() != null) {
            sb.append(separator).append(""SOAPAction : "").append(getSoapAction());
        }

        if (getReplyTo() != null) {
            sb.append(separator).append(""ReplyTo : "").append(getReplyTo().getAddress());
        }

        if (getMessageID() != null) {
            sb.append(separator).append(""MessageID : "").append(getMessageID());
        }

        SOAPHeader soapHeader = getEnvelope().getHeader();
        if (soapHeader != null) {
            
            sb.append(separator).append(""Headers : "");
            for (Iterator iter = soapHeader.examineAllHeaderBlocks(); iter.hasNext();) {

                Object o = iter.next();
                if (o instanceof SOAPHeaderBlock) {

                    SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) o;
                    sb.append(separator).append(""\t"").append(
                        headerBlock.getLocalName()).append("" : "").append(headerBlock.getText());

                } else if (o instanceof OMElement) {

                    OMElement headerElem = (OMElement) o;
                    sb.append(separator).append(""\t"").append(
                        headerElem.getLocalName()).append("" : "").append(headerElem.getText());
                }
            }
        }

        SOAPBody soapBody = getEnvelope().getBody();
        if (soapBody != null) {
            sb.append(separator).append(""Body : "").append(soapBody.toString());
        }

        return sb.toString();
    }

}
"
org/apache/synapse/Command.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

/**
 * This is the Command interface that will be implemented to write command objects, but it is not
 * required to implement this interface Synapse will use reflection to find an execute method as
 * a convention in the command pattern and will start the execution from the execute method
 */
public interface Command {

    /**
     * This method will be implemented with a set of getters and setters for the command properties
     * in an implementation of a Command.
     */
    public void execute();
}
"
org/apache/synapse/config/xml/SendMediatorFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.config.xml.endpoints.EndpointFactory;
import org.apache.synapse.mediators.builtin.SendMediator;
import org.apache.synapse.endpoints.Endpoint;

import javax.xml.namespace.QName;

/**
 * Factory for {@link SendMediator} instances.
 * <p>
 * TODO: document endpoints, failover and load balacing
 * <p>
 * The &lt;send&gt; element is used to send messages out of Synapse to some endpoint. In the simplest case,
 * the place to send the message to is implicit in the message (via a property of the message itself)-
 * that is indicated by the following:
 * <pre>
 *  &lt;send/&gt;
 * </pre>
 *
 * If the message is to be sent to one or more endpoints, then the following is used:
 * <pre>
 *  &lt;send&gt;
 *   (endpointref | endpoint)+
 *  &lt;/send&gt;
 * </pre>
 * where the endpointref token refers to the following:
 * <pre>
 * &lt;endpoint ref=""name""/&gt;
 * </pre>
 * and the endpoint token refers to an anonymous endpoint defined inline:
 * <pre>
 *  &lt;endpoint address=""url""/&gt;
 * </pre>
 * If the message is to be sent to an endpoint selected by load balancing across a set of endpoints,
 * then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;load-balance algorithm=""uri""&gt;
 *     (endpointref | endpoint)+
 *   &lt;/load-balance&gt;
 * &lt;/send&gt;
 * </pre>
 * Similarly, if the message is to be sent to an endpoint with failover semantics, then it is indicated by the following:
 * <pre>
 * &lt;send&gt;
 *   &lt;failover&gt;
 *     (endpointref | endpoint)+
 *   &lt;/failover&gt;
 * &lt;/send&gt;
 * </pre>
 */
public class SendMediatorFactory extends AbstractMediatorFactory  {

    private static final QName SEND_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""send"");
    private static final QName ENDPOINT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""endpoint"");

    public Mediator createMediator(OMElement elem) {

        SendMediator sm =  new SendMediator();

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(sm,elem);

        OMElement epElement = elem.getFirstChildWithName(ENDPOINT_Q);
        if (epElement != null) {
            // create the endpoint and set it in the send medaitor
            Endpoint endpoint = EndpointFactory.getEndpointFromElement(epElement, true);
            if (endpoint != null) {
                sm.setEndpoint(endpoint);
            }
        }

        return sm;
    }

    public QName getTagQName() {
        return SEND_Q;
    }
}
"
org/apache/synapse/endpoints/dispatch/Dispatcher.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints.dispatch;

import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;

/**
 * Defines the behavior of session dispatchers. There can be two dispatcher types. Server initiated
 * session dispatchers and client initiated session dispatchers. In the former one, server generates
 * the session ID and sends it to the client in the first RESPONSE. In the later case, client should
 * generate the session ID and send it to the server in the first REQUEST. A dispatcher object will
 * be created for each session affinity load balance endpoint.
 */
public interface Dispatcher {

    /**
     * Dispatcher should check the session id pattern in the synapseMessageContext and return the
     * matching endpoint for that session id, if available. If the session id in the given
     * synapseMessageContext is not found it should return null.
     *
     * @param synCtx client -> esb message context.
     * @param dispatcherContext context for dispatching
     * @return Endpoint Endpoint associated with this session.
     */
    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext);

    /**
     * Updates the session maps. This will be called in the first client -> synapse -> server flow
     * for client initiated sessions. For server initiated sessions, this will be called in the
     * first server -> synapse -> client flow.
     *
     * @param synCtx   SynapseMessageContext
     * @param dispatcherContext context for dispatching
     * @param endpoint Selected endpoint for this session.
     */
    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
        Endpoint endpoint);

    /**
     * Removes the session belonging to the given message context.
     *
     * @param synCtx MessageContext containing an session ID.
     * @param dispatcherContext context for dispatching
     */
    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext);

    /**
     * Determine whether the session supported by the implementing dispatcher is initiated by the
     * server (e.g. soap session) or by the client. This can be used for optimizing session updates.
     *
     * @return true, if the session is initiated by the server. false, otherwise.
     */
    public boolean isServerInitiatedSession();
}
"
org/apache/synapse/endpoints/IndirectEndpoint.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.endpoints;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.FaultHandler;
import org.apache.synapse.MessageContext;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.endpoints.utils.EndpointDefinition;

/**
 * This class represents the endpoints referred by keys. It does not store the actual referred
 * endpoint as a private variable as it could expire. Therefore, it only stores the key and gets the
 * actual endpoint from the synapse configuration.
 * <p/>
 * As this is also an instance of endpoint, this can be used any place, where a normal endpoint is
 * used.
 */
public class IndirectEndpoint extends FaultHandler implements Endpoint {

    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
    private static final Log log = LogFactory.getLog(IndirectEndpoint.class);

    private String name = null;
    private String key = null;
    private Endpoint parentEndpoint = null;

    public void send(MessageContext synMessageContext) {

        // get the actual endpoint and send
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        assert endpoint != null;
        if (endpoint.isActive(synMessageContext)) {
             // register this as the immediate fault handler for this message.
            synMessageContext.pushFaultHandler(this);
            endpoint.send(synMessageContext);
        } else {
            // if this is a child of some other endpoint, inform parent about the failure.
            // if not, inform to the next fault handler.
            if (parentEndpoint != null) {
                auditWarn(""Endpoint : "" + endpoint.getName() + "" is currently inactive"" +
                        "" - invoking parent endpoint"", synMessageContext);
                parentEndpoint.onChildEndpointFail(this, synMessageContext);

            } else {
                auditWarn(""Endpoint : "" + endpoint.getName() + "" is currently inactive"" +
                        "" - invoking fault handler / assuming failure"", synMessageContext);

                Object o = synMessageContext.getFaultStack().pop();
                if (o != null) {
                    ((FaultHandler) o).handleFault(synMessageContext);
                }
            }
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    /**
     * IndirectEndpoints are active if its referref endpoint is active and vise versa. Therefore,
     * this returns if its referred endpoint is active or not.
     *
     * @param synMessageContext MessageContext of the current message.
     * @return true if the referred endpoint is active. false otherwise.
     */
    public boolean isActive(MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        assert endpoint != null;
        return endpoint.isActive(synMessageContext);
    }

    /**
     * Activating or deactivating an IndirectEndpoint is the activating or deactivating its
     * referref endpoint. Therefore, this sets the active state of its referred endpoint.
     *
     * @param active            true if active. false otherwise.
     * @param synMessageContext MessageContext of the current message.
     */
    public void setActive(boolean active, MessageContext synMessageContext) {
        Endpoint endpoint = synMessageContext.getEndpoint(key);
        if (endpoint == null) {
            handleException(""Reference to non-existent endpoint for key : "" + key);
        }

        assert endpoint != null;
        endpoint.setActive(active, synMessageContext);
    }

    public void setParentEndpoint(Endpoint parentEndpoint) {
        this.parentEndpoint = parentEndpoint;
    }

    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {

        // if this is a child of some other endpoint, inform parent about the failure.
        // if not, inform to the next fault handler.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);
        } else {
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }

    private void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    protected void auditWarn(String msg, MessageContext msgContext) {
        log.warn(msg);
        if (msgContext.getServiceLog() != null) {
            msgContext.getServiceLog().warn(msg);
        }
        if (shouldTrace(msgContext)) {
            trace.warn(msg);
        }
    }

    public boolean shouldTrace(MessageContext synCtx) {
        Endpoint endpoint = synCtx.getEndpoint(key);
        EndpointDefinition endptDefn = null;
        if (endpoint instanceof AddressEndpoint) {
            AddressEndpoint addEndpt = (AddressEndpoint) endpoint;
            endptDefn = addEndpt.getEndpoint();
        } else if (endpoint instanceof WSDLEndpoint) {
            WSDLEndpoint wsdlEndpt = (WSDLEndpoint) endpoint;
            endptDefn = wsdlEndpt.getEndpoint();
        }

        return endptDefn != null && ((endptDefn.getTraceState() == SynapseConstants.TRACING_ON) ||
                (endptDefn.getTraceState() == SynapseConstants.TRACING_UNSET &&
                        synCtx.getTracingState() == SynapseConstants.TRACING_ON));
    }

    public void onFault(MessageContext synMessageContext) {
        // At this point,child endpoint is in inactive state
        // if this is a child of some other endpoint, inform parent about the failure.
        // if not, inform to the next fault handler.
        if (parentEndpoint != null) {
            parentEndpoint.onChildEndpointFail(this, synMessageContext);
        } else {
            Object o = synMessageContext.getFaultStack().pop();
            if (o != null) {
                ((FaultHandler) o).handleFault(synMessageContext);
            }
        }
    }
}
"
org/apache/synapse/mediators/builtin/LogMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.builtin;

import org.apache.axiom.soap.SOAPHeaderBlock;
import org.apache.axiom.soap.SOAPHeader;
import org.apache.axiom.om.OMElement;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractMediator;
import org.apache.synapse.mediators.MediatorProperty;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * Logs the specified message into the configured logger. The log levels specify
 * which attributes would be logged, and is configurable. Additionally custom
 * properties may be defined to the logger, where literal values or expressions
 * could be specified for logging. The custom properties are printed into the log
 * using the defined separator (\n, "","" etc)
 */
public class LogMediator extends AbstractMediator {

    /** Only properties specified to the Log mediator */
    public static final int CUSTOM  = 0;
    /** To, From, WSAction, SOAPAction, ReplyTo, MessageID and any properties */
    public static final int SIMPLE  = 1;
    /** All SOAP header blocks and any properties */
    public static final int HEADERS = 2;
    /** all attributes of level 'simple' and the SOAP envelope and any properties */
    public static final int FULL    = 3;

    public static final String DEFAULT_SEP = "", "";

    /** The default log level is set to SIMPLE */
    private int logLevel = SIMPLE;
    /** The separator for which used to separate logging information */
    private String separator = DEFAULT_SEP;
    /** The holder for the custom properties */
    private List properties = new ArrayList();

    /**
     * Logs the current message according to the supplied semantics
     *
     * @param synCtx (current) message to be logged
     * @return true always
     */
    public boolean mediate(MessageContext synCtx) {

        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Log mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        String logMessage = getLogMessage(synCtx);
        synCtx.getServiceLog().info(logMessage);

        if (log.isInfoEnabled()) {
            log.info(logMessage);
        }
        if (traceOn) {
            trace.info(""Log message : "" + logMessage);
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Log mediator"");
        }
        return true;
    }

    private String getLogMessage(MessageContext synCtx) {
        switch (logLevel) {
            case CUSTOM:
                return getCustomLogMessage(synCtx);
            case SIMPLE:
                return getSimpleLogMessage(synCtx);
            case HEADERS:
                return getHeadersLogMessage(synCtx);
            case FULL:
                return getFullLogMessage(synCtx);
            default:
                return ""Invalid log level specified"";
        }
    }

    private String getCustomLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getSimpleLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        if (synCtx.getTo() != null)
            sb.append(""To: "" + synCtx.getTo().getAddress());
        else
            sb.append(""To: "");
        if (synCtx.getFrom() != null)
            sb.append(separator + ""From: "" + synCtx.getFrom().getAddress());
        if (synCtx.getWSAAction() != null)
            sb.append(separator + ""WSAction: "" + synCtx.getWSAAction());
        if (synCtx.getSoapAction() != null)
            sb.append(separator + ""SOAPAction: "" + synCtx.getSoapAction());
        if (synCtx.getReplyTo() != null)
            sb.append(separator + ""ReplyTo: "" + synCtx.getReplyTo().getAddress());
        if (synCtx.getMessageID() != null)
            sb.append(separator + ""MessageID: "" + synCtx.getMessageID());
        sb.append(separator + ""Direction: "" + (synCtx.isResponse() ? ""response"" : ""request""));
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getHeadersLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        if (synCtx.getEnvelope() != null) {
            SOAPHeader header = synCtx.getEnvelope().getHeader();
            if (header != null) {
                for (Iterator iter = header.examineAllHeaderBlocks(); iter.hasNext();) {
                    Object o = iter.next();
                    if (o instanceof SOAPHeaderBlock) {
                        SOAPHeaderBlock headerBlk = (SOAPHeaderBlock) o;
                        sb.append(separator + headerBlk.getLocalName() + "" : "" +
                                headerBlk.getText());
                    } else if (o instanceof OMElement) {
                        OMElement headerElem = (OMElement) o;
                        sb.append(separator + headerElem.getLocalName() + "" : "" +
                                headerElem.getText());
                    }
                }
            }
        }
        setCustomProperties(sb, synCtx);
        return trimLeadingSeparator(sb);
    }

    private String getFullLogMessage(MessageContext synCtx) {
        StringBuffer sb = new StringBuffer();
        sb.append(getSimpleLogMessage(synCtx));
        if (synCtx.getEnvelope() != null)
            sb.append(separator + ""Envelope: "" + synCtx.getEnvelope());        
        return trimLeadingSeparator(sb);
    }

    private void setCustomProperties(StringBuffer sb, MessageContext synCtx) {
        if (properties != null && !properties.isEmpty()) {
            for (Iterator iter = properties.iterator(); iter.hasNext();) {
                MediatorProperty prop = (MediatorProperty) iter.next();
                sb.append(separator + prop.getName() + "" = "" +
                        (prop.getValue() != null ? prop.getValue() :
                                prop.getEvaluatedExpression(synCtx)));
            }
        }
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getSeparator() {
        return separator;
    }

    public void setSeparator(String separator) {
        this.separator = separator;
    }

    public void addProperty(MediatorProperty p) {
        properties.add(p);
    }

    public void addAllProperties(List list) {
        properties.addAll(list);
    }

    public List getProperties() {
        return properties;
    }

    private String trimLeadingSeparator(StringBuffer sb) {
        String retStr = sb.toString();
        if (retStr.startsWith(separator)) {
            return retStr.substring(separator.length());
        } else {
            return retStr;
        }
    }
}
"
org/apache/synapse/statistics/impl/EndPointStatisticsStack.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics.impl;

import org.apache.synapse.statistics.StatisticsStack;
import org.apache.synapse.statistics.StatisticsCollector;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;

/**
 * The data structure to hold statistics related to the endpoints
 *
 */

public class EndPointStatisticsStack implements StatisticsStack {

    /** list of endpoint statistics */
    private List endpointStatistics;
    /** To decide whether the reporting of the in flow statistics have been completed*/
    private boolean isCompleteInFlowStatisicsReport = false;

    /**
     * To put statistics
     * @param key                   - The name of the End Point
     * @param initTime
     * @param isInFlow
     * @param isStatisticsEnable
     * @param isFault
     */
    public void put(String key, long initTime, boolean isInFlow, boolean isStatisticsEnable,
                    boolean isFault) {
        if (endpointStatistics == null) {
            endpointStatistics = new ArrayList();
        }
        endpointStatistics.add(
                new EndPointStatistics(key, initTime, isInFlow, isStatisticsEnable, isFault));
    }

    /**
     * This method used to report the latest  statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     */

    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            EndPointStatistics statistics =
                    (EndPointStatistics) endpointStatistics.get(
                            endpointStatistics.size() - 1);
            if (statistics != null && statistics.isStatisticsEnable &&
                    statistics.endPointName != null) {
                if (statistics.inTimeForInFlow != -1) {
                    long initTimeForOutFlow = System.currentTimeMillis();
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            false, statistics.inTimeForInFlow,
                            initTimeForOutFlow, isFault);
                    statistics.inTimeForInFlow = -1;
                    statistics.inTimeForOutFlow = initTimeForOutFlow;
                } else if (statistics.inTimeForOutFlow != -1 &&
                        isCompleteInFlowStatisicsReport) {
                    statisticsCollector.reportForEndPoint(statistics.endPointName,
                            true, statistics.inTimeForOutFlow,
                            System.currentTimeMillis(), isFault);
                    endpointStatistics.remove(statistics);
                }
            }
        }
    }

    /**
     * Report a particular statistics to the StatisticsCollector
     * @param statisticsCollector
     * @param isFault
     * @param name
     */
    public void reportToStatisticsCollector(StatisticsCollector statisticsCollector,
                                            boolean isFault, String name) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null &&
                            statistics.endPointName.equals(name)) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
    }

    /**
     * This method  used to unreported all statistics to the StatisticsCollector
     * @param statisticsCollector
     */
    public void reportAllToStatisticsCollector(StatisticsCollector statisticsCollector,
                                               boolean isFault) {
        if (endpointStatistics != null && !endpointStatistics.isEmpty()) {
            List tobeRemoved = new ArrayList();
            for (Iterator epIterator = endpointStatistics.iterator();
                 epIterator.hasNext();) {
                Object statisticsObj = epIterator.next();
                if (statisticsObj instanceof EndPointStatistics) {
                    EndPointStatistics statistics = (EndPointStatistics) statisticsObj;
                    if (statistics.isStatisticsEnable && statistics.endPointName != null) {
                        if (statistics.inTimeForInFlow != -1) {
                            long initTimeForOutFlow = System.currentTimeMillis();
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    false, statistics.inTimeForInFlow,
                                    initTimeForOutFlow, isFault);
                            statistics.inTimeForInFlow = -1;
                            statistics.inTimeForOutFlow = initTimeForOutFlow;
                        } else if (statistics.inTimeForOutFlow != -1 &&
                                isCompleteInFlowStatisicsReport) {
                            statisticsCollector.reportForEndPoint(statistics.endPointName,
                                    true, statistics.inTimeForOutFlow,
                                    System.currentTimeMillis(), isFault);
                            tobeRemoved.add(statistics);
                        }
                    }
                }
            }
            endpointStatistics.removeAll(tobeRemoved);
        }
        isCompleteInFlowStatisicsReport = true;
    }

    class EndPointStatistics {

        /** The name of the endpoint    */
        private String endPointName;
         /** To check whether IN message flow or not   */
        private boolean isStatisticsEnable;
        /** To indicate whether this is fault or not  */
        private boolean isFault;
        /** The time which starts to collect statistics for IN flow */
        private long inTimeForInFlow = -1;
        /** The time which starts to collect statistics for OUT flow */
        private long inTimeForOutFlow = -1;

        public EndPointStatistics(String endPointName, long initTime, boolean inFlow,
                                  boolean statisticsEnable, boolean fault) {
            if (inFlow) {
                this.endPointName = endPointName;
                this.inTimeForInFlow = initTime;
                isStatisticsEnable = statisticsEnable;
                isFault = fault;
            }
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            EndPointStatistics that = (EndPointStatistics) o;

            if (endPointName != null ? !endPointName.equals(that.endPointName) : that.endPointName != null)
                return false;

            return true;
        }

        public int hashCode() {
            return (endPointName != null ? endPointName.hashCode() : 0);
        }
    }
}
"
org/apache/synapse/SynapseConstants.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMNamespace;

import javax.xml.namespace.QName;

/**
 * Global constants for the Apache Synapse project
 */
public final class SynapseConstants {

    /** The Synapse namespace */
    public static final String SYNAPSE_NAMESPACE = ""http://ws.apache.org/ns/synapse"";
    /** An OMNamespace object for the Synapse NS */
    public static final OMNamespace SYNAPSE_OMNAMESPACE =
            OMAbstractFactory.getOMFactory().createOMNamespace(SYNAPSE_NAMESPACE, ""syn"");

    /** The name of the main sequence for message mediation */
    public static final String MAIN_SEQUENCE_KEY  = ""main"";
    /** The name of the fault sequence to execute on failures during mediation */
    public static final String FAULT_SEQUENCE_KEY = ""fault"";
    /** The name of the mandatory sequence to execute before the begining of the actual mediation */
    public static final String MANDATORY_SEQUENCE_KEY = ""pre-mediate"";

    /** The name of the Synapse service (used for message mediation) */
    public static final String SYNAPSE_SERVICE_NAME =""__SynapseService"";
    /** The operation name used by the Synapse service (for message mediation) */
    public static final QName SYNAPSE_OPERATION_NAME = new QName(""mediate"");

    //- names of modules to be engaged at runtime -
    /** The Name of the WS-RM Mercury module */
    public static final String MERCURY_MODULE_NAME = ""Mercury"";
    /** The Name of the WS-A Addressing module */
    public static final String ADDRESSING_MODULE_NAME = ""addressing"";
    /** The Name of the WS-Security Rampart module */
    public static final String RAMPART_MODULE_NAME = ""rampart"";

    //- Standard headers that can be read as get-property('header')-
    /** Refers to the To header */
    public static final String HEADER_TO = ""To"";
    /** Refers to the From header */
    public static final String HEADER_FROM = ""From"";
    /** Refers to the FaultTo header */
    public static final String HEADER_FAULT = ""FaultTo"";
    /** Refers to the Action header */
    public static final String HEADER_ACTION = ""Action"";
    /** Refers to the ReplyTo header */
    public static final String HEADER_REPLY_TO = ""ReplyTo"";
    /** Refers to the RelatesTo header */
    public static final String HEADER_RELATES_TO = ""RelatesTo"";
    /** Refers to the MessageID header */
    public static final String HEADER_MESSAGE_ID = ""MessageID"";
    /** Message format: pox, soap11, soap12 */
    public static final String PROPERTY_MESSAGE_FORMAT = ""MESSAGE_FORMAT"";
    /** WSDL operation name **/
    public static final String PROPERTY_OPERATION_NAME = ""OperationName"";
    /** WSDL operation namespace **/
    public static final String PROPERTY_OPERATION_NAMESPACE = ""OperationNamespace"";
    /** System time in milliseconds - the offset from epoch (i.e. System.currentTimeMillis) */
    public static final String SYSTEM_TIME = ""SYSTEM_TIME"";
    /** System date */
    public static final String SYSTEM_DATE = ""SYSTEM_DATE"";

    public static final String ADDRESSING_VERSION_FINAL = ""final"";
    public static final String ADDRESSING_VERSION_SUBMISSION = ""submission"";

    /** The Axis2 client options property name for the Rampart policy */
    public static final String RAMPART_POLICY = ""rampartPolicy"";
    /** The Axis2 client options property name for the Sandesha policy */
	public static final String SANDESHA_POLICY = ""sandeshaPolicy"";

    /** The name of the Parameter set on the Axis2Configuration to hold the Synapse Configuration */
    public static final String SYNAPSE_CONFIG = ""synapse.config"";
    /** The name of the Parameter set on the Axis2Configuration to hold the Synapse Environment */
    public static final String SYNAPSE_ENV = ""synapse.env"";

    /** The name of the system property that will hold the Synapse home directory */
    public static final String SYNAPSE_HOME = ""synapse.home"";
    /** The name of the system property used to specify/override the Synapse config XML location */
    public static final String SYNAPSE_XML = ""synapse.xml"";
    /** The name of the system property used to specify/override the Synapse properties location */
    public static final String SYNAPSE_PROPERTIES = ""synapse.properties"";
    /** conf directory name **/
    public static final String CONF_DIRECTORY = ""conf"";

    //- Synapse Message Context Properties -
        /** The Synapse MC property name that holds the name of the Proxy service thats handling it */
        public static final String PROXY_SERVICE = ""proxy.name"";
        /** The Synapse MC property that marks it as a RESPONSE */
        public static final String RESPONSE = ""RESPONSE"";
        /** The Synapse MC property that marks the message as a OUT_ONLY message */
        public static final String OUT_ONLY = ""OUT_ONLY"";

        //-- error handling --
        /** The message context property name which holds the error code for the last encountered exception */
        public static final String ERROR_CODE = ""ERROR_CODE"";
        /** The MC property name which holds the error message for the last encountered exception */
        public static final String ERROR_MESSAGE = ""ERROR_MESSAGE"";
        /** The message context property name which holds the error detail (stack trace) for the last encountered exception */
        public static final String ERROR_DETAIL = ""ERROR_DETAIL"";
        /** The message context property name which holds the exception (if any) for the last encountered exception */
        public static final String ERROR_EXCEPTION = ""ERROR_EXCEPTION"";

        /** Mercury last message property name */
        public static final String MERCURY_LAST_MESSAGE = ""MercuryLastMessage"";
        /** Mercury last sequence key property name */
        public static final String MERCURY_SEQUENCE_KEY = ""MercurySequenceKey"";
        /** Mercury WS-RM specification version property name */
        public static final String MERCURY_SPEC_VERSION = ""MercuryRMSpecVersion"";

    //- Axis2 Message Context Properties used by Synapse -
    /** an axis2 message context property set to hold the relates to for POX responses */
    public static final String RELATES_TO_FOR_POX = ""synapse.RelatesToForPox"";

    /** an axis2 message context property set to indicate this is a response message for Synapse */
    public static final String ISRESPONSE_PROPERTY = ""synapse.isresponse"";


    //- tracing and statistics constants -
        /** Tracing logger name */
        public static final String TRACE_LOGGER =""TRACE_LOGGER"";
        public static final String SERVICE_LOGGER_PREFIX =""SERVICE_LOGGER."";

        /** The tracing state -off */
        public static final int TRACING_OFF =0;
        /** The tracing state-on */
        public static final int TRACING_ON =1;
        /** The tracing state-unset */
        public static final int TRACING_UNSET=2;

        /** The statistics state -off */
        public static final int STATISTICS_OFF =0;
        /** The statistics state-on */
        public static final int STATISTICS_ON =1;
        /** The statistics state-unset */
        public static final int STATISTICS_UNSET=2;

        /** key for lookup sequence statistics stack */
        public static final String SEQUENCE_STATS =""synapse.sequence.stats"";

        /** key for lookup Proxy Service statistics stack */
        public static final String PROXY_STATS =""synapse.proxy.stats"";

        /** key for lookup Proxy Service statistics stack */
        public static final String SERVICE_STATS =""synapse.service.stats"";

        /** key for lookup Endpoint statistics stack */
        public static final String ENDPOINT_STATS =""synapse.endpoint.stats"";

        /** Sequence statistics category*/
        public static final int  SEQUENCE_STATISTICS = 0;

        /** Proxy Service statistics category */
        public static final int  PROXYSERVICE_STATISTICS = 1;

        /** Endpoint statistics category*/
        public static final int ENDPOINT_STATISTICS = 2;

    //- handling of timed out events from the callbacks -
        /** The System property that states the duration at which the timeout handler runs */
        public static final String TIMEOUT_HANDLER_INTERVAL = ""synapse.timeout_handler_interval"";

        /**
         * Interval for activating the timeout handler for cleaning up expired requests. Note that
         * there can be an error as large as the value of the interval. But for smaller intervals
         * and larger timeouts this error is negligilble.
         */
        public static final long DEFAULT_TIMEOUT_HANDLER_INTERVAL = 15000;

        /**
         * This is a system wide interval for handling otherwise non-expiring callbacks to
         * ensure system stability over a period of time 
         */
        public static final String GLOBAL_TIMEOUT_INTERVAL = ""synapse.global_timeout_interval"";

        /**
         * this is the timeout for otherwise non-expiring callbacks
         * to ensure system stability over time
         */
        public static final long DEFAULT_GLOBAL_TIMEOUT = 24 * 60 * 60 * 1000;

        /**
         * don't do anything for response timeouts. this means infinite timeout. this is the default
         * action, if the timeout configuration is not explicitly set.
         */
        public static final int NONE = 100;

        /** Discard the callback if the timeout for the response is expired */
        public static final int DISCARD = 101;

        /**
         * Discard the callback and activate specified fault sequence if the timeout for the response
         * is expired
         */
        public static final int DISCARD_AND_FAULT = 102;

        /**
         * Error codes for message sending. We go with closest HTTP fault codes.
         */
        public static final String TIME_OUT = ""504"";
        public static final String SENDING_FAULT = ""503"";

    //- Endpoints processing constants -
    /** Property name to store the last endpoint through which the message has flowed */
    public static final String PROCESSED_ENDPOINT = ""processed_endpoint"";
    
    /** A name to use for anonymous endpoints */
    public static final String ANONYMOUS_ENDPOINT = ""AnonymousEndpoint"";

    /** A name to use for anonymous sequences in the sequence stack */
    public static final String ANONYMOUS_SEQUENCE = ""AnonymousSequence"";
    
    /** Message format values in EndpointDefinition. Used by address, wsdl endpoints */
    public static final String FORMAT_POX = ""pox"";
    public static final String FORMAT_GET = ""get"";
    public static final String FORMAT_SOAP11 = ""soap11"";
    public static final String FORMAT_SOAP12 = ""soap12"";    
    
    /** Synapse server instance name */
    public static final String SERVER_NAME = ""serverName"";

    public static final String SYNAPSE_DATASOURCES = ""synapse.datasources"";
    
    /** Root for relative path */
    public static final String RESOLVE_ROOT = ""resolve.root"";

    /* URL connection read timeout and connection timeout */

    public static final int DEFAULT_READTIMEOUT = 100000;

    public static final int DEFAULT_CONNECTTIMEOUT = 20000;

    public static final String READTIMEOUT = ""synapse.connection.read_timeout"";

    public static final String CONNECTTIMEOUT = ""synapse.connection.connect_timeout"";

    /** chunk size and chunk length configuration parameters */
    public static final int DEFAULT_THRESHOLD_CHUNKS = 8;

    public static final int DEFAULT_CHUNK_SIZE = 1024;

    public static final String DEFAULT_TEMPFILE_PREFIX = ""tmp_"";

    public static final String DEFAULT_TEMPFILE_SUFIX = "".dat"";

    public static final String THRESHOLD_CHUNKS = ""synapse.temp_data.chunk.threshold"";
    
    public static final String CHUNK_SIZE = ""synapse.temp_data.chunk.size"";

    public static final String TEMP_FILE_PREFIX = ""synapse.tempfile.prefix"";
    
    public static final String TEMP_FILE_SUFIX = ""synapse.tempfile.sufix"";

}
"
org/apache/synapse/Mediator.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse;

import org.apache.synapse.MessageContext;

/**
 * All Synapse mediators must implement this Mediator interface. As a message passes
 * through the Synapse system, each mediator's mediate() method is invoked in the
 * sequence/order defined in the SynapseConfiguration.
 */
public interface Mediator {

    /**
     * Invokes the mediator passing the current message for mediation. Each
     * mediator performs its mediation action, and returns true if mediation
     * should continue, or false if further mediation should be aborted.
     *
     * @param synCtx the current message for mediation
     * @return true if further mediation should continue
     */
    public boolean mediate(MessageContext synCtx);

    /**
     * This is used for debugging purposes and exposes the type of the current
     * mediator for logging and debugging purposes
     * @return a String representation of the mediator type
     */
    public String getType();

    /**
     * This is used to check whether the tracing should be enabled on the current mediator or not
     * @return value that indicate whether tracing is on, off or unset
     */
    public int getTraceState();

    /**
     * This is used to set the value of tracing enable variable
     * @param traceState Set whether the tracing is enabled or not
     */
    public void setTraceState(int traceState);
}
"
org/apache/synapse/statistics/StatisticsUtils.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
package org.apache.synapse.statistics;

import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.statistics.impl.SequenceStatisticsStack;
import org.apache.synapse.statistics.impl.EndPointStatisticsStack;
import org.apache.synapse.statistics.impl.ProxyServiceStatisticsStack;

/**
 * A utils to process statistics
 *
 */

public class StatisticsUtils {

    /**
     * To process statistics related to the proxy services
     *
     * @param synCtx
     */
    public static void processProxyServiceStatistics(MessageContext synCtx) {

        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        ProxyServiceStatisticsStack proxyServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(SynapseConstants.PROXY_STATS);
        if (proxyServiceStatisticsStack != null) {
            proxyServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
        ProxyServiceStatisticsStack synapseServiceStatisticsStack = (ProxyServiceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SERVICE_STATS);
        if (synapseServiceStatisticsStack != null) {
            synapseServiceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

    /**
     * To process statistics related to the End Points
     *
     * @param synCtx
     */
    public static void processEndPointStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        EndPointStatisticsStack endPointStatisticsStack = (EndPointStatisticsStack)
                synCtx.getProperty(SynapseConstants.ENDPOINT_STATS);
        if (endPointStatisticsStack != null) {
            Object endpointObj = synCtx.getProperty(SynapseConstants.PROCESSED_ENDPOINT);
            if (endpointObj instanceof Endpoint) {
                Endpoint endpoint = (Endpoint) endpointObj;
                String name = endpoint.getName();
                if (name == null) {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault);
                } else {
                    endPointStatisticsStack.reportToStatisticsCollector(
                            statisticsCollector, isFault, name);
                }
                endPointStatisticsStack.reportAllToStatisticsCollector(statisticsCollector, true);
            }
        }
    }

    /**
     * To process statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportToStatisticsCollector(statisticsCollector,isFault);
        }
    }

     /**
     * To process all statistics related to the sequence
     *
     * @param synCtx
     */
    public static void processAllSequenceStatistics(MessageContext synCtx) {
        StatisticsCollector statisticsCollector = getStatisticsCollector(synCtx);
        boolean isFault = synCtx.getEnvelope().getBody().hasFault();
        SequenceStatisticsStack sequenceStatisticsStack = (SequenceStatisticsStack)
                synCtx.getProperty(SynapseConstants.SEQUENCE_STATS);
        if (sequenceStatisticsStack != null) {
            sequenceStatisticsStack.reportAllToStatisticsCollector(statisticsCollector,isFault);
        }
    }
    /**
     * A helper method to get StatisticsCollector from the Synapse Message Context
     *
     * @param synCtx
     * @return StatisticsCollector
     */
    private static StatisticsCollector getStatisticsCollector(MessageContext synCtx) {
        SynapseEnvironment synEnv = synCtx.getEnvironment();
        StatisticsCollector statisticsCollector = null;
        if (synEnv != null) {
            statisticsCollector = synEnv.getStatisticsCollector();
            if (statisticsCollector == null) {
                statisticsCollector = new StatisticsCollector();
                synEnv.setStatisticsCollector(statisticsCollector);
            }
        }
        return statisticsCollector;
    }
}
"
org/apache/synapse/util/DataSourceRegistrar.java,true,"/*
*  Licensed to the Apache Software Foundation (ASF) under one
*  or more contributor license agreements.  See the NOTICE file
*  distributed with this work for additional information
*  regarding copyright ownership.  The ASF licenses this file
*  to you under the Apache License, Version 2.0 (the
*  ""License""); you may not use this file except in compliance
*  with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
package org.apache.synapse.util;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.pool.impl.GenericObjectPool;
import org.apache.commons.pool.impl.GenericKeyedObjectPool;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;

import javax.naming.*;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Properties;
import java.util.Hashtable;
import java.io.*;

/**
 * Utility class to handle data source registration
 */
public class DataSourceRegistrar {

    public static final Log log = LogFactory.getLog(DataSourceRegistrar.class);

    /**
     * The  static constants only for constructing key prefix for each property
     */
    private static final String PROP_ICFACTORY = ""icFactory"";
    private static final String PROP_PROVIDER_URL = ""providerUrl"";
    private static final String PROP_PROVIDER_PORT = ""providerPort"";
    private static final String DOT_STRING = ""."";
    private static final String PROP_USER_NAME = ""username"";
    private static final String PROP_PASSWORD = ""password"";
    private static final String PROP_DRIVER_CLS_NAME = ""driverClassName"";
    private static final String PROP_DSNAME = ""dsName"";
    private static final String PROP_URL = ""url"";
    private static final String PROP_DRIVER = ""driver"";
    private static final String PROP_USER = ""user"";

    private static final String PROP_CPDSADAPTER = ""cpdsadapter"";
    private static final String PROP_JNDI_ENV = ""jndiEnvironment"";
    private static final String PROP_DEFAULTMAXACTIVE = ""defaultMaxActive"";
    private static final String PROP_DEFAULTMAXIDLE = ""defaultMaxIdle"";
    private static final String PROP_DEFAULTMAXWAIT = ""defaultMaxWait"";
    private static final String PROP_DATA_SOURCE_NAME = ""dataSourceName"";

    private final static String PROP_DEFAULTAUTOCOMMIT = ""defaultAutoCommit"";
    private final static String PROP_DEFAULTREADONLY = ""defaultReadOnly"";
    private final static String PROP_TESTONBORROW = ""testOnBorrow"";
    private final static String PROP_TESTONRETURN = ""testOnReturn"";
    private final static String PROP_TIMEBETWEENEVICTIONRUNSMILLIS =
            ""timeBetweenEvictionRunsMillis"";
    private final static String PROP_NUMTESTSPEREVICTIONRUN = ""numTestsPerEvictionRun"";
    private final static String PROP_MINEVICTABLEIDLETIMEMILLIS = ""minEvictableIdleTimeMillis"";
    private final static String PROP_TESTWHILEIDLE = ""testWhileIdle"";
    private final static String PROP_VALIDATIONQUERY = ""validationQuery"";
    private final static String PROP_MAXACTIVE = ""maxActive"";
    private final static String PROP_MAXIDLE = ""maxIdle"";
    private final static String PROP_MAXWAIT = ""maxWait"";

    private final static String PROP_MINIDLE = ""minIdle"";
    private final static String PROP_INITIALSIZE = ""initialSize"";
    private final static String PROP_DEFAULTTRANSACTIONISOLATION = ""defaultTransactionIsolation"";
    private final static String PROP_DEFAULTCATALOG = ""defaultCatalog"";
    private final static String PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED =
            ""accessToUnderlyingConnectionAllowed"";
    private final static String PROP_REMOVEABANDONED = ""removeAbandoned"";
    private final static String PROP_REMOVEABANDONEDTIMEOUT = ""removeAbandonedTimeout"";
    private final static String PROP_LOGABANDONED = ""logAbandoned"";
    private final static String PROP_POOLPREPAREDSTATEMENTS = ""poolPreparedStatements"";
    private final static String PROP_MAXOPENPREPAREDSTATEMENTS = ""maxOpenPreparedStatements"";
    private final static String PROP_CONNECTIONPROPERTIES = ""connectionProperties"";

    /**
     * Register data sources in the JNDI context
     * Given properties should contains all the properties need for construct JNDI naming references
     *
     * @param dsProperties The source properties
     */
    public static void registerDataSources(Properties dsProperties) {

        if (dsProperties == null) {
            if (log.isDebugEnabled()) {
                log.debug(""DataSource properties cannot be found.."");
            }
            return;
        }

        String dataSources = getProperty(dsProperties,
                SynapseConstants.SYNAPSE_DATASOURCES, null);

        if (dataSources == null || """".equals(dataSources)) {
            if (log.isDebugEnabled()) {
                log.debug(""No DataSources defined for initialization.."");
            }
            return;
        }

        String[] dataSourcesNames = dataSources.split("","");
        if (dataSourcesNames == null || dataSourcesNames.length == 0) {
            if (log.isDebugEnabled()) {
                log.debug(""No DataSource definitions found for initialization.."");
            }
            return;
        }

        StringBuffer buffer = new StringBuffer();
        buffer.append(SynapseConstants.SYNAPSE_DATASOURCES);
        buffer.append(DOT_STRING);
        // The prefix for root level properties
        String rootPrefix = buffer.toString();

        // setting naming provider
        Hashtable props = new Hashtable();
        Properties jndiEvn = new Properties();  //This is needed for PerUserPoolDatasource

        String namingFactory = getProperty(dsProperties, rootPrefix + PROP_ICFACTORY,
                ""com.sun.jndi.rmi.registry.RegistryContextFactory"");

        props.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);
        jndiEvn.put(Context.INITIAL_CONTEXT_FACTORY, namingFactory);

        String providerHost = ""localhost"";
        try {
            InetAddress addr = InetAddress.getLocalHost();
            if (addr != null) {
                String hostname = addr.getHostName();
                if (hostname == null) {
                    String ipAddr = addr.getHostAddress();
                    if (ipAddr != null) {
                        providerHost = ipAddr;
                    }
                } else {
                    providerHost = hostname;
                }
            }
        } catch (UnknownHostException e) {
            log.warn(""Unable to determine hostname or IP address.. Using localhost"", e);
        }

        // default port for RMI registry
        int port = 2199;
        String providerPort =
                getProperty(dsProperties, rootPrefix + PROP_PROVIDER_PORT, String.valueOf(port));
        try {
            port = Integer.parseInt(providerPort);
        } catch (NumberFormatException ignored) {
        }

        // Create a RMI local registry
        RMIRegistryController.getInstance().createLocalRegistry(port);

        String providerUrl = getProperty(dsProperties, rootPrefix + PROP_PROVIDER_URL,
                ""rmi://"" + providerHost + "":"" + providerPort);

        props.put(Context.PROVIDER_URL, providerUrl);
        jndiEvn.put(Context.PROVIDER_URL, providerUrl);

        log.info(""DataSources will be registered in the JNDI context with provider PROP_URL : "" +
                providerUrl);

        try {
            InitialContext initialContext = new InitialContext(props);
            //Registering data sources with the initial context
            for (int i = 0; i < dataSourcesNames.length; i++) {
                registerDataSource(dataSourcesNames[i], dsProperties, initialContext, jndiEvn);
            }

        } catch (NamingException e) {
            String msg = ""Error constructing an InitialContext to register DataSources"";
            handleException(msg, e);
        }
    }

    /**
     * Helper method to register a single data source .The given data source name is used ,
     * if there is no property with name dsName ,when,data source is binding to the initial context,
     *
     * @param dsName         The name of the data source
     * @param dsProperties   The property bag
     * @param initialContext The initial context instance
     * @param jndiEnv        The JNDI environment properties
     */
    private static void registerDataSource(String dsName, Properties dsProperties, InitialContext initialContext, Properties jndiEnv) {

        if (dsName == null || """".equals(dsName)) {
            if (log.isDebugEnabled()) {
                log.debug(""DataSource name is either empty or null, ignoring.."");
            }
            return;
        }

        StringBuffer buffer = new StringBuffer();
        buffer.append(SynapseConstants.SYNAPSE_DATASOURCES);
        buffer.append(DOT_STRING);
        buffer.append(dsName);
        buffer.append(DOT_STRING);

        // Prefix for getting particular data source's properties
        String prefix = buffer.toString();

        String driver = getProperty(dsProperties, prefix + PROP_DRIVER_CLS_NAME, null);
        if (driver == null) {
            handleException(prefix + PROP_DRIVER_CLS_NAME + "" cannot be found."");
        }

        String url = getProperty(dsProperties, prefix + PROP_URL, null);
        if (url == null) {
            handleException(prefix + PROP_URL + "" cannot be found."");
        }

        // get other required properties
        String user = getProperty(dsProperties, prefix + PROP_USER_NAME, ""synapse"");
        String password = getProperty(dsProperties, prefix + PROP_PASSWORD, ""synapse"");
        String dataSourceName = getProperty(dsProperties, prefix + PROP_DSNAME, dsName);

        //populates context tree
        populateContextTree(initialContext, dataSourceName);

        String dsType = getProperty(dsProperties, prefix + ""type"", ""BasicDataSource"");

        String maxActive = getProperty(dsProperties, prefix + PROP_MAXACTIVE,
                String.valueOf(GenericObjectPool.DEFAULT_MAX_ACTIVE));
        String maxIdle = getProperty(dsProperties, prefix + PROP_MAXIDLE,
                String.valueOf(GenericObjectPool.DEFAULT_MAX_IDLE));
        String maxWait = getProperty(dsProperties, prefix + PROP_MAXWAIT,
                String.valueOf(GenericObjectPool.DEFAULT_MAX_WAIT));

        if (""BasicDataSource"".equals(dsType)) {

            Reference ref = new Reference(""javax.sql.DataSource"",
                    ""org.apache.commons.dbcp.BasicDataSourceFactory"", null);

            ref.add(new StringRefAddr(PROP_DRIVER_CLS_NAME, driver));
            ref.add(new StringRefAddr(PROP_URL, url));
            ref.add(new StringRefAddr(PROP_USER_NAME, user));
            ref.add(new StringRefAddr(PROP_PASSWORD, password));
            ref.add(new StringRefAddr(PROP_MAXACTIVE, maxActive));
            ref.add(new StringRefAddr(PROP_MAXIDLE, maxIdle));
            ref.add(new StringRefAddr(PROP_MAXWAIT, maxWait));

            //set BasicDataSource specific parameters
            setBasicDataSourceParameters(ref, dsProperties, prefix);
            //set default properties for reference
            setCommonParameters(ref, dsProperties, prefix);

            try {
                initialContext.rebind(dataSourceName, ref);
            } catch (NamingException e) {
                String msg = "" Error binding name ' "" + dataSourceName + "" ' to "" +
                        ""the DataSource(BasicDataSource) reference"";
                handleException(msg, e);
            }

        } else if (""PerUserPoolDataSource"".equals(dsType)) {

            // Construct DriverAdapterCPDS reference
            String className = getProperty(dsProperties, prefix + PROP_CPDSADAPTER +
                    DOT_STRING + ""className"",
                    ""org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS"");
            String factory = getProperty(dsProperties, prefix + PROP_CPDSADAPTER +
                    DOT_STRING + ""factory"",
                    ""org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS"");
            String name = getProperty(dsProperties, prefix + PROP_CPDSADAPTER +
                    DOT_STRING + ""name"",
                    ""cpds"");

            Reference cpdsRef =
                    new Reference(className, factory, null);

            cpdsRef.add(new StringRefAddr(PROP_DRIVER, driver));
            cpdsRef.add(new StringRefAddr(PROP_URL, url));
            cpdsRef.add(new StringRefAddr(PROP_USER, user));
            cpdsRef.add(new StringRefAddr(PROP_PASSWORD, password));

            try {
                initialContext.rebind(name, cpdsRef);
            } catch (NamingException e) {
                String msg = ""Error binding name '"" + name + ""' to "" +
                        ""the DriverAdapterCPDS reference"";
                handleException(msg, e);
            }

            // Construct PerUserPoolDataSource reference
            Reference ref =
                    new Reference(""org.apache.commons.dbcp.datasources.PerUserPoolDataSource"",
                            ""org.apache.commons.dbcp.datasources.PerUserPoolDataSourceFactory"", null);

            ref.add(new BinaryRefAddr(PROP_JNDI_ENV, serialize(jndiEnv)));
            ref.add(new StringRefAddr(PROP_DATA_SOURCE_NAME, name));
            ref.add(new StringRefAddr(PROP_DEFAULTMAXACTIVE, maxActive));
            ref.add(new StringRefAddr(PROP_DEFAULTMAXIDLE, maxIdle));
            ref.add(new StringRefAddr(PROP_DEFAULTMAXWAIT, maxWait));

            //set default properties for reference
            setCommonParameters(ref, dsProperties, prefix);

            try {
                initialContext.rebind(dataSourceName, ref);
            } catch (NamingException e) {
                String msg = ""Error binding name ' "" + dataSourceName + "" ' to "" +
                        ""the PerUserPoolDataSource reference"";
                handleException(msg, e);
            }

        } else {
            handleException(""Unsupported data source type : "" + dsType);
        }
    }

    /**
     * Helper method to serialize object into a byte array
     *
     * @param data The object to be serialized
     * @return The byte array representation of the provided object
     */
    private static byte[] serialize(Object data) {

        ObjectOutputStream outputStream = null;
        ByteArrayOutputStream binOut = null;
        byte[] result = null;
        try {
            binOut = new ByteArrayOutputStream();
            outputStream = new ObjectOutputStream(binOut);
            outputStream.writeObject(data);
            result = binOut.toByteArray();
        } catch (IOException e) {
            handleException(""Error serializing object :"" + data);
        } finally {
            if (binOut != null) {
                try {
                    binOut.close();
                } catch (IOException ex) {
                }
            }
            if (outputStream != null) {
                try {
                    outputStream.close();
                } catch (IOException ex) {
                }
            }
        }
        return result;
    }

    /**
     * Helper method to set all default parameter for naming reference of data source
     *
     * @param reference  The naming reference instance
     * @param properties The properties which contains required parameter value
     * @param prefix     The key prefix for which is used to get data from given properties
     */
    private static void setCommonParameters(Reference reference, Properties properties, String prefix) {
        String defaultAutoCommit = getProperty(properties,
                prefix + PROP_DEFAULTAUTOCOMMIT, String.valueOf(true));
        String defaultReadOnly = getProperty(properties,
                prefix + PROP_DEFAULTREADONLY, String.valueOf(false));
        String testOnBorrow = getProperty(properties,
                prefix + PROP_TESTONBORROW, String.valueOf(true));
        String testOnReturn = getProperty(properties,
                prefix + PROP_TESTONRETURN, String.valueOf(false));
        String timeBetweenEvictionRunsMillis = getProperty(properties,
                prefix + PROP_TIMEBETWEENEVICTIONRUNSMILLIS,
                String.valueOf(GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS));
        String numTestsPerEvictionRun = getProperty(properties,
                prefix + PROP_NUMTESTSPEREVICTIONRUN,
                String.valueOf(GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN));
        String minEvictableIdleTimeMillis = getProperty(properties,
                prefix + PROP_MINEVICTABLEIDLETIMEMILLIS,
                String.valueOf(GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS));
        String testWhileIdle = getProperty(properties,
                prefix + PROP_TESTWHILEIDLE, String.valueOf(false));
        String validationQuery = getProperty(properties,
                prefix + PROP_VALIDATIONQUERY, null);

        reference.add(new StringRefAddr(PROP_DEFAULTAUTOCOMMIT, defaultAutoCommit));
        reference.add(new StringRefAddr(PROP_DEFAULTREADONLY, defaultReadOnly));
        reference.add(new StringRefAddr(PROP_TESTONBORROW, testOnBorrow));
        reference.add(new StringRefAddr(PROP_TESTONRETURN, testOnReturn));
        reference.add(new StringRefAddr(PROP_TIMEBETWEENEVICTIONRUNSMILLIS,
                timeBetweenEvictionRunsMillis));
        reference.add(new StringRefAddr(PROP_NUMTESTSPEREVICTIONRUN, numTestsPerEvictionRun));
        reference.add(new StringRefAddr(PROP_MINEVICTABLEIDLETIMEMILLIS,
                minEvictableIdleTimeMillis));
        reference.add(new StringRefAddr(PROP_TESTWHILEIDLE, testWhileIdle));
        if (validationQuery != null && !"""".equals(validationQuery)) {
            reference.add(new StringRefAddr(PROP_VALIDATIONQUERY, validationQuery));
        }
    }

    /**
     * Helper method to set all BasicDataSource specific parameter
     *
     * @param reference  The naming reference instance
     * @param properties The properties which contains required parameter value
     * @param prefix     The key prefix for which is used to get data from given properties
     */
    private static void setBasicDataSourceParameters(Reference reference, Properties properties, String prefix) {
        String minIdle = getProperty(properties,
                prefix + PROP_MINIDLE, String.valueOf(GenericObjectPool.DEFAULT_MIN_IDLE));
        String initialSize = getProperty(properties, prefix + PROP_INITIALSIZE, String.valueOf(0));
        String defaultTransactionIsolation = getProperty(properties,
                prefix + PROP_DEFAULTTRANSACTIONISOLATION, null);
        String defaultCatalog = getProperty(properties, prefix + PROP_DEFAULTCATALOG, null);
        String accessToUnderlyingConnectionAllowed = getProperty(properties,
                prefix + PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED, String.valueOf(false));
        String removeAbandoned = getProperty(properties,
                prefix + PROP_REMOVEABANDONED, String.valueOf(false));
        String removeAbandonedTimeout = getProperty(properties,
                prefix + PROP_REMOVEABANDONEDTIMEOUT, String.valueOf(300));
        String logAbandoned = getProperty(properties,
                prefix + PROP_LOGABANDONED, String.valueOf(false));
        String poolPreparedStatements = getProperty(properties,
                prefix + PROP_POOLPREPAREDSTATEMENTS, String.valueOf(false));
        String maxOpenPreparedStatements = getProperty(properties,
                prefix + PROP_MAXOPENPREPAREDSTATEMENTS,
                String.valueOf(GenericKeyedObjectPool.DEFAULT_MAX_TOTAL));

        reference.add(new StringRefAddr(PROP_MINIDLE, minIdle));
        if (defaultTransactionIsolation != null && !"""".equals(defaultTransactionIsolation)) {
            reference.add(new StringRefAddr(PROP_DEFAULTTRANSACTIONISOLATION,
                    defaultTransactionIsolation));
        }
        reference.add(new StringRefAddr(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED,
                accessToUnderlyingConnectionAllowed));
        reference.add(new StringRefAddr(PROP_REMOVEABANDONED, removeAbandoned));
        reference.add(new StringRefAddr(PROP_REMOVEABANDONEDTIMEOUT, removeAbandonedTimeout));
        reference.add(new StringRefAddr(PROP_LOGABANDONED, logAbandoned));
        reference.add(new StringRefAddr(PROP_POOLPREPAREDSTATEMENTS, poolPreparedStatements));
        reference.add(new StringRefAddr(PROP_MAXOPENPREPAREDSTATEMENTS,
                maxOpenPreparedStatements));
        reference.add(new StringRefAddr(PROP_INITIALSIZE, initialSize));
        if (defaultCatalog != null && !"""".equals(defaultCatalog)) {
            reference.add(new StringRefAddr(PROP_DEFAULTCATALOG, defaultCatalog));
        }
    }

    /**
     * Helper method to create context tree for a given path
     *
     * @param initialContext The root context
     * @param path           The path of the resource
     */
    private static void populateContextTree(InitialContext initialContext, String path) {

        String[] paths = path.split(""/"");
        if (paths != null && paths.length > 1) {

            Context context = initialContext;
            for (int i = 0; i < paths.length; i++) {

                try {
                    context = context.createSubcontext(paths[i]);
                    if (context == null) {
                        handleException(""sub context "" + paths[i] + "" could not be created"");
                    }

                } catch (NamingException e) {
                    handleException(""Unable to create sub context : "" + paths[i], e);
                }
            }
        }
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     */
    private static void handleException(String msg) {
        log.error(msg);
        throw new SynapseException(msg);
    }

    /**
     * Helper methods for handle errors.
     *
     * @param msg The error message
     * @param e   The exception
     */
    private static void handleException(String msg, Exception e) {
        log.error(msg, e);
        throw new SynapseException(msg, e);
    }

    /**
     * Helper method to get the value of the property from a given property bag
     *
     * @param dsProperties The property collection
     * @param name         The name of the property
     * @param def          The default value for the property
     * @return The value of the property if it is found , otherwise , default value
     */
    private static String getProperty(Properties dsProperties, String name, String def) {

        String result = dsProperties.getProperty(name);
        if ((result == null || result.length() == 0 || """".equals(result)) && def != null) {
            if (log.isDebugEnabled()) {
                log.debug(""The name with ' "" + name + "" ' cannot be found. "" +
                        ""Using default value "" + def);
            }
            result = def;
        }
        if (result != null) {
            return result.trim();
        } else {
            return def;
        }
    }
}
"
org/apache/synapse/config/xml/FaultMediatorFactory.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMAttribute;
import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.SynapseException;
import org.apache.synapse.mediators.transform.FaultMediator;
import org.jaxen.JaxenException;

import javax.xml.namespace.QName;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Factory for {@link FaultMediator} instances.
 * <p>
 * Configuration syntax:
 * <pre>
 * &lt;makefault [version=""soap11|soap12|pox""]&gt;
 *   &lt;code (value=""literal"" | expression=""xpath"")/&gt;?
 *   &lt;reason (value=""literal"" | expression=""xpath"")&gt;?
 *   &lt;node&gt;?
 *   &lt;role&gt;?
 *   &lt;detail&gt;?
 * &lt;/makefault&gt;
 * </pre>
 */
public class FaultMediatorFactory extends AbstractMediatorFactory  {

    private static final QName FAULT_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""makefault"");

    private static final QName ATT_VERSION_Q
            = new QName(XMLConfigConstants.NULL_NAMESPACE, ""version"");
    private static final QName CODE_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""code"");
    private static final QName REASON_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""reason"");
    private static final QName NODE_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""node"");
    private static final QName ROLE_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""role"");
    private static final QName DETAIL_Q
            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, ""detail"");

    private static final String SOAP11 = ""soap11"";
    private static final String SOAP12 = ""soap12"";
    private static final String POX = ""pox"";

    public Mediator createMediator(OMElement elem) {

        FaultMediator faultMediator = new FaultMediator();

        OMAttribute version = elem.getAttribute(ATT_VERSION_Q);
        if (version != null) {
            if (SOAP11.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP11);
            } else if (SOAP12.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.SOAP12);
            } else if (POX.equals(version.getAttributeValue())) {
                faultMediator.setSoapVersion(FaultMediator.POX);
            } else {
                handleException(""Invalid SOAP version"");
            }
        }

        OMElement code = elem.getFirstChildWithName(CODE_Q);
        if (code != null) {
            OMAttribute value = code.getAttribute(ATT_VALUE);
            OMAttribute expression = code.getAttribute(ATT_EXPRN);

            if (value != null) {
                String strValue = value.getAttributeValue();
                String prefix = null;
                String name = null;
                if (strValue.indexOf("":"") != -1) {
                    prefix = strValue.substring(0, strValue.indexOf("":""));
                    name = strValue.substring(strValue.indexOf("":"")+1);
                } else {
                    handleException(""A QName is expected for fault code as prefix:name"");
                }
                String namespaceURI = OMElementUtils.getNameSpaceWithPrefix(prefix, code);
                if (namespaceURI == null) {
                    handleException(""Invalid namespace prefix '"" + prefix + ""' in code attribute"");
                }
                faultMediator.setFaultCodeValue(new QName(namespaceURI, name, prefix));
            } else if (expression != null) {
                try {
                    faultMediator.setFaultCodeExpr(
                        SynapseXPathFactory.getSynapseXPath(code, ATT_EXPRN));
                } catch (JaxenException je) {
                    handleException(""Invalid fault code expression : "" + je.getMessage(), je);
                }
            } else {
                handleException(""A 'value' or 'expression' attribute must specify the fault code"");
            }

        } else if (faultMediator.getSoapVersion() != FaultMediator.POX) {
            handleException(""The fault code is a required attribute for the "" +
                    ""makefault mediator unless it is a pox fault"");
        }

        OMElement reason = elem.getFirstChildWithName(REASON_Q);
        if (reason != null) {
            OMAttribute value = reason.getAttribute(ATT_VALUE);
            OMAttribute expression = reason.getAttribute(ATT_EXPRN);

            if (value != null) {
                faultMediator.setFaultReasonValue(value.getAttributeValue());
            } else if (expression != null) {
                try {
                    faultMediator.setFaultReasonExpr(
                        SynapseXPathFactory.getSynapseXPath(reason, ATT_EXPRN));
                } catch (JaxenException je) {
                    handleException(""Invalid fault reason expression : "" + je.getMessage(), je);
                }
            } else {
                handleException(""A 'value' or 'expression' attribute must specify the fault code"");
            }

        } else if (faultMediator.getSoapVersion() != FaultMediator.POX) {
            handleException(""The fault reason is a required attribute for the "" +
                    ""makefault mediator unless it is a pox fault"");
        }

        // after successfully creating the mediator
        // set its common attributes such as tracing etc
        processTraceState(faultMediator,elem);

        OMElement node = elem.getFirstChildWithName(NODE_Q);
        if (node != null && node.getText() != null) {
            try {
                faultMediator.setFaultNode(new URI(node.getText()));
            } catch (URISyntaxException e) {
                handleException(""Invalid URI specified for fault node : "" + node.getText(), e);
            }
        }

        OMElement role = elem.getFirstChildWithName(ROLE_Q);
        if (role != null && role.getText() != null) {
            try {
                faultMediator.setFaultRole(new URI(role.getText()));
            } catch (URISyntaxException e) {
                handleException(""Invalid URI specified for fault role : "" + role.getText(), e);
            }
        }

        OMElement detail = elem.getFirstChildWithName(DETAIL_Q);
        if (detail != null) {
            OMAttribute detailExpr = detail.getAttribute(ATT_EXPRN);
            if (detailExpr != null && detailExpr.getAttributeValue() != null) {
                try {
                    faultMediator.setFaultDetailExpr(
                            SynapseXPathFactory.getSynapseXPath(detail, ATT_EXPRN));
                } catch (JaxenException e) {
                    handleException(""Unable to build the XPath for fault detail "" +
                            ""from the expression : "" + detailExpr.getAttributeValue(), e);
                }
            } else if (detail.getText() != null) {
                faultMediator.setFaultDetail(detail.getText());
            }
        }

        return faultMediator;
    }

    public QName getTagQName() {
        return FAULT_Q;
    }
}
"
org/apache/synapse/mediators/eip/EIPConstants.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.eip;

/** Constants related to the EIP mediators */
public final class EIPConstants {

    /** Typically the message ID of the parent message in a split/iterate etc so that
     * its children could be uniquely aggregated by the aggrgate mediator etc
     */
    public static final String AGGREGATE_CORRELATION = ""aggregateCorelation"";

    /** Constant for the message sequence property key */
    public static final String MESSAGE_SEQUENCE = ""messageSequence"";

    /** Delimiter for the message sequence value */
    public static final String MESSAGE_SEQUENCE_DELEMITER = ""/"";
}
"
org/apache/synapse/mediators/filters/OutMediator.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.mediators.filters;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.MessageContext;
import org.apache.synapse.mediators.AbstractListMediator;

/**
 * The Out Mediator acts only on ""outgoing"" messages from synapse. This is
 * performed by looking at the result of MessageContext#isResponse()
 *
 * @see org.apache.synapse.MessageContext#isResponse()
 */
public class OutMediator extends AbstractListMediator implements org.apache.synapse.mediators.FilterMediator {

    /**
     * Executes the list of sub/child mediators, if the filter condition is satisfied
     *
     * @param synCtx the current message
     * @return true if filter condition fails. else returns as per List mediator semantics
     */
    public boolean mediate(MessageContext synCtx) {
        
        boolean traceOn = isTraceOn(synCtx);
        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""Start : Out mediator"");

            if (traceOn && trace.isTraceEnabled()) {
                trace.trace(""Message : "" + synCtx.getEnvelope());
            }
        }

        boolean result = true;
        if (test(synCtx)) {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is outgoing - executing child mediators"");
            }
            result = super.mediate(synCtx);

        } else {
            if (traceOrDebugOn) {
                traceOrDebug(traceOn, ""Current message is a request - skipping child mediators"");
            }
        }

        if (traceOrDebugOn) {
            traceOrDebug(traceOn, ""End : Out mediator"");
        }

        return result;
    }

    /**
     * Apply mediation only on response messages
     *
     * @param synCtx the message context
     * @return MessageContext#isResponse()
     */
    public boolean test(MessageContext synCtx) {
        return synCtx.isResponse();
    }
}
"
org/apache/synapse/startup/tasks/MessageInjector.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.startup.tasks;

import org.apache.axiom.om.OMElement;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.ManagedLifecycle;
import org.apache.synapse.MessageContext;
import org.apache.synapse.core.SynapseEnvironment;
import org.apache.synapse.startup.Task;
import org.apache.synapse.util.PayloadHelper;

/**
 * Injects a Message in to the Synapse environment
 */
public class MessageInjector implements Task, ManagedLifecycle {

    /**
     * Holds the logger for logging purposes
     */
    private Log log = LogFactory.getLog(MessageInjector.class);

    /**
     * Holds the Message to be injected
     */
    private OMElement message = null;

    /**
     * Holds the to address for the message to be injected
     */
    private String to = null;

    private String soapAction = null;

    /**
     * Holds the SynapseEnv to which the message will be injected
     */
    private SynapseEnvironment synapseEnvironment;

    /**
     * Initializes the Injector
     *
     * @param se
     *          SynapseEnvironment of synapse
     */
    public void init(SynapseEnvironment se) {
		synapseEnvironment = se;
	}

    /**
     * Set the message to be injected
     *
     * @param elem
     *          OMElement describing the message
     */
    public void setMessage(OMElement elem) {
		log.debug(""set message "" + elem.toString());
		message = elem;
	}

    /**
     * Set the to address of the message to be injected
     *
     * @param url
     *          String containing the to address
     */
    public void setTo(String url) {
		to = url;
	}

    public void setSoapAction(String soapAction) {
        this.soapAction = soapAction;
    }

    /**
     * This will be invoked by the schedular to inject the message
     * in to the SynapseEnvironment
     */
    public void execute() {
		log.debug(""execute"");
		if (synapseEnvironment == null) {
			log.error(""Synapse Environment not set"");
			return;
		}
		if (message == null) {
			log.error(""message not set"");
			return;

		}
		if (to == null) {
			log.error(""to address not set"");
			return;

		}
        MessageContext mc = synapseEnvironment.createMessageContext();
        mc.setTo(new EndpointReference(to));
        PayloadHelper.setXMLPayload(mc, message.cloneOMElement());
        if (soapAction != null) {
            mc.setSoapAction(soapAction);
        }
        synapseEnvironment.injectMessage(mc);

	}

    /**
     * Destroys the Injector
     */
    public void destroy() {
	}

}
"
org/apache/synapse/config/xml/RMSequenceMediatorSerializer.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml;

import org.apache.axiom.om.OMElement;
import org.apache.synapse.Mediator;
import org.apache.synapse.mediators.builtin.RMSequenceMediator;

/**
 * Serializer for {@link RMSequenceMediator} instances.
 * 
 * @see RMSequenceMediatorFactory
 */
public class RMSequenceMediatorSerializer extends AbstractMediatorSerializer {

    public OMElement serializeMediator(OMElement parent, Mediator m) {

        if (!(m instanceof RMSequenceMediator)) {
            handleException(""Unsupported mediator passed in for serialization : "" + m.getType());
        }

        RMSequenceMediator mediator = (RMSequenceMediator) m;
        OMElement sequence = fac.createOMElement(""RMSequence"", synNS);
        saveTracingState(sequence, mediator);
        
        if(mediator.isSingle() && mediator.getCorrelation() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a correlation attribute specified."");
        }
        if(mediator.isSingle() && mediator.getLastMessage() != null) {
            handleException(""Invalid RMSequence mediator. A RMSequence can't have both a "" 
                    + ""single attribute value of true and a last-message attribute specified."");
        }
        
        if (mediator.isSingle()) {
            sequence.addAttribute(fac.createOMAttribute(""single"", nullNS, String.valueOf(mediator.isSingle())));
        } else if (mediator.getCorrelation() != null) {
            SynapseXPathSerializer.serializeXPath(
                mediator.getCorrelation(), sequence, ""correlation"");
        } else {
            handleException(""Invalid RMSequence mediator. Specify a single message sequence "" 
                    + ""or a correlation attribute."");
        }
        
        if (mediator.getLastMessage() != null) {
            SynapseXPathSerializer.serializeXPath(
                mediator.getLastMessage(), sequence, ""last-message"");
        }
        
        if (mediator.getVersion() != null) {
            sequence.addAttribute(fac.createOMAttribute(""version"", nullNS, mediator.getVersion()));
        }

        if (parent != null) {
            parent.addChild(sequence);
        }
        return sequence;
    }

    public String getMediatorClassName() {
        return RMSequenceMediator.class.getName();
    }
}
"
org/apache/synapse/config/SynapseConfigUtils.java,true,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config;

import org.apache.axiom.om.*;
import org.apache.axiom.om.impl.builder.StAXOMBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.synapse.SynapseConstants;
import org.apache.synapse.SynapseException;
import org.apache.synapse.ServerManager;
import org.apache.synapse.util.SynapseBinaryDataSource;
import org.xml.sax.InputSource;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.stream.StreamSource;
import javax.activation.DataHandler;
import java.io.*;
import java.net.*;

public class SynapseConfigUtils {

    private static final Log log = LogFactory.getLog(SynapseConfigUtils.class);

    /**
     * Return a StreamSource for the given Object
     *
     * @param o the object
     * @return the StreamSource
     */
    public static StreamSource getStreamSource(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMElement) {
            OMElement omElement = (OMElement) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omElement.serialize(baos);
                return new StreamSource(new ByteArrayInputStream(baos.toByteArray()));
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else if (o instanceof OMText) {
            DataHandler dataHandler = (DataHandler) ((OMText) o).getDataHandler();
            if (dataHandler != null) {
                try {
                    return new StreamSource(dataHandler.getInputStream());
                } catch (IOException e) {
                    handleException(""Error in reading content as a stream "");
                }
            }
        } else {

            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    public static InputStream getInputStream(Object o) {

        if (o == null) {
            handleException(""Cannot convert null to a StreamSource"");

        } else if (o instanceof OMElement) {
            OMElement omElement = (OMElement) o;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try {
                omElement.serialize(baos);
                return new ByteArrayInputStream(baos.toByteArray());
            } catch (XMLStreamException e) {
                handleException(""Error converting to a StreamSource"", e);
            }

        } else if (o instanceof OMText) {
            DataHandler dataHandler = (DataHandler) ((OMText) o).getDataHandler();
            if (dataHandler != null) {
                try {
                    return dataHandler.getInputStream();
                } catch (IOException e) {
                    handleException(""Error in reading content as a stream "");
                }
            }
        } else if (o instanceof URI) {
            try {
                return ((URI) (o)).toURL().openStream();
            } catch (IOException e) {
                handleException(""Error opening stream form URI"", e);
            }
        } else {
            handleException(""Cannot convert object to a StreamSource"");
        }
        return null;
    }

    /**
     * Get an object from a given URL. Will first fetch the content from the
     * URL and depending on the content-type, a suitable XMLToObjectMapper
     * (if available) would be used to transform this content into an Object.
     * If a suitable XMLToObjectMapper cannot be found, the content would be
     * treated as XML and an OMNode would be returned
     *
     * @param url the URL to the resource
     * @return an Object created from the given URL
     */
    public static Object getObject(URL url) {
        try {
            if (url != null && ""file"".equals(url.getProtocol())) {
                try {
                    url.openStream();
                } catch (IOException ignored) {
                    String path = url.getPath();
                    if (log.isDebugEnabled()) {
                        log.debug(""Can not open a connection to the URL with a path :"" +
                                path);
                    }
                    String synapseHome = ServerManager.getInstance().getSynapseHome();
                    if (synapseHome != null) {
                        if (log.isDebugEnabled()) {
                            log.debug(""Trying  to resolve an absolute path of the "" +
                                    "" URL using the synapse.home : "" + synapseHome);
                        }
                        if (synapseHome.endsWith(""/"")) {
                            synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
                        }
                        url = new URL(url.getProtocol() + "":"" + synapseHome + ""/"" + path);
                        try {
                            url.openStream();
                        } catch (IOException e) {
                            if (log.isDebugEnabled()) {
                                log.debug(""Faild to resolve an absolute path of the "" +
                                        "" URL using the synapse.home : "" + synapseHome);
                            }
                            log.warn(""IO Error reading from URL "" + url.getPath() + e);
                        }
                    }
                }
            }
            if (url == null) {
                return null;
            }
            URLConnection urlc = url.openConnection();
            XMLToObjectMapper xmlToObject =
                    getXmlToObjectMapper(urlc.getContentType());
            InputStream inputStream = urlc.getInputStream();
            try {
                XMLStreamReader parser = XMLInputFactory.newInstance().
                        createXMLStreamReader(inputStream);
                StAXOMBuilder builder = new StAXOMBuilder(parser);
                OMElement omElem = builder.getDocumentElement();

                // detach from URL connection and keep in memory
                // TODO remove this 
                omElem.build();

                if (xmlToObject != null) {
                    return xmlToObject.getObjectFromOMNode(omElem);
                } else {
                    return omElem;
                }

            } catch (XMLStreamException e) {
                if (log.isDebugEnabled()) {
                    log.debug(""Content at URL : "" + url + "" is non XML.."");
                }
                return readNonXML(url);
            } catch (OMException e) {
                if (log.isDebugEnabled()) {
                    log.debug(""Content at URL : "" + url + "" is non XML.."");
                }
                return readNonXML(url);
            } finally {
                inputStream.close();
            }

        } catch (IOException e) {
            handleException(""Error connecting to URL : "" + url, e);
        }
        return null;
    }

    /**
     * Helper method to handle non-XMl resources
     *
     * @param url The resource url
     * @return The content as an OMNode
     */
    public static OMNode readNonXML(URL url) {

        try {
            // Open a new connection
            URLConnection newConnection = url.openConnection();

            BufferedInputStream newInputStream = new BufferedInputStream(
                    newConnection.getInputStream());

            OMFactory omFactory = OMAbstractFactory.getOMFactory();
            return omFactory.createOMText(
                    new DataHandler(new SynapseBinaryDataSource(newInputStream,
                            newConnection.getContentType())), true);

        } catch (IOException e) {
            handleException(""Error when getting a stream from resource's content"", e);
        }
        return null;
    }

    /**
     * Return an OMElement from a URL source
     *
     * @param urlStr a URL string
     * @return an OMElement of the resource
     * @throws IOException for invalid URL's or IO errors
     */
    public static OMNode getOMElementFromURL(String urlStr) throws IOException {

        URL url = getURLFromPath(urlStr);
        if (url == null) {
            return null;
        }
        URLConnection conn = url.openConnection();
        conn.setReadTimeout(getReadTimeout());
        conn.setConnectTimeout(getConnectionTimeout());
        conn.setRequestProperty(""Connection"", ""close""); // if http is being used
        BufferedInputStream urlInStream = new BufferedInputStream(
                conn.getInputStream());
        try {
            StAXOMBuilder builder = new StAXOMBuilder(urlInStream);
            OMElement doc = builder.getDocumentElement();
            doc.build();
            return doc;
        } catch (Exception e) {
            if (log.isDebugEnabled()) {
                log.info(""Content at URL : "" + url + "" is non XML.."");
            }

            Object content = readNonXML(url);
            if (content instanceof OMNode) {
                return (OMNode) content;
            }
        } finally {
            try {
                urlInStream.close();
            } catch (IOException ignore) {
            }
        }
        return null;
    }

    public static InputSource getInputSourceFormURI(URI uri) {
        if (uri == null) {
            if (log.isDebugEnabled()) {
                log.debug(""Can not create a URL from 'null' "");
            }
            return null;
        }
        try {
            URL url = uri.toURL();
            String protocol = url.getProtocol();
            String path = url.getPath();
            if (protocol == null || """".equals(protocol)) {
                url = new URL(""file:"" + path);
            }
            URLConnection conn = url.openConnection();
            conn.setReadTimeout(getReadTimeout());
            conn.setConnectTimeout(getConnectionTimeout());
            conn.setRequestProperty(""Connection"", ""close""); // if http is being used
            BufferedInputStream urlInStream = new BufferedInputStream(
                    conn.getInputStream());
            return new InputSource(urlInStream);
        } catch (MalformedURLException e) {
            handleException(""Invalid URL ' "" + uri + "" '"", e);
        } catch (IOException e) {
            handleException(""Error reading at URI ' "" + uri + "" ' "", e);
        }
        return null;
    }

    private static int getReadTimeout() {
        return ServerManager.getInstance().getReadTimeout();
    }

    private static int getConnectionTimeout() {
        return ServerManager.getInstance().getConnectTimeout();
    }

    private static void handleException(String msg, Exception e) {
        log.warn(msg, e);
        throw new SynapseException(msg, e);
    }

    private static void handleException(String msg) {
        log.warn(msg);
        throw new SynapseException(msg);
    }

    /**
     * Return a suitable XMLToObjectMapper for the given content type if one
     * is available, else return null;
     *
     * @param contentType the content type for which a mapper is required
     * @return a suitable XMLToObjectMapper or null if none can be found
     */
    public static XMLToObjectMapper getXmlToObjectMapper(String contentType) {
        return null;
    }

    /**
     * Utility method to resolve url(only If need) path using synapse home system property
     *
     * @param path Path to the URL
     * @return Valid URL instance or null(if it is inavalid or can not open a connection to it )
     */
    public static URL getURLFromPath(String path) {
        if (path == null || ""null"".equals(path)) {
            if (log.isDebugEnabled()) {
                log.debug(""Can not create a URL from 'null' "");
            }
            return null;
        }
        URL url = null;
        try {
            url = new URL(path);
            if (""file"".equals(url.getProtocol())) {
                try {
                    url.openStream();
                } catch (MalformedURLException e) {
                    handleException(""Invalid URL reference : "" + path, e);
                } catch (IOException ignored) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Can not open a connection to the URL with a path :"" +
                                path);
                    }
                    String synapseHome = ServerManager.getInstance().getSynapseHome();
                    if (synapseHome != null) {
                        if (synapseHome.endsWith(""/"")) {
                            synapseHome = synapseHome.substring(0, synapseHome.lastIndexOf(""/""));
                        }
                        if (log.isDebugEnabled()) {
                            log.debug(""Trying  to resolve an absolute path of the "" +
                                    "" URL using the synapse.home : "" + synapseHome);
                        }
                        try {
                            url = new URL(url.getProtocol() + "":"" + synapseHome + ""/"" +
                                    url.getPath());
                            url.openStream();
                        } catch (MalformedURLException e) {
                            handleException(""Invalid URL reference "" + url.getPath() + e);
                        } catch (IOException e) {
                            if (log.isDebugEnabled()) {
                                log.debug(""Faild to resolve an absolute path of the "" +
                                        "" URL using the synapse.home : "" + synapseHome);
                            }
                            log.warn(""IO Error reading from URL : "" + url.getPath() + e);
                        }
                    }
                }
            }
        } catch (MalformedURLException e) {
            handleException(""Invalid URL reference :  "" + path, e);
        } catch (IOException e) {
            handleException(""IO Error reading from URL : "" + path, e);
        }
        return url;
    }

    public static String resolveRelativeURI(String parentLocation, String relativeLocation) {

        if (relativeLocation == null) {
            throw new IllegalArgumentException(""Import URI cannot be null"");
        }

        if (log.isDebugEnabled()) {
            log.debug(""Resolving import URI ' "" + parentLocation + "" '  against base URI ' "" + relativeLocation + "" '  "");
        }

        URI importUri = null;
        try {
            importUri = new URI(relativeLocation);
            if (importUri.isAbsolute()) {
                return importUri.toString();
            }
        } catch (URISyntaxException e) {
            handleException(""Invalid URI : "" + relativeLocation, e);
        }

        if (parentLocation == null) {
            return importUri.toString();
        } else {
            // if the importuri is absolute
            if (relativeLocation.startsWith(""/"") || relativeLocation.startsWith(""\\"")) {
                if (importUri != null && !importUri.isAbsolute()) {
                    try {
                        importUri = new URI(""file:"" + relativeLocation);
                        return importUri.toString();
                    } catch (URISyntaxException e) {
                        handleException(""Invalid URI ' "" + importUri.getPath() + "" '"", e);
                    }
                }
            } else {
                int index = parentLocation.lastIndexOf(""/"");
                if (index == -1) {
                    index = parentLocation.lastIndexOf(""\\"");
                }
                if (index != -1) {
                    String basepath = parentLocation.substring(0, index + 1);
                    String resolvedPath = basepath + relativeLocation;
                    try {
                        URI resolvedUri = new URI(resolvedPath);
                        if (!resolvedUri.isAbsolute()) {
                            resolvedUri = new URI(""file:"" + resolvedPath);
                        }
                        return resolvedUri.toString();
                    } catch (URISyntaxException e) {
                        handleException(""Invalid URI ' "" + resolvedPath + "" '"", e);
                    }
                } else {
                    return importUri.toString();
                }
            }
        }
        return null;
    }
}

"
org/apache/synapse/config/xml/endpoints/IndirectEndpointFactory.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.config.xml.endpoints;

import org.apache.synapse.endpoints.Endpoint;
import org.apache.synapse.endpoints.IndirectEndpoint;
import org.apache.synapse.SynapseException;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNode;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;

/**
 * Creates an IndirectEndpoint using a XML configuration. Key can be a name of an endpoint defined
 * in the same Synapse configuration or a registry key pointing to an endpoint configuration in the
 * registry (e.g. &lt;endpoint key=""registry/endpoint1.xml""/&gt;).
 *
 * &lt;endpoint key=""key""/&gt;
 */
public class IndirectEndpointFactory extends EndpointFactory {

    private static IndirectEndpointFactory instance = new IndirectEndpointFactory();

    private IndirectEndpointFactory() {}

    public static IndirectEndpointFactory getInstance() {
        return instance;
    }

    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {

        IndirectEndpoint indirectEndpoint = new IndirectEndpoint();
        String ref = epConfig.getAttributeValue(new QName(""key""));
        String name = epConfig.getAttributeValue(new QName(""name""));
        if (name != null) {
            indirectEndpoint.setName(name);
        }
        indirectEndpoint.setKey(ref);
        return indirectEndpoint;
    }
}
"
org/apache/synapse/util/SynapseBinaryDataSource.java,false,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  ""License""); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package org.apache.synapse.util;

import org.apache.synapse.core.SynapseEnvironment;

import javax.activation.DataSource;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * DataSource which will be used to pass the Hessian messages in to SOAP body within axis2/synapse
 *
 * @see javax.activation.DataSource
 */
public class SynapseBinaryDataSource implements DataSource {

    /** Content type of the DataSource */
    private String contentType;

    /** Hessian message is kept inside the DataSource as a byte array */
    private TemporaryData data;

    /**
     * Constructs the HessianDataSource from the given InputStream. Inside the HessianDataSource,
     * data is stored in a byte[] or in a temp file format inorder to be able to get the stream any
     * number of time, otherwise the stream can only be read once
     *
     * @param inputstream contains the Hessian message for later retrieval
     * @param contentType message content type
     * @throws IOException failure in reading from the InputStream
     */
    public SynapseBinaryDataSource(InputStream inputstream, String contentType) throws IOException {

        this.contentType = contentType;
        this.data = new TemporaryData(4, 1024, ""tmp_"", "".dat"");

        data.readFrom(inputstream);
        inputstream.close();
    }

    public SynapseBinaryDataSource(InputStream inputstream, String contentType,
        SynapseEnvironment synEnv) throws IOException {

        this.contentType = contentType;
        this.data = synEnv.createTemporaryData();

        data.readFrom(inputstream);
        inputstream.close();
    }

    public String getContentType() {
        return contentType;
    }

    public InputStream getInputStream() throws IOException {
        return data.getInputStream();
    }

    public String getName() {
        return this.getClass().getName();
    }

    public OutputStream getOutputStream() throws IOException {
        return data.getOutputStream();
    }

}
"
